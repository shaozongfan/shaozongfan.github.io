<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.893Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->50 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在当今数字化时代，Linux 系统凭借其开源、稳定、安全等诸多优势，在服务器领域占据了举足轻重的地位。据统计，全球超过 70% 的网站服务器都运行在 Linux 操作系统上 ，众多大型互联网公司如 Google、Facebook 等，都在其数据中心大规模使用 Linux，以实现高效的数据处理和存储。</p><p>对于企业而言，Linux 服务器的性能直接关系到业务的稳定运行和用户体验。想象一下，当用户访问网站或使用应用程序时，如果系统响应缓慢甚至出现卡顿，用户很可能会选择离开，这不仅会导致业务流失，还会损害企业的声誉。而通过有效的性能分析，我们能够及时发现系统中的潜在问题，找出性能瓶颈所在，从而采取针对性的优化措施，确保系统始终处于最佳运行状态。</p><p>在 Linux 性能分析的工具家族中，ftrace 是一款功能强大且独特的工具，它犹如一把精密的手术刀，能够深入剖析 Linux 内核的运行时行为，为我们揭示系统内部的奥秘，在性能分析和故障调试中发挥着关键作用。</p><h1>一、Ftrace概述</h1><p>ftrace，即 Function Trace 的缩写，是 Linux 内核自带的一款强大的跟踪工具 。它诞生于 2008 年，由 Steven Rostedt 开发，并在 2.6.27 版本的内核中首次引入。最初，ftrace 只是一个简单的函数跟踪器，主要用于记录内核的函数调用流程，随着不断的发展和完善，如今它已演变成一个功能丰富的跟踪框架，采用插件式的设计，支持开发者添加更多类型的跟踪功能，在 Linux 内核的开发与调试中发挥着不可或缺的作用。</p><p>简单来说，ftrace 就像是一个 “内核侦探”，能够深入系统内部，帮助开发人员了解 Linux 内核在运行时的各种行为。无论是内核函数的调用顺序、执行时间，还是进程的调度情况、中断的处理过程，ftrace 都能进行详细的跟踪和记录。通过这些信息，开发人员可以像侦探破案一样，从蛛丝马迹中找出系统运行时出现的问题，进而进行针对性的优化和调试。</p><p>在实际应用中，ftrace 的用途十分广泛。当系统出现性能瓶颈时，我们可以借助 ftrace 来分析是哪些内核函数占用了大量的时间，从而找出性能瓶颈所在，进行优化。比如，在一个高并发的 Web 服务器中，如果发现响应时间过长，通过 ftrace 跟踪相关的网络处理函数和文件系统操作函数，就有可能发现是某些函数的低效实现或者资源竞争导致了性能问题。又或者，当系统出现异常崩溃时，ftrace 记录的函数调用栈信息可以帮助我们快速定位到问题的根源，确定是哪个函数在什么情况下出现了错误，大大提高了故障排查的效率。</p><h1>二、Ftrace的功能详解</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21多样化的追踪功能">2.1多样化的追踪功能<a class="hash-link" href="#21多样化的追踪功能" title="标题的直接链接">​</a></h2><p>ftrace 拥有丰富多样的追踪功能，这得益于它所支持的一系列不同类型的 tracer，这些 tracer 就像是一个个各有所长的 “侦察兵”，能够从不同角度对 Linux 内核的运行时行为进行细致入微的跟踪。</p><p>其中，Function tracer（函数跟踪器）是最基础的一种 tracer ，它就像一个勤奋的记录员，能够忠实地跟踪内核函数的调用情况。当系统运行时，它会详细记录下每个函数何时被调用，为开发人员提供了函数调用的基本时间线。通过分析 Function tracer 生成的跟踪信息，开发人员可以清晰地了解到系统中各个函数的执行顺序，这对于理解复杂的内核代码逻辑以及排查因函数调用顺序错误而导致的问题非常有帮助。例如，在一个文件系统操作中，Function tracer 可以记录下从文件打开函数到文件读写函数再到文件关闭函数的一系列调用过程，让开发人员一目了然地看到整个文件操作的流程。</p><p>Function graph tracer（函数调用图跟踪器）则以一种更加直观的图形化方式展示函数调用的层次关系 。它不仅能够显示函数的调用顺序，还能清晰地呈现出函数之间的嵌套关系，就像一幅详细的作战地图，让开发人员对函数调用的整体结构有更全面的认识。比如，在一个网络数据包处理的过程中，可能涉及到多个层次的函数调用，从网络驱动层的接收函数，到网络协议栈中的各个处理函数，再到应用层的回调函数。Function graph tracer 可以将这些函数的调用关系以图形的形式展示出来，使开发人员能够迅速定位到关键函数以及它们之间的依赖关系，方便进行性能优化和问题排查。</p><p>Schedule switch tracer（调度切换跟踪器）主要负责跟踪进程的调度情况 ，它能够记录下系统中进程何时进行了切换，以及切换的原因。在多任务的 Linux 系统中，进程调度是一个关键的环节，进程的频繁切换可能会带来额外的开销，影响系统性能。通过分析 Schedule switch tracer 的跟踪数据，开发人员可以了解到系统中进程调度的频繁程度，判断是否存在不合理的调度策略。例如，如果发现某个进程频繁地被调度，可能是因为该进程的优先级设置不合理，或者是因为它在执行过程中出现了资源竞争等问题，开发人员可以据此进行针对性的调整和优化。</p><p>Wakeup tracer（唤醒跟踪器）专注于跟踪进程的调度延迟 ，特别是对于实时进程，它能够记录下高优先级进程从进入就绪状态到获得 CPU 的延迟时间。在实时系统中，对进程的响应时间有着严格的要求，哪怕是微小的调度延迟都可能导致严重的后果。Wakeup tracer 就像是一个精准的计时器，能够帮助开发人员准确地测量出调度延迟，从而找出导致延迟的原因，比如是否存在其他进程占用了过多的 CPU 资源，或者是内核调度算法在某些情况下存在缺陷等。通过优化这些问题，可以提高实时系统的响应性能，确保关键任务能够及时得到处理。</p><p>Irqsoff tracer（中断关闭跟踪器）则是专门用于跟踪内核中中断被禁止的情况 。当中断被禁止时，系统无法及时响应外部事件，这可能会导致系统响应延迟，影响用户体验。Irqsoff tracer 会记录下哪些函数禁止了中断，并且会特别标示出中断禁止时间最长的函数，就像一个 “罪魁祸首探测器”，让开发人员能够迅速定位到那些可能导致系统响应问题的函数。例如，在一个实时控制系统中，如果某个函数长时间禁止中断，可能会导致传感器数据无法及时采集和处理，从而影响系统的控制精度。通过使用 Irqsoff tracer，开发人员可以及时发现并解决这类问题，保证系统的稳定性和可靠性。</p><p>除了上述几种常见的 tracer，ftrace 还支持 Branch tracer（分支跟踪器），用于跟踪内核程序中的分支预测命中率情况，帮助开发人员优化程序的执行路径；Hardware branch tracer（硬件分支跟踪器），利用处理器的分支跟踪能力，实现硬件级别的指令跳转记录；Initcall tracer（初始化调用跟踪器），记录系统在启动阶段所调用的初始化函数；Mmiotrace tracer（内存映射 I/O 跟踪器），记录内存映射 I/O 的相关信息；</p><p>Power tracer（电源跟踪器），记录系统电源管理相关的信息；Sysprof tracer（系统性能分析跟踪器），定期对内核进行采样，记录函数调用和堆栈信息；Kernel memory tracer（内核内存跟踪器），跟踪内核内存分配器的分配情况，帮助开发人员分析内存碎片问题；Workqueue statistical tracer（工作队列统计跟踪器），统计系统中所有工作队列的工作情况，辅助开发人员选择合适的工作队列实现方式；Event tracer（事件跟踪器），跟踪系统中的各种事件，如定时器、系统调用、中断等。这些丰富的 tracer 类型，使得 ftrace 能够满足不同场景下的性能分析和故障调试需求，成为 Linux 内核开发和维护的得力助手。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22轻量级与稳定性">2.2轻量级与稳定性<a class="hash-link" href="#22轻量级与稳定性" title="标题的直接链接">​</a></h2><p>ftrace 在设计上采用了静态代码插装技术，这使得它具有显著的轻量级特性。简单来说，静态代码插装就是在编译内核时，将一些特定的代码片段插入到内核函数中，这些代码片段就像是预先设置好的 “小探针”，能够在函数执行时收集相关信息。与其他一些动态跟踪技术相比，ftrace 的静态代码插装方式不需要在运行时进行复杂的动态分析和代码注入，因此代码量相对较小，对系统资源的占用也非常低。在一个高负载的服务器环境中，系统资源十分宝贵，使用 ftrace 进行性能分析时，它几乎不会对系统的正常运行产生明显的影响，就像一个安静的观察者，默默地记录着系统的运行情况，而不会干扰系统的正常工作节奏。</p><p>这种静态代码插装技术还赋予了 ftrace 极高的稳定性 。由于它不需要支持复杂的编程接口让用户自定义跟踪行为，也就减少了因用户不当使用而导致内核崩溃的风险。与一些功能强大但设计复杂的跟踪工具（如 SystemTap）相比，ftrace 的设计目标更加简单直接，它专注于提供可靠的跟踪功能，而不是追求过于复杂的自定义能力。在实际的生产环境中，稳定性是至关重要的，任何一次系统崩溃都可能导致严重的业务损失。ftrace 的稳定可靠特性，使得它成为了内核开发人员和系统管理员在进行性能分析和故障排查时的首选工具之一，就像一位值得信赖的老伙伴，始终能够在关键时刻提供准确可靠的信息，帮助解决问题。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23便捷的接口">2.3便捷的接口<a class="hash-link" href="#23便捷的接口" title="标题的直接链接">​</a></h2><p>ftrace 通过 debugfs 接口与用户进行交互，这使得它的使用变得非常便捷 。debugfs 是 Linux 内核提供的一种特殊文件系统，它主要用于调试目的，为用户提供了一种简单直观的方式来访问和修改内核的调试信息。ftrace 利用 debugfs 文件系统，将其各种控制和配置选项以文件的形式呈现给用户，用户只需要通过简单的文件读写操作，就可以完成对 ftrace 的各种设置和操作。</p><p>具体来说，当用户想要使用 ftrace 时，首先需要挂载 debugfs 文件系统，这通常只需要执行一条简单的命令，如 “mount -t debugfs nodev /sys/kernel/debug”（在不同的系统中，挂载点可能会有所不同）。挂载完成后，用户就可以在 “/sys/kernel/debug/tracing” 目录下找到 ftrace 的各种控制文件。</p><p>例如，“available_tracers” 文件列出了当前系统中可用的所有 tracer 类型，用户可以通过查看这个文件来了解 ftrace 支持哪些跟踪功能；“current_tracer” 文件则用于指定当前要使用的 tracer，用户只需要将想要使用的 tracer 名称写入这个文件，就可以轻松切换跟踪器；“tracing_on” 文件用于控制 ftrace 的开启和关闭，将 “1” 写入该文件表示开启跟踪，将 “0” 写入则表示关闭跟踪；“trace” 文件则是用于查看 ftrace 生成的跟踪信息，用户可以使用 “cat” 命令来读取这个文件的内容，从而获取系统的运行时行为数据。</p><p>这种基于文件系统的接口设计，使得 ftrace 的使用非常灵活方便，即使是对于那些不太熟悉复杂命令行工具的用户来说，也能够轻松上手。用户不需要学习复杂的命令语法和参数设置，只需要熟悉基本的文件操作命令，就可以充分利用 ftrace 的强大功能。而且，由于 ftrace 的输出信息都是以文本文件的形式呈现，用户可以方便地使用各种文本处理工具对跟踪数据进行进一步的分析和处理，如使用 grep 命令进行关键词搜索，使用 awk 命令进行数据提取和统计等，大大提高了分析效率。</p><h1>三、Ftrace的工作原理</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31插桩技术">3.1插桩技术<a class="hash-link" href="#31插桩技术" title="标题的直接链接">​</a></h2><p>ftrace 的强大功能离不开其背后精妙的工作原理，而插桩技术则是其实现内核跟踪的核心基础。插桩技术就像是在系统这个庞大的机器中安装了许多精密的 “传感器”，这些 “传感器” 能够实时捕捉系统运行时的各种信息，为我们深入了解系统内部的运行机制提供了关键数据。ftrace 采用了静态插桩和动态插桩两种方式，它们各有特点，相互配合，共同实现了高效的内核跟踪。</p><p><img loading="lazy" alt="1742998590821" src="/assets/images/1742998590821-b4151a69231a594c3c6aff7d9d35ee26.png" width="1471" height="840" class="img_ev3q"></p><p><img loading="lazy" alt="image-20250326221456688" src="/assets/images/image-20250326221456688-fbbdc9e21d14bc9d49bae728438a876f.png" width="1485" height="1174" class="img_ev3q"></p><p>静态插桩是 ftrace 实现跟踪功能的基础方式之一 。当我们在 Kernel 中打开 CONFIG_FUNCTION_TRACER 功能后，编译过程中会增加一个 - pg 的编译选项。这个编译选项就像是一个神奇的 “指令注入器”，它会在每个函数入口处插入一条 bl mcount 跳转指令。这意味着，当系统中的每个函数运行时，都会先跳转到 mcount 函数。在 mcount 函数中，会判断函数指针 ftrace_trace_function 是否被注册，默认注册的是空函数 ftrace_stub，只有打开 function tracer 后才会注册具体的处理函数 ftrace_trace_function。</p><p>这种静态插桩的方式，就像是在每个函数的必经之路上设置了一个固定的 “检查点”，无论函数何时被调用，都必须经过这个 “检查点”，从而实现对所有函数调用的跟踪。然而，这种方式虽然能够全面地跟踪函数调用，但也带来了一定的性能开销，因为每个函数调用都要额外执行一次跳转和判断操作，这在高负载的系统中可能会对性能产生明显的影响。</p><p>为了解决静态插桩带来的性能问题，开发者们推出了 Dynamic ftrace，即动态插桩技术 。动态插桩技术的核心思想是动态修改函数指令，以实现更加灵活和高效的跟踪。在编译时，系统会记录所有被添加跳转指令（即支持追踪）的函数。</p><p>在内核启动时，这些函数入口处的跳转指令会被替换为 nop 指令（nop 指令是一种空操作指令，执行它不会产生任何实际的运算或操作，仅占用一个指令周期），这样在非调试状态下，函数的执行就不会受到额外的性能损耗，就像在高速公路上取消了所有不必要的收费站，车辆可以畅行无阻，大大提高了系统的运行效率。而当需要进行跟踪时，根据 function tracer 的设置，系统会动态地将被调试函数的 nop 指令替换为跳转指令，从而实现对特定函数的追踪。</p><p>这种动态插桩的方式，就像是一个智能的 “交通管制系统”，只有在需要监控某些特定 “车辆”（函数）时，才会在其行驶路径上设置 “检查点”，而在其他时候，道路则保持畅通，既实现了跟踪功能，又最大限度地减少了对系统性能的影响。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32数据记录与存储">3.2数据记录与存储<a class="hash-link" href="#32数据记录与存储" title="标题的直接链接">​</a></h2><p>当 ftrace 通过插桩技术在函数入口处设置好 “传感器” 后，接下来就需要考虑如何记录这些函数调用过程中产生的数据，并将这些宝贵的信息存储起来，以便后续的分析和处理。</p><p>在开启 ftrace 的跟踪功能后，首先会打开编译选项 -pg，为每个函数都增加跳转指令，这就像是为每个函数都安装了一个 “数据采集器”，当函数被调用时，“数据采集器” 就会被触发。</p><p>然后，系统会记录这些可追踪的函数，并为了减少性能消耗，将跳转函数替换为 nop 指令，就像暂时关闭了这些 “数据采集器”，让系统能够高效运行。而当需要进行跟踪时，通过 flag 标志位来动态管理，将需要追踪的函数预留的 nop 指令替换回追踪指令，此时 “数据采集器” 重新启动，开始记录调试信息，包括函数的调用时间、调用参数、返回值等关键信息。</p><p>ftrace 将这些追踪信息存储到 Ring buffer 缓冲区中 。Ring buffer 是一种环形缓冲区，它就像是一个循环的 “数据仓库”，具有固定的大小。当追踪信息产生时，会按照顺序依次写入 Ring buffer 中。当缓冲区被填满后，新产生的追踪信息会覆盖最早写入的信息，就像一个不断循环的传送带，始终保持最新的追踪数据在缓冲区中。这种设计方式既保证了追踪信息的实时性，又避免了因缓冲区溢出而导致的数据丢失问题。</p><p>用户可以通过读取 Ring buffer 中的数据，来获取系统的运行时行为信息，为性能分析和故障排查提供有力的支持。例如，在分析系统性能瓶颈时，开发人员可以从 Ring buffer 中读取函数调用的时间信息，找出那些执行时间较长的函数，进而深入分析这些函数的内部实现，找出性能瓶颈所在；在排查系统故障时，开发人员可以读取函数调用的参数和返回值信息，判断函数是否在某些特定参数下出现异常，从而快速定位问题的根源。</p><h1>四、Ftrace的使用方法</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="41内核配置">4.1内核配置<a class="hash-link" href="#41内核配置" title="标题的直接链接">​</a></h2><p>在使用 ftrace 之前，首先需要确保内核配置中启用了相关选项。这一步至关重要，就像搭建一座房子，内核配置是基石，只有打好了基础，ftrace 才能正常发挥其强大的功能。主要的配置选项包括：</p><ul><li>CONFIG_FTRACE：这是 ftrace 的核心配置选项，它就像是 ftrace 的总开关，只有开启了这个选项，ftrace 的其他功能才能得以启用。如果没有启用 CONFIG_FTRACE，那么后续的一切配置和操作都将无法进行，就如同没有启动发动机的汽车，无论多么精美的内饰和先进的配置都无法让它行驶起来。在编译内核时，通过 make menuconfig 命令进入内核配置界面，在 “Kernel hacking ---&gt; Tracers ---&gt;” 路径下，可以找到 CONFIG_FTRACE 选项，将其设置为 “<!-- -->[*]<!-- -->”，表示启用该选项。</li><li>CONFIG_FUNCTION_TRACER：此选项用于启用函数跟踪功能，它是 ftrace 中最常用的功能之一。一旦启用，ftrace 就能够跟踪内核中函数的调用情况，记录函数的调用时间、调用参数等关键信息。对于开发者来说，这些信息就像是打开系统内部奥秘的钥匙，能够帮助他们深入了解系统的运行机制，排查各种潜在的问题。在上述内核配置界面中，找到 “<!-- -->[*]<!-- --> Kernel Function Tracer” 选项，将其选中即可启用函数跟踪功能。</li><li>CONFIG_FUNCTION_GRAPH_TRACER：这个选项主要用于启用函数调用图跟踪功能，它能够以图形化的方式展示函数之间的调用关系，让开发者对系统的函数调用结构一目了然。在分析复杂的系统时，函数调用图能够帮助开发者快速定位关键函数和它们之间的依赖关系，大大提高了问题排查和性能优化的效率。在 “Tracers ---&gt;” 路径下，找到 “[] Kernel Function Graph Tracer” 选项，将其设置为 “[]”，即可启用函数调用图跟踪功能。</li><li>CONFIG_DYNAMIC_FTRACE：动态 ftrace 配置选项，它允许在运行时动态地修改函数指令，以实现更加灵活的跟踪。通过启用这个选项，ftrace 可以在不重新编译内核的情况下，根据实际需求动态地开启或关闭对某些函数的跟踪，大大提高了 ftrace 的使用灵活性和效率。在 “Tracers ---&gt;” 路径下，找到 “<!-- -->[*]<!-- --> Dynamic ftrace” 选项，将其选中即可启用动态 ftrace 功能。</li></ul><p>除了上述主要选项外，还有许多其他的配置选项，如 CONFIG_IRQSOFF_TRACER（用于启用中断关闭跟踪功能）、CONFIG_SCHED_TRACER（用于启用调度跟踪功能）等，开发者可以根据具体的需求进行选择和配置。不同的配置选项就像是不同的工具，开发者可以根据问题的类型和分析的目的，选择合适的工具来进行系统性能分析和故障排查。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="42挂载-debugfs-文件系统">4.2挂载 debugfs 文件系统<a class="hash-link" href="#42挂载-debugfs-文件系统" title="标题的直接链接">​</a></h2><p>在完成内核配置并成功编译内核后，接下来需要挂载 debugfs 文件系统，这是使用 ftrace 的关键步骤之一。debugfs 是一种特殊的文件系统，它为内核调试提供了一个接口，ftrace 正是通过这个接口与用户进行交互，将内核的跟踪信息呈现给用户。</p><p>挂载 debugfs 文件系统的步骤如下：</p><ol><li><p>首先，检查系统中是否已经挂载了 debugfs 文件系统。可以使用以下命令进行检查</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mount | grep debugfs</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果命令输出中包含类似于 “debugfs /sys/kernel/debug debugfs rw,relatime 0 0” 的信息，说明 debugfs 文件系统已经挂载，挂载点为 /sys/kernel/debug。此时，可以直接进入下一步操作。</p></li><li><p>如果 debugfs 文件系统尚未挂载，则需要手动进行挂载。使用以下命令进行挂载：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mount -t debugfs none /sys/kernel/debug</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个命令中，“-t debugfs” 表示指定要挂载的文件系统类型为 debugfs，“none” 表示不需要指定设备，因为 debugfs 是一种虚拟文件系统，不需要实际的物理设备支持，“/sys/kernel/debug” 是挂载点，即将 debugfs 文件系统挂载到 /sys/kernel/debug 目录下。执行这个命令后，debugfs 文件系统就会被挂载到指定的目录下，就像将一个装满工具的工具箱放置在了一个方便取用的位置，用户可以通过这个挂载点来访问 ftrace 提供的各种调试信息和控制文件</p></li><li><p>挂载完成后，可以通过查看 /sys/kernel/debug 目录下的文件来验证 debugfs 文件系统是否挂载成功。在该目录下，应该可以看到一个名为 “tracing” 的目录，这个目录就是 ftrace 的主要工作目录，其中包含了各种用于控制和查看 ftrace 跟踪信息的文件。如果能够找到 “tracing” 目录，说明 debugfs 文件系统挂载成功，可以继续进行后续的 ftrace 配置和使用操作。</p></li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="43常用文件及操作">4.3常用文件及操作<a class="hash-link" href="#43常用文件及操作" title="标题的直接链接">​</a></h2><p>各种控制文件和跟踪信息文件。这些文件就像是 ftrace 的操作手册和日志记录，通过对它们的操作和查看，用户可以实现对 ftrace 的各种配置和跟踪信息的获取。以下是一些常用文件及其操作方法：</p><p>trace 文件：这是 ftrace 最重要的文件之一，它包含了当前的追踪内容。就像一个详细的日记，trace 文件记录了 ftrace 跟踪到的所有内核函数调用、事件发生等信息。</p><p>用户可以使用以下命令查看 trace 文件的内容：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat /sys/kernel/debug/tracing/trace</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>执行这个命令后，系统会输出 trace 文件中的内容，这些内容通常以文本形式呈现，包括时间戳、进程 ID、CPU 编号、函数名等信息，通过分析这些信息，用户可以了解系统的运行时行为，找出潜在的性能问题和故障原因。例如，如果在 trace 文件中发现某个函数的调用频率非常高，或者某个函数的执行时间过长，就可以进一步深入分析这个函数，查看它的实现逻辑和调用参数，找出优化的方向。</p><p>tracing_on 文件：用于启用或停止追踪，它就像是 ftrace 的启动和停止按钮。将 “1” 写入 tracing_on 文件，表示启用追踪，此时 ftrace 会开始记录系统的运行时信息；将 “0” 写入该文件，表示停止追踪，ftrace 会停止记录新的信息。、</p><p>使用以下命令可以启用追踪：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 1 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用以下命令可以停止追踪：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 0 &gt; /sys/kernel/debug/tracing/tracing_on</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过灵活地控制 tracing_on 文件，用户可以根据实际需求在需要时开启追踪，获取系统的运行信息，在不需要时停止追踪，减少系统资源的消耗。</p><p>current_tracer 文件：用于设置当前启用的 tracer，它就像是 ftrace 的功能选择器。ftrace 支持多种不同类型的 tracer，每种 tracer 都有其特定的功能和用途，通过设置 current_tracer 文件，用户可以选择使用不同的 tracer 来满足不同的分析需求。</p><p>例如，如果想要跟踪内核函数的调用情况，可以将 “function” 写入 current_tracer 文件；如果想要以图形化的方式查看函数调用关系，可以将 “function_graph” 写入该文件。</p><p>使用以下命令可以设置当前启用的 tracer 为 function：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo function &gt; /sys/kernel/debug/tracing/current_tracer</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在设置 current_tracer 文件后，ftrace 会根据用户选择的 tracer 类型来记录和展示系统的运行时信息。</p><p>available_tracers 文件：列出了当前系统中可用的所有 tracer 类型，它就像是 ftrace 的功能菜单。</p><p>用户可以使用以下命令查看 available_tracers 文件的内容：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat /sys/kernel/debug/tracing/available_tracers</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>执行这个命令后，系统会输出当前系统中可用的 tracer 类型，如 function、function_graph、irqsoff、wakeup 等。通过查看这个文件，用户可以了解 ftrace 支持哪些跟踪功能，从而根据实际需求选择合适的 tracer。</p><p>set_ftrace_filter 文件：用于设置函数过滤，它就像是一个筛子，可以帮助用户筛选出感兴趣的函数进行跟踪。通过将需要跟踪的函数名写入 set_ftrace_filter 文件，用户可以只让 ftrace 跟踪这些特定的函数，而忽略其他函数，从而减少跟踪数据的量，提高分析效率。</p><p>例如，如果只对 “vfs_open” 函数感兴趣，可以使用以下命令设置函数过滤：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo vfs_open &gt; /sys/kernel/debug/tracing/set_ftrace_filter</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>设置完成后，ftrace 只会跟踪 “vfs_open” 函数的调用情况，而不会记录其他函数的信息。</p><p>set_ftrace_pid 文件：用于设置进程 ID 过滤，它就像是一个定位器，可以让用户只跟踪特定进程的函数调用。将需要跟踪的进程 ID 写入 set_ftrace_pid 文件，ftrace 会只记录该进程中函数的调用情况，而忽略其他进程的信息。例如，如果要跟踪进程 ID 为 1234 的进程，可以使用以下命令设置进程 ID 过滤：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 1234 &gt; /sys/kernel/debug/tracing/set_ftrace_pid</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过设置进程 ID 过滤，用户可以更有针对性地分析特定进程的性能和行为，找出该进程中可能存在的问题。</p><h1>五、Ftrace应用案例</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="51性能优化">5.1性能优化<a class="hash-link" href="#51性能优化" title="标题的直接链接">​</a></h2><p>假设我们正在开发一个文件系统相关的内核模块，近期发现系统在进行大量文件读写操作时，性能出现了明显的下降。为了找出性能瓶颈，我们决定使用 ftrace 来进行深入分析。</p><p>首先，我们需要确保 ftrace 已经正确配置并启用。通过前面介绍的方法，挂载 debugfs 文件系统，并进入 /sys/kernel/debug/tracing 目录。</p><p>接下来，我们使用 Function graph tracer 来跟踪文件系统相关函数的调用情况。因为 Function graph tracer 能够以图形化的方式展示函数调用关系和执行时间，这对于我们分析性能瓶颈非常有帮助。我们执行以下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 0 &gt; tracing_on  # 停止追踪</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo nop &gt; current_tracer  # 清除当前追踪器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo function_graph &gt; current_tracer  # 启用function_graph跟踪器</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后，我们设置只跟踪与文件系统相关的函数，这里以 “vfs_read” 和 “vfs_write” 函数为例，执行以下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo vfs_read &gt; set_graph_function</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo vfs_write &gt;&gt; set_graph_function</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>完成上述设置后，我们开始进行文件读写操作，模拟实际的业务场景。操作完成后，我们停止追踪，执行命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 0 &gt; tracing_on</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接着，我们查看 trace 文件，获取跟踪结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat trace</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 trace 文件中，我们可以看到类似以下的信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># tracer: function_graph</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># CPU  DURATION                  FUNCTION CALLS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># |     |   |                     |   |   |   |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  1234.567 us |  vfs_read() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  10.123 us |    generic_file_read() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  5.678 us |      do_generic_file_read() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  3.456 us |        page_cache_sync_readahead() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  1.234 us |          ra_submit() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.567 us |            submit_bio() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.234 us |              generic_make_request() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.123 us |                blk_queue_bio() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.067 us |                  blk_mq_submit_bio() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.034 us |                    blk_mq_alloc_request() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.012 us |                      kmem_cache_alloc() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.005 us |                        slab_alloc() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.002 us |                         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.002 us |                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.005 us |                      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.012 us |                    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.034 us |                  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.067 us |                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.123 us |              }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.234 us |            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  0.567 us |          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  1.234 us |        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  3.456 us |      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  5.678 us |    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0)  1234.567 us |  }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从这些信息中，我们可以清晰地看到函数的调用层次和每个函数的执行时间。通过分析，我们发现 “page_cache_sync_readahead” 函数的执行时间较长，进一步查看其内部调用的函数，发现 “ra_submit” 函数以及其下的一系列函数调用也占用了不少时间。经过深入研究代码逻辑，我们发现 “ra_submit” 函数在某些情况下会进行不必要的磁盘 I/O 操作，导致性能下降。</p><p>针对这个问题，我们对代码进行了优化，减少了不必要的磁盘 I/O 操作。再次使用 ftrace 进行跟踪测试，发现 “vfs_read” 和 “vfs_write” 函数的执行时间明显缩短，系统的文件读写性能得到了显著提升。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="52故障排查">5.2故障排查<a class="hash-link" href="#52故障排查" title="标题的直接链接">​</a></h2><p>某一天，运维人员发现生产系统出现了响应延迟的问题，用户反馈在访问系统时，页面加载速度明显变慢，一些操作甚至需要等待很长时间才能完成。为了找出问题的根源，我们决定使用 ftrace 来进行故障排查。</p><p>首先，我们怀疑是中断相关的问题导致了系统响应延迟，因为当中断被禁止时，系统无法及时响应外部事件，可能会导致响应延迟。所以我们使用 Irqsoff tracer 来跟踪中断禁止的情况。进入 /sys/kernel/debug/tracing 目录，执行以下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 0 &gt; tracing_on  # 停止追踪</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo nop &gt; current_tracer  # 清除当前追踪器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo irqsoff &gt; current_tracer  # 启用irqsoff跟踪器</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后，我们等待系统响应延迟问题再次出现，在问题出现期间，ftrace 会记录下中断禁止的相关信息。问题出现后，我们停止追踪，执行命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo 0 &gt; tracing_on</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接着，查看 trace 文件，获取跟踪结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cat trace</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在 trace 文件中，我们看到了类似以下的信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># tracer: irqsoff</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># WORST IRQSOFF LATENCY: 12345 us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#              _-----=&gt; irqs-off</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#             / _----=&gt; need-resched</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#            | / _---=&gt; hardirq/softirq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#            || / _--=&gt; preempt-depth</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#            ||| / _-=&gt; migrate-disable</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#            |||| /     delay</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#           TASK-PID     CPU#  |||||  TIMESTAMP  FUNCTION</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#              | |         |   |||||     |         |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">my_task-1234[000] d.h. 123456.789012: irqsoff_delay: 12345 us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">my_task-1234[000] d.h. 123456.789012:   &lt;stack trace&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> =&gt; 0xffffffffc0123456</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> =&gt; some_function_1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> =&gt; some_function_2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> =&gt; some_function_3</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从这些信息中，我们可以看到中断禁止的最长延迟时间为 12345 微秒，并且记录了导致中断禁止的函数调用栈。通过分析函数调用栈，我们发现 “some_function_3” 函数在执行过程中禁止了中断，并且禁止时间较长，很可能是这个函数导致了系统响应延迟。</p><p>进一步查看 “some_function_3” 函数的代码，发现该函数在进行一些复杂的数据处理时，为了保证数据的一致性，错误地禁止了中断，而且处理过程中存在一些低效的算法，导致执行时间过长。我们对该函数进行了优化，将数据处理过程中的中断禁止时间尽量缩短，并优化了算法，提高了执行效率。</p><p>经过优化后，再次观察系统运行情况，响应延迟问题得到了有效解决，用户反馈系统恢复正常。通过这个案例，我们可以看到 ftrace 在故障排查中的强大作用，它能够帮助我们快速定位问题的根源，为解决系统故障提供有力的支持。</p><h1>六、Ftrace与其他工具对比</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="61ftrace与-systemtap-对比">6.1ftrace与 systemTap 对比<a class="hash-link" href="#61ftrace与-systemtap-对比" title="标题的直接链接">​</a></h2><p>在 Linux 性能分析工具的大家庭中，systemTap 是与 ftrace 常常被放在一起比较的工具。systemTap 诞生于 Linux 社区对 SUN Dtrace 的回应，其目标是达到甚至超越 Dtrace ，这使得它在设计上较为复杂。它为用户提供了一种强大的脚本语言，用户可以通过编写脚本来自定义跟踪逻辑，实现对系统各种行为的深入分析。比如，用户可以使用 systemTap 编写脚本，精确地统计某个系统调用在特定时间段内的调用次数，或者计算某个函数的平均执行时间等，这种高度的自定义能力使得 systemTap 在处理复杂的性能分析场景时具有很大的优势。</p><p>然而，正是由于 systemTap 的设计复杂，它也存在一些不足之处。在实际应用中，systemTap 始终处于不断完善自身的状态，不当的使用和其自身的不完善都有可能导致系统崩溃。例如，在一个生产环境中，运维人员尝试使用 systemTap 来分析系统性能，由于对脚本编写不够熟悉，编写的脚本中存在一些逻辑错误，结果在运行脚本时，导致了系统的不稳定，甚至出现了短暂的服务中断，给业务带来了一定的影响。</p><p>相比之下，ftrace 的设计目标则简单得多，它本质上是一种静态代码插装技术，不需要支持复杂的编程接口让用户自定义 trace 行为。这种设计使得 ftrace 更加可靠，不会因为用户的不当使用而轻易导致内核崩溃 。ftrace 的代码量也很小，这意味着它对系统资源的占用非常低，在系统运行时几乎不会对系统性能产生明显的影响。在一个对稳定性要求极高的服务器环境中，ftrace 的这些特性使得它成为了系统管理员和内核开发者的首选工具之一。即使是在系统高负载运行的情况下，使用 ftrace 进行性能分析也不会给系统带来额外的负担，能够确保系统的稳定运行。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="62ftrace与-lttng-对比">6.2ftrace与 LTTng 对比<a class="hash-link" href="#62ftrace与-lttng-对比" title="标题的直接链接">​</a></h2><p>LTTng（Linux Trace Toolkit Next Generation）也是一款功能强大的跟踪工具，它与 ftrace 在一些方面存在明显的差异。</p><p>从接口类型来看，ftrace 采用的是 ASCII 接口，这使得它的输出信息可以直接阅读，对于内核开发人员来说，这种接口非常具有吸引力，因为他们只需要结合内核代码和简单的 cat 命令，就可以轻松地获取和分析跟踪信息，操作十分便捷。在进行内核调试时，开发人员可以直接通过 cat 命令查看 ftrace 生成的跟踪文件，快速定位问题所在。而 LTTng 则采用 binary 接口，这种接口更利于专门工具进行分析使用，它能够将跟踪数据以二进制的形式高效存储，适合通过特定的工具进行深入的数据挖掘和分析。</p><p>在 ring buffer 的实现上，两者也有所不同。ftrace 对所有 tracer 都采用同一个 ring buffer，就像一个公共的 “数据仓库”，所有的跟踪信息都存储在这个统一的缓冲区中。这种方式虽然简单直接，但在某些情况下可能会导致缓冲区的竞争和数据覆盖问题。例如，当多个 tracer 同时产生大量的跟踪信息时，可能会因为缓冲区空间不足而导致部分数据被覆盖，影响分析的完整性。而 LTTng 则使用各自不同的 ring buffer，每个 tracer 都有自己独立的 “小仓库”，这样可以有效地避免缓冲区竞争问题，确保每个 tracer 的数据都能得到准确的存储和记录。这使得 LTTng 在处理多 tracer 同时工作的复杂场景时，具有更好的性能和稳定性。</p><p>由于这些差异，ftrace 和 LTTng 在适用场景上也各有侧重。ftrace 由于其简单易用、直接可读的特点，更适合内核开发人员在日常开发和调试中快速获取系统运行时的基本信息，进行初步的性能分析和问题排查；而 LTTng 则凭借其高效的二进制接口和独立的 ring buffer 设计，更受嵌入式工程师的欢迎，在对跟踪数据的存储和分析要求较高的嵌入式系统开发中发挥着重要作用。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.889Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->46 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在 Linux 内核的广袤天地里，性能优化与故障排查宛如两座高耸的山峰，横亘在开发者前行的道路上。为了攀登这两座高峰，开发者们不断寻觅着强大的工具。而 perf，无疑是其中最为耀眼的 “神器” 之一。当你在运行一个复杂的 Linux 系统时，是否常常被一些莫名的性能问题所困扰？系统突然变得卡顿，应用程序响应迟缓，可你却无从下手，不知问题究竟出在哪里。或许是某个内核函数在不经意间消耗了大量资源，又或许是进程间的资源竞争引发了瓶颈。</p><p>在过去，面对这些问题，开发者们犹如在黑暗中摸索，只能凭借经验和猜测来进行调试。但 perf 的出现，彻底改变了这一局面。它就像一把精准的手术刀，能够深入到内核的每一个角落，精准地剖析系统性能。从处理器的指令周期，到缓存的命中率；从函数的调用频率，到进程的上下文切换，perf 都能提供详尽的数据。接下来，让我们一同深入 perf 的世界，探寻它究竟是如何实现这一强大功能的，看看它是怎样在复杂的内核环境中，为我们揭示性能奥秘，助力解决棘手的问题 。</p><h1>一、Perf工具简介</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11什么是-perf">1.1什么是 Perf<a class="hash-link" href="#11什么是-perf" title="标题的直接链接">​</a></h2><p>在 Linux 性能分析的广袤领域中，Perf 犹如一颗璀璨的明星，散发着独特的光芒。Perf，即 Performance 的缩写，是一款集成于 Linux 内核的性能分析工具，如同一位技艺精湛的诊断大师，能深入系统的各个角落，精准地剖析系统性能。它以事件驱动为核心机制，如同精密的仪器，能够捕捉到硬件、软件以及内核层面的各种性能事件。</p><p>随着 Linux 内核的不断演进，Perf 也在持续发展壮大。从最初简单的性能监测，到如今具备丰富多样的功能，Perf 已经成为 Linux 性能分析不可或缺的工具。它不仅支持硬件事件的监测，如 CPU 时钟周期、缓存命中情况等，这些硬件事件犹如系统运行的脉搏，反映着硬件的工作状态；还能捕捉软件事件，如进程切换、缺页中断等，这些软件事件则是系统运行的 “软指标”，揭示着软件层面的运行效率。此外，内核追踪点事件、用户程序静态追踪点以及动态追踪等功能，更是让 Perf 的监测能力如虎添翼，能够全方位、深层次地洞察系统性能。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12perf-的强大功能">1.2Perf 的强大功能<a class="hash-link" href="#12perf-的强大功能" title="标题的直接链接">​</a></h2><p>Perf 之所以备受赞誉，是因为它拥有一系列强大而实用的功能，这些功能犹如一把把精准的手术刀，能够深入剖析系统性能的各个方面。Perf是内置于Linux内核源码树中的性能剖析(profiling)工具。它基于事件采样原理，以性能事件为基础，支持针对处理器相关性能指标与操作系统相关性能指标的性能剖析，常用于性能瓶颈的查找与热点代码的定位。</p><p><strong>(1)轻量级事件采样</strong></p><p>Perf 具备轻量级事件采样的能力，这使其能够通过硬件性能计数对处理器事件进行采样，从而获取应用程序或内核的性能数据 。它可以监测指令执行的数量，了解程序在运行过程中到底执行了多少条指令，这就像是记录一场比赛中运动员的动作次数，能直观反映出程序的工作量。缓存命中率也是它的监测范围，缓存作为计算机系统中速度较快的存储区域，缓存命中率的高低直接影响着系统的性能，Perf 能够精确地捕捉到缓存命中的次数以及未命中的次数，让我们清楚地知道缓存的工作效率。分支预测同样逃不过 Perf 的 “眼睛”，分支预测是处理器为了提高执行效率而采用的一种技术，Perf 可以监测分支预测的成功率，帮助我们评估处理器在这方面的性能表现。这些监测指标就像一个个关键的信号，为我们揭示了系统性能的奥秘。</p><p><strong>(2)Trace 功能</strong></p><p>Trace 功能是 Perf 的又一强大武器，它可以跟踪进程或内核的函数调用链，如同一位经验丰富的侦探，能够顺着线索找出代码的执行路径。通过这一功能，Perf 可以生成函数调用图，函数调用图就像是一幅详细的地图，展示了各个函数之间的调用关系，让我们一目了然地看到程序的执行流程。火焰图也是 Perf Trace 功能的重要产物，火焰图以一种直观的方式展示了函数的执行时间和调用栈深度，越宽的部分表示该函数占用的时间越长，就像火焰的大小反映了火势的强弱，帮助我们快速定位性能瓶颈所在。在一个复杂的应用程序中，可能存在多个函数相互调用，通过火焰图，我们可以轻松地发现哪些函数占用了大量的时间，从而有针对性地进行优化。</p><p><strong>(3)Profiling 功能</strong></p><p>Profiling 功能使 Perf 能够对特定的应用程序进行深入分析，找出其中最耗时的函数和代码行。它提供了逐行统计的功能，就像一位细心的校对员，对每一行代码的执行时间进行统计，让我们清楚地知道每一行代码对性能的影响。火焰图在 Profiling 功能中同样发挥着重要作用，通过火焰图，我们可以从宏观的角度看到整个程序的性能热点，快速锁定需要优化的区域。热点分析也是 Perf Profiling 功能的重要组成部分，它能够帮助我们找出程序中最常被访问或执行时间最长的代码区域，这些区域往往是性能优化的关键所在。在开发一个大型软件项目时，可能存在一些核心算法或频繁调用的函数，通过 Perf 的 Profiling 功能，我们可以准确地找出这些函数和代码行，对其进行优化，从而提高整个软件的性能。</p><p><strong>(4)基准测试</strong></p><p>在基准测试方面，Perf 可以与其他基准测试工具如 sysbench、fio 等结合使用，对系统的整体性能进行全面评估。与 sysbench 结合时，Perf 可以测量 CPU 在不同负载下的性能表现，比如在高并发的数据库事务处理中，CPU 的运算速度、响应时间等指标，这对于评估服务器在实际业务场景中的性能非常重要。在内存性能评估上，Perf 与 fio 配合，能够精准地测量内存的读写速度、带宽利用率等参数。磁盘 IO 性能也是 Perf 的 “拿手好戏”，它可以测试磁盘的读写速率、寻道时间等关键指标，为系统调优提供全面而准确的参考数据。在构建一个大型数据中心时，需要对服务器的性能进行全面评估，Perf 与其他基准测试工具的结合使用，可以帮助我们了解服务器在不同工作负载下的性能表现，从而合理配置硬件资源，提高系统的整体性能。</p><p><strong>(5)调试功能</strong></p><p>Perf 还具备强大的调试功能，它可以与调试器如 gdb 结合使用，为开发人员提供更详细的性能分析和调试信息。在程序运行时，Perf 能够捕获跟踪数据，这些数据就像是程序运行的 “脚印”，记录了程序的执行过程。并且，Perf 可以将这些跟踪数据与源代码进行关联，就像将案件的线索与嫌疑人的行为联系起来，让开发人员能够清晰地看到程序在执行过程中各个函数的调用情况、执行时间以及变量的变化等信息，从而更好地理解程序的运行机制，快速定位并解决性能问题。在开发一个复杂的软件系统时，可能会遇到一些难以排查的性能问题，通过 Perf 与 gdb 的结合使用，开发人员可以深入分析程序的执行过程，找出问题的根源，提高软件开发的效率和质量。</p><h1>二、Perf安装与使用</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21安装-perf">2.1安装 Perf<a class="hash-link" href="#21安装-perf" title="标题的直接链接">​</a></h2><p>在使用 Perf 之前，首先需要将其安装到系统中。Perf 在不同的 Linux 发行版中有不同的安装方式。</p><p>在基于 Debian 或 Ubuntu 的系统中，Perf 工具通常包含在linux-tools-common和linux-tools-&lt; kernel-version&gt;包中。安装命令如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo apt-get install linux-tools-common linux-tools-`uname -r`</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述命令中，uname -r用于获取当前系统的内核版本，linux-tools-kernel-version包会根据实际的内核版本进行安装，确保 Perf 与系统内核版本兼容。</p><p>对于基于 Red Hat 或 CentOS 的系统，可以使用 yum 包管理器进行安装：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo yum install perf</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果系统中没有配置对应的 yum 源，可能需要先配置 yum 源，再进行安装。yum 源的配置方式根据不同的系统和需求有所不同，一般可以通过下载官方的 yum 源配置文件，放置到/etc/yum.repos.d/目录下，并根据实际情况修改文件中的参数，如baseurl、gpgcheck等。</p><p>从源码安装 Perf 则是另一种安装方式，适合那些需要定制 Perf 功能或在没有包管理器的环境中安装的情况。首先，需要从 Linux 内核官方网站下载内核源码，下载命令如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下载完成后，进入内核源码目录中的tools/perf子目录，执行make命令进行编译：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cd linux/tools/perf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">make</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>编译过程中，系统会检查依赖库的情况，如果缺少依赖库，会提示需要安装相应的库。安装完所有依赖库后，再次执行make命令进行编译。编译完成后，在当前目录下会生成一个名为perf的二进制文件，这就是 Perf 工具。可以将其复制到系统的可执行文件目录中，如/usr/local/bin/，以便在系统的任何位置都能执行 Perf 命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo cp perf /usr/local/bin/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>安装完成后，可以通过运行perf --version命令来验证 Perf 是否正确安装。如果安装成功，会显示 Perf 的版本信息。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22perf的基本使用">2.2Perf的基本使用<a class="hash-link" href="#22perf的基本使用" title="标题的直接链接">​</a></h2><p>CPU周期(cpu-cycles)是默认的性能事件，所谓的CPU周期是指CPU所能识别的最小时间单元，通常为亿分之几秒，是CPU执行最简单的指令时所需要的时间，例如读取寄存器中的内容，也叫做clock tick。</p><p>perf COMMAND <!-- -->[-e event ...]<!-- --> PROGRAM, perf 是采用的这么一个命令格式, COMMAND一般常用的就是 top, stat, record, report等. 然后用 -e 参数来统计需要关注的事件. 多个事件就用多个 -e 连接。</p><p>Perf是一个包含22种子工具的工具集，以下是最常用的6种：</p><ol><li>perf-list</li><li>perf-stat</li><li>perf-top</li><li>perf-record</li><li>perf-report</li><li>perf-trace</li></ol><p><strong>⑴perf-list</strong></p><p>Perf-list用来查看perf所支持的性能事件，有软件的也有硬件的。
List all symbolic event types。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">perf list [hw | sw | cache | tracepoint | event_glob]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><strong>⑵perf stat</strong></p><p>说明一个工具的最佳途径是列举一个例子。考查下面这个例子程序。其中函数 longa() 是个很长的循环，比较浪费时间。函数 foo1 和 foo2 将分别调用该函数 10 次，以及 100 次。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//t1.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void longa()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int i,j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for(i = 0; i &lt; 1000000; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   j=i; //am I silly or crazy? I feel boring and desperate.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void foo2()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for(i=0 ; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        longa();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void foo1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   for(i = 0; i&lt; 100; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      longa();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> int main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   foo1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   foo2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后编译它：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gcc -o t1 -g t1.c</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面演示了 perf stat 针对程序 t1 的输出：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">root@ubuntu-test:~# perf stat ./t1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;./t1&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        218.584169 task-clock # 0.997 CPUs utilized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                18 context-switches # 0.000 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 CPU-migrations # 0.000 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                82 page-faults # 0.000 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       771,180,100 cycles # 3.528 GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     &lt;not counted&gt; stalled-cycles-frontend</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     &lt;not counted&gt; stalled-cycles-backend</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       550,703,114 instructions # 0.71 insns per cycle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       110,117,522 branches # 503.776 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             5,009 branch-misses # 0.00% of all branches</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0.219155248 seconds time elapsed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">程序 t1 是一个 CPU bound 型，因为 task-clock-msecs 接近 1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对 t1 进行调优应该要找到热点 ( 即最耗时的代码片段 )，再看看是否能够提高热点代码的效率。缺省情况下，除了 task-clock-msecs 之外，perf stat 还给出了其他几个最常用的统计信息：</p><ul><li>Task-clock-msecs：CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。</li><li>Context-switches：进程切换次数，记录了程序运行过程中发生了多少次进程切换，频繁的进程切换是应该避免的。</li><li>Cache-misses：程序运行过程中总体的 cache 利用情况，如果该值过高，说明程序的 cache 利用不好</li><li>CPU-migrations：表示进程 t1 运行过程中发生了多少次 CPU 迁移，即被调度器从一个 CPU 转移到另外一个 CPU 上运行。</li><li>Cycles：处理器时钟，一条机器指令可能需要多个 cycles，Instructions: 机器指令数目。</li><li>IPC：是 Instructions/Cycles 的比值，该值越大越好，说明程序充分利用了处理器的特性。</li><li>Cache-references: cache 命中的次数，Cache-misses: cache 失效的次数。</li></ul><p>通过指定 -e 选项，您可以改变 perf stat 的缺省事件 ( 关于事件，在上一小节已经说明，可以通过 perf list 来查看 )。假如您已经有很多的调优经验，可能会使用 -e 选项来查看您所感兴趣的特殊的事件。</p><p>有些程序慢是因为计算量太大，其多数时间都应该在使用 CPU 进行计算，这叫做 CPU bound 型；有些程序慢是因为过多的 IO，这种时候其 CPU 利用率应该不高，这叫做 IO bound 型；对于 CPU bound 程序的调优和 IO bound 的调优是不同的。</p><p><strong>⑶perf top</strong></p><p>使用 perf stat 的时候，往往您已经有一个调优的目标。比如我刚才写的那个无聊程序 t1。</p><p>也有些时候，您只是发现系统性能无端下降，并不清楚究竟哪个进程成为了贪吃的 hog。</p><p>此时需要一个类似 top 的命令，列出所有值得怀疑的进程，从中找到需要进一步审查的家伙。</p><p>Perf top 用于实时显示当前系统的性能统计信息。该命令主要用来观察整个系统当前的状态，比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程。</p><p>让我们再设计一个例子来演示吧，我很快就想到了如代码清单 2 所示的一个程序：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//t2.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main(){</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(1) i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>然后编译这个程序：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gcc -o t2 -g t2.c</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行这个程序后， 我们另起一个窗口，运行perf top来看看：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Events: 8K cycles</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 98.67% t2 [.] main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1.10% [kernel] [k] __do_softirq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0.07% [kernel] [k] _raw_spin_unlock_irqrestore</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0.05% perf [.] kallsyms__parse</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0.05% libc-2.15.so [.] 0x807c7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0.05% [kernel] [k] kallsyms_expand_symbol</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  0.02% perf [.] map__process_kallsym_symbol</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>很容易便发现 t2 是需要关注的可疑程序。不过其作案手法太简单：肆无忌惮地浪费着 CPU。所以我们不用再做什么其他的事情便可以找到问题所在。但现实生活中，影响性能的程序一般都不会如此愚蠢，所以我们往往还需要使用其他的 perf 工具进一步分析。</p><p><strong>⑷使用 perf record, 解读 report</strong></p><p>使用 top 和 stat 之后，您可能已经大致有数了。要进一步分析，便需要一些粒度更细的信息。比如说您已经断定目标程序计算量较大，也许是因为有些代码写的不够精简。那么面对长长的代码文件，究竟哪几行代码需要进一步修改呢？这便需要使用 perf record 记录单个函数级别的统计信息，并使用 perf report 来显示统计结果。</p><p>您的调优应该将注意力集中到百分比高的热点代码片段上，假如一段代码只占用整个程序运行时间的 0.1%，即使您将其优化到仅剩一条机器指令，恐怕也只能将整体的程序性能提高 0.1%。俗话说，好钢用在刀刃上，不必我多说了。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">perf record -e cpu-clock ./t1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">perf report</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>perf report 输出结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Events: 229 cpu-clock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100.00% t1 t1 [.] longa</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>不出所料，hot spot 是 longa( ) 函数。但，代码是非常复杂难说的，t1 程序中的 foo1() 也是一个潜在的调优对象，为什么要调用 100 次那个无聊的 longa() 函数呢？但我们在上图中无法发现 foo1 和 foo2，更无法了解他们的区别了。</p><p>我曾发现自己写的一个程序居然有近一半的时间花费在 string 类的几个方法上，string 是 C++ 标准，我绝不可能写出比 STL 更好的代码了。因此我只有找到自己程序中过多使用 string 的地方。因此我很需要按照调用关系进行显示的统计信息。</p><p>使用 perf 的 -g 选项便可以得到需要的信息：</p><p>输出结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Events: 270 cpu-clock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- 100.00% t1 t1 [.] longa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   - longa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      + 91.85% foo1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      + 8.15% foo2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过对 calling graph 的分析，能很方便地看到 91.85% 的时间都花费在 foo1() 函数中，因为它调用了 100 次 longa() 函数，因此假如 longa() 是个无法优化的函数，那么程序员就应该考虑优化 foo1，减少对 longa() 的调用次数。</p><p><strong>⑸使用tracepoint</strong></p><p>当 perf 根据 tick 时间点进行采样后，人们便能够得到内核代码中的 hot spot。那什么时候需要使用 tracepoint 来采样呢？</p><p>我想人们使用 tracepoint 的基本需求是对内核的运行时行为的关心，如前所述，有些内核开发人员需要专注于特定的子系统，比如内存管理模块。这便需要统计相关内核函数的运行情况。另外，内核行为对应用程序性能的影响也是不容忽视的：</p><p>以之前的遗憾为例，假如时光倒流，我想我要做的是统计该应用程序运行期间究竟发生了多少次系统调用。在哪里发生的？</p><p>下面我用 ls 命令来演示 sys_enter 这个 tracepoint 的使用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">root@ubuntu-test:~# perf stat -e raw_syscalls:sys_enter ls</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bin libexec off perf.data.old t1 t3 tutong.iso</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bwtest minicom.log perf.data pktgen t1.c t3.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Performance counter stats for &#x27;ls&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               111 raw_syscalls:sys_enter</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0.001557549 seconds time elapsed</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上个报告详细说明了在 ls 运行期间发生了多少次系统调用 ( 上例中有 111 次 )。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23常用命令详解">2.3常用命令详解<a class="hash-link" href="#23常用命令详解" title="标题的直接链接">​</a></h2><p>Perf 提供了丰富的命令和参数，以满足不同的性能分析需求。下面详细介绍一些常用的命令及参数。</p><p><strong>(1)列出所有可监测事件</strong></p><p>perf list命令用于列出系统中所有可监测的性能事件，这些事件包括硬件性能事件、软件性能事件以及 tracepoints。硬件性能事件由 CPU 硬件提供，如cycles表示 CPU 时钟周期计数，instructions表示执行的指令数，cache-misses表示缓存未命中计数等；软件性能事件由内核软件提供，例如context-switches表示上下文切换的次数，page-faults表示页面错误的次数，cpu-migrations表示 CPU 迁移的次数等；tracepoints 则是内核中静态 tracepoint 所触发的事件，用来判断程序运行期间内核的行为细节 。使用perf list命令可以查看系统支持的所有事件类型，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">List of pre-defined events (to be used in -e):</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-instructions OR branches                    [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-misses                                      [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bus-cycles                                         [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-misses                                       [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-references                                   [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-cycles OR cycles                               [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  instructions                                       [Hardware event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  alignment-faults                                   [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bpf-output                                         [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  context-switches OR cs                             [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-clock                                          [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-migrations OR migrations                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dummy                                              [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  emulation-faults                                   [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  major-faults                                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  minor-faults                                       [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  page-faults OR faults                              [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  task-clock                                         [Software event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  duration_time                                      [Tool event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-load-misses                              [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-loads                                    [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-dcache-stores                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-icache-load-misses                              [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  L1-icache-loads                                    [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-load-misses                                 [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-loads                                       [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dTLB-load-misses                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dTLB-loads                                         [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dTLB-store-misses                                  [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  dTLB-stores                                        [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  iTLB-load-misses                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  iTLB-loads                                         [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  node-load-misses                                   [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  node-loads                                         [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  node-store-misses                                  [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  node-stores                                        [Hardware cache event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-instructions OR cpu/branch-instructions/    [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  branch-misses OR cpu/branch-misses/                [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bus-cycles OR cpu/bus-cycles/                      [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-misses OR cpu/cache-misses/                  [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cache-references OR cpu/cache-references/          [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  cpu-cycles OR cpu/cpu-cycles/                      [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  instructions OR cpu/instructions/                  [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mem-loads OR cpu/mem-loads/                        [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  mem-stores OR cpu/mem-stores/                      [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ref-cycles OR cpu/ref-cycles/                      [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  topdown-fetch-bubbles OR cpu/topdown-fetch-bubbles/ [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  topdown-recovery-bubbles OR cpu/topdown-recovery-bubbles/ [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  topdown-slots-issued OR cpu/topdown-slots-issued/  [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  topdown-slots-retired OR cpu/topdown-slots-retired/ [Kernel PMU event]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  topdown-total-slots OR cpu/topdown-total-slots/    [Kernel PMU event]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过查看这些事件，可以了解系统中哪些性能指标是可以被监测的，从而在进行性能分析时选择合适的事件进行监测。</p><p><strong>(2)显示统计信息</strong></p><p>perf stat命令用于分析指定程序或命令的性能概况，它会在程序执行结束后，输出各类事件的统计信息，帮助用户了解程序在运行过程中的性能表现。例如，使用perf stat命令监测ls命令的性能：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf stat ls</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Performance counter stats for &#x27;ls&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         0.653782 task-clock (msec)         #    0.691 CPUs utilized</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 context-switches          #    0.000 K/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 0 CPU-migrations            #    0.000 K/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               247 page-faults               #    0.378 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         1,625,426 cycles                    #    2.486 GHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         1,050,293 stalled-cycles-frontend   #   64.62% frontend cycles idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           838,781 stalled-cycles-backend    #   51.60% backend cycles idle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         1,055,735 instructions              #    0.65  insns per cycle</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              #    0.99  stalled cycles per insn</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           210,587 branches                  #  322.106 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            10,809 branch-misses             #    5.13% of all branches</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0.000945883 seconds time elapsed</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述输出中，task-clock表示任务真正占用的处理器时间，单位为毫秒；CPUs utilized表示 CPU 的占用率，通过task-clock除以time elapsed计算得出；context-switches表示上下文的切换次数；CPU-migrations表示处理器迁移次数，Linux 为了维持多个处理器的负载均衡，在特定条件下会将某个任务从一个 CPU 迁移到另一个 CPU；page-faults表示缺页异常的次数，当应用程序请求的页面尚未建立、请求的页面不在内存中，或者请求的页面虽然在内存中，但物理地址和虚拟地址的映射关系尚未建立时，都会触发一次缺页异常；cycles表示消耗的处理器周期数；instructions表示执行的指令数；branches表示遇到的分支指令数；branch-misses表示预测错误的分支指令数；time elapsed表示程序持续时间。</p><p>perf stat命令还可以通过-e选项指定要显示统计的性能事件，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf stat -e cache-misses,cache-references ls</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Performance counter stats for &#x27;ls&#x27;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            13,808 cache-misses              #    14.603 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            53,932 cache-references          #    57.029 M/sec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       0.000945883 seconds time elapsed</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述命令只统计了cache-misses和cache-references事件，帮助用户更专注地了解程序在缓存方面的性能表现。</p><p><strong>(3)实时查看系统性能</strong></p><p>perf top命令用于实时显示系统或进程的性能统计信息，它会动态地展示占用最多 CPU 时间的函数或程序，类似于top命令，但更加专注于性能分析。直接运行perf top命令，将会展示系统中所有的进程和函数，按照它们占用 CPU 时间的百分比降序排列：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf top</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Samples: 1M of event &#x27;cycles&#x27;, Event count (approx.): 73891391490</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5.44%  perf                 [.] 0x0000000000023256</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4.86%  [kernel]             [k] _spin_lock</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2.43%  [kernel]             [k] _spin_lock_bh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2.29%  [kernel]             [k] _spin_lock_irqsave</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1.77%  [kernel]             [k] __d_lookup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1.55%  libc-2.12.so         [.] __strcmp_sse42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1.43%  nginx                [.] ngx_vslprintf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1.37%  [kernel]             [k] tcp_poll</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第一列表示符号引发的性能事件的比例，默认指占用的 CPU 周期比例；第二列表示符号所在的 DSO（Dynamic Shared Object），可以是应用程序、内核、动态链接库、模块；第三列表示 DSO 的类型，<!-- -->[.]<!-- -->表示此符号属于用户态的 ELF 文件，包括可执行文件与动态链接库，<!-- -->[k]<!-- -->表示此符号属于内核或模块；第四列表示符号名，有些符号不能解析为函数名，只能用地址表示。</p><p>如果只想关注特定的进程，可以使用-p选项，后面跟上进程的 PID：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf top -p &lt;PID&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用-e选项可以指定一个特定的性能事件，比如关心缓存未命中（cache misses）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf top -e cache-misses</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>-a选项用于查看所有 CPU 的数据，而不仅仅是默认的 CPU 0：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf top -a</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>-K选项可以隐藏内核相关的符号，如果只对用户空间的性能感兴趣，这个选项会非常有用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf top -K</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在运行perf top时，需要确保有足够的权限，大多数情况下，需要 root 权限才能运行它。并且，perf top的结果是实时更新的，用户只需要保持窗口开启，就可以实时观察到系统性能的变化。</p><p><strong>(4)记录与生成报告</strong></p><p>perf record命令用于收集程序运行时的性能数据，并将数据保存到一个名为perf.data的文件中。例如，使用perf record命令记录ls命令的性能数据：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf record -g ls</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述命令中，-g选项用于记录函数间的调用关系，方便后续分析函数的调用栈。运行该命令后，ls命令的性能数据会被记录到perf.data文件中。</p><p>perf report命令用于分析perf record生成的perf.data文件，并显示分析报告。运行perf report命令后，会进入一个交互式界面，展示性能数据的详细分析结果，包括函数的调用关系、每个函数占用的 CPU 时间等信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ perf report -i perf.data</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>-i选项用于指定要分析的perf.data文件，如果不指定，默认分析当前目录下的perf.data文件。在交互式界面中，可以使用方向键上下移动选择不同的函数，按回车键可以查看函数的详细信息，如汇编代码、调用栈等。还可以使用/键进行搜索，输入关键词来查找特定的函数或符号。</p><p>此外，perf report命令还可以通过其他参数进行更详细的分析。例如，-d选项只显示指定 DSO 的符号，-C选项只显示指定 comm（触发事件的进程名）的信息，-S选项只考虑指定符号，-U选项只显示已解析的符号，-g<!-- -->[type,min,order]<!-- -->选项显示调用关系，具体等同于perf top命令中的-g选项 。通过这些参数的组合使用，可以根据具体需求对性能数据进行更有针对性的分析。</p><h1>三、Perf的应用场景与重要性</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31性能问题定位">3.1性能问题定位<a class="hash-link" href="#31性能问题定位" title="标题的直接链接">​</a></h2><p>perf 在解决系统性能问题方面发挥着至关重要的作用。当面临 CPU 利用率过高的情况时，perf 可以通过收集性能数据，分析各个进程和函数对 CPU 资源的占用情况，找出导致高 CPU 使用率的热点代码段。例如，通过 perf top 命令可以实时显示当前系统中消耗 CPU 周期最多的函数或指令，快速定位可能存在性能问题的代码区域。</p><p>在 cache miss 过多的场景下，perf 能够评估程序对各级 cache 的访问次数和丢失次数。利用 perf stat 命令可以查看与 cache 相关的性能事件，如 L1-dcache-loads、L1-dcache-load-miss 等，了解 cache 的利用情况。如果发现 cache miss 率过高，可以进一步分析代码，优化数据访问模式以提高 cache 命中率。</p><p>对于内存 I/O 过慢的问题，perf 可以评估程序的内存访问行为。通过收集与内存相关的性能事件，如 page-faults、dTLB-loads、dTLB-load-miss 等，分析内存访问的效率。如果频繁出现页错误或者 TLB 未命中，可能需要调整内存分配策略或者优化数据结构，以减少内存访问的开销。</p><p>此外，perf 还可以生成程序的调用图，记录函数之间的调用关系。通过 perf record 和 perf report 命令，可以收集程序运行时的性能数据，并生成详细的报告，包括函数调用图、耗时分布等信息。这有助于理解程序的执行流程，找出可能存在性能瓶颈的函数调用链。</p><p>同时，perf 还能检测程序的内存泄漏问题。虽然文章中未明确提及 perf 在内存泄漏检测方面的具体方法，但可以推测，通过对内存相关性能事件的监测以及对程序运行时内存使用情况的分析，可能能够发现内存泄漏的迹象。例如，持续观察内存使用量的增长情况，结合函数调用图分析可能存在内存分配但未释放的位置。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32性能优化关键">3.2性能优化关键<a class="hash-link" href="#32性能优化关键" title="标题的直接链接">​</a></h2><p>perf 在程序性能优化中具有不可替代的重要性。它可以深入了解应用程序的执行过程，为开发者提供关键的性能指标和分析结果，帮助发现性能瓶颈并进行针对性优化。</p><p>通过追踪 CPU 使用情况，开发者可以了解程序在不同阶段对 CPU 资源的消耗情况。利用 perf stat 命令可以获取诸如 cycles、instructions、IPC 等指标，分析程序是否充分利用了处理器的特性。如果 IPC 值较低，可能需要优化代码以提高指令的执行效率，减少不必要的指令或循环。</p><p>内存占用的追踪也是性能优化的重要方面。perf 可以监测内存的使用情况，包括内存分配、释放以及 cache 的利用情况。通过分析这些数据，可以优化内存管理策略，减少内存碎片，提高内存的使用效率。例如，合理调整数据结构的大小和布局，避免频繁的内存分配和释放操作。</p><p>函数调用堆栈的追踪可以帮助开发者找出热点函数，即那些消耗大量资源的函数。利用 perf top 和 perf record 命令可以收集函数级别的性能数据，确定哪些函数是性能瓶颈所在。针对热点函数，可以进行算法优化或代码重构，提高其执行效率。</p><h1>四、常见性能问题分析</h1><p><strong>⑴性能测试大致分以下几个步骤：</strong></p><ol><li>需求分析</li><li>脚本准备</li><li>测试执行</li><li>结果整理</li><li>问题分析</li></ol><blockquote><p>需求描述：有一个服务，启动时会加载一个1G的词表文件到内存，请求来了之后，会把请求词去词表里做模糊匹配，如果匹配到了就向一个后端服务发送一条http请求，拿回数据之后，返回给客户端的同时，向mysql记录请求的唯一标识和一个请求次数的标记；</p></blockquote><ul><li>其中有几个关键函数</li><li>模糊匹配（fuzzyMatching）</li><li>后端请求函数（sendingRequest）</li><li>拼装请求函数（buildResponse）</li><li>记录mysql请求次数标记（signNum）</li></ul><p><strong>问题及分析：</strong></p><p>第一组：完全随机请求词，qps达到1k时，服务器未见异常，cpu、内存、带宽均未满，qps无法继续提升；</p><blockquote><p>分析：由于此服务后端连接了其它服务，所以在压测之前，要确认后端服务不会成为瓶颈点，目前的状态很可能是后端服务限制了被测服务的性能；此时可以检查后端服务所在机器的各项指标，或者查看本机的连接状况，一般后端服务无法处理，而被测服务又会一直向后面请求的话，timewait状态的连接会变得比较多；</p></blockquote><p>第二组：解决后端服务的问题后，第二组使用平均30个字的请求词，来打压，qps到400时，cpu load已满；</p><blockquote><p>分析：这种情况明显是由于fuzzyMatching函数计算效率的问题导致cpu满载，从而无法提升qps，使响应时间不断增大，此时可以通过perf+火焰图来确定整个处理请求过程中响应时间长的函数；此时需要评估压测数据是否合理，如果线上平均请求词只有2个的时候，此组测试明显不合理，此时要开发进行性能优化就是浪费时间的；如果评估测试数据合理，可以再次更换短词数据进行压测验证猜测；</p></blockquote><p>第三组：解决了上述两个问题之后，使用完全随机请求词，qps到达3k后降低至1k，然后再次提升到3k，如此反复；</p><blockquote><p>分析：此时关注一下各项指标，排除了以上的问题的话，操作mysql慢的问题可能性大一些，对这种需要高并发的系统来说，直接读写mysql不是个聪明的解决方案，一般会用redis做一层缓存，这里说道的另一个问题就是开发设计不合理，导致的性能问题；</p></blockquote><p>第四组：将后端换做真实的服务来做整体压测，发现qps最高只能到300，此时检查各项指标，发现入口带宽占满了；</p><blockquote><p>分析：这次问题比较明显，后端服务返回内容过大，导致带宽被占满，此时依然需要评估需求：1、是否需要后端返回的所有数据内容；2、评估更换万兆网卡的性价比；3、是否可以通过技术手段优化带宽占用，比如把一次请求分散到多组服务的多个请求；</p></blockquote><p><strong>⑵perf+火焰图定位函数问题</strong></p><p>这里简单说一下如何使用perf+火焰图来直观的定位性能问题：</p><p>Perf 拥有了众多的性能分析能力，举例来说，使用 Perf 可以计算每个时钟周期内的指令数，称为 IPC，IPC 偏低表明代码没有很好地利用 CPU。Perf 还可以对程序进行函数级别的采样，从而了解程序的性能瓶颈究竟在哪里等等。Perf 还可以替代 strace，可以添加动态内核 probe 点，还可以做 benchmark 衡量调度器的好坏。</p><ul><li>使用举例：perf record -e cpu-clock -g -p 11110 -o data/perf.data sleep 30</li><li>-g 选项是告诉perf record额外记录函数的调用关系 -e cpu-clock 指perf record监控的指标为cpu周期 -p 指定需要record的进程pid</li></ul><p><strong>⑶生成火焰图</strong></p><p>①第一步：使用压力测试工具对程序进行打压，压到程序拐点；</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$sudo perf record -e cpu-clock -g -p 11110</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Ctrl+c结束执行后，在当前目录下会生成采样数据perf.data.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>②第二步：用perf 工具对perf.data进行解析</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">perf -i perf.data &amp;&gt; perf.unfold</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>⑶第三步：将perf.unfold中的符号进行折叠：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>④最后生成svg图：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./flamegraph.pl perf.folded &gt; perf.svg</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>到这儿可以生成函数调用火焰图，如下图：</p><p><img loading="lazy" alt="640" src="/assets/images/640-0b60176d0282c75e79d7c1e77db248cf.webp" width="720" height="414" class="img_ev3q"></p><p>原生的perf可以直接定位C/C++的程序，通常编译debug版本的程序能看到更多的信息，java、go等语言可以通过各自定制的工具来生成，原理类似；通过火焰图可以轻松定位到哪个函数的处理时间最长，从而找到问题所在。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.889Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->15 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux内核中，信号处理是一个复杂的过程，涉及用户态和内核态的交互。以下是信号处理的详细流程，结合代码和注释进行说明。</p><h1>一、信号处理的整体流程</h1><p>信号处理的流程可以分为以下几个步骤：</p><ol><li><p>信号产生：内核或用户程序发送信号。</p></li><li><p>信号传递：内核将信号添加到目标进程的信号队列中。</p></li><li><p>信号检查：在进程从内核态返回到用户态时，内核检查是否有未处理的信号。</p></li><li><p>信号处理：</p><p>​	如果进程注册了信号处理函数，内核会调用该函数。</p><p>​	如果没有注册处理函数，内核会执行默认行为（如终止进程、忽略信号等）。</p></li><li><p>信号处理完成：进程返回到被信号打断的代码位置继续执行。</p></li></ol><h1>二、信号处理的代码实现</h1><p>以下是Linux内核中信号处理的核心代码片段，结合注释进行说明。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-信号传递">2.1 信号传递<a class="hash-link" href="#21-信号传递" title="标题的直接链接">​</a></h2><p>当内核需要向进程发送信号时，会调用<code>send_signal()</code>函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;/kernel/signal.c&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * send_signal - 向指定任务发送信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @sig: 要发送的信号编号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @info: 指向kernel_siginfo结构的指针，包含信号信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @t: 指向目标任务结构的指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @type: 进程ID类型</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 此函数负责向指定的任务发送信号。根据信号的不同来源和类型，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 可能需要强制发送信号（即使目标进程通常会忽略该信号）。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 函数处理了不同命名空间之间的信号发送，并适当调整信号发送者的</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 用户ID和进程ID信息。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 返回值：成功发送信号返回0，失败返回相应的错误码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            enum pid_type type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Should SIGKILL or SIGSTOP be received by a pid namespace init? */ //  检查SIGKILL或SIGSTOP信号是否应该被pid namespace的init进程接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool force = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (info == SEND_SIG_NOINFO) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Force if sent from an ancestor pid namespace */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        force = !task_pid_nr_ns(current, task_active_pid_ns(t)); //  根据当前进程和目标进程的命名空间关系决定是否强制发送信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (info == SEND_SIG_PRIV) { //  判断是否为特权信号发送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* Don&#x27;t ignore kernel generated signals */ //  不要忽略内核生成的信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        force = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (has_si_pid_and_uid(info)) { //  检查是否具有特殊信号ID和用户ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* SIGKILL and SIGSTOP is special or has ids */ //  SIGKILL和SIGSTOP是特殊信号或者具有ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct user_namespace *t_user_ns; //  定义用户命名空间指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rcu_read_lock(); //  读锁，确保RCU读临界区安全</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        t_user_ns = task_cred_xxx(t, user_ns); //  获取目标任务的用户命名空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (current_user_ns() != t_user_ns) { //  如果当前用户命名空间与目标不同</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            kuid_t uid = make_kuid(current_user_ns(), info-&gt;si_uid); //  创建当前命名空间的UID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            info-&gt;si_uid = from_kuid_munged(t_user_ns, uid); //  转换为目标命名空间的UID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        rcu_read_unlock(); //  释放读锁</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* A kernel generated signal? */ //  是否为内核生成的信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        force = (info-&gt;si_code == SI_KERNEL); //  设置force标志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /* From an ancestor pid namespace? */ //  是否来自祖先PID命名空间</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!task_pid_nr_ns(current, task_active_pid_ns(t))) { //  如果当前进程不在目标的PID命名空间中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            info-&gt;si_pid = 0; //  重置发送者PID为0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            force = true; //  设置强制发送标志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return __send_signal(sig, info, t, type, force); //  调用底层信号发送函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><strong><code>send_signal()</code></strong>：将信号添加到目标进程的信号队列中。</li><li><strong><code>signal_wake_up()</code></strong>：如果进程处于可中断睡眠状态，唤醒进程。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22--信号检查">2.2  信号检查<a class="hash-link" href="#22--信号检查" title="标题的直接链接">​</a></h2><p>在进程从内核态返回到用户态时，内核会调用<code>do_signal()</code>函数检查是否有未处理的信号。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/kernel/signal.c&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * do_signal - 处理当前进程的待处理信号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @regs: 指向CPU寄存器状态的指针，包含当前进程的上下文信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 该函数负责处理当前进程的待处理信号。主要功能包括：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 1. 检查是否在系统调用中，如果是则处理系统调用重启相关逻辑</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 2. 获取需要传递的信号，并根据信号设置决定是否重启系统调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 3. 如果没有需要处理的信号，则处理系统调用重启的特殊情况</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 4. 恢复保存的信号掩码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 注意：该函数在返回用户空间之前被调用，此时调试器可能改变所有寄存器的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void do_signal(struct pt_regs *regs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long continue_addr = 0, restart_addr = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int retval = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct ksignal ksig;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bool syscall = in_syscall(regs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果来自系统调用，检查是否需要重启系统调用...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (syscall) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        continue_addr = regs-&gt;pc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        restart_addr = continue_addr - (compat_thumb_mode(regs) ? 2 : 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        retval = regs-&gt;regs[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 避免通过ret_to_user进行额外的系统调用重启</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        forget_syscall(regs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 准备系统调用重启。我们在这里做这个操作，这样调试器就能看到已经改变的PC。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (retval) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case -ERESTARTNOHAND:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case -ERESTARTSYS:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case -ERESTARTNOINTR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        case -ERESTART_RESTARTBLOCK:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            regs-&gt;regs[0] = regs-&gt;orig_x0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            regs-&gt;pc = restart_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 获取需要传递的信号。在ptrace下运行时，此时调试器可能会改变我们的所有寄存器。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (get_signal(&amp;ksig)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 根据信号设置，我们可能需要撤销重启系统调用的决定，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 但如果调试器选择在不同的PC处重启，则跳过此步骤。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (regs-&gt;pc == restart_addr &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            (retval == -ERESTARTNOHAND ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             retval == -ERESTART_RESTARTBLOCK ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (retval == -ERESTARTSYS &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              !(ksig.ka.sa.sa_flags &amp; SA_RESTART)))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            syscall_set_return_value(current, regs, -EINTR, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            regs-&gt;pc = continue_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        handle_signal(&amp;ksig, regs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 处理重启不同的系统调用。如上所述，如果调试器选择在不同的PC处重启，则忽略重启。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (syscall &amp;&amp; regs-&gt;pc == restart_addr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (retval == -ERESTART_RESTARTBLOCK)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            setup_restart_syscall(regs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        user_rewind_single_step(current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    restore_saved_sigmask();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li><strong><code>get_signal()</code></strong>：从信号队列中获取一个未处理的信号。</li><li><strong><code>handle_signal()</code></strong>：调用用户注册的信号处理函数。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="23信号处理">2.3信号处理<a class="hash-link" href="#23信号处理" title="标题的直接链接">​</a></h2><p>如果进程注册了信号处理函数，内核会调用<code>handle_signal()</code>函数。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/kernel/signal.c&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * handle_signal - 处理信号传递和设置信号处理栈帧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @ksig: 包含信号信息的结构体指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @regs: 指向处理器寄存器状态的指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 该函数负责处理信号的传递，包括设置信号处理程序的栈帧，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 并确保寄存器状态的有效性。根据任务是否为兼容模式（compat mode），</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 选择不同的栈帧设置方式。最后，检查寄存器状态是否有效，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 并完成信号处理的设置。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 注意：该函数在内核信号处理路径中被调用。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sigset_t *oldset = sigmask_to_save(); //  保存当前信号掩码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int usig = ksig-&gt;sig; //  获取信号编号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret; //  返回值，用于标记操作是否成功</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    rseq_signal_deliver(ksig, regs); //  执行线程相关的信号处理</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Set up the stack frame</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (is_compat_task()) { //  检查当前任务是否为兼容模式</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (ksig-&gt;ka.sa.sa_flags &amp; SA_SIGINFO) //  如果是兼容模式且设置了SA_SIGINFO标志，则设置兼容版本的实时信号处理帧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = compat_setup_rt_frame(usig, ksig, oldset, regs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else //  否则设置兼容版本的普通信号处理帧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ret = compat_setup_frame(usig, ksig, oldset, regs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret = setup_rt_frame(usig, ksig, oldset, regs); //  非兼容模式下，设置实时信号处理帧</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Check that the resulting registers are actually sane.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret |= !valid_user_regs(&amp;regs-&gt;user_regs, current); //  将valid_user_regs函数的返回值与ret进行按位或操作，并更新ret的值 valid_user_regs用于验证用户寄存器的有效性，参数为用户寄存器结构和当前进程 如果寄存器无效，则!valid_user_regs返回1，否则返回0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Step into the signal handler if we are stepping */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    signal_setup_done(ret, ksig, test_thread_flag(TIF_SINGLESTEP)); //  如果当前线程设置了单步执行标志(TIF_SINGLESTEP)，则进入信号处理程序 signal_setup_done函数完成信号处理的设置工作 参数ret表示之前的处理状态，ksig表示信号结构，test_thread_flag用于检查线程标志</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="24-信号处理完成">2.4 信号处理完成<a class="hash-link" href="#24-信号处理完成" title="标题的直接链接">​</a></h2><p>信号处理函数执行完毕后，进程会返回到被信号打断的代码位置继续执行</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/kernel/signal.c&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * rt_sigreturn - 系统调用，用于从信号处理程序返回并恢复进程上下文</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 该函数实现了rt_sigreturn系统调用，其主要功能是：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 1. 确保任何待重启的系统调用返回-EINTR</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 2. 检查栈指针是否对齐（128位边界）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 3. 验证用户空间信号帧的内存可访问性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 4. 恢复信号帧中的寄存器状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 5. 恢复备选栈信息</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 6. 返回原始系统调用的返回值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 返回值：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 成功时返回原始系统调用的返回值（regs-&gt;regs[0]）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 失败时发送段错误信号并返回0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SYSCALL_DEFINE0(rt_sigreturn)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct pt_regs *regs = current_pt_regs(); //  获取当前进程的寄存器状态</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct rt_sigframe __user *frame; //  定义一个指向用户空间信号帧结构的指针</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Always make any pending restarted system calls return -EINTR */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    current-&gt;restart_block.fn = do_no_restart_syscall; //  设置当前进程的重启块函数为do_no_restart_syscall，表示不重启系统调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Since we stacked the signal on a 128-bit boundary, then &#x27;sp&#x27; should</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * be word aligned here.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (regs-&gt;sp &amp; 15)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto badframe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    frame = (struct rt_sigframe __user *)regs-&gt;sp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!access_ok(frame, sizeof (*frame))) /* * 检查传入的frame指针是否有效 * 如果访问不安全，则跳转到badframe标签处 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto badframe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (restore_sigframe(regs, frame)) /*    * 尝试恢复信号帧   * 如果恢复失败，则跳转到badframe标签处    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto badframe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (restore_altstack(&amp;frame-&gt;uc.uc_stack)) /*    * 恢替备用栈     * 如果恢复失败，则跳转到badframe标签处    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto badframe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return regs-&gt;regs[0]; //  返回寄存器0中的值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">badframe:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    arm64_notify_segfault(regs-&gt;sp); //  发生段错误通知，并返回0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>三、信号处理的场景和影响</h1><p>（1）场景1：进程正在运行
场景：进程正在执行用户态代码，突然收到信号（如SIGINT）。</p><p>流程：</p><ul><li><p>内核将信号添加到进程的信号队列中。</p></li><li><p>进程从内核态返回到用户态时，检查到未处理的信号。</p></li><li><p>内核调用用户注册的信号处理函数。</p></li><li><p>信号处理函数执行完毕后，进程返回到被信号打断的代码位置继续执行。</p></li></ul><p>影响：进程的执行被信号打断，但会继续执行。</p><p>（2）场景2：进程处于可中断睡眠
场景：进程正在等待I/O操作（如read()），突然收到信号（如SIGTERM）。</p><p>流程：</p><ul><li><p>内核将信号添加到进程的信号队列中。</p></li><li><p>内核唤醒进程，并将其状态设置为TASK_RUNNING。</p></li><li><p>进程从内核态返回到用户态时，检查到未处理的信号。</p></li><li><p>内核调用用户注册的信号处理函数。</p></li><li><p>信号处理函数执行完毕后，进程返回到被信号打断的代码位置继续执行。</p></li></ul><p>影响：进程被信号唤醒，I/O操作可能被中断。</p><p>（3）场景3：进程处于不可中断睡眠
场景：进程正在等待硬件I/O操作（如磁盘读写），突然收到信号（如SIGKILL）。</p><p>流程：</p><ul><li><p>内核将信号添加到进程的信号队列中。</p></li><li><p>由于进程处于不可中断睡眠状态，信号不会唤醒进程。</p></li><li><p>进程继续等待硬件I/O操作完成。</p></li><li><p>硬件I/O操作完成后，进程被唤醒并处理信号。</p></li></ul><p>影响：信号不会立即生效，进程必须等待硬件操作完成。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.877Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在中complete_signal加入dump_stack()</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412897]  dump_backtrace+0x0/0x160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412909]  dump_stack+0xd0/0x12c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412919]  complete_signal+0x198/0x1b0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412926]  __send_signal+0x1c4/0x314</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412932]  send_signal+0xd8/0x120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412937]  do_send_sig_info+0x60/0xc0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412943]  __kill_pgrp_info+0xc8/0xe0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412949]  kill_pgrp+0x44/0x70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412954]  isig+0x90/0x170</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412960]  n_tty_receive_signal_char+0x24/0x7c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412966]  n_tty_receive_char_special+0x4a0/0xb90</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412972]  n_tty_receive_buf_common+0x72c/0x9b0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412978]  n_tty_receive_buf2+0x14/0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412984]  tty_ldisc_receive_buf+0x20/0x70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412991]  tty_port_default_receive_buf+0x44/0x8c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.412998]  flush_to_ldisc+0xdc/0x160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.413004]  process_one_work+0x1cc/0x29c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.413012]  worker_thread+0x60/0x394</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.413019]  kthread+0x18c/0x1a0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.413025]  ret_from_fork+0x10/0x34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435462] CPU: 0 PID: 258 Comm: top Not tainted 5.10.83-cip1-rt1-arm64-renesas #7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435487] Hardware name: Renesas SMARC EVK based on r9a07g044l2 (DT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435492] Call trace:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435494]  dump_backtrace+0x0/0x160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435512]  dump_stack+0xd0/0x12c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435522]  complete_signal+0x198/0x1b0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435530]  __send_signal+0x1c4/0x314</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435536]  do_notify_parent+0x244/0x27c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435541]  do_exit+0x834/0x990</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435549]  do_group_exit+0x44/0xa0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435554]  __arm64_sys_exit_group+0x18/0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435561]  el0_svc_common.constprop.0+0x78/0x1c4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435569]  do_el0_svc+0x24/0x8c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435576]  el0_svc+0x14/0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435583]  el0_sync_handler+0xb0/0xb4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   42.435588]  el0_sync+0x180/0x1c0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在中do_signal加入dump_stack()</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809377] Workqueue: events_unbound flush_to_ldisc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809399] Call trace:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809401]  dump_backtrace+0x0/0x160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809415]  dump_stack+0xd0/0x12c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809424]  __send_signal+0x30/0x298</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809430]  send_signal+0xf8/0x124</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809437]  do_send_sig_info+0x60/0xc0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809443]  __kill_pgrp_info+0xc8/0xe0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809449]  kill_pgrp+0x44/0x70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809454]  isig+0x90/0x170</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809461]  n_tty_receive_signal_char+0x24/0x7c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809467]  n_tty_receive_char_special+0x4a0/0xb90</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809473]  n_tty_receive_buf_common+0x72c/0x9b0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809479]  n_tty_receive_buf2+0x14/0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809485]  tty_ldisc_receive_buf+0x20/0x70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809491]  tty_port_default_receive_buf+0x44/0x8c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809498]  flush_to_ldisc+0xdc/0x160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809504]  process_one_work+0x1cc/0x29c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809512]  worker_thread+0x60/0x394</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809519]  kthread+0x18c/0x1a0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.809527]  ret_from_fork+0x10/0x34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822368] CPU: 0 PID: 258 Comm: top Not tainted 5.10.83-cip1-rt1-arm64-renesas #4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822386] Hardware name: Renesas SMARC EVK based on r9a07g044l2 (DT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822391] Call trace:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822393]  dump_backtrace+0x0/0x160</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822411]  dump_stack+0xd0/0x12c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822420]  __send_signal+0x30/0x298</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822426]  do_notify_parent+0x244/0x27c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822434]  do_exit+0x834/0x990</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822441]  do_group_exit+0x44/0xa0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822446]  __arm64_sys_exit_group+0x18/0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822453]  el0_svc_common.constprop.0+0x78/0x1c4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822462]  do_el0_svc+0x24/0x8c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822468]  el0_svc+0x14/0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822474]  el0_sync_handler+0xb0/0xb4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   49.822480]  el0_sync+0x180/0x1c0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><code>ls</code> 结束后内核向它的<strong>父进程</strong>（通常是 shell）发送 <strong>SIGCHLD（信号 17）</strong>，不是为了 <code>ls</code> 自己，而是为了通知父进程：“你的某个子进程已经终止了”。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[  328.459410] szf: complete_signal, 1055,sig is 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[  328.460320] szf: complete_signal, 1055,sig is 19</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.789Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->17 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Ringbuffer是trace32框架的一个基础，所有的trace原始数据都是通过Ring Buffer记录的，其主要有以下几个作用：</p><ul><li>存储在内存中，速度非常快，对系统的性能影响降到最低的水平</li><li>ring结构，可以循环写，安全而不浪费内存空间，能够get到最新的trace信息</li></ul><p>对于系统，真正的难点在于系统在各种复杂的场景下，例如常规的上下文、中断上下文(NMI/IRQ/SOFTIRQ)等都能很好的trace，如何保证既不影响系统的逻辑，又能处理好相互之间的关系，同时又不影响系统的性能。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-ring-buffer设计思路">1.1 Ring buffer设计思路<a class="hash-link" href="#11-ring-buffer设计思路" title="标题的直接链接">​</a></h2><p>对于Ring Buffer面临的最大问题</p><ul><li>当我们使用trace工具的时候，可能处在不同的上下文中执行，对Ring Buffer的访问时随时可能被打断的，所以需要对Ring Buffer的访问时需要互斥保护的</li><li>RingBuffer不能使用常规的lock操作，这样会使不同的上下文之间出现大量的阻塞操作，产生了大量的耦合逻辑，影响程序原理的逻辑和性能</li></ul><p>何解决这些问题呢？首先从Ring Buffer使用的方式来看，工作模式，对于该模式，是一个很典型的生产者和消费者，其主要分为：</p><ul><li>Producer/Consumer模式： 有不断的数据写入到Ring Buffer，是一个写入者；同时对于用户也不断的从RingBuffer中读取数据，在生产者已经把Ring Buffer空间写满的情况下，如果没有消费者来读取数据，没有Free空间，那么生产者就会停止写入丢弃新的数据</li><li>Overwrite模式： 在生产者已经把Ring Buffer空间写满的情况下，如果没有消费者来读数据free空间，生产者会覆盖写入，最老的数据会被覆盖；</li></ul><p>其次，从架构图中，我们面对有很多的写者，对于同一个per cpu的RingBuffer，其写必须满足：</p><ul><li>不能同时有两个写入者在进行写操作</li><li>允许高优先级的写入者中断低优先级的写入者</li></ul><p><strong>对于读操作必须要满足：</strong></p><ul><li>读操作可以随时发生，但是同一时刻只有一个读者在工作</li><li>读操作和写操作可以同时发生</li><li>读操作不会中断写操作，但是写操作会中断读操作</li><li>支持两种模式的读操作：简易读，也叫iterator读，在读取时会关闭写入，且读完不会破坏数据可以重复读取，实例见&quot;/sys/kernel/debug/tracing/trace&quot;；并行读，也叫custom读，常用于监控程序实时地进行并行读，其利用了一个reader page交换出ring buffer中的head page，避免了读写的相互阻塞，实例见&quot;/sys/kernel/debug/tracing/trace_pipe&quot;；</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-代码流程和框架">1.2 代码流程和框架<a class="hash-link" href="#12-代码流程和框架" title="标题的直接链接">​</a></h2><p>对于Ringbuffer的初始化，主要是通过tracer_alloc_buffers调用到ring_buffer_alloc完成的，其主要流程如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * __ring_buffer_alloc - allocate a new ring_buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @size: the size in bytes per cpu that is needed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * @flags: attributes to set for the ring buffer.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Currently the only flag that is available is the RB_FL_OVERWRITE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * flag. This flag means that the buffer will overwrite old data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * when the buffer wraps. If this flag is not set, the buffer will</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * drop data when the tail hits the head.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    struct lock_class_key *key)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct ring_buffer *buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long nr_pages;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int bsize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int cpu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* keep it in its own cache line */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             GFP_KERNEL);        /*分配ring_buffer数据结构*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!buffer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!zalloc_cpumask_var(&amp;buffer-&gt;cpumask, GFP_KERNEL))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail_free_buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer-&gt;flags = flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer-&gt;clock = trace_clock_local;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer-&gt;reader_lock_key = key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    init_irq_work(&amp;buffer-&gt;irq_work.work, rb_wake_up_waiters);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    init_waitqueue_head(&amp;buffer-&gt;irq_work.waiters);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* need at least two pages */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (nr_pages &lt; 2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        nr_pages = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer-&gt;cpus = nr_cpu_ids;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bsize = sizeof(void *) * nr_cpu_ids;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer-&gt;buffers = kzalloc(ALIGN(bsize, cache_line_size()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!buffer-&gt;buffers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail_free_cpumask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cpu = raw_smp_processor_id();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cpumask_set_cpu(cpu, buffer-&gt;cpumask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    buffer-&gt;buffers[cpu] = rb_allocate_cpu_buffer(buffer, nr_pages, cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!buffer-&gt;buffers[cpu])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail_free_buffers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret = cpuhp_state_add_instance(CPUHP_TRACE_RB_PREPARE, &amp;buffer-&gt;node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        goto fail_free_buffers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mutex_init(&amp;buffer-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> fail_free_buffers:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for_each_buffer_cpu(buffer, cpu) { /*为每个CPU分配ring_buffer的per cpu机构*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (buffer-&gt;buffers[cpu])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rb_free_cpu_buffer(buffer-&gt;buffers[cpu]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kfree(buffer-&gt;buffers);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> fail_free_cpumask:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    free_cpumask_var(buffer-&gt;cpumask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> fail_free_buffer:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kfree(buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EXPORT_SYMBOL_GPL(__ring_buffer_alloc);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其主要数据结构如下图所示：</p><p><img loading="lazy" alt="image-20250326225000375" src="/assets/images/image-20250326225000375-91504b981890792a1d42413d69c91c83.png" width="1525" height="1197" class="img_ev3q"></p><ul><li>struct ring_buffer在每个cpu上有独立的struct ring_buffer_per_cpu数据结构</li><li>struct ring_buffer_per_cpu根据定义size的大小，分配page空间，并把page连成环形结构</li><li>struct buffer_page是一个控制结构；struct buffer_data_page才是一个实际的page，除了开头的两个控制字段time_stamp、commit，其他空间都是用来存储数据的；数据使用struct ring_buffer_event来存储，其在包头中还存储了时间戳、长度/类型信息</li><li>struct ring_buffer_per_cpu中使用head_page(读)、commit_page(写确认)、tail_page(写)三种指针来管理page ring；同理buffer_page-&gt;read(读)、buffer_page-&gt;write(写)、buffer_data_page-&gt;commit(写确认)用来描述page内的偏移指针</li><li>ring_buffer_per_cpu-&gt;reader_page中还包含了一个独立的page，用来支持reader方式的读操作</li></ul><h1>二，ftrace的内核注册</h1><p>对于ftrace的framwork层，首先需要建立<a href="https://zhida.zhihu.com/search?content_id=194763848&amp;content_type=Article&amp;match_order=1&amp;q=debugfs&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDMxNzExNzIsInEiOiJkZWJ1Z2ZzIiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTk0NzYzODQ4LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.nyedhLi7L2sXKuYcPcqErb8Ep6UHWhZNLTjNRZJ6vUI&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">debugfs</a>的一系列的访问节点，是通过如下的流程完成的</p><p><img loading="lazy" alt="v2-8ad55885a702197e0b66196e0d039edf_r" src="/assets/images/v2-8ad55885a702197e0b66196e0d039edf_r-ef4e961fec83c2e61d52d61dcdb0367f.jpg" width="1190" height="643" class="img_ev3q"></p><p>完成了核心的注册后，我们来看看ftrace是如何完成各个功能的，对于任何一个trace功能，<strong>都可以归纳于如下流程：</strong></p><ul><li>函数插桩： 使用各种插桩方式把自己的trace函数插入到需要跟踪的probe point上</li><li>Input trace数据： 在trace的probe函数中命中时，会存储数据到ring buffer当中，这里主要包括filter和tigger功能</li><li>Output trace数据： 用户和程序需要读取trace数据，根据需要输出数据，对数据进行解析等</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-function-tracer的实现">2.1 Function tracer的实现<a class="hash-link" href="#21-function-tracer的实现" title="标题的直接链接">​</a></h2><p>这个功能是利用_mcount()函数进行插桩的，在gcc使用了&quot;-gp“选项以后，会在每个函数入口插入以下的语句</p><p><img loading="lazy" alt="v2-437619132779b3504d125ef972c90451_1440w" src="/assets/images/v2-437619132779b3504d125ef972c90451_1440w-c4aa184012a14ae1b0d15f4ee6e5e254.jpg" width="943" height="438" class="img_ev3q"></p><p>每个函数入口处插入对_mcount()函数的调用，就是gcc提供的插桩机制，我们可以重新定义_mcount()函数中的内容，调用想要执行的内容。对于tracer自身而言，是不是需要-pg选项，因此在kernel/tracing/Makefile中将-pg选项中由我们自己定义</p><p><img loading="lazy" alt="v2-2cab18882895033fa62d93c9b77af728_1440w" src="/assets/images/v2-2cab18882895033fa62d93c9b77af728_1440w-bc555d32b488bfb602d361fb6532d0b7.jpg" width="890" height="345" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="211-静态插桩">2.1.1 静态插桩<a class="hash-link" href="#211-静态插桩" title="标题的直接链接">​</a></h3><p>我们来看看ARM64如何处理的，其代码路径为arch/arm64/kernel/entry-ftrace.S</p><p><img loading="lazy" alt="v2-c1216c3a204eff9e28a66b48500c6437_r" src="/assets/images/v2-c1216c3a204eff9e28a66b48500c6437_r-b1fcecf220279a09d5972806aa3a9916.jpg" width="987" height="686" class="img_ev3q"></p><p><strong>当未选中CONFIG_DYNAMIC_FTRACE时，其采用如下的方案;</strong></p><ul><li>每个函数调用都会根据不同的体系结构的实现调用_mcount函数</li><li>如果ftrace使用了某些跟踪器，ftrace_trace_function指针不再指向ftrace_stub，而是指向具体的跟踪函数</li><li>否则就执行到体系结构相关的ftrace_stub从函数返回，而该接口为空函数</li></ul><p><img loading="lazy" alt="v2-aa88732557ae827f51d2717f3af624dc_r" src="data:image/jpeg;base64,iVBORw0KGgoAAAANSUhEUgAAAqQAAABGCAIAAACVNxFeAAAMi0lEQVR4nO3dT0hb2R4H8N8d3ibLgc5rdl6fZhxHXSWLoHQkWUTSZ0XM4CIgz9c84oB3qBUCIwyGhIEKAas0whiqz4eQhVApHcegiwRHlCySVc3ETky9bkrKuHcxi7zFvbl/8kejjX9y8/3gor33nnNP7eJ3zu+cew7z4cMH+jSfff7XJ9YAAAAA1+ez224AAAAAXC8EewAAAI1DsAcAANA4BHsAAACNQ7AHAADQOAR7AAAAjUOwBwAA0DgEewAAAI1DsAcAANA4BHsAAACN+9ttN6D29Lr/3nYT7oTc2b9vuwkAAHAnaGZkH/PohkLZ227FnRPz6Kait90IAAC4XbUJ9nxwSK9rkn8syzwRZZf7dU16LiY+lF3u1w2FsiUP65r0uqb+IE/EhywllQgXpUqIiCjKSXfF94cso+nArLtF3axuaybvzee9+bw3M3e/Jv/SO+n+XMa76S57yzIeeOdEvAcAaGy1G9m7VnJnJ+JP7DErXjWaUi+KBtwsty48FnbJpTY4sYQpsJM7O8md7fjJZ+ZiRKz7pde0NOrZKpTPLs8uGf0vpVcQH5ycJm+QY1Wvoftz/3tA8z8zjI9hfIaJj8LV7rnxfMbaXbN/9nWpVTtZbtZvDjvVvSUAAGgo157GH3C0vYnwly/H2hxGSh3zRNTyeNJFqzPiUD763JdwfS8P4rPLnIeUsb/g71+2nv669vFqzdYQobdU3OUCAIDGcf1z9nZb+6sof+lisQVP0uSwskREZA2ujMR9XJAXh/VPLdJzfGQjYe63tVSoRqF7bjyf9+49uUetD/bE9P74XHfh1mYXuYdLc/7uTXEiIJ8fVmXKFXMEyiG4/Hx143JF/WIqvnI71el697D6FffnMqp6ZC3WAXPySl0uAADQgtqtxl8a1S8V/uxayQWleGyxd7zYzj4uP6dcIuHp1XuIiEyBnQ05M28ZDxjNnkXPYZgCO8q5+feHSZNjllVW4R7OL7YLf7TveZ8QEaXHmLXQxAIzQd1z43v/TPcYovtFL7YP5Q27PYxvv9ua2ft2bm1hYp+658YHX/uYh0RE7k3vYsZ6IBR0D+cX2yNjPkNIVYd707tI6wzzVvjzXobKvEihe2580bDbw6ie2T+/nRXYF7+jMR8Tou658b3FYXdoTXGTtTmM04fHRGyl4gAAoGHXM2cvR3oiIuujtunn1c4ZmwI7ubMdv7n4ujD3vLrknFTNzfNHqZIqQmsM42OY9Qidzvf4GMbHMGuhkqdKpMeEyLr/Z4bufdlJRLQ/sfCwUDL0Oi096h5sp8j6w+JKuwbtp/M/vRWf/2n3qLV9+MLRfTXPVCEy5hPasz/xW4S++Lq0TmFOBAAAGs+NfGffN+afWYySoeoCrPsH5/RMlOeUM/FsawdRh81a+/YREVEkXYjdbx8yYsCmbmtm70Gr9MzRLhER3f/aQJHAWyrS/YWB7hVyCYLT89+5P7HQQ+N7QpGj3erH8RcROysAAAB0U9/ZszbHu0jkMiX6xvzkW9i6+MHr1LW5J6/nZ8bSynuGr8t+yyflEoSfhYmLovf+xALD+Bjm53l6sLfZVYNWd39hoNM/DkqudzSzNagdAADqzw1tqsPa+9OvNi5VwuYwSivwz38scZkFgPu//3mlzHnXZmEdANHHtV9PW598O1dUyX7q16N7T368WsD++HumqnbaB7uIiLqtGbk9Ku4fH7RGflN3MvjtV0nTV81XahgAANS92gX7pdGS/XAUWh5PdiQTl6mPtfebhBX4VTx2iRxAaG0scu/Jnmo1fgVvf5o/bX3yXT7vzee/+WNeHtnvTyz0zFOhEmnh/ccJw8/zhqF8uVX6ZSmX4i8adnseKqYGyrTz48S/do/sQ/m8N793L6DONNgXC/XQOvNQPcWQjb6JGwfsbHW/IAAA0Brmw4cPn1jFZ5//VZOmXFmUa3KmvPHCTj7YG19Q2BufD1l63ziUnzYAAEBj0cLe+NagtN0eFKuwvSAAADQQbZx6x7pjKxndi9BTS/H2+LevazM/ZC93Q/pY7jrFFjxt4bPS7QUBAKCBaCGNXwRpfAGOuAUAAIEGgz0AAAAoaWHOHgAAAM6BYA8AAKBxmg32fHCozOf+AAAAjUezwR4AAAAE9RHs+eCQnovR1pSwQ1+/Ylu9KFe8bR8fHNLrmsyeJMV9ZnFTv6FQ9nZaDgAAcOvqI9gTES2N6mcM8bOT3IGXPJNC8I5yTU4Sj9YNd/jMlmWeiOXWc2cn8YCRzN64eOru+t37/h4AAOCG1E+wJ2dY2BC3pbmdkpkjIopFloz+pxbhtvWp1xTf2MYIHgAAQK1+dtBzSSfZWwJnJ0RE2eM0JVc7m6blh4wDt9AyAACAO61+gn15Rv8BUvQAAADnqaM0fokW64A5Of28/Pk3rKGNkNUHAACo72BPrDu240+NiqvxFQvyiYj6noVdyelOrMYHAIBGh73xAQAANK6uR/YAAABwMQR7AAAAjUOwBwAA0DgEewAAAI1r2GAf82CJfhkxj24qetuNAACA2qpNsBfOnin+BC673K9r0nOF7+Czy/1CfBWuF34Up9rwIYuiEjnqqK+rD66VD8IpilKKtygPzilUOJoOzBbvxnNeES3hQ5Ymz1bZW5bxwDsn4j0AgLbUbmTvEg+kyZ2d5IRN7ImIjKbUi3IDaGdYfHil3dMrdwiIRl6LlYRdYWXUMQV2cmcnubMdP/nMhedVB+G4wk6pH7A1pe/0tReqClJUGb344OQ0eYMcSyp86D8+Et9yslG4yweHiroXd1Ot2slys35z2MmV36oIAADq0bWn8QccbW8ifOX7lsCB17RUpkNgfeo1UThSPABlbQ4jpY55IsouzyoPwgmujMR9C1tExIdmwqbATqCvUIZ7bJUqyC5zHvK/lLojkuNM3DhgL7nccFj3y/L/IwAAUKeuf87ebmt/FeXPeaCluZ2S53YIlGILnqTJYWWJ+MhGwtxvk1PxFruL0hmestE3lcN2SamKhLkJsydJcZ9Zp9qJjw8O6bkYbU2V5vyrmVZQDsHl56sblyvqF1PxldupTtdvTalfIU+OFKf0W6wD5ur/RwAA4K6rXbBfUmxbq0oCW+wd5+9R32wwl7kafe5LmL3jhdF5wtOr1zXpdaPpwI6UY6eOZlZdKnF4TEeZBLW1Vgjn7w/FvoJMjNmjqyRtrzsVJWK59dzZSTxgJLM3Lk46KA7dWRrVzxjiZye5Ay95JqVOQOTRyYXTCtI0h2oaosNnvije88EhZ0pqzImQurignRWsDvZmfjgRCq4OFk3SszaHMXF4fEEVAABQJ65nzj5oUd6xPmqrdFxNqdVBscfgTHnj8ty/MGe/41d0C94fJi/fSv4oVXKt75mwemCEjP4D4Z/wzFqmbBFnWGheS3M7JTNHREQsty7NHVgfOaVHo7+EybUi3SqIRZTTEE+9pmpO7qnR6T4jr6W+wvcj9O6otE5hrgQAAOrfjXx61zfmT21XXuB9nInLfxkpGf4qsO4fnInCpMA/vjKqAxJ/lCLTV81ERGWjV225bIUOgSVQGGSrcvWDYWXDRh5ZimvIHqflXEKTvtOXuOidLLceD5BYpJbLBsXOCgAAaNLNfGfP2hzvIpEKN7e2V6nqlXF9Y34SVuEJh9hm3sv3jjNxajew1GcbucQigBqKeTrl9fy5107lvXSmbHukXEK16XchaV/0VcInyR6nyWhoLbleMkUCAAB16oY21WHt/elXG2VuZJf7B8Om0k/eK9dkcxhXZ5Z5IuobU34kFuVGV8U5fst4wJjw9ErrzvjgclRRPHH+gsGi9xnarpQ5j3nkkT1rcxgThXl9WYt1wJysfoKjqF2tHVW1c/WXGJH4ey5bUfS5L+H6Xv3757dfJQs5EgAAqHvXs0CvNMPc8niyI6lIU4edhdx1+2v5o/ZqsPZ+U9zHBfmi8+ydtCJl/lluPR4wStP/HFmt6uIL5beUKafvWdglJdvP33RP7GTodU163QtDQB7Zq9Lv8u9H1f5qMvPKpfjOlDeuXBtRpp3CR3Sjel2TvjMzqc40yGsjaKVojcX5nzMAAEDdacTz7KNc8eo/UOBDlt43jp1L9cAAAOAua8S98a3B2k14a06F7QUBAKCONeLInoiIYh7dC8PBxQviblzMoxtdLXdD+ljumt++ba/qy0MAAKgbDRvsAQAAGkUjpvEBAAAaCoI9AACAxiHYAwAAaByCPQAAgMYh2AMAAGgcgj0AAIDGIdgDAABoHII9AACAxiHYAwAAaByCPQAAgMYh2AMAAGjc/wELPwMxJ6jyDgAAAABJRU5ErkJggg==" width="676" height="70" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="212-动态插桩">2.1.2 动态插桩<a class="hash-link" href="#212-动态插桩" title="标题的直接链接">​</a></h3><p>static ftrace一旦使能，对kernel中所有的函数(除开notrace、online、其他特殊函数)进行插装，这带来的性能开销是惊人的，有可能导致人们弃用ftrace功能。</p><p>为了解决这个问题，内核开发者推出了dynamic ftrace，因为实际上调用者一般不需要对所有函数进行追踪，只会对感兴趣的一部分函数进行追踪。dynamic ftrace把不需要追踪的函数入口处指令“bl _mcount&quot;替换成nop，这样基本上对性能无影响，对需要追踪的函数替换入口处&quot;bl _mcount&quot;为需要调用的函数。</p><ul><li>ftrace在初始化时，“scripts/recordmcount.pl”脚本记录的所有函数入口处插桩位置的“bl _mcount”，将其替换成“nop”指令，对性能基本无影响</li><li>在tracer enable的时候，把需要跟踪的函数的插桩位置nop替换成bl ftrace_caller</li></ul><p><img loading="lazy" alt="v2-ff24f390f26d41862312f89549c356ed_r" src="/assets/images/v2-ff24f390f26d41862312f89549c356ed_r-c8aa374bf6b3b3420649adc2e00b29a3.jpg" width="825" height="660" class="img_ev3q"></p><p>在编译的时候调用recordmcount.pl搜索所有_mcount函数调用点，并且所有的调用点地址保存到section _mcount_loc，其定义在include/asm-generic/vmlinux.lds.h，详细的见文件以具体研究“scripts/recordmcount.pl、scripts/recordmcount.c”。</p><p><img loading="lazy" alt="v2-273bbb42eb4c4a2738b943b3229384d5_r" src="/assets/images/v2-273bbb42eb4c4a2738b943b3229384d5_r-7f7ca1092b86d2a035c4c29392b11016.jpg" width="774" height="280" class="img_ev3q"></p><p>在初始化时，遍历section __mcount_loc的调用点地址，默认为所有“bl _mcount”替换成“nop”，其定义为kernel/trace/ftrace.c</p><p><img loading="lazy" alt="v2-26c700e0ed80688c007040f77ca70966_r" src="/assets/images/v2-26c700e0ed80688c007040f77ca70966_r-912ef0ca078bc9d05c544059f6205550.jpg" width="797" height="483" class="img_ev3q"></p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="213-irqs-offpreempt-offpreempt-irqsoff-tracer">2.1.3 irqs off/preempt off/preempt irqsoff tracer<a class="hash-link" href="#213-irqs-offpreempt-offpreempt-irqsoff-tracer" title="标题的直接链接">​</a></h3><ul><li>irqsoff tracer： 当中断被禁止时，系统无法响应外部事件，比如鼠标和键盘，时钟也无法产生tick中断，这也意味着系统响应延迟，irqsoff这个tracer能够跟踪并记录内核中哪些函数禁止了中断，对于其中中断禁止时间最长的，irqsoff将在Log文件中第一行标记出来，从而使开发者可以迅速定位造成响应延迟的罪魁祸首</li><li>preemptoff tracer： 跟踪并记录禁止内核抢占并关闭中断占用期间的函数，并清晰地显示出禁止抢占时间最长的内核函数</li><li>preempt irqsoff tracer: 跟踪和记录禁止中断或禁止抢占的内核函数，以及禁止时间最长的函数</li></ul><p><strong>preemptoff与irqsoff跟踪器</strong></p><p>preempt off与irqs off跟踪器用的跟踪函数是相同的，都是irqsoff_tracer_call()。</p><p>preemptoff与irqsoff跟踪器的不同之处</p><p>irqsoff跟踪器的start点在开启或关闭中断的地方，如local_irq_disable()</p><p>preemptoff跟踪器的start点在开启或关闭抢占的地方，如prempt_disable()</p><p><img loading="lazy" alt="v2-17e3fd0528caf09b71ce07f85d1b03d3_r" src="/assets/images/v2-17e3fd0528caf09b71ce07f85d1b03d3_r-7ce2e3e8518707f220a7c7748e24f886.jpg" width="708" height="183" class="img_ev3q"></p><p>irqsoff tracer的插桩方法，是直接在local_irq_enable()、local_irq_disable()中直接插入钩子函数trace_hardirqs_on()、trace_hardirqs_off()。</p><p><img loading="lazy" alt="v2-c504cb01a770d6a6cfc4cf4d6b9a0472_r" src="/assets/images/v2-c504cb01a770d6a6cfc4cf4d6b9a0472_r-ae9f7db49f83b01d55a4414eee5af299.jpg" width="1177" height="306" class="img_ev3q"></p><p>我们来看看start_critical_timing的实现，其主要为：</p><p><img loading="lazy" alt="v2-fb7ec502cb0230944d8b69881adf6c68_r" src="/assets/images/v2-fb7ec502cb0230944d8b69881adf6c68_r-4dd95170ded7be114ef7ff565bea066c.jpg" width="1024" height="598" class="img_ev3q"></p><p>其主要的设计思想如下</p><p><img loading="lazy" alt="v2-53da13949b09a2c35d6132954532a26e_r" src="/assets/images/v2-53da13949b09a2c35d6132954532a26e_r-010c2233dbd8ff12d44f8e70216ab8b7.jpg" width="1401" height="391" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-trace-event">2.2 trace event<a class="hash-link" href="#22-trace-event" title="标题的直接链接">​</a></h2><p>linux trace中，最基础的时function tracer和tracer event，上面学习了function，本节是学习event，其也离不开如下流程</p><p><img loading="lazy" alt="v2-b639d0d23c8ca3a00a9d3c4514b5ba49_r" src="/assets/images/v2-b639d0d23c8ca3a00a9d3c4514b5ba49_r-8ee56d42596e7fd587ac0bfa2bc068a3.jpg" width="1004" height="525" class="img_ev3q"></p><p>trace event的插桩使用的是<a href="https://zhida.zhihu.com/search?content_id=194763848&amp;content_type=Article&amp;match_order=1&amp;q=tracepoint&amp;zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NDMxNzExNzIsInEiOiJ0cmFjZXBvaW50IiwiemhpZGFfc291cmNlIjoiZW50aXR5IiwiY29udGVudF9pZCI6MTk0NzYzODQ4LCJjb250ZW50X3R5cGUiOiJBcnRpY2xlIiwibWF0Y2hfb3JkZXIiOjEsInpkX3Rva2VuIjpudWxsfQ.h_Isu7mAqNcwOWVjtiyUI4_Jd8DmgwyMWqlwWyXwqlk&amp;zhida_source=entity" target="_blank" rel="noopener noreferrer">tracepoint</a>机制，该机制是一种静态的插桩方法，它需要静态的定义桩函数，并且在插桩位置显式调用。这种方法的好处是高效可靠，并且可以处于函数中的任何位置、方便的访问各种变量，坏处是不太灵活。对于kernel在重要的节点固定位置，插入了几百个trace event用于跟踪。</p><p><img loading="lazy" alt="v2-793d4aec6243b543241e78c515121e0b_r" src="/assets/images/v2-793d4aec6243b543241e78c515121e0b_r-76813db121b99f3b9ff7d0fce7b9352a.jpg" width="1371" height="594" class="img_ev3q"></p><p>对于内核，我们创建了几个操作tracepoint的函数:</p><ul><li>桩函数： trace_##name();</li><li>注册回调函数： register<em>trace</em>##name();</li><li>注销回调函数：unregister<em>trace</em>##name();</li></ul><p>tracepoint 的定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct tracepoint {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const char *name;       /* Tracepoint name */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct static_key key;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void (*regfunc)(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void (*unregfunc)(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct tracepoint_func __rcu *funcs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>key tracepoint:是否使能开关，如果回调函数数组为空，则key为disable；如果回调函数数组中有函数指针，则key为enable</li><li>regfunc/unregfunc: 注册/注销回调函数时的钩子函数</li><li>funcs :回调函数数组，tracepoint的作用就是在桩函数被命中时，逐个调用回调函数数组的函数</li></ul><p>我们在探测点插入桩函数：(kernl/sched/core.c)</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void __sched notrace __schedule(bool preempt)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    trace_sched_switch(preempt, prev, next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>桩函数被命中时的执行流程，可以看到就是逐个的执行回调函数数组中的函数指针:</p><p><img loading="lazy" alt="v2-67e2d3fcb3f948b07d74b1817983ad2a_r" src="/assets/images/v2-67e2d3fcb3f948b07d74b1817983ad2a_r-d322aa406c7ecffd9387eb11337b9b9b.jpg" width="1116" height="237" class="img_ev3q"></p><p><img loading="lazy" alt="v2-d89a370a5cac042dabd81b4f02a1c452_r" src="/assets/images/v2-d89a370a5cac042dabd81b4f02a1c452_r-ed01cf4dcbf4800321ea6adf003aca1f.jpg" width="1136" height="362" class="img_ev3q"></p><p>可以通过 register<em>trace</em>##name()/unregister<em>trace</em>##name() 函数向回调函数数组中添加/删除函数指针</p><p><img loading="lazy" alt="v2-3f7ea42857f084418e15d04474472ef3_r" src="/assets/images/v2-3f7ea42857f084418e15d04474472ef3_r-36ec04ac3f677fb3c82ba052c595e7e1.jpg" width="1118" height="324" class="img_ev3q"></p><p>trace event 对 tracepoint 的利用，以上可以看到，tracepoint 只是一种静态插桩方法。trace event 可以使用，其他机制也可以使用，只是 kernel 的绝大部分 tracepoint 都是 trace event 在使用。</p><p>trace event 也必须向 tracepoint 注册自己的回调函数，这些回调函数的作用就是在函数被命中时往 ringbuffer 中写入 trace 信息。ftrace开发者们意识到了这点，所以提供了trace event功能，开发者不需要自己去注册桩函数了，易用性较好</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="221-增加一个新的-trace-event">2.2.1 增加一个新的 trace event<a class="hash-link" href="#221-增加一个新的-trace-event" title="标题的直接链接">​</a></h3><p>在现有的代码中添加探测函数，这是让很多内核开发者非常不爽的一件事，因为这可能降低性能或者让代码看起来非常臃肿。为了解决这些问题，内核最终进化出了一个 TRACE_EVENT() 来实现 trace event 的定义，这是非常简洁、智能的一个宏定义。</p><p>首先我们先来了解一下怎么样使用 TRACE_EVENT() 新增加一个 trace event，新增加 trace event，我们必须遵循规定的格式。</p><p>以下以内核中已经存在的 event sched_switch 为例，说明定义过程。</p><p>首先需要在 include/trace/events/文件夹下添加一个自己 event 的头文件，需要遵循注释的标准格式：include/trace/events/sched.h</p><p>在探测点位置中调用桩函数，需要遵循注释的标准格式</p><p>由于内核各个子系统大量使用 event tracing 来 trace 不同的事件，每有一个需要 trace 的事件就实现这么一套函数，这样内核就会存在大量类似的重复的代码，为了避免这样的情况，内核开发者使用一个宏，让宏自动展开成具有相似性的代码。这个宏就是 TRACE_EVENT，要为某个事件添加一个 trace event，只需要声明这样一个宏就可以了</p><h1>三、kprobe</h1><p>kprobe event就是这样的产物。krpobe event和trace event的功能一样，但是因为它采用的是kprobe插桩机制，所以它不需要预留插桩位置，可以动态的在任何位置进行插桩。开销会大一点，但是非常灵活，是一个非常方便的补充机制。</p><p>kprobe的主要原理是使用“断点异常”和“单步异常”两种异常指令来对任意地址进行插桩，在此基础之上实现了三种机制：</p><ul><li>kprobe： 可以被插入到内核的任何指令位置，在被插入指令之前调用kp.pre_handler()，在被插入指令之后调用kp.post_handler()</li><li>jprobe： 只支持对函数进行插入</li><li>kretprobe： 和jprobe类似，机制略有不同，会替换被探测函数的返回地址，让函数先执行插入的钩子函数，再恢复。</li></ul></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.777Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p><img loading="lazy" alt="1753882115624" src="/assets/images/1753882115624-1757599056156-1-3709978d2d3d77c3bcae11bcb6fc5579.png" width="961" height="367" class="img_ev3q"></p><p><img loading="lazy" alt="1753882154478" src="/assets/images/1753882154478-1757599056156-2-a837b2fc6ba64c4a248da428388e0d12.png" width="1018" height="157" class="img_ev3q"></p><p><img loading="lazy" alt="9c85c87b302256850ce0b33901003e1" src="/assets/images/9c85c87b302256850ce0b33901003e1-1757599056157-4-ffae8944c1b36640be6e6f7785ad822f.png" width="897" height="793" class="img_ev3q"></p><p><img loading="lazy" alt="1753882047106" src="/assets/images/1753882047106-1757599056157-3-2c9aa8d85b773acfbff5f47017fbf5d1.png" width="1239" height="435" class="img_ev3q"></p><p><img loading="lazy" alt="1753882074921" src="/assets/images/1753882074921-1757599056157-5-09a116a0d5a26cf4c442415845975f4e.png" width="1348" height="627" class="img_ev3q"></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:16.689Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>busybox支持kdump</p><p>一、内核选项支持</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_KEXEC=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_KEXEC_CORE=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_SYSFS=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_DEBUG_INFO=Y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_CRASH_DUMP=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_PROC_VMCORE=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_PROC_KCORE=y</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_PROC_VMCORE=y</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>CONFIG_CMA is not set  //必选</h1><p>然后编译成新的内核和设备树。</p><p>二、应用程序移植kdump和kexec
需要将kexec、vmcore-dmesg、makedumpfile三个工具和依赖库移植到开发板卡上</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ldd /usr/bin/kexec</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    linux-vdso.so.1 (0x0000007f87fd3000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libz.so.1 =&gt; /lib/aarch64-linux-gnu/libz.so.1 (0x0000007f87f1e000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000007f87dab000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /lib/ld-linux-aarch64.so.1 (0x0000007f87fa3000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ldd /usr/sbin/vmcore-dmesg </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    linux-vdso.so.1 (0x0000007f92820000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000007f9264b000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /lib/ld-linux-aarch64.so.1 (0x0000007f927f0000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ldd /usr/bin/makedumpfile</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    linux-vdso.so.1 (0x0000007f8f8a4000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 (0x0000007f8f7bd000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    liblzo2.so.2 =&gt; /lib/aarch64-linux-gnu/liblzo2.so.2 (0x0000007f8f78f000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libdw.so.1 =&gt; /lib/aarch64-linux-gnu/libdw.so.1 (0x0000007f8f72b000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2 (0x0000007f8f717000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libelf.so.1 =&gt; /lib/aarch64-linux-gnu/libelf.so.1 (0x0000007f8f6ea000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libz.so.1 =&gt; /lib/aarch64-linux-gnu/libz.so.1 (0x0000007f8f6c0000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000007f8f54d000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /lib/ld-linux-aarch64.so.1 (0x0000007f8f874000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    liblzma.so.5 =&gt; /lib/aarch64-linux-gnu/liblzma.so.5 (0x0000007f8f519000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    libbz2.so.1.0 =&gt; /lib/aarch64-linux-gnu/libbz2.so.1.0 (0x0000007f8f4f8000)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>三、制作启动第二内核的文件系统
使用将kexec、vmcore-dmesg、makedumpfile三个工具和依赖库移植完成的文件系统比如</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cd ram</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ls</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ata2  dev  firmware  home  lib      mnt  proc     root  sbin  ssd   sys  usr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bin   etc  flashDev  init  linuxrc  opt  ramDisk  run   srv   stop  tmp  var</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在文件系统所在的目录执行如下命令</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo find . | cpio -o -H newc &gt; ../test.cpio</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo gzip -9 &lt; ../test.cpio &gt; ../test.cpio.gz</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>四、编写脚本
编写kexec.sh脚本，配置完成后可以触发启动第二内核。该脚本在正常的文件系统中部署</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#!/bin/bash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kexec -p /root/Image-smarc-rzg2l.bin --initrd=test.cpio.gz --append=&quot;root=/dev/mmcblk1p1 debug&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cat /sys/kernel/kexec_crash_size</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cat /sys/kernel/kexec_crash_loaded</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中Image-smarc-rzg2l.bin是步骤一内核选型支持编译出来的内核和设备树。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">kexec -p /root/Image-smarc-rzg2l.bin --initrd=test.cpio.gz --append=&quot;root=/dev/mmcblk1p1 debug&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>-p​​：指定加载的内核用于崩溃转储（与 -l不同，-p专为 kdump 场景设计）/root/Image-smarc-rzg2l.bin​​：目标内核镜像文件（需与当前运行内核架构匹配，如 ARM64）。
​--initrd=test.cpio.gz​​：指定初始 RAM 磁盘（initrd），通常包含捕获内核所需的驱动和工具（如 makedumpfile）
​--append​​：传递内核启动参数，例如：root=/dev/mmcblk1p1：指定根文件系统设备。debug：启用内核调试输出</p><p>编写vmcore.sh脚本，该脚本用于生成vmcore文件。该脚本在第二内核启动后的文件系统中使用。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#!/bin/bash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/etc/init.d/haveged restart</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/etc/init.d/ssh restart</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vmcore-dmesg /proc/vmcore &gt; vdmesg-test.txt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">makedumpfile -l --message-level 1 -d 31 /proc/vmcore vmcore-test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scp vmcore-test kylin@172.30.192.248:/home/kylin/test/kdump</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scp vdmesg-test.txt kylin@172.30.192.248:/home/kylin/test/kdump</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">​</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>vmcore-dmesg /proc/vmcore &gt; vdmesg-test.txt
vmcore-dmesg：用于从内核崩溃转储文件（/proc/vmcore）中提取内核日志（dmesg）的工具。
/proc/vmcore：是内核崩溃时生成的转储文件，包含崩溃时的内存状态和内核日志。</p><blockquote><p>vdmesg-test.txt：将提取的日志重定向到vdmesg-test.txt文件中。
​
makedumpfile -l --message-level 1 -d 31 /proc/vmcore vmcore-test
-l：使用LZO压缩算法压缩转储数据（需编译时启用USELZO=on）。
--message-level 1：限制输出消息级别为1（仅显示关键错误信息）。
-d 31：指定转储级别为31，排除以下页面类型：
1（填零页面）
2（非私有缓存页面）
4（所有缓存页面）
8（用户进程数据页面）
16（空闲页面）
/proc/vmcore：输入文件，即崩溃内核的内存映像。
vmcore-test：输出文件，生成压缩后的转储文件。</p></blockquote><p>五、测试
1、重启设置uboot的bootargs参数，加入crashkernel=512M</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">root=/dev/mmcblk1p1  rootwait rw isolcpus=1 nohz_full=1 crashkernel=512M</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2、替换第一步编译的编译成新的内核和设备树，作为默认内核和设备树启动，然后启动文件系统
3、将第三步制作启动第二内核的文件系统制作的test.cpio.gz和第四部编写的kexec.sh脚本拷贝到，文件系统内</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ls kdump</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Image-smarc-rzg2l.bin              kexec.sh          Image-r9a07g044l2-smarc.dtb         test.cpio.gz</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>执行kexec.sh</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./kexec.sh</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">./kexec.sh </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">536870912</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4、触发kdump，执行如下命令</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo c &gt; /proc/sysrq-trigger</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>触发启动第二内核日志如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo c &gt; /proc/sysrq-trigger                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.750075] sysrq: SysRq : Trigger a crash                                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.754270] Unable to handle kernel NULL pointer dereference at virtual address 0000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.763050] Mem abort info:                                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.765839]   ESR = 0x96000046                                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.768889]   Exception class = DABT (current EL), IL = 32 bits                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.774803]   SET = 0, FnV = 0                                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.777852]   EA = 0, S1PTW = 0                                                           </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.780986] Data abort info:                                                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.783860]   ISV = 0, ISS = 0x00000046                                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.787689]   CM = 0, WnR = 1                                                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.790647] user pgtable: 4k pages, 48-bit VAs, pgdp = 0000000004c0b539                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.797254] [0000000000000000] pgd=00000021744ac003, pud=0000002175db3003, pmd=00000000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.805952] Internal error: Oops: 96000046 [#1] PREEMPT SMP                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.811514] Modules linked in:                                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.814559] CPU: 3 PID: 2183 Comm: sh Kdump: loaded Not tainted 4.19.90-g79148c6d4-dirty 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.822986] Hardware name: FT-2000/4-D4-DSK Development Board (DT)                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.829155] pstate: 60000005 (nZCv daif -PAN -UAO)                                        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.833938] pc : sysrq_handle_crash+0x28/0x38                                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.838283] lr : sysrq_handle_crash+0x14/0x38                                             </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.842628] sp : ffff00000f983c50                                                         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.845931] x29: ffff00000f983c50 x28: ffff8020f1fe5280                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.851234] x27: 0000000000000000 x26: 0000000000000000                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.856536] x25: 0000000056000000 x24: ffff00000a0af000                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.861837] x23: 0000000000000000 x22: 0000000000000007                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.867139] x21: ffff00000a0afa38 x20: 0000000000000063                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.872441] x19: ffff000009f4f000 x18: ffffffffffffffff                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.877742] x17: 0000000000000000 x16: 0000000000000000                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.883044] x15: ffff000009f2a788 x14: ffff00008a1a753f                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.888345] x13: ffff00000a1a754d x12: ffff000009f4f000                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.893647] x11: 0000000005f5e0ff x10: ffff000009f2a9e8                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.898949] x9 : ffff000008931bc0 x8 : 6120726567676972                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.904250] x7 : 54203a2071527379 x6 : 0000000000000397                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.909552] x5 : 0000000000000000 x4 : ffff8020f1fe5280                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.914854] x3 : ffff000009f2b000 x2 : 38d1cde1282e1e00                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.920155] x1 : 0000000000000001 x0 : 0000000000000000                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.925457] Process sh (pid: 2183, stack limit = 0x0000000097ef60d4)                      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.931799] Call trace:                                                                   </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.934235]  sysrq_handle_crash+0x28/0x38                                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.938233]  __handle_sysrq+0xb0/0x1a8                                                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.941971]  write_sysrq_trigger+0x70/0x88                                                </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.946058]  proc_reg_write+0x80/0xd8                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.949710]  __vfs_write+0x60/0x180                                                       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.953187]  vfs_write+0xac/0x1c0                                                         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.956491]  ksys_write+0x6c/0xd8                                                         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.959794]  __arm64_sys_write+0x24/0x30                                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.963707]  el0_svc_common+0x7c/0x118                                                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.967444]  el0_svc_handler+0x38/0x78                                                    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.971182]  el0_svc+0x8/0xc                                                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.974052] Code: 52800021 b903c001 d5033e9f d2800000 (39000001)                          </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   39.980139] SMP: stopping secondary CPUs                                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NNNOOOTTTIIICCCEEE:::      SSSttta[daddSSrri1c   atl:0088000a022u                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> kIrE: .ft2                                                                                  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           04_pwr_domain_off                                                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTICE:  [CLUST_PSOCFG_REG]= 50                                                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTICE:  ft2004_pwr_domr_dooff                                                               </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pwrICE: _[CLUSNOTSOE:G_REG]= fi_e                                                            </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 NOTI E:  ft2004_pwr_domain_off                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTICE:  [CLUST_PSOCFG_REG]= 53                                                              </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTICE:  power off cluster, CLUST_PSOCFG_REG = 0x53.                                         </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTICE:  ft2004_psci_pwr_domain_pwr_down_wfi                                                 </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">NOTICE:  scpi_wfi_enalbe                                                                     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[   40.018025] Bye! </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5、第二内核启动后生成vmcore
进入第二内核启动的系统后，执行如下命令</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./vmcore.sh</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>将生成如下文件</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">vdmesg-test.txt  vmcore-test</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>将这两个文件导出即可，最好通过网络传输出来
六、常见问题
6.1 问题：vmcore-dmesg /proc/vmcore 报错No program header covering vaddr 0xffff800010ee29f0found kexec bug?
解决方法：建议将kexec-tools升级到最新版本</p><p>6.2 问题：使用crash工具报错
gdb called without error_hook: Dwarf Error: wrong version in compilation unit header (is 0, should be 2, 3, or 4) <!-- -->[in module /home/rlk/szf/rzg/kernel-source/vmlinux]<!-- -->
Dwarf Error: wrong version in compilation unit header (is 0, should be 2, 3, or 4) <!-- -->[in module /home/rlk/szf/rzg/kernel-source/vmlinux]</p><p>crash: kernel-source/vmlinux: no debugging data available
解决方法：gcc版本要10以下</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.137Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>多个设备共享一根硬件中断线的情况在实际的硬件系统中广泛存在，Linux支持这种中断共享。下面是中断共享的使用方法。</p><p>1）共享中断的多个设备在申请中断时，都应该使用IRQF_SHARED标志，而且一个设备以IRQF_SHARED申请某中断成功的前提是该中断未被申请，或该中断虽然被申请了，但是之前申请该中断的所有设备也都以IRQF_SHARED标志申请该中断。</p><p>2）尽管内核模块可访问的全局地址都可以作为request_irq（…，void*dev_id）的最后一个参数dev_id，但是设备结构体指针显然是可传入的最佳参数。</p><p>3）在中断到来时，会遍历执行共享此中断的所有中断处理程序，直到某一个函数返回IRQ_HANDLED。在中断处理程序顶半部中，应根据硬件寄存器中的信息比照传入的dev_id参数迅速地判断是否为本设备的中断，若不是，应迅速返回IRQ_NONE，如图10.5所示。</p><p><img loading="lazy" alt="1743431228924" src="/assets/images/1743431228924-e2aa27023bb7dc40cb5c6496dd0353ac.png" width="439" height="517" class="img_ev3q"></p><p>图10.5　共享中断的处理</p><p>代码清单10.8给出了使用共享中断的设备驱动程序的模板（仅包含与共享中断机制相关的部分）。</p><p>代码清单10.8　共享中断编程模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 中断处理顶半部 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2irqreturn_t xxx_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 int status = read_int_status();      /* 获知中断源*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 if(!is_myint(dev_id,status))         /* 判断是否为本设备中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          return IRQ_NONE;            /* 不是本设备中断，立即返回*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 /* 是本设备中断，进行处理*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   return IRQ_HANDLED;                /* 返回IRQ_HANDLED表明中断已被处理*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14/* 设备驱动模块加载函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15int xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    /* 申请共享中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    result = request_irq(sh_irq, xxx_interrupt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        IRQF_SHARED, &quot;xxx&quot;, xxx_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24/* 设备驱动模块卸载函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25void xxx_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28    /* 释放中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    free_irq(xxx_irq, xxx_interrupt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.129Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->20 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux网络设备驱动程序的体系结构如图14.1所示，从上到下可以划分为4层，依次为网络协议接口层、网络设备接口层、提供实际功能的设备驱动功能层以及网络设备与媒介层，这4层的作用如下所示。</p><p>1）网络协议接口层向网络层协议提供统一的数据包收发接口，不论上层协议是ARP，还是IP，都通过dev_queue_xmit（）函数发送数据，并通过netif_rx（）函数接收数据。这一层的存在使得上层协议独立于具体的设备。</p><p>2）网络设备接口层向协议接口层提供统一的用于描述具体网络设备属性和操作的结构体net_device，该结构体是设备驱动功能层中各函数的容器。实际上，网络设备接口层从宏观上规划了具体操作硬件的设备驱动功能层的结构。</p><p>3）设备驱动功能层的各函数是网络设备接口层net_device数据结构的具体成员，是驱使网络设备硬件完成相应动作的程序，它通过hard_start_xmit（）函数启动发送操作，并通过网络设备上的中断触发接收操作</p><p>。4）网络设备与媒介层是完成数据包发送和接收的物理实体，包括网络适配器和具体的传输媒介，网络适配器被设备驱动功能层中的函数在物理上驱动。对于Linux系统而言，网络设备和媒介都可以是虚拟的。</p><p><img loading="lazy" alt="1744814560076" src="/assets/images/1744814560076-963f54ac8aece79ebd44abef1a82313b.png" width="876" height="610" class="img_ev3q"></p><p>图14.1　Linux网络设备驱动程序的体系结构</p><p>在设计具体的网络设备驱动程序时，我们需要完成的主要工作是编写设备驱动功能层的相关函数以填充net_device数据结构的内容并将net_device注册入内核。</p><h1>14.1.1　网络协议接口层</h1><p>网络协议接口层最主要的功能是给上层协议提供透明的数据包发送和接收接口。当上层ARP或IP需要发送数据包时，它将调用网络协议接口层的dev_queue_xmit（）函数发送该数据包，同时需传递给该函数一个指向struct sk_buff数据结构的指针。dev_queue_xmit（）函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int dev_queue_xmit(struct sk_buff *skb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>同样地，上层对数据包的接收也通过向netif_rx（）函数传递一个struct sk_buff数据结构的指针来完成。netif_rx（）函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int netif_rx(struct sk_buff *skb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>sk_buff结构体非常重要，它定义于include/linux/skbuff.h文件中，含义为“套接字缓冲区”，用于在Linux网络子系统中的各层之间传递数据，是Linux网络子系统数据传递的“中枢神经”。</p><p>当发送数据包时，Linux内核的网络处理模块必须建立一个包含要传输的数据包的sk_buff，然后将sk_buff递交给下层，各层在sk_buff中添加不同的协议头直至交给网络设备发送。同样地，当网络设备从网络媒介上接收到数据包后，它必须将接收到的数据转换为sk_buff数据结构并传递给上层，各层剥去相应的协议头直至交给用户。代码清单14.1列出了sk_buff结构体中的几个关键数据成员以及描述。</p><p>代码清单14.1　sk_buff结构体中的几个关键数据成员以及描述</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 *      struct sk_buff - socket buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 *      @next: Next buffer in list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 *      @prev: Previous buffer in list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 *      @len: Length of actual data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 *      @data_len: Data length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 *      @mac_len: Length of link layer header</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 *      @hdr_len: writable header length of cloned skb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 *      @csum: Checksum (must include start/offset pair)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 *      @csum_start: Offset from skb-&gt;head where checksumming should start</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 *      @csum_offset: Offset from csum_start where checksum should be stored</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 *      @priority: Packet queueing priority</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 *      @protocol: Packet protocol from driver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 *      @inner_protocol: Protocol (encapsulation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 *      @inner_transport_header: Inner transport layer header (encapsulation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 *      @inner_network_header: Network layer header (encapsulation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 *      @inner_mac_header: Link layer header (encapsulation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 *      @transport_header: Transport layer header</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 *      @network_header: Network layer header</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 *      @mac_header: Link layer header</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 *      @tail: Tail pointer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 *      @end: End pointer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 *      @head: Head of buffer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 *      @data: Data head pointer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27struct sk_buff {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        /* These two members must be first. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        struct sk_buff          *next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        struct sk_buff          *prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        unsigned int            len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34                                data_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35        __u16                   mac_len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36                                hdr_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38        __u32                   priority;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40        __be16                  protocol;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44        __be16                  inner_protocol;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45        __u16                   inner_transport_header;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46        __u16                   inner_network_header;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47        __u16                   inner_mac_header;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48        __u16                   transport_header;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49        __u16                   network_header;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50        __u16                   mac_header;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51        /* These elements must be at the end, see alloc_skb() for details.  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52        sk_buff_data_t          tail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53        sk_buff_data_t          end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54        unsigned char           *head,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55                                *data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如图14.1所示，尤其值得注意的是head和end指向缓冲区的头部和尾部，而data和tail指向实际数据的头部和尾部。每一层会在head和data之间填充协议头，或者在tail和end之间添加新的协议数据。</p><p><img loading="lazy" alt="1744814702888" src="/assets/images/1744814702888-4f763cfe19a12051d23fbf042865913e.png" width="1062" height="741" class="img_ev3q"></p><p>图14.2　sk_buff的head、data、tail、end指针</p><p>下面我们来分析套接字缓冲区涉及的操作函数，Linux套接字缓冲区支持分配、释放、变更等功能函数。</p><p>（1）分配</p><p>Linux内核中用于分配套接字缓冲区的函数有：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct sk_buff *alloc_skb(unsigned int len, gfp_t priority);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct sk_buff *dev_alloc_skb(unsigned int len);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>alloc_skb（）函数分配一个套接字缓冲区和一个数据缓冲区，参数len为数据缓冲区的空间大小，通常以L1_CACHE_BYTES字节（对于ARM为32）对齐，参数priority为内存分配的优先级。dev_alloc_skb（）函数以GFP_ATOMIC优先级进行skb的分配，原因是该函数经常在设备驱动的接收中断里被调用</p><p>（2）释放</p><p>Linux内核中用于释放套接字缓冲区的函数有：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void kfree_skb(struct sk_buff *skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void dev_kfree_skb(struct sk_buff *skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void dev_kfree_skb_irq(struct sk_buff *skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void dev_kfree_skb_any(struct sk_buff *skb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数用于释放被alloc_skb（）函数分配的套接字缓冲区和数据缓冲区。</p><p>Linux内核内部使用kree_skb（）函数，而在网络设备驱动程序中则最好用dev_kfree_skb（）、dev_kfree_skb_irq（）或dev_kfree_skb_any（）函数进行套接字缓冲区的释放。其中，dev_kfree_skb（）函数用于非中断上下文，dev_kfree_skb_irq（）函数用于中断上下文，而dev_kfree_skb_any（）函数在中断和非中断上下文中皆可采用，它其实是做一个非常简单的上下文判断，然后再调用__dev_kfree_skb_irq（）或者dev_kfree_skb（），这从其代码的实现中也可以看出：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void __dev_kfree_skb_any(struct sk_buff *skb, enum skb_free_reason reason)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (in_irq() || irqs_disabled())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                __dev_kfree_skb_irq(skb, reason);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                dev_kfree_skb(skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>（3）变更</p><p>在Linux内核中可以用如下函数在缓冲区尾部增加数据：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *skb_put(struct sk_buff *skb, unsigned int len);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它会导致skb-&gt;tail后移len（skb-&gt;tail+=len），而skb-&gt;len会增加len的大小（skb-&gt;len+=len）。通常，在设备驱动的接收数据处理中会调用此函数。</p><p>在Linux内核中可以用如下函数在缓冲区开头增加数据：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *skb_push(struct sk_buff *skb, unsigned int len);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它会导致skb-&gt;data前移len（skb-&gt;data-=len），而skb-&gt;len会增加len的大小（skb-&gt;len+=len）。与该函数的功能完成相反的函数是skb_pull（），它可以在缓冲区开头移除数据，执行的动作是skb-&gt;len-=len、skb-&gt;data+=len。</p><p>对于一个空的缓冲区而言，调用如下函数可以调整缓冲区的头部：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void skb_reserve(struct sk_buff *skb, int len);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它会将skb-&gt;data和skb-&gt;tail同时后移len，执行skb-&gt;data+=len、skb-&gt;tail+=len。内核里存在许多这样的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">skb=alloc_skb(len+headspace, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">skb_reserve(skb, headspace);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">skb_put(skb,len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">memcpy_fromfs(skb-&gt;data,data,len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">pass_to_m_protocol(skb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码先分配一个全新的sk_buff，接着调用skb_reserve（）腾出头部空间，之后调用skb_put（）腾出数据空间，然后把数据复制进来，最后把sk_buff传给协议栈。</p><h1>14.1.2　网络设备接口层</h1><p>网络设备接口层的主要功能是为千变万化的网络设备定义统一、抽象的数据结构net_device结构体，以不变应万变，实现多种硬件在软件层次上的统一。</p><p>net_device结构体在内核中指代一个网络设备，它定义于include/linux/netdevice.h文件中，网络设备驱动程序只需通过填充net_device的具体成员并注册net_device即可实现硬件操作函数与内核的挂接。</p><p>net_device是一个巨大的结构体，定义于include/linux/netdevice.h中，包含网络设备的属性描述和操作接口，下面介绍其中的一些关键成员。</p><p>（1）全局信息</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">char name[IFNAMESIZ];</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>name是网络设备的名称。</p><p>（2）硬件信息</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long mem_end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long mem_start;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mem_start和mem_end分别定义了设备所使用的共享内存的起始和结束地址。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long base_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char if_port;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char dma;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>base_addr为网络设备I/O基地址。</p><p>irq为设备使用的中断号。</p><p>if_port指定多端口设备使用哪一个端口，该字段仅针对多端口设备。例如，如果设备同时支持IF_PORT_10BASE2（同轴电缆）和IF_PORT_10BASET（双绞线），则可使用该字段。</p><p>dma指定分配给设备的DMA通道。</p><p>（3）接口信息</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned short hard_header_len;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>hard_header_len是网络设备的硬件头长度，在以太网设备的初始化函数中，该成员被赋为ETH_HLEN，即14。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned short type;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>type是接口的硬件类型。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned mtu;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mtu指最大传输单元（MTU）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char           *dev_addr;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>用于存放设备的硬件地址，驱动可能提供了设置MAC地址的接口，这会导致用户设置的MAC地址等存入该成员，如代码清单14.2drivers/net/ethernet/moxa/moxart_ether.c中的moxart_set_mac_address（）函数所示。</p><p>代码清单14.2　set_mac_address（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static int moxart_set_mac_address(struct net_device *ndev, void *addr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3        struct sockaddr *address = addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5        if (!is_valid_ether_addr(address-&gt;sa_data))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6                return -EADDRNOTAVAIL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8        memcpy(ndev-&gt;dev_addr, address-&gt;sa_data, ndev-&gt;addr_len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9        moxart_update_mac_address(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码完成了memcpy（）以及最终硬件上的MAC地址变更。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned short flags；</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>flags指网络接口标志，以IFF_（Interface Flags）开头，部分标志由内核来管理，其他的在接口初始化时被设置以说明设备接口的能力和特性。接口标志包括IFF_UP（当设备被激活并可以开始发送数据包时，内核设置该标志）、IFF_AUTOMEDIA（设备可在多种媒介间切换）、IFF_BROADCAST（允许广播）、IFF_DEBUG（调试模式，可用于控制printk调用的详细程度）、IFF_LOOPBACK（回环）、IFF_MULTICAST（允许组播）、IFF_NOARP（接口不能执行ARP）和IFF_POINTOPOINT（接口连接到点到点链路）等。</p><p>（4）设备操作函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const struct net_device_ops *netdev_ops;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该结构体是网络设备的一系列硬件操作行数的集合，它也定义于include/linux/netdevice.h中，这个结构体很大，代码清单14.3列出了其中的一些基础部分。</p><p>代码清单14.3　net_device_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct net_device_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        int             (*ndo_init)(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        void            (*ndo_uninit)(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        int             (*ndo_open)(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int             (*ndo_stop)(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        netdev_tx_t     (*ndo_start_xmit) (struct sk_buff *skb,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                                           struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        u16             (*ndo_select_queue)(struct net_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                                            struct sk_buff *skb,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                                            void *accel_priv,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                                            select_queue_fallback_t fallback);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        void            (*ndo_change_rx_flags)(struct net_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                                               int flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        void            (*ndo_set_rx_mode)(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int             (*ndo_set_mac_address)(struct net_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                                               void *addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        int             (*ndo_validate_addr)(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        int             (*ndo_do_ioctl)(struct net_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                                        struct ifreq *ifr, int cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ndo_open（）函数的作用是打开网络接口设备，获得设备需要的I/O地址、IRQ、DMA通道等。stop（）函数的作用是停止网络接口设备，与open（）函数的作用相反。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int  (*ndo_start_xmit) (struct sk_buff *skb,struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ndo_start_xmit（）函数会启动数据包的发送，当系统调用驱动程序的xmit函数时，需要向其传入一个sk_buff结构体指针，以使得驱动程序能获取从上层传递下来的数据包。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void (*ndo_tx_timeout)(struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当数据包的发送超时时，ndo_tx_timeout（）函数会被调用，该函数需采取重新启动数据包发送过程或重新启动硬件等措施来恢复网络设备到正常状态。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct net_device_stats* (*ndo_get_stats)(struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ndo_get_stats（）函数用于获得网络设备的状态信息，它返回一个net_device_stats结构体指针。net_device_stats结构体保存了详细的网络设备流量统计信息，如发送和接收的数据包数、字节数等，详见14.8节。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int (*ndo_do_ioctl)(struct net_device *dev, struct ifreq *ifr, int cmd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int (*ndo_set_config)(struct net_device *dev, struct ifmap *map);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int (*ndo_set_mac_address)(struct net_device *dev, void *addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ndo_do_ioctl（）函数用于进行设备特定的I/O控制。</p><p>ndo_set_config（）函数用于配置接口，也可用于改变设备的I/O地址和中断号。</p><p>ndo_set_mac_address（）函数用于设置设备的MAC地址。</p><p>除了netdev_ops以外，在net_device中还存在类似于ethtool_ops、header_ops这样的操作集：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const struct ethtool_ops *ethtool_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const struct header_ops *header_ops;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ethtool_ops成员函数与用户空间ethtool工具的各个命令选项对应，ethtool提供了网卡及网卡驱动管理能力，能够为Linux网络开发人员和管理人员提供对网卡硬件、驱动程序和网络协议栈的设置、查看以及调试等功能。</p><p>header_ops对应于硬件头部操作，主要是完成创建硬件头部和从给定的sk_buff分析出硬件头部等操作。</p><p>（5）辅助成员</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long trans_start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long last_rx;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>trans_start记录最后的数据包开始发送时的时间戳，last_rx记录最后一次接收到数据包时的时间戳，这两个时间戳记录的都是jiffies，驱动程序应维护这两个成员。</p><p>通常情况下，网络设备驱动以中断方式接收数据包，而poll_controller（）则采用纯轮询方式，另外一种数据接收方式是NAPI（New API），其数据接收流程为“接收中断来临→关闭接收中断→以轮询方式接收所有数据包直到收空→开启接收中断→接收中断来临……”内核中提供了如下与NAPI相关的API：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void netif_napi_add(struct net_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  struct napi_struct *napi,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  int (*poll)(struct napi_struct *, int),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  int weight);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void netif_napi_del(struct napi_struct *napi);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以上两个函数分别用于初始化和移除一个NAPI，netif_napi_add（）的poll参数是NAPI要调度执行的轮询函数。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void napi_enable(struct napi_struct *n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void napi_disable(struct napi_struct *n);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以上两个函数分别用于使能和禁止NAPI调度。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int napi_schedule_prep(struct napi_struct *n);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于检查NAPI是否可以调度，而napi_schedule（）函数用于调度轮询实例的运行，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void napi_schedule(struct napi_struct *n);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在NAPI处理完成的时候应该调用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void napi_complete(struct napi_struct *n);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>14.1.3　设备驱动功能层</h1><p>net_device结构体的成员（属性和net_device_ops结构体中的函数指针）需要被设备驱动功能层赋予具体的数值和函数。对于具体的设备xxx，工程师应该编写相应的设备驱动功能层的函数，这些函数形如xxx_open（）、xxx_stop（）、xxx_tx（）、xxx_hard_header（）、xxx_get_stats（）和xxx_tx_timeout（）等。</p><p>由于网络数据包的接收可由中断引发，设备驱动功能层中的另一个主体部分将是中断处理函数，它负责读取硬件上接收到的数据包并传送给上层协议，因此可能包含xxx_interrupt（）和xxx_rx（）函数，前者完成中断类型判断等基本工作，后者则需完成数据包的生成及将其递交给上层等复杂工作。</p><p>14.2~14.8节将对上述函数进行详细分析并给出参考设计模板。</p><p>对于特定的设备，我们还可以定义相关的私有数据和操作，并封装为一个私有信息结构体xxx_private，让其指针赋值给net_device的私有成员。在xxx_private结构体中可包含设备的特殊属性和操作、自旋锁与信号量、定时器以及统计信息等，这都由工程师自定义。在驱动中，要用到私有数据的时候，则使用在netdevice.h中定义的接口：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void *netdev_priv(const struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>比如在驱动drivers/net/ethernet/davicom/dm9000.c的dm9000_probe（）函数中，使用alloc_etherdev（sizeof（struct board_info））分配网络设备，board_info结构体就成了这个网络设备的私有数据，在其他函数中可以简单地提取这个私有数据，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned long flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        board_info_t *db = netdev_priv(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.113Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->6 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>除了前文介绍的of<em>machine_is_compatible（）、of_device_is_compatible（）等常用函数以外，在Linux的BSP和驱动代码中，经常会使用到一些Linux中其他设备树的API，这些API通常被冠以of</em>前缀，它们的实现代码位于内核的drivers/of目录下。</p><p>这些常用的API包括下面内容。</p><h1>1.寻找节点</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct device_node *of_find_compatible_node(struct device_node *from,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *type, const char *compatible);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>根据兼容属性，获得设备节点。遍历设备树中的设备节点，看看哪个节点的类型、兼容属性与本函数的输入参数匹配，在大多数情况下，from、type为NULL，则表示遍历了所有节点。</p><h1>2.读取属性</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int of_property_read_u8_array(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *propname, u8 *out_values, size_t sz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int of_property_read_u16_array(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *propname, u16 *out_values, size_t sz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int of_property_read_u32_array(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *propname, u32 *out_values, size_t sz);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int of_property_read_u64(const struct device_node *np, const char</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*propname, u64 *out_value);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>读取设备节点np的属性名，为propname，属性类型为8、16、32、64位整型数组。对于32位处理器来讲，最常用的是of_property_read_u32_array（）。</p><p>如在arch/arm/mm/cache-l2x0.c中，通过如下语句可读取L2cache的&quot;arm，data-latency&quot;属性：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">of_property_read_u32_array(np, &quot;arm,data-latency&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">data, ARRAY_SIZE(data));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在arch/arm/boot/dts/vexpress-v2p-ca9.dts中，对应的含有&quot;arm，data-latency&quot;属性的L2cache节点如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">L2: cache-controller@1e00a000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;arm,pl310-cache&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt;0x1e00a000 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interrupts = &lt;0 43 4&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cache-level = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arm,data-latency = &lt;1 1 1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">arm,tag-latency = &lt;1 1 1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在有些情况下，整型属性的长度可能为1，于是内核为了方便调用者，又在上述API的基础上封装出了更加简单的读单一整形属性的API，它们为int of_property_read_u8（）、of_property_read_u16（）等，实现于include/linux/of.h中，如代码清单18.19所示。</p><p>代码清单18.19　设备树中整型属性的读取API</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static inline int of_property_read_u8(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                                        const char *propname,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3                                        u8 *out_value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         return of_property_read_u8_array(np, propname, out_value, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8static inline int of_property_read_u16(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                                        const char *propname,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                                        u16 *out_value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         return of_property_read_u16_array(np, propname, out_value, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15static inline int of_property_read_u32(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                                        const char *propname,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                                        u32 *out_value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         return of_property_read_u32_array(np, propname, out_value, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了整型属性外，字符串属性也比较常用，其对应的API包括：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int of_property_read_string(struct device_node *np, const char</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*propname,const char **out_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int of_property_read_string_index(struct device_node *np, const char</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       *propname,int index, const char **output);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前者读取字符串属性，后者读取字符串数组属性中的第index个字符串。如drivers/clk/clk.c中的of_clk_get_parent_name（）函数就通过of_property_read_string_index（）遍历clkspec节点的所有&quot;clock-output-names&quot;字符串数组属性。</p><p>代码清单18.20　在驱动中读取第index个字符串的例子</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1const char *of_clk_get_parent_name(struct device_node *np, int index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          struct of_phandle_args clkspec;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          const char *clk_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5          int rc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          if (index &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                  return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          rc = of_parse_phandle_with_args(np, &quot;clocks&quot;, &quot;#clock-cells&quot;, index,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                                         &amp;clkspec);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          if (rc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                  return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15          if (of_property_read_string_index(clkspec.np, &quot;clock-output-names&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                                    clkspec.args_count  clkspec.args[0] : 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                                            &amp;clk_name) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                  clk_name = clkspec.np-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20          of_node_put(clkspec.np);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21          return clk_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23EXPORT_SYMBOL_GPL(of_clk_get_parent_name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除整型、字符串以外的最常用属性类型就是布尔型，其对应的API很简单，具体如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline bool of_property_read_bool(const struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *propname);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果设备节点np含有propname属性，则返回true，否则返回false。一般用于检查空属性是否存在。</p><h1>3.内存映射</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void __iomem *of_iomap(struct device_node *node, int index);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述API可以直接通过设备节点进行设备内存区间的ioremap（），index是内存段的索引。若设备节点的reg属性有多段，可通过index标示要ioremap（）的是哪一段，在只有1段的情况，index为0。采用设备树后，一些设备驱动通过of_iomap（）而不再通过传统的ioremap（）进行映射，当然，传统的ioremap（）的用户也不少。</p><p>上述API通过设备节点获取与它对应的内存资源的resource结构体。其本质是分析reg属性以获取内存基地址、大小等信息并填充到struct resource*r参数指向的结构体中。</p><h1>4.解析中断</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int irq_of_parse_and_map(struct device_node *dev, int index);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过设备树获得设备的中断号，实际上是从.dts中的interrupts属性里解析出中断号。若设备使用了多个中断，index指定中断的索引号。</p><h1>5.获取与节点对应的platform_device</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct platform_device *of_find_device_by_node(struct device_node *np);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在可以拿到device_node的情况下，如果想反向获取对应的platform_device，可使用上述API。</p><p>当然，在已知platform_device的情况下，想获取device_node则易如反掌，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int sirfsoc_dma_probe(struct platform_device *op)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct device_node *dn = op-&gt;dev.of_node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/2"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>