<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">9.4.1　AIO概念与GNU C库AIO | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="9.4.1　AIO概念与GNU C库AIO | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="Linux中最常用的输入/输出（I/O）模型是同步I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是一种很好的解决方案，调用应用程序在等待I/O请求完成时不需要占用CPU。但是在许多应用场景中，I/O请求可能需要与CPU消耗产生交叠，以充分利用CPU和I/O提高吞吐率。"><meta data-rh="true" property="og:description" content="Linux中最常用的输入/输出（I/O）模型是同步I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是一种很好的解决方案，调用应用程序在等待I/O请求完成时不需要占用CPU。但是在许多应用场景中，I/O请求可能需要与CPU消耗产生交叠，以充分利用CPU和I/O提高吞吐率。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2025-09-15T14:44:14.689Z"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_Ikge" itemprop="headline">9.4.1　AIO概念与GNU C库AIO</h1><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.689Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->17 分钟阅读</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>Linux中最常用的输入/输出（I/O）模型是同步I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是一种很好的解决方案，调用应用程序在等待I/O请求完成时不需要占用CPU。但是在许多应用场景中，I/O请求可能需要与CPU消耗产生交叠，以充分利用CPU和I/O提高吞吐率。</p><p>图9.3描绘了异步I/O的时序，应用程序发起I/O动作后，直接开始执行，并不等待I/O结束，它要么过一段时间来查询之前的I/O请求完成情况，要么I/O请求完成了会自动被调用与I/O完成绑定的回调函数。</p><p><img loading="lazy" alt="image-20250329162852016" src="/assets/images/image-20250329162852016-f73873f65ad99eced05bc485ccb4c906.png" width="1033" height="688" class="img_ev3q"></p><p>图9.3　异步I/O的时序</p><p>Linux的AIO有多种实现，其中一种实现是在用户空间的glibc库中实现的，它本质上是借用了多线程模型，用开启新的线程以同步的方法来做I/O，新的AIO辅助线程与发起AIO的线程以pthread_cond_signal（）的形式进行线程间的同步。glibc的AIO主要包括如下函数。</p><p>1.aio_read（）</p><p>aio_read（）函数请求对一个有效的文件描述符进行异步读操作。这个文件描述符可以表示一个文件、套接字，甚至管道。aio_read函数的原型如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_read( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>aio_read（）函数在请求进行排队之后会立即返回（尽管读操作并未完成）。如果执行成功，返回值就为0；如果出现错误，返回值就为-1，并设置errno的值。</p><p>参数aiocb（AIO I/O Control Block）结构体包含了传输的所有信息，以及为AIO操作准备的用户空间缓冲区。在产生I/O完成通知时，aiocb结构就被用来唯一标识所完成的I/O操作。</p><p>2.aio_write（）</p><p>aio_write（）函数用来请求一个异步写操作。其函数原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_write( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>aio_write（）函数会立即返回，并且它的请求已经被排队（成功时返回值为0，失败时返回值为-1，并相应地设置errno）。</p><p>3.aio_error（）</p><p>aio_error（）函数被用来确定请求的状态。其原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_error( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数可以返回以下内容。</p><p>EINPROGRESS：说明请求尚未完成。</p><p>ECANCELED：说明请求被应用程序取消了。</p><p>-1：说明发生了错误，具体错误原因由errno记录。</p><p>4.aio_return（）</p><p>异步I/O和同步阻塞I/O方式之间的一个区别是不能立即访问这个函数的返回状态，因为异步I/O并没有阻塞在read（）调用上。在标准的同步阻塞read（）调用中，返回状态是在该函数返回时提供的。但是在异步I/O中，我们要使用aio_return（）函数。这个函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t aio_return( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>只有在aio_error（）调用确定请求已经完成（可能成功，也可能发生了错误）之后，才会调用这个函数。aio_return（）的返回值就等价于同步情况中read（）或write（）系统调用的返回值（所传输的字节数如果发生错误，返回值为负数）。</p><p>代码清单9.12给出了用户空间应用程序进行异步读操作的一个例程，它首先打开文件，然后准备aiocb结构体，之后调用aio_read（&amp;my_aiocb）进行提出异步读请求，当aio_error（&amp;my_aiocb）==EINPROGRESS，即操作还在进行中时，一直等待，结束后通过aio_return（&amp;my_aiocb）获得返回值。</p><p>代码清单9.12　用户空间异步读例程</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 #include &lt;aio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 int fd, ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct aiocb my_aiocb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 fd = open(&quot;file.txt&quot;, O_RDONLY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 if (fd &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    perror(&quot;open&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10/* 清零aiocb结构体 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11bzero(&amp;my_aiocb, sizeof(struct aiocb));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13/* 为aiocb请求分配数据缓冲区*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14my_aiocb.aio_buf = malloc(BUFSIZE + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15if (!my_aiocb.aio_buf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   perror(&quot;malloc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18/* 初始化aiocb的成员 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19my_aiocb.aio_fildes = fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20my_aiocb.aio_nbytes = BUFSIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21my_aiocb.aio_offset = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23ret = aio_read(&amp;my_aiocb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   perror(&quot;aio_read&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27while (aio_error(&amp;my_aiocb) == EINPROGRESS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30if ((ret = aio_return(&amp;my_iocb)) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31   /* 获得异步读的返回值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32} else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33   /* 读失败，分析errorno */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5.aio_suspend（）</p><p>用户可以使用aio_suspend（）函数来阻塞调用进程，直到异步请求完成为止。调用者提供了一个aiocb引用列表，其中任何一个完成都会导致aio_suspend（）返回。aio_suspend（）的函数原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_suspend( const struct aiocb *const cblist[],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          int n, const struct timespec *timeout );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单9.13给出了用户空间进行异步读操作时使用aio_suspend（）函数的例子。</p><p>代码清单9.13　用户空间异步I/O aio_suspend（）函数使用例程</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct aioct *cblist[MAX_LIST]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2/* 清零aioct结构体链表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3bzero( (char *)cblist, sizeof(cblist) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4/* 将一个或更多的aiocb放入aioct的结构体链表中*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5cblist[0] = &amp;my_aiocb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6ret = aio_read(&amp;my_aiocb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7ret = aio_suspend(cblist, MAX_LIST, NULL );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当然，在glibc实现的AIO中，除了上述同步的等待方式以外，也可以使用信号或者回调机制来异步地标明AIO的完成。</p><p>6.aio_cancel（）</p><p>aio_cancel（）函数允许用户取消对某个文件描述符执行的一个或所有I/O请求。其原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_cancel(int fd, struct aiocb *aiocbp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>要取消一个请求，用户需提供文件描述符和aiocb指针。如果这个请求被成功取消了，那么这个函数就会返回AIO_CANCELED。如果请求完成了，这个函数就会返回AIO_NOTCANCELED。</p><p>要取消对某个给定文件描述符的所有请求，用户需要提供这个文件的描述符，并将aiocbp参数设置为NULL。如果所有的请求都取消了，这个函数就会返回AIO_CANCELED；如果至少有一个请求没有被取消，那么这个函数就会返回AIO_NOT_CANCELED；如果没有一个请求可以被取消，那么这个函数就会返回AIO_ALLDONE。然后，可以使用aio_error（）来验证每个AIO请求，如果某请求已经被取消了，那么aio_error（）就会返回-1，并且errno会被设置为ECANCELED。</p><p>7.lio_listio（）</p><p>lio_listio（）函数可用于同时发起多个传输。这个函数非常重要，它使得用户可以在一个系统调用中启动大量的I/O操作。lio_listio API函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int lio_listio( int mode, struct aiocb *list[], int nent, struct sigevent *sig );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mode参数可以是LIO_WAIT或LIO_NOWAIT。LIO_WAIT会阻塞这个调用，直到所有的I/O都完成为止。但是若是LIO_NOWAIT模型，在I/O操作进行排队之后，该函数就会返回。list是一个aiocb引用的列表，最大元素的个数是由nent定义的。如果list的元素为NULL，lio_listio（）会将其忽略。</p><p>代码清单9.14给出了用户空间进行异步I/O操作时使用lio_listio（）函数的例子。</p><p>代码清单9.14　用户空间异步I/O lio_listio（）函数使用例程</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct aiocb aiocb1, aiocb2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2struct aiocb *list[MAX_LIST];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4/* 准备第一个aiocb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5aiocb1.aio_fildes = fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6aiocb1.aio_buf = malloc( BUFSIZE+1 );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7aiocb1.aio_nbytes = BUFSIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8aiocb1.aio_offset = next_offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9aiocb1.aio_lio_opcode = LIO_READ;                    /* 异步读操作*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10...  /* 准备多个aiocb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11bzero( (char *)list, sizeof(list) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13/* 将aiocb填入链表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14list[0] = &amp;aiocb1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15list[1] = &amp;aiocb2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17ret = lio_listio( LIO_WAIT, list, MAX_LIST, NULL );  /* 发起大量I/O操作*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第9行中，因为是进行异步读操作，所以操作码为LIO_READ，对于写操作来说，应该使用LIO_WRITE作为操作码，而LIO_NOP意味着空操作。</p><p>网页<a href="http://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html" target="_blank" rel="noopener noreferrer">http://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html</a> 包含了AIO库函数的详细信息。</p><h1>9.4.2　Linux内核AIO与libaio</h1><p>Linux AIO也可以由内核空间实现，异步I/O是Linux 2.6以后版本内核的一个标准特性。对于块设备而言，AIO可以一次性发出大量的read/write调用并且通过通用块层的I/O调度来获得更好的性能，用户程序也可以减少过多的同步负载，还可以在业务逻辑中更灵活地进行并发控制和负载均衡。相较于glibc的用户空间多线程同步等实现也减少了线程的负载和上下文切换等。对于网络设备而言，在socket层面上，也可以使用AIO，让CPU和网卡的收发动作充分交叠以改善吞吐性能。选择正确的I/O模型对系统性能的影响很大，有兴趣的读者可以参阅著名的C10K问题（指的是服务器同时支持成千上万个客户端的问题），详见网址<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener noreferrer">http://www.kegel.com/c10k.html</a> 。</p><p>在用户空间中，我们一般要结合libaio来进行内核AIO的系统调用。内核AIO提供的系统调用主要包括：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int io_setup(int maxevents, io_context_t *ctxp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_destroy(io_context_t ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_submit(io_context_t ctx, long nr, struct iocb *ios[]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_cancel(io_context_t ctx, struct iocb *iocb, struct io_event *evt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_getevents(io_context_t ctx_id, long min_nr, long nr, struct io_event *events,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec *timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_set_callback(struct iocb *iocb, io_callback_t cb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_pwritev(struct iocb *iocb, int fd, const struct iovec *iov, int iovcnt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long long offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_preadv(struct iocb *iocb, int fd, const struct iovec *iov, int iovcnt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long long offset);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>AIO的读写请求都用io_submit（）下发。下发前通过io_prep_pwrite（）和io_prep_pread（）生成iocb的结构体，作为io_submit（）的参数。这个结构体指定了读写类型、起始地址、长度和设备标志符等信息。读写请求下发之后，使用io_getevents（）函数等待I/O完成事件。io_set_callback（）则可设置一个AIO完成的回调函数。</p><p>代码清单9.15演示了一个简单的利用libaio向内核发起AIO请求的模版。该程序位于本书源代码的/kernel/drivers/globalfifo/ch9/aior.c下，使用命令gcc aior.c-o aior–laio编译，运行时带1个文本文件路径作为参数，该程序会打印该文本文件前4096个字节的内容。</p><p>代码清单9.15　使用libaio调用内核AIO的范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define _GNU_SOURCE     /* O_DIRECT is not POSIX */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;stdio.h&gt;      /* for perror() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;unistd.h&gt;     /* for syscall() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;fcntl.h&gt;      /* O_RDWR */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#include &lt;string.h&gt;     /* memset() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#include &lt;inttypes.h&gt;   /* uint64_t */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#include &lt;libaio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#define BUF_SIZE 4096</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13int main(int argc, char **argv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  io_context_t ctx = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  struct iocb cb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  struct iocb *cbs[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  unsigned char *buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  struct io_event events[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  int fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  if (argc &lt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       printf(&quot;the command format: aior [FILE]\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       exit(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  fd = open(argv[1], O_RDWR | O_DIRECT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  if (fd &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       perror(&quot;open error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31       goto err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34  /* Allocate aligned memory */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  ret = posix_memalign((void **)&amp;buf, 512, (BUF_SIZE + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36  if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37       perror(&quot;posix_memalign failed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38       goto err1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40  memset(buf, 0, BUF_SIZE + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42  ret = io_setup(128, &amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43  if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44       printf(&quot;io_setup error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45       goto err2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48  /* setup I/O control block */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49  io_prep_pread(&amp;cb, fd, buf, BUF_SIZE, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51  cbs[0] = &amp;cb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52  ret = io_submit(ctx, 1, cbs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53  if (ret != 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54       if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55            printf(&quot;io_submit error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56       } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57            fprintf(stderr, &quot;could not sumbit IOs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59       goto err3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62  /* get the reply */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63  ret = io_getevents(ctx, 1, 1, events, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64  if (ret != 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65       if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66            printf(&quot;io_getevents error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67       } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68            fprintf(stderr, &quot;could not get Events&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70       goto err3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72  if (events[0].res2 == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73       printf(&quot;%s\n&quot;, buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75       printf(&quot;AIO error:%s&quot;, strerror(-events[0].res));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76       goto err3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79  if ((ret = io_destroy(ctx)) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80       printf(&quot;io_destroy error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81       goto err2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84  free(buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85  close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">86  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">87</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">88 err3:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">89  if ((ret = io_destroy(ctx)) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">90       printf(&quot;io_destroy error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">91 err2:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">92  free(buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">93 err1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">94  close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">95 err:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">96  return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">97}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>9.4.3　AIO与设备驱动</h1><p>用户空间调用io_submit（）后，对应于用户传递的每一个iocb结构，内核会生成一个与之对应的kiocb结构。file_operations包含3个与AIO相关的成员函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_read) (struct kiocb *iocb, const struct iovec *iov, unsigned long</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nr_segs, loff_t pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_write) (struct kiocb *iocb, const struct iovec *iov, unsigned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long nr_segs, loff_t pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int (*aio_fsync) (struct kiocb *iocb, int datasync);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>io_submit（）系统调用间接引起了file_operations中的aio_read（）和aio_write（）的调用。</p><p>在早期的Linux内核中，aio_read（）和aio_write（）的原型是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_read) (struct kiocb *iocb, char __user *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         size_t size, loff_t pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_write) (struct kiocb *iocb, const char *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size_t count, loff_t offset);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个老的原型里，只含有一个缓冲区指针，而在新的原型中，则可以传递一个向量iovec，它含有多段缓冲区。详见位于<a href="https://lwn.net/Articles/170954/" target="_blank" rel="noopener noreferrer">https://lwn.net/Articles/170954/</a> 的文档《Asynchronous I/O and vectored operations》。</p><p>AIO一般由内核空间的通用代码处理，对于块设备和网络设备而言，一般在Linux核心层的代码已经解决。字符设备驱动一般不需要实现AIO支持。Linux内核中对字符设备驱动实现AIO的特例包括drivers/char/mem.c里实现的null、zero等，由于zero这样的虚拟设备其实也不存在在要去读的时候读不到东西的情况，所以aio_read_zero（）本质上也不包含异步操作，不过从代码清单9.16我们可以一窥iovec的全貌。</p><p>代码清单9.16　zero设备的aio_read实现</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t aio_read_zero(struct kiocb *iocb, const struct iovec *iov,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                             unsigned long nr_segs, loff_t pos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        size_t written = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        unsigned long i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        ssize_t ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        for (i = 0; i &lt; nr_segs; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                ret = read_zero(iocb-&gt;ki_filp, iov[i].iov_base, iov[i].iov_len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                                &amp;pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                written += ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        return written   written : -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想"><div class="pagination-nav__sublabel">较新一篇</div><div class="pagination-nav__label">12.4.1　主机驱动与外设驱动分离</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">16.4.1　UDC和Gadget驱动的关键数据结构与API</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>