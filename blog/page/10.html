<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/10"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/10"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/10" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/10" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.553Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux的文件操作系统调用（在Windows编程领域，习惯称操作系统提供的接口为API）涉及创建、打开、读写和关闭文件。</p><p>1.创建</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int creat(const char *filename, mode_t mode);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>参数mode指定新建文件的存取权限，它同umask一起决定文件的最终权限（mode&amp;umask），其中，umask代表了文件在创建时需要去掉的一些存取权限。umask可通过系统调用umask（）来改变：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int umask(int newmask);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该调用将umask设置为newmask，然后返回旧的umask，它只影响读、写和执行权限。</p><p>2.打开</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int open(const char *pathname, int flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int open(const char *pathname, int flags, mode_t mode);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>open（）函数有两个形式，其中pathname是我们要打开的文件名（包含路径名称，缺省是认为在当前路径下面），flags可以是表5.1中的一个值或者是几个值的组合。</p><p>表5.1　文件打开标志</p><p><img loading="lazy" alt="1742741435705" src="/assets/images/1742741435705-ebd1f1969cabafd31d7d8775333898a5.png" width="1476" height="463" class="img_ev3q"></p><p>O_RDONLY、O_WRONLY、O_RDWR三个标志只能使用任意的一个。</p><p>如果使用了O_CREATE标志，则使用的函数是int open（const char*pathname，int flags，mode_t mode）；这个时候我们还要指定mode标志，以表示文件的访问权限。mode可以是表5.2中所列值的组合。</p><p>表5.2　文件访问权限</p><p><img loading="lazy" alt="1742741468416" src="/assets/images/1742741468416-8eefb4ddb6c6a1a3d490c09db54e09f7.png" width="1102" height="738" class="img_ev3q"></p><p>除了可以通过上述宏进行“或”逻辑产生标志以外，我们也可以自己用数字来表示，Linux用5个数字来表示文件的各种权限：第一位表示设置用户ID；第二位表示设置组ID；第三位表示用户自己的权限位；第四位表示组的权限；最后一位表示其他人的权限。每个数字可以取1（执行权限）、2（写权限）、4（读权限）、0（无）或者是这些值的和。例如，要创建一个用户可读、可写、可执行，但是组没有权限，其他人可以读、可以执行的文件，并设置用户ID位，那么应该使用的模式是1（设置用户ID）、0（不设置组ID）、7（1+2+4，读、写、执行）、0（没有权限）、5（1+4，读、执行）即10705：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">open(&quot;test&quot;, O_CREAT, 10 705);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述语句等价于：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">open(&quot;test&quot;, O_CREAT, S_IRWXU | S_IROTH | S_IXOTH | S_ISUID );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果文件打开成功，open函数会返回一个文件描述符，以后对该文件的所有操作就可以通过对这个文件描述符进行操作来实现。</p><p>3.读写</p><p>在文件打开以后，我们才可对文件进行读写，Linux中提供文件读写的系统调用是read、write函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int read(int fd, const void *buf, size_t length);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int write(int fd, const void *buf, size_t length);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中，参数buf为指向缓冲区的指针，length为缓冲区的大小（以字节为单位）。函数read（）实现从文件描述符fd所指定的文件中读取length个字节到buf所指向的缓冲区中，返回值为实际读取的字节数。函数write实现把length个字节从buf指向的缓冲区中写到文件描述符fd所指向的文件中，返回值为实际写入的字节数。</p><p>以O_CREAT为标志的open实际上实现了文件创建的功能，因此，下面的函数等同于creat（）函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int open(pathname, O_CREAT | O_WRONLY | O_TRUNC, mode);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4.定位</p><p>对于随机文件，我们可以随机指定位置进行读写，使用如下函数进行定位：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int lseek(int fd, offset_t offset, int whence);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>lseek（）将文件读写指针相对whence移动offset个字节。操作成功时，返回文件指针相对于文件头的位置。参数whence可使用下述值：</p><ul><li>SEEK_SET：相对文件开头</li><li>SEEK_CUR：相对文件读写指针的当前位置</li><li>SEEK_END：相对文件末尾</li></ul><p>offset可取负值，例如下述调用可将文件指针相对当前位置向前移动5个字节：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">lseek(fd, -5, SEEK_CUR);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于lseek函数的返回值为文件指针相对于文件头的位置，因此下列调用的返回值就是文件的长度：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">lseek(fd, 0, SEEK_END);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5.关闭</p><p>当我们操作完成以后，要关闭文件，此时，只要调用close就可以了，其中fd是我们要关闭的文件描述符：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int close(int fd);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>例程：编写一个程序，在当前目录下创建用户可读写文件hello.txt，在其中写入“Hello，software weekly”，关闭该文件。再次打开该文件，读取其中的内容并输出在屏幕上。</p><p>解答如代码清单5.1。</p><p>代码清单5.1　Linux文件操作用户空间编程（使用系统调用）</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1  #include &lt;sys/types.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  #include &lt;sys/stat.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  #include &lt;fcntl.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  #include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  #define LENGTH 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    int fd, len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    char str[LENGTH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11    fd = open(&quot;hello.txt&quot;, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR); /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    创建并打开文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13    if (fd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         write(fd, &quot;Hello World&quot;, strlen(&quot;Hello World&quot;)); /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         写入字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16         close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    fd = open(&quot;hello.txt&quot;, O_RDWR);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    len = read(fd, str, LENGTH); /* 读取文件内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21    str[len] = &#x27;\0&#x27;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22    printf(&quot;%s\n&quot;, str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>编译并运行，执行结果为输出“Hello World”。</p><h1>5.1.2　C库文件操作</h1><p>C库函数的文件操作实际上独立于具体的操作系统平台，不管是在DOS、Windows、Linux还是在VxWorks中都是这些函数</p><p>1.创建和打开</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">fiLE *fopen(const char *path, const char *mode);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>fopen（）用于打开指定文件filename，其中的mode为打开模式，C库函数中支持的打开模式如表5.3所示。</p><p>表5.3　C库函数文件打开标志</p><p><img loading="lazy" alt="1742741795661" src="/assets/images/1742741795661-33f7bea6f567007407c542b3853ec709.png" width="1279" height="361" class="img_ev3q"></p><p>其中，b用于区分二进制文件和文本文件，这一点在DOS、Windows系统中是有区分的，但Linux不区分二进制文件和文本文件。</p><p>2.读写</p><p>C库函数支持以字符、字符串等为单位，支持按照某种格式进行文件的读写，这一组函数为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int fgetc(fiLE *stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int fputc(int c, fiLE *stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">char *fgets(char *s, int n, fiLE *stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int fputs(const char *s, fiLE *stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int fprintf(fiLE *stream, const char *format, ...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int fscanf (fiLE *stream, const char *format, ...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size_t fread(void *ptr, size_t size, size_t n, fiLE *stream);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size_t fwrite (const void *ptr, size_t size, size_t n, fiLE *stream);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>fread（）实现从流（stream）中读取n个字段，每个字段为size字节，并将读取的字段放入ptr所指的字符数组中，返回实际已读取的字段数。当读取的字段数小于num时，可能是在函数调用时出现了错误，也可能是读到了文件的结尾。因此要通过调用feof（）和ferror（）来判断。</p><p>write（）实现从缓冲区ptr所指的数组中把n个字段写到流（stream）中，每个字段长为size个字节，返回实际写入的字段数。</p><p>另外，C库函数还提供了读写过程中的定位能力，这些函数包括：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int fgetpos(fiLE *stream, fpos_t *pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int fsetpos(fiLE *stream, const fpos_t *pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int fseek(fiLE *stream, long offset, int whence);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3.关闭</p><p>利用C库函数关闭文件依然是很简单的操作：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int fclose (fiLE *stream);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>例程：将第5.1.1节中的例程用C库函数来实现，如代码清单5-2所示</p><p>代码清单5.2　Linux文件操作用户空间编程（使用C库函数）</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 #include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 #define LENGTH 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   fiLE *fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   char str[LENGTH];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   fd = fopen(&quot;hello.txt&quot;, &quot;w+&quot;);/* 创建并打开文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   if (fd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       fputs(&quot;Hello World&quot;, fd); /* 写入字符串</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       fclose(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   fd = fopen(&quot;hello.txt&quot;, &quot;r&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   fgets(str, LENGTH, fd);       /* 读取文件内容</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   printf(&quot;%s\n&quot;, str);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17   fclose(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.541Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>设备的中断会打断内核进程中的正常调度和运行，系统对更高吞吐率的追求势必要求中断服务程序尽量短小精悍。但是，这个良好的愿望往往与现实并不吻合。在大多数真实的系统中，当中断到来时，要完成的工作往往并不会是短小的，它可能要进行较大量的耗时处理。</p><p>图10.3描述了Linux内核的中断处理机制。为了在中断执行时间尽量短和中断处理需完成的工作尽量大之间找到一个平衡点，Linux将中断处理程序分解为两个半部：顶半部（Top Half）和底半部（Bottom Half）。</p><p><img loading="lazy" alt="1743346115936" src="/assets/images/1743346115936-fb287e25f344c64657f9b916ac13452a.png" width="693" height="426" class="img_ev3q"></p><p>图10.3　Linux中断处理机制</p><p>顶半部用于完成尽量少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态，并在清除中断标志后就进行“登记中断”的工作。“登记中断”意味着将底半部处理程序挂到该设备的底半部执行队列中去。这样，顶半部执行的速度就会很快，从而可以服务更多的中断请求。</p><p>现在，中断处理工作的重心就落在了底半部的头上，需用它来完成中断事件的绝大多数任务。底半部几乎做了中断处理程序所有的事情，而且可以被新的中断打断，这也是底半部和顶半部的最大不同，因为顶半部往往被设计成不可中断。底半部相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行。</p><p>尽管顶半部、底半部的结合能够改善系统的响应能力，但是，僵化地认为Linux设备驱动中的中断处理一定要分两个半部则是不对的。如果中断要处理的工作本身很少，则完全可以直接在顶半部全部完成。</p><p>其他操作系统中对中断的处理也采用了类似于Linux的方法，真正的硬件中断服务程序都应该尽量短。因此，许多操作系统都提供了中断上下文和非中断上下文相结合的机制，将中断的耗时工作保留到非中断上下文去执行。例如，在VxWorks中，网络设备包接收中断到来后，中断服务程序会通过netJobAdd（）函数将耗时的包接收和上传工作交给tNetTask任务去执行。</p><p>在Linux中，查看/proc/interrupts文件可以获得系统中中断的统计信息，并能统计出每一个中断号上的中断在每个CPU上发生的次数，具体如图10.4所示。</p><p><img loading="lazy" alt="image-20250330224941927" src="/assets/images/image-20250330224941927-9b0c6f8f117288a73fae5a9e100f60cd.png" width="1188" height="931" class="img_ev3q"></p><p>图10.4　Linux中的中断统计信息</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.541Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->13 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux的I2 C体系结构分为3个组成部分。</p><p>（1）I2 C核心</p><p>I2 C核心提供了I2 C总线驱动和设备驱动的注册、注销方法，I2 C通信方法（即Algorithm）上层的与具体适配器无关的代码以及探测设备、检测设备地址的上层代码等，如图15.1所示。</p><p>（2）I2 C总线驱动</p><p>I2 C总线驱动是对I2 C硬件体系结构中适配器端的实现，适配器可由CPU控制，甚至可以直接集成在CPU内部。</p><p>I2 C总线驱动主要包含I2 C适配器数据结构i2c_adapter、I2 C适配器的Algorithm数据结构i2c_algorithm和控制I2 C适配器产生通信信号的函数。</p><p><img loading="lazy" alt="1744988278285" src="/assets/images/1744988278285-ad84009052c6baa96b5c7a120f46d9ff.png" width="771" height="1063" class="img_ev3q"></p><p>图15.1　Linux的I2 C体系结构</p><p>经由I2 C总线驱动的代码，我们可以控制I2 C适配器以主控方式产生开始位、停止位、读写周期，以及以从设备方式被读写、产生ACK等。</p><p>（3）I2 C设备驱动</p><p>I2 C设备驱动（也称为客户驱动）是对I2 C硬件体系结构中设备端的实现，设备一般挂接在受CPU控制的I2 C适配器上，通过I2 C适配器与CPU交换数据。</p><p>I2 C设备驱动主要包含数据结构i2c_driver和i2c_client，我们需要根据具体设备实现其中的成员函数。</p><p>在Linux 2.6内核中，所有的I2 C设备都在sysfs文件系统中显示，存于/sys/bus/i2c/目录下，以适配器地址和芯片地址的形式列出，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ tree /sys/bus/i2c/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/sys/bus/i2c/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|-- devices</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|   |-- i2c0 -&gt; ../../../devices/platform/versatile-i2c.0/i2c-0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">|   &#x27;-- i2c1 -&gt; ../../../devices/platform/versatile-i2c.0/i2c-1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&#x27;-- drivers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &#x27;-- dummy</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux内核源代码中的drivers目录下有一个i2c目录，而在i2c目录下又包含如下文件和文件夹。</p><p>（1）i2c-core.c</p><p>这个文件实现了I2 C核心的功能以及/proc/bus/i2c*接口。</p><p>（2）i2c-dev.c</p><p>实现了I2 C适配器设备文件的功能，每一个I2 C适配器都被分配一个设备。通过适配器访问设备时的主设备号都为89，次设备号为0~255。应用程序通过“i2c-%d”（i2c-0，i2c-1，…，i2c-10，…）文件名并使用文件操作接口open（）、write（）、read（）、ioctl（）和close（）等来访问这个设备。</p><p>i2c-dev.c并不是针对特定的设备而设计的，只是提供了通用的read（）、write（）和ioctl（）等接口，应用层可以借用这些接口访问挂接在适配器上的I2 C设备的存储空间或寄存器，并控制I2 C设备的工作方式。</p><p>（3）busses文件夹</p><p>这个文件包含了一些I2 C主机控制器的驱动，如i2c-tegra.c、i2c-omap.c、i2c-versatile.c、i2c-s3c2410.c等。</p><p>（4）algos文件夹</p><p>实现了一些I2 C总线适配器的通信方法。</p><p>此外，内核中的i2c.h头文件对i2c_adapter、i2c_algorithm、i2c_driver和i2c_client这4个数据结构进行了定义。理解这4个结构体的作用十分重要，它们的定义位于include/linux/i2c.h文件中，代码清单15.1、15.2、15.3、15.4分别对它们进行了描述。</p><p>代码清单15.1　i2c_adapter结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct i2c_adapter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        struct module *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        unsigned int class;                 /* classes to allow probing for */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        const struct i2c_algorithm *algo;   /* the algorithm to access the bus */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        void *algo_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        /* data fields that are valid for all devices   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        struct rt_mutex bus_lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        int timeout;                        /* in jiffies */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        int retries;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        struct device dev;                  /* the adapter device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        int nr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        char name[48];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        struct completion dev_released;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        struct mutex userspace_clients_lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        struct list_head userspace_clients;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        struct i2c_bus_recovery_info *bus_recovery_info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单15.2　i2c_algorithm结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct i2c_algorithm {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        /* If an adapter algorithm can&#x27;t do I2C-level access, set master_xfer</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3           to NULL. If an adapter algorithm can do SMBus access, set</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4           smbus_xfer. If set to NULL, the SMBus protocol is simulated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5           using common I2C messages */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        /* master_xfer should return the number of messages successfully</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7           processed, or a negative value on error */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                           int num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                        unsigned short flags, char read_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                        u8 command, int size, union i2c_smbus_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        /* To determine what the adapter supports */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        u32 (*functionality) (struct i2c_adapter *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述第8行代码对应为I2 C传输函数指针，I2 C主机驱动的大部分工作也聚集在这里。上述第10行代码对应为SMBus传输函数指针，SMBus不需要增加额外引脚，与I2 C总线相比，在访问时序上也有一定的差异。</p><p>代码清单15.3　i2c_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct i2c_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        unsigned int class;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        /* Notifies the driver that a new bus has appeared. You should avoid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         * using this, it will be removed in a near future.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        int (*attach_adapter)(struct i2c_adapter *) __deprecated;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        /* Standard driver model interfaces */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        int (*probe)(struct i2c_client *, const struct i2c_device_id *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        int (*remove)(struct i2c_client *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        /* driver model interfaces that don&#x27;t relate to enumeration  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        void (*shutdown)(struct i2c_client *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int (*suspend)(struct i2c_client *, pm_message_t mesg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int (*resume)(struct i2c_client *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        /* Alert callback, for example for the SMBus alert protocol.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         * The format and meaning of the data value depends on the protocol.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         * For the SMBus alert protocol, there is a single bit of data passed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21         * as the alert response&#x27;s low bit (&quot;event flag&quot;).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        void (*alert)(struct i2c_client *, unsigned int data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        /* a ioctl like command that can be used to perform specific functions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         * with the device.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        struct device_driver driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31        const struct i2c_device_id *id_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        /* Device detection callback for automatic device creation */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34        int (*detect)(struct i2c_client *, struct i2c_board_info *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35        const unsigned short *address_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36        struct list_head clients;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单15.4　i2c_client结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct i2c_client {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        unsigned short flags;         /* div., see below            */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        unsigned short addr;          /* chip address - NOTE: 7bit    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4                                      /* addresses are stored in the  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                                      /* _LOWER_ 7 bits             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        char name[I2C_NAME_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        struct i2c_adapter *adapter;  /* the adapter we sit on        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        struct device dev;            /* the device structure         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        int irq;                      /* irq issued by device         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        struct list_head detected;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面分析i2c_adapter、i2c_algorithm、i2c_driver和i2c_client这4个数据结构的作用及其盘根错节的关系。</p><p>（1）i2c_adapter与i2c_algorithm</p><p>i2c_adapter对应于物理上的一个适配器，而i2c_algorithm对应一套通信方法。一个I2 C适配器需要i2c_algorithm提供的通信函数来控制适配器产生特定的访问周期。缺少i2c_algorithm的i2c_adapter什么也做不了，因此i2c_adapter中包含所使用的i2c_algorithm的指针。</p><p>i2c_algorithm中的关键函数master_xfer（）用于产生I2 C访问周期需要的信号，以i2c_msg（即I2 C消息）为单位。i2c_msg结构体也是非常重要的，它定义于include/uapi/linux/i2c.h（在uapi目录下，证明用户空间的应用也可能使用这个结构体）中，代码清单15.5给出了它的定义，其中的成员表明了I2 C的传输地址、方向、缓冲区、缓冲区长度等信息。</p><p>代码清单15.5　i2c_msg结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct i2c_msg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        __u16 addr;                     /* slave address          */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        __u16 flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#define I2C_M_TEN             0x0010  /* this is a ten bit chip address */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#define I2C_M_RD              0x0001  /* read data, from slave to master */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#define I2C_M_STOP            0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#define I2C_M_NOSTART         0x4000  /* if I2C_FUNC_NOSTART */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8#define I2C_M_REV_DIR_ADDR    0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#define I2C_M_IGNORE_NAK      0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10#define I2C_M_NO_RD_ACK       0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#define I2C_M_RECV_LEN        0x0400  /* length will be first received byte */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         __u16 len;                     /* msg length                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         __u8 *buf;                     /* pointer to msg data          */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>（2）i2c_driver与i2c_client</p><p>i2c_driver对应于一套驱动方法，其主要成员函数是probe（）、remove（）、suspend（）、resume（）等，另外，struct i2c_device_id形式的id_table是该驱动所支持的I2 C设备的ID表。i2c_client对应于真实的物理设备，每个I2 C设备都需要一个i2c_client来描述。i2c_driver与i2c_client的关系是一对多，一个i2c_driver可以支持多个同类型的i2c_client。</p><p>i2c_client的信息通常在BSP的板文件中通过i2c_board_info填充，如下面的代码就定义了一个I2 C设备的ID为“ad7142_joystick”、地址为0x2C、中断号为IRQ_PF5的i2c_client：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct i2c_board_info __initdata xxx_i2c_board_info[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#if defined(CONfiG_JOYSTICK_AD7142) || defined(CONfiG_JOYSTICK_AD7142_MODULE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               I2C_BOARD_INFO(&quot;ad7142_joystick&quot;, 0x2C),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .irq = IRQ_PF5,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在I2 C总线驱动i2c_bus_type的match（）函数i2c_device_match（）中，会调用i2c_match_id（）函数匹配在板文件中定义的ID和i2c_driver所支持的ID表。</p><p>（3）i2c_adpater与i2c_client</p><p>i2c_adpater与i2c_client的关系与I2 C硬件体系中适配器和设备的关系一致，即i2c_client依附于i2c_adpater。由于一个适配器可以连接多个I2 C设备，所以一个i2c_adpater也可以被多个i2c_client依附，i2c_adpater中包括依附于它的i2c_client的链表。</p><p>假设I2 C总线适配器xxx上有两个使用相同驱动程序的yyy I2 C设备，在打开该I2 C总线的设备节点后，相关数据结构之间的逻辑组织关系将如图15.2所示。</p><p><img loading="lazy" alt="image-20250418230357150" src="/assets/images/image-20250418230357150-2e9634bd72ee33537545fc6ccb2ab6aa.png" width="1035" height="1462" class="img_ev3q"></p><p>图15.2　I2 C驱动的各种数据结构的关系</p><p>从上面的分析可知，虽然I2 C硬件体系结构比较简单，但是I2 C体系结构在Linux中的实现却相当复杂。当工程师拿到实际的电路板时，面对复杂的Linux I2 C子系统，应该如何下手写驱动呢？究竟有哪些是需要亲自做的，哪些是内核已经提供的呢？理清这个问题非常有意义，可以使我们在面对具体问题时迅速抓住重点</p><p>一方面，适配器驱动可能是Linux内核本身还不包含的；另一方面，挂接在适配器上的具体设备驱动可能也是Linux内核还不包含的。因此，工程师要实现的主要工作如下。</p><ul><li>·提供I2 C适配器的硬件驱动，探测、初始化I2 C适配器（如申请I2 C的I/O地址和中断号）、驱动CPU控制的I2 C适配器从硬件上产生各种信号以及处理I2 C中断等。</li><li>·提供I2 C适配器的Algorithm，用具体适配器的xxx_xfer（）函数填充i2c_algorithm的master_xfer指针，并把i2c_algorithm指针赋值给i2c_adapter的algo指针。</li><li>·实现I2 C设备驱动中的i2c_driver接口，用具体设备yyy的yyy_probe（）、yyy_remove（）、yyy_suspend（）、yyy_resume（）函数指针和i2c_device_id设备ID表赋值给i2c_driver的probe、remove、suspend、resume和id_table指针。</li><li>·实现I2 C设备所对应类型的具体驱动，i2c_driver只是实现设备与总线的挂接，而挂接在总线上的设备则千差万别。例如，如果是字符设备，就实现文件操作接口，即实现具体设备yyy的yyy_read（）、yyy_write（）和yyy_ioctl（）函数等；如果是声卡，就实现ALSA驱动。</li></ul><p>上述工作中前两个属于I2 C总线驱动，后两个属于I2 C设备驱动。15.3~15.4节将详细分析这些工作的实施方法，给出设计模板，而15.5~15.6节将给出两个具体的实例。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.537Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>外设可处于CPU的内存空间和I/O空间，除x86外，嵌入式处理器一般只存在内存空间。在Linux系统中，为I/O内存和I/O端口的访问提高了一套统一的方法，访问流程一般为“申请资源→映射→访问→去映射→释放资源”。</p><p>对于有MMU的处理器而言，Linux系统的内部布局比较复杂，可直接映射的物理内存称为常规内存，超出部分为高端内存。kmalloc（）和__get_free_pages（）申请的内存在物理上连续，而vmalloc（）申请的内存在物理上不连续。</p><p>DMA操作可能导致Cache的不一致性问题，因此，对于DMA缓冲，应该使用dma_alloc_coherent（）等方法申请。在DMA操作中涉及总线地址、物理地址和虚拟地址等概念，区分这3类地址非常重要。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.537Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>现今的SoC一般包含很多集成组件，在系统运行过程中，并不需要所有的模块都运行于最高频率和最高性能。在SoC内，某些domain可以运行在较低的频率和电压下，而其他domain可以运行在较高的频率和电压下，某个domain所支持的&lt;频率，电压&gt;对的集合被称为Operating Performance Point，缩写为OPP。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int opp_add(struct device *dev, unsigned long freq, unsigned long u_volt);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>目前，TI OMAP CPUFreq驱动的底层就使用了OPP这种机制来获取CPU所支持的频率和电压列表。在开机的过程中，TI OMAP4芯片会注册针对CPU设备的OPP表（代码位于arch/arm/mach-omap2/中），如代码清单19.10所示。</p><p>代码清单19.10　TI OMAP4 CPU的OPP表</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static struct omap_opp_def __initdata omap44xx_opp_def_list[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2       /* MPU OPP1 - OPP50 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3       OPP_INITIALIZER(&quot;mpu&quot;, true, 300000000, OMAP4430_VDD_MPU_OPP50_UV),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4       /* MPU OPP2 - OPP100 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5       OPP_INITIALIZER(&quot;mpu&quot;, true, 600000000, OMAP4430_VDD_MPU_OPP100_UV),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6       /* MPU OPP3 - OPP-Turbo */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7       OPP_INITIALIZER(&quot;mpu&quot;, true, 800000000, OMAP4430_VDD_MPU_OPPTURBO_UV),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8       /* MPU OPP4 - OPP-SB */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9       OPP_INITIALIZER(&quot;mpu&quot;, true, 1008000000, OMAP4430_VDD_MPU_OPPNITRO_UV),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12/**</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 * omap4_opp_init() - initialize omap4 opp table</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15int __init omap4_opp_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18      r = omap_init_opp_table(omap44xx_opp_def_list,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                   ARRAY_SIZE(omap44xx_opp_def_list));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21      return r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23device_initcall(omap4_opp_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24int __init omap_init_opp_table(struct omap_opp_def *opp_def,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25             u32 opp_def_size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28      /* Lets now register with OPP library */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29      for (i = 0; i &lt; opp_def_size; i++, opp_def++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30            …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31            if (!strncmp(opp_def-&gt;hwmod_name, &quot;mpu&quot;, 3)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32                   /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33                    * All current OMAPs share voltage rail and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34                    * clock source, so CPU0 is used to represent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                    * the MPU-SS.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36                    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37                   dev = get_cpu_device(0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38            } …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39            r = opp_add(dev, opp_def-&gt;freq, opp_def-&gt;u_volt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40            …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>针对与device结构体指针dev对应的domain中增加一个新的OPP，参数freq和u_volt即为该OPP对应的频率和电压。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int opp_enable(struct device *dev, unsigned long freq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int opp_disable(struct device *dev, unsigned long freq);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述API用于使能和禁止某个OPP，一旦被禁止，其available将成为false，之后有设备驱动想设置为这个OPP就不再可能了。譬如，当温度超过某个范围后，系统不允许1GHz的工作频率，可采用类似下面的代码实现：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (cur_temp &gt; temp_high_thresh) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* Disable 1GHz if it was enabled */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      rcu_read_lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opp = opp_find_freq_exact(dev, 1000000000, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      rcu_read_unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      /* just error check */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (!IS_ERR(opp))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ret = opp_disable(dev, 1000000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">goto try_something_else;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中调用的opp_find_freq_exact（）用于寻找与一个确定频率和available匹配的OPP，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct opp *opp_find_freq_exact(struct device *dev, unsigned long freq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bool available);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，Linux还提供两个变体，opp_find_freq_floor（）用于寻找1个OPP，它的频率向上接近或等于指定的频率；opp_find_freq_ceil（）用于寻找1个OPP，它的频率向下接近或等于指定的频率，这两个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct opp *opp_find_freq_floor(struct device *dev, unsigned long *freq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct opp *opp_find_freq_ceil(struct device *dev, unsigned long *freq);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们可用下面的代码分别寻找1个设备的最大和最小工作频率：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">freq = ULONG_MAX;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rcu_read_lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opp_find_freq_floor(dev, &amp;freq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rcu_read_unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">freq = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rcu_read_lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opp_find_freq_ceil(dev, &amp;freq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rcu_read_unlock();</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在频率降低的同时，支撑该频率运行所需的电压也往往可以动态调低；反之，则可能需要调高，下面这两个API分别用于获取与某OPP对应的电压和频率：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long opp_get_voltage(struct opp *opp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long opp_get_freq(struct opp *opp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>举个例子，当某CPUFreq驱动想将CPU设置为某一频率的时候，它可能会同时设置电压，其代码流程为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">soc_switch_to_freq_voltage(freq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* do things */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     rcu_read_lock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opp = opp_find_freq_ceil(dev, &amp;freq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     v = opp_get_voltage(opp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     rcu_read_unlock();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           regulator_set_voltage(.., v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* do other things */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如下简单的API可用于获取某设备所支持的OPP的个数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int opp_get_opp_count(struct device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前面提到，TI OMAP CPUFreq驱动的底层就使用了OPP这种机制来获取CPU所支持的频率和电压列表。它在omap_init_opp_table（）函数中添加了相应的OPP，在TI OMAP芯片的CPUFreq驱动drivers/cpufreq/omap-cpufreq.c中，则借助了快捷函数opp_init_cpufreq_table（）来根据前面注册的OPP建立CPUFreq的频率表：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (!freq_table)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">result = opp_init_cpufreq_table(mpu_dev, &amp;freq_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而在CPUFreq驱动的目标成员函数omap_target（）中，则使用与OPP相关的API来获取频率和电压：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int omap_target(struct cpufreq_policy *policy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int target_freq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int relation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (mpu_reg) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">opp = opp_find_freq_ceil(mpu_dev, &amp;freq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">volt = opp_get_voltage(opp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/cpufreq/omap-cpufreq.c相对来说较为规范，它在&lt;频率，电压&gt;表方面，在底层使用了OPP，在设置电压的时候又使用了规范的Regulator API。</p><p>比较新的驱动一般不太喜欢直接在代码里面固化OPP表，而是喜欢在相应的节点处添加operating-points属性，如imx27.dtsi中的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpus {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              #size-cells = &lt;0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu: cpu@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    device_type = &quot;cpu&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;arm,arm926ej-s&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">operating-points = &lt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          /* kHz uV */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          266000 1300000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          399000 1450000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clock-latency = &lt;62500&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clocks = &lt;&amp;clks IMX27_CLK_CPU_DIV&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">voltage-tolerance = &lt;5&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果CPUFreq的变化可以使用非常标准的regulator、clk API，我们甚至可以直接使用drivers/cpufreq/cpufreq-dt.c这个驱动。这样只需要在CPU节点上填充好频率电压表，然后在平台代码里面注册cpufreq-dt设备就可以了，在arch/arm/mach-imx/imx27-dt.c、arch/arm/mach-imx/mach-imx51.c中可以找到类似的例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void __init imx27_dt_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct platform_device_info devinfo = { .name = &quot;cpufreq-dt&quot;, };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       platform_device_register_full(&amp;devinfo);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.529Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->11 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>对于包含MMU的处理器而言，Linux系统提供了复杂的存储管理系统，使得进程所能访问的内存达到4GB。</p><p>在Linux系统中，进程的4GB内存空间被分为两个部分——用户空间与内核空间。用户空间的地址一般分布为0~3GB（即PAGE_OFFSET，在0x86中它等于0xC0000000），这样，剩下的3~4GB为内核空间，如图11.5所示。用户进程通常只能访问用户空间的虚拟地址，不能访问内核空间的虚拟地址。用户进程只有通过系统调用（代表用户进程在内核态执行）等方式才可以访问到内核空间</p><p><img loading="lazy" alt="1743604956112" src="/assets/images/1743604956112-140ff33629bf7e977222fd38161b672f.png" width="795" height="222" class="img_ev3q"></p><p>图11.5　用户空间与内核空间</p><p>每个进程的用户空间都是完全独立、互不相干的，用户进程各自有不同的页表。而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间的虚拟地址到物理地址映射是被所有进程共享的，内核的虚拟空间独立于其他程序。</p><p>Linux中1GB的内核地址空间又被划分为物理内存映射区、虚拟内存分配区、高端页面映射区、专用页面映射区和系统保留映射区这几个区域，如图11.6所示。</p><p><img loading="lazy" alt="1743604985909" src="/assets/images/1743604985909-ee139486a79cb2b1744f92aff2970089.png" width="1177" height="625" class="img_ev3q"></p><p>图11.6　32位x86系统Linux内核的地址空间</p><p>对于x86系统而言，一般情况下，物理内存映射区最大长度为896MB，系统的物理内存被顺序映射在内核空间的这个区域中。当系统物理内存大于896MB时，超过物理内存映射区的那部分内存称为高端内存（而未超过物理内存映射区的内存通常被称为常规内存），内核在存取高端内存时必须将它们映射到高端页面映射区。</p><p>Linux保留内核空间最顶部FIXADDR_TOP~4GB的区域作为保留区。</p><p>紧接着最顶端的保留区以下的一段区域为专用页面映射区（FIXADDR_START~FIXADDR_TOP），它的总尺寸和每一页的用途由fixed_address枚举结构在编译时预定义，用__fix_to_virt（index）可获取专用区内预定义页面的逻辑地址。其开始地址和结束地址宏定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define FIXADDR_START       (FIXADDR_TOP - _ _FIXADDR_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define FIXADDR_TOP       ((unsigned long)_ _FIXADDR_TOP)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define _ _FIXADDR_TOP    0xfffff000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接下来，如果系统配置了高端内存，则位于专用页面映射区之下的就是一段高端内存映射区，其起始地址为PKMAP_BASE，定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define PKMAP_BASE ( (FIXADDR_BOOT_START - PAGE_SIZE*(LAST_PKMAP + 1)) &amp; PMD_MASK )</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中所涉及的宏定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define FIXADDR_BOOT_START    (FIXADDR_TOP - _ _FIXADDR_BOOT_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define LAST_PKMAP    PTRS_PER_PTE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTRS_PER_PTE    512</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PMD_MASK    (~(PMD_SIZE-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># define PMD_SIZE    (1UL &lt;&lt; PMD_SHIFT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PMD_SHIFT    21</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在物理区和高端映射区之间为虚拟内存分配器区（VMALLOC_START~VMALLOC_END），用于vmalloc（）函数，它的前部与物理内存映射区有一个隔离带，后部与高端映射区也有一个隔离带，vmalloc区域定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define VMALLOC_OFFSET (8*1024*1024)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define VMALLOC_START    (((unsigned long) high_memory +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vmalloc_earlyreserve + 2*VMALLOC_OFFSET-1) &amp; ~(VMALLOC_OFFSET-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_HIGHMEM    /* 支持高端内存*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># define VMALLOC_END    (PKMAP_BASE-2*PAGE_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#else                    /* 不支持高端内存*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># define VMALLOC_END    (FIXADDR_START-2*PAGE_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当系统物理内存超过4GB时，必须使用CPU的扩展分页（PAE）模式所提供的64位页目录项才能存取到4GB以上的物理内存，这需要CPU的支持。加入了PAE功能的Intel Pentium Pro及以后的CPU允许内存最大可配置到64GB，它们具备36位物理地址空间寻址能力。</p><p>由此可见，对于32位的x86而言，在3~4GB之间的内核空间中，从低地址到高地址依次为：物理内存映射区→隔离带→vmalloc虚拟内存分配器区→隔离带→高端内存映射区→专用页面映射区→保留区。</p><p>直接进行映射的896MB物理内存其实又分为两个区域，在低于16MB的区域，ISA设备可以做DMA，所以该区域为DMA区域（内核为了保证ISA驱动在申请DMA缓冲区的时候，通过GFP_DMA标记可以确保申请到16MB以内的内存，所以必须把这个区域列为一个单独的区域管理）；16MB~896MB之间的为常规区域。高于896MB的就称为高端内存区域了</p><p>32位ARM Linux的内核空间地址映射与x86不太一样，内核文档Documentation/arm/memory.txt给出了ARM Linux的内存映射情况。0xffff0000~0xffff0fff是“CPU vector page”，即向量表的地址。0xffc00000~0xffefffff是DMA内存映射区域，dma_alloc_xxx族函数把DMA缓冲区映射在这一段，VMALLOC_START~VMALLOC_END-1是vmalloc和ioremap区域（在vmalloc区域的大小可以配置，通过“vmalloc=”这个启动参数可以指定），PAGE_OFFSET~high_memory-1是DMA和正常区域的映射区域，MODULES_VADDR~MODULES_END-1是内核模块区域，PKMAP_BASE~PAGE_OFFSET-1是高端内存映射区。假设我们把PAGE_OFFSET定义为3GB，实际上Linux内核模块位于3GB-16MB~3GB-2MB，高端内存映射区则通常位于3GB-2MB~3GB。</p><p>图11.7给出了32位ARM系统Linux内核地址空间中的内核模块区域、高端内存映射区、vmalloc、向量表区域等。我们假定编译内核的时候选择的是VMSPLIT_3G（3G/1G user/kernel split）。如果用户选择的是VMSPLIT_2G（2G/2G user/kernel split），则图11.7中的内核模块开始于2GB-16MB，DMA和常规内存区域映射区也开始于2GB。</p><p><img loading="lazy" alt="1743605207309" src="/assets/images/1743605207309-de0133d3768b87e3baf34cfa548ec3a9.png" width="1089" height="696" class="img_ev3q"></p><p>图11.7　32位ARM系统中Linux内核的地址空间</p><p>ARM系统的Linux之所以把内核模块安置在3GB或者2GB附近的16MB范围内，主要是为了实现内核模块和内核本身的代码段之间的短跳转</p><p>对于ARM SoC而言，如果芯片内部有的硬件组件的DMA引擎访问内存时有地址空间限制（某些空间访问不到），比如假设UART控制器的DMA只能访问32MB，那么这个低32MB就是DMA区域；32MB到高端内存地址的这段称为常规区域；再之上的称为高端内存区域。</p><p>图11.8给出了几种DMA、常规、高端内存区域可能的分布，在第一种情况下，有硬件的DMA引擎不能访问全部地址，且内存较大而无法全部在内核空间虚拟地址映射下，存放有3个区域；第二种情况下，没有硬件的DMA引擎不能访问全部地址，且内存较大而无法全部在内核空间虚拟地址映射下，则常规区域实际退化为0；第三种情况下，有硬件的DMA引擎不能访问全部地址，且内存较小可以全部在内核空间虚拟地址映射下，则高端内存区域实际退化为0；第四种情况下，没有硬件的DMA引擎不能访问全部地址，且内存较小可以全部在内核空间虚拟地址映射下，则常规和高端内存区域实际退化为0</p><p><img loading="lazy" alt="image-20250402224805017" src="/assets/images/image-20250402224805017-f29f2403941489bc3f9f6a5c653995c0.png" width="1299" height="478" class="img_ev3q"></p><p>图11.8　DMA、常规、高端内存区域分布</p><p>如图11.9所示，DMA、常规、高端内存这3个区域都采用buddy算法进行管理，把空闲的页面以2的n次方为单位进行管理，因此Linux最底层的内存申请都是以2n 为单位的。Buddy算法最主要的优点是避免了外部碎片，任何时候区域里的空闲内存都能以2的n次方进行拆分或合并。</p><p><img loading="lazy" alt="image-20250402224832312" src="/assets/images/image-20250402224832312-60d33e7facd2c06724b609c1efa6caa6.png" width="772" height="682" class="img_ev3q"></p><p>图11.9　buddy算法</p><p>/proc/buddyinfo会显示每个区域里面2n的空闲页面分布情况，比如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$cat /proc/buddyinfo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node 0, zone      DMA      8      5      2      7      8      3      0      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0      1      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Node 0, zone   Normal   2002   1252    524    187    183     71      7      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0      1      1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述结果显示高端内存区域为0，DMA区域里1页空闲的内存还有8个，连续2页空闲的有5个，连续4页空闲的有2个，以此类推；常规区域里面1页空闲的还有2002个，连续2页空闲的有1252个，以此类推。</p><p>对于内核物理内存映射区的虚拟内存（即从DMA和常规区域映射过来的），使用virt_to_phys（）可以实现内核虚拟地址转化为物理地址。与之对应的函数为phys_to_virt（），它将物理地址转化为内核虚拟地址。</p><p>注意： 上述virt_to_phys（）和phys_to_virt（）方法仅适用于DMA和常规区域，高端内存的虚拟地址与物理地址之间不存在如此简单的换算关系。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.517Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux直接提供了对KGDB的支持，KGDB采用了典型的嵌入式系统“插桩”技巧，一般依赖于串口与调试主机通信。为了支持KGDB，串口驱动应该实现纯粹的轮询收发单一字符的成员函数，以供drivers/tty/serial/kgdboc.c调用，譬如drivers/tty/serial/8250/8250_core.c中的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct uart_ops serial8250_pops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_CONSOLE_POLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .poll_get_char = serial8250_get_poll_char,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .poll_put_char = serial8250_put_poll_char,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在编译内核时，运行make ARCH=arm menuconfig时需选择关于KGDB的编译项目，如图21.6所示。</p><p><img loading="lazy" alt="1747579229228" src="/assets/images/1747579229228-8b5af0f3c3f97682c4af110bb54e0bd4.png" width="1338" height="712" class="img_ev3q"></p><p>图21.6　KGDB编译选项配置</p><p>对于目标板而言，需要在bootargs中设置与KGDB对应的串口等信息，如kgdboc=ttyS0，115200kgdbcon。</p><p>如果想一开机内核就直接进入等待GDB连接的调试状态，可以在bootargs中设置kgdbwait，kgdbwait的含义是启动时就等待主机的GDB连接。而若想在内核启动后进入GDB调试模式，可运行echo g&gt;/proc/sysrq_trigger命令给内核传入一个键值是g的magic_sysrq。</p><p>在调试PC上，依次运行如下命令就可以启动调试并连接至目标机（假设串口在PC上对应的设备节点是/dev/ttyS0）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># arm-eabi-gdb ./vmlinux</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set remotebaud 115200</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) target remote /dev/ttyS0                              //连接目标机</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之后，在主机上，我们可以使用GDB像调试应用程序一样调试使能了KGDB的目标机上的内核。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.497Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>devfs（设备文件系统）是由Linux 2.4内核引入的，引入时被许多工程师给予了高度评价，它的出现使得设备驱动程序能自主地管理自己的设备文件。具体来说，devfs具有如下优点。</p><p>1）可以通过程序在设备初始化时在/dev目录下创建设备文件，卸载设备时将它删除。</p><p>2）设备驱动程序可以指定设备名、所有者和权限位，用户空间程序仍可以修改所有者和权限位。</p><p>3）不再需要为设备驱动程序分配主设备号以及处理次设备号，在程序中可以直接给register_chrdev（）传递0主设备号以获得可用的主设备号，并在devfs_register（）中指定次设备号。</p><p>驱动程序应调用下面这些函数来进行设备文件的创建和撤销工作。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* 创建设备目录*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">devfs_handle_t devfs_mk_dir(devfs_handle_t dir, const char *name, void *info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 创建设备文件*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">devfs_handle_t devfs_register(devfs_handle_t dir, const char *name, unsigned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   int flags, unsigned int major, unsigned int minor, umode_t mode, void *ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   void *info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 撤销设备文件 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void devfs_unregister(devfs_handle_t de);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux 2.4的设备驱动编程中，分别在模块加载、卸载函数中创建和撤销设备文件是被普遍采用并值得大力推荐的好方法。代码清单5.5给出了一个使用devfs的范例。</p><p>代码清单5.5　devfs的使用范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 static devfs_handle_t devfs_handle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 static int _ _init xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4     int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5     int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6     /* 在内核中注册设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7     ret = register_chrdev(XXX_MAJOR, DEVICE_NAME, &amp;xxx_fops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8     if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         printk(DEVICE_NAME &quot; can&#x27;t register major number\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     /* 创建设备文件*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     devfs_handle =devfs_register(NULL, DEVICE_NAME, DEVFS_FL_DEFAULT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14     XXX_MAJOR, 0, S_IFCHR | S_IRUSR | S_IWUSR, &amp;xxx_fops, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16     printk(DEVICE_NAME &quot; initialized\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 static void _ _exit xxx_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22     devfs_unregister(devfs_handle);             /* 撤销设备文件*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     unregister_chrdev(XXX_MAJOR, DEVICE_NAME);  /* 注销设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 module_init(xxx_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 module_exit(xxx_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码中第7行和第23行分别用于注册和注销字符设备，使用的register_chrdev（）和unregister_chrdev（）在Linux 2.6以后的内核中仍被采用。第13和22行分别用于创建和删除devfs文件节点，这些API已经被删除了。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.493Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->14 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>软件意义上的定时器最终依赖硬件定时器来实现，内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部执行。实质上，时钟中断处理程序会唤起TIMER_SOFTIRQ软中断，运行当前处理器上到期的所有定时器。</p><p>在Linux设备驱动编程中，可以利用Linux内核中提供的一组函数和数据结构来完成定时触发工作或者完成某周期性的事务。这组函数和数据结构使得驱动工程师在多数情况下不用关心具体的软件定时器究竟对应着怎样的内核和硬件行为。</p><p>Linux内核所提供的用于操作定时器的数据结构和函数如下。</p><p>1.timer_list</p><p>在Linux内核中，timer_list结构体的一个实例对应一个定时器，如代码清单10.9所示。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct timer_list {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         * All fields that change during normal runtime grouped to the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         * same cacheline</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        struct list_head entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        unsigned long expires;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        struct tvec_base *base;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        void (*function)(unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        unsigned long data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int slack;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15#ifdef CONFIG_TIMER_STATS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int start_pid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        void *start_site;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        char start_comm[16];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20#ifdef CONFIG_LOCKDEP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        struct lockdep_map lockdep_map;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当定时器期满后，其中第10行的function（）成员将被执行，而第11行的data成员则是传入其中的参数，第7行的expires则是定时器到期的时间（jiffies）。</p><p>如下代码定义一个名为my_timer的定时器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct timer_list my_timer;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.初始化定时器</p><p>init_timer是一个宏，它的原型等价于：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void init_timer(struct timer_list * timer);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述init_timer（）函数初始化timer_list的entry的next为NULL，并给base指针赋值。</p><p>TIMER_INITIALIZER（_function，_expires，_data）宏用于赋值定时器结构体的function、expires、data和base成员，这个宏等价于：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define TIMER_INITIALIZER(_function, _expires, _data) {        \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      .entry = { .prev = TIMER_ENTRY_STATIC }, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      .function = (_function),                 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      .expires = (_expires),                   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      .data = (_data),                         \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      .base = &amp;boot_tvec_bases,                \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>DEFINE_TIMER（_name，_function，_expires，_data）宏是定义并初始化定时器成员的“快捷方式”，这个宏定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define DEFINE_TIMER(_name, _function, _expires, _data)\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              struct timer_list _name =\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            TIMER_INITIALIZER(_function, _expires, _data)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此外，setup_timer（）也可用于初始化定时器并赋值其成员，其源代码为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define __setup_timer(_timer, _fn, _data, _flags)               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {                                                    \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                __init_timer((_timer), (_flags));               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (_timer)-&gt;function = (_fn);                     \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (_timer)-&gt;data = (_data);                       \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } while (0)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3.增加定时器</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void add_timer(struct timer_list * timer);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数用于注册内核定时器，将定时器加入到内核动态定时器链表中。</p><p>4.删除定时器</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int del_timer(struct timer_list * timer);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数用于删除定时器。</p><p>del_timer_sync（）是del_timer（）的同步版，在删除一个定时器时需等待其被处理完，因此该函数的调用不能发生在中断上下文中。</p><p>5.修改定时器的expire</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int mod_timer(struct timer_list *timer, unsigned long expires);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数用于修改定时器的到期时间，在新的被传入的expires到来后才会执行定时器函数。</p><p>代码清单10.10给出了一个完整的内核定时器使用模板，在大多数情况下，设备驱动都如这个模板那样使用定时器。</p><p>代码清单10.10　内核定时器使用模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* xxx设备结构体*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2struct xxx_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  struct cdev cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  timer_list xxx_timer;      /* 设备要使用的定时器 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8/* xxx驱动中的某函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9xxx_func1(…)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  struct xxx_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  /* 初始化定时器*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  init_timer(&amp;dev-&gt;xxx_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  dev-&gt;xxx_timer.function = &amp;xxx_do_timer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  dev-&gt;xxx_timer.data = (unsigned long)dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                      /* 设备结构体指针作为定时器处理函数参数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  dev-&gt;xxx_timer.expires = jiffies + delay;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  /* 添加（注册）定时器*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  add_timer(&amp;dev-&gt;xxx_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24/* xxx驱动中的某函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25xxx_func2(…)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  /* 删除定时器 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  del_timer (&amp;dev-&gt;xxx_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33/* 定时器处理函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34static void xxx_do_timer(unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36  struct xxx_device *dev = (struct xxx_device *)(arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38  /* 调度定时器再执行*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39  dev-&gt;xxx_timer.expires = jiffies + delay;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40  add_timer(&amp;dev-&gt;xxx_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从代码清单第18、39行可以看出，定时器的到期时间往往是在目前jiffies的基础上添加一个时延，若为Hz，则表示延迟1s。</p><p>在定时器处理函数中，在完成相应的工作后，往往会延后expires并将定时器再次添加到内核定时器链表中，以便定时器能再次被触发。</p><p>此外，Linux内核支持tickless和NO_HZ模式后，内核也包含对hrtimer（高精度定时器）的支持，它可以支持到微秒级别的精度。内核也定义了hrtimer结构体，hrtimer_set_expires（）、hrtimer_start_expires（）、hrtimer_forward_now（）、hrtimer_restart（）等类似的API来完成hrtimer的设置、时间推移以及到期回调。我们可以从sound/soc/fsl/imx-pcm-fiq.c中提取出一个使用范例，如代码清单10.11所示。</p><p>代码清单10.11　内核高精度定时器（hrtimer）使用模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        hrtimer_forward_now(hrt, ns_to_ktime(iprtd-&gt;poll_time_ns));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        return HRTIMER_RESTART;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10static int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        struct snd_pcm_runtime *runtime = substream-&gt;runtime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        struct imx_pcm_runtime_data *iprtd = runtime-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        switch (cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        case SNDRV_PCM_TRIGGER_START:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        case SNDRV_PCM_TRIGGER_RESUME:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                hrtimer_start(&amp;iprtd-&gt;hrt, ns_to_ktime(iprtd-&gt;poll_time_ns),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                      HRTIMER_MODE_REL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25static int snd_imx_open(struct snd_pcm_substream *substream)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        hrtimer_init(&amp;iprtd-&gt;hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        iprtd-&gt;hrt.function = snd_hrtimer_callback;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34static int snd_imx_close(struct snd_pcm_substream *substream)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        hrtimer_cancel(&amp;iprtd-&gt;hrt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第28~29行在声卡打开的时候通过hrtimer_init（）初始化了hrtimer，并指定回调函数为snd_hrtimer_callback（）；在启动播放（第15~21行SNDRV_PCM_TRIGGER_START）等时刻通过hrtimer_start（）启动了hrtimer；iprtd-&gt;poll_time_ns纳秒后，时间到snd_hrtimer_callback（）函数在中断上下文被执行，它紧接着又通过hrtimer_forward_now（）把hrtimer的时间前移了iprtd-&gt;poll_time_ns纳秒，这样周而复始；直到声卡被关闭，第37行又调用了hrtimer_cancel（）取消在open时初始化的hrtimer。</p><h1>10.5.2　内核中延迟的工作delayed_work</h1><p>对于周期性的任务，除了定时器以外，在Linux内核中还可以利用一套封装得很好的快捷机制，其本质是利用工作队列和定时器实现，这套快捷机制就是delayed_work，delayed_work结构体的定义如代码清单10.12所示。</p><p>代码清单10.12　delayed_work结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct delayed_work {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2        struct work_struct work;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3        struct timer_list timer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5        /* target workqueue and CPU -&gt;timer uses to queue -&gt;work */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6        struct workqueue_struct *wq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7        int cpu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们可以通过如下函数调度一个delayed_work在指定的延时后执行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int schedule_delayed_work(struct delayed_work *work, unsigned long delay);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当指定的delay到来时，delayed_work结构体中的work成员work_func_t类型成员func（）会被执行。work_func_t类型定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef void (*work_func_t)(struct work_struct *work);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中，delay参数的单位是jiffies，因此一种常见的用法如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">schedule_delayed_work(&amp;work, msecs_to_jiffies(poll_interval));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>msecs_to_jiffies（）用于将毫秒转化为jiffies。</p><p>如果要周期性地执行任务，通常会在delayed_work的工作函数中再次调用schedule_delayed_work（），周而复始。</p><p>如下函数用来取消delayed_work：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int cancel_delayed_work(struct delayed_work *work);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int cancel_delayed_work_sync(struct delayed_work *work);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>10.5.3　实例：秒字符设备</h1><p>下面我们编写一个字符设备“second”（即“秒”）的驱动，它在被打开的时候初始化一个定时器并将其添加到内核定时器链表中，每秒输出一次当前的jiffies（为此，定时器处理函数中每次都要修改新的expires），整个程序如代码清单10.13所示。</p><p>代码清单10.13　使用内核定时器的second字符设备驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  1#include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2#include &lt;linux/fs.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  3#include &lt;linux/mm.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4#include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5#include &lt;linux/cdev.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  6#include &lt;linux/slab.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  7#include &lt;linux/uaccess.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  9#define SECOND_MAJOR 248</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 11static int second_major = SECOND_MAJOR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 12module_param(second_major, int, S_IRUGO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 14struct second_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 15    struct cdev cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 16    atomic_t counter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 17    struct timer_list s_timer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 18};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 20static struct second_dev *second_devp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 22static void second_timer_handler(unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 23{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 24 mod_timer(&amp;second_devp-&gt;s_timer, jiffies + HZ);  /* 触发下一次定时*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25 atomic_inc(&amp;second_devp-&gt;counter);               /* 增加秒计数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 27 printk(KERN_INFO &quot;current jiffies is %ld\n&quot;, jiffies);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 28}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 30static int second_open(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 31{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 32 init_timer(&amp;second_devp-&gt;s_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 33 second_devp-&gt;s_timer.function = &amp;second_timer_handler;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 34 second_devp-&gt;s_timer.expires = jiffies + HZ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 36 add_timer(&amp;second_devp-&gt;s_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 38 atomic_set(&amp;second_devp-&gt;counter, 0);            /* 初始化秒计数为0 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 40 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 41}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 43static int second_release(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 44{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 45 del_timer(&amp;second_devp-&gt;s_timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 47 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 48}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 50static ssize_t second_read(struct file *filp, char __user * buf, size_t count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 51 loff_t * ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 52{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 53 int counter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 55 counter = atomic_read(&amp;second_devp-&gt;counter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 56 if (put_user(counter, (int *)buf))/* 复制counter到userspace */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 57     return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 58 else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 59   return sizeof(unsigned int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 60}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 61</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 62static const struct file_operations second_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 63 .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 64 .open = second_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 65 .release = second_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 66 .read = second_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 67};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 68</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 69static void second_setup_cdev(struct second_dev *dev, int index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 70{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 71 int err, devno = MKDEV(second_major, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 72</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 73 cdev_init(&amp;dev-&gt;cdev, &amp;second_fops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 74 dev-&gt;cdev.owner = THIS_MODULE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 75 err = cdev_add(&amp;dev-&gt;cdev, devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 76 if (err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 77     printk(KERN_ERR &quot;Failed to add second device\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 78}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 79</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 80static int __init second_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 81{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 82 int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 83 dev_t devno = MKDEV(second_major, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 84</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 85 if (second_major)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 86     ret = register_chrdev_region(devno, 1, &quot;second&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 87 else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 88     ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;second&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 89     second_major = MAJOR(devno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 90 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 91 if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 92     return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 93</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 94 second_devp = kzalloc(sizeof(*second_devp), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 95 if (!second_devp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 96     ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 97     goto fail_malloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 98 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 99</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100 second_setup_cdev(second_devp, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">101</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">102 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">103</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">104fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">105 unregister_chrdev_region(devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">106 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">107}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">108module_init(second_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">109</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">110static void __exit second_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">111{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">112 cdev_del(&amp;second_devp-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">113 kfree(second_devp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">114 unregister_chrdev_region(MKDEV(second_major, 0), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">115}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">116module_exit(second_exit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">117</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">118MODULE_AUTHOR(&quot;Barry Song &lt;21cnbao@gmail.com&gt;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">119MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在second的open（）函数中，将启动定时器，此后每1s会再次运行定时器处理函数，在second的release（）函数中，定时器被删除。</p><p>second_dev结构体中的原子变量counter用于秒计数，每次在定时器处理函数中调用的atomic_inc（）会令其原子性地增1，second的read（）函数会将这个值返回给用户空间。</p><p>本书配套的Ubuntu中/home/baohua/develop/training/kernel/drivers/second/包含了second设备驱动以及second_test.c用户空间测试程序，运行make命令编译得到second.ko和second_test，加载second.ko内核模块并创建/dev/second设备文件节点：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># mknod /dev/second c 248 0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单10.14给出了second_test.c这个应用程序，它打开/dev/second，其后不断地读取自/dev/second设备文件打开以后经历的秒数。</p><p>代码清单10.14　second设备用户空间测试程序</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#include ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  int fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  int counter = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  int old_counter = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  /* 打开/dev/second设备文件*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  fd = open(&quot;/dev/second&quot;, O_RDONLY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  if (fd != - 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      while (1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         read(fd,&amp;counter, sizeof(unsigned int));/* 读目前经历的秒数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16         if(counter!=old_counter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18            printf(&quot;seconds after open /dev/second :%d\n&quot;,counter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19               old_counter = counter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20          }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      printf(&quot;Device open failure\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>运行second_test后，内核将不断地输出目前的jiffies值</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[13935.122093] current jiffies is 13635122</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13936.124441] current jiffies is 13636124</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13937.126078] current jiffies is 13637126</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13952.832648] current jiffies is 13652832</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13953.834078] current jiffies is 13653834</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13954.836090] current jiffies is 13654836</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13955.838389] current jiffies is 13655838</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[13956.840453] current jiffies is 13656840</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上述内核的打印消息也可以看出，本书配套Ubuntu上的每秒jiffies大概走1000次。而应用程序将不断输出自/dec/second打开以后经历的秒数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># ./second_test</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">seconds after open /dev/second :1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">seconds after open /dev/second :2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">seconds after open /dev/second :3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">seconds after open /dev/second :4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">seconds after open /dev/second :5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.481Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核的PM框架涉及众多组件，弄清楚这些组件之间的依赖关系，在合适的着眼点上进行优化，采用正确的方法进行PM的编程，对改善代码的质量、辅助功耗和性能测试都有极大的好处。</p><p>另外，在实际工程中，尤其是在消费电子的领域，可能有超过半数的bug都属于电源管理。这个时候，电源管理的很多工作就是在搞定鲁棒性和健壮性，可以说，在很多时候，这就是个体力活，需要工程师有足够的耐性。</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/9"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/11"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>