<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/12"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/12"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/12" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/12" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.389Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在ARM Linux领域，目前比较主流的是采用ARM DS-5Development Studio方案。ARM DS-5是一个针对基于Linux的系统和裸机嵌入式系统的专业软件开发解决方案，它涵盖了开发的所有阶段，从启动代码、内核移植直到应用程序调试、分析。如图21.7所示，它使用了DSTREAM高性能仿真器（ARM已经停止更新RVI-RVT2仿真器），在Eclipse内包含了DS-5和DSTREAM的开发插件。</p><p>调试主机一般通过网线与DSTREAM仿真器连接，而仿真器则连接与电路板类似的JTAG接口，之后用DS-5调试器进行调试。DS-5图形化调试器提供了全面和直观的调试图，非常易于调试Linux和裸机程序，易于查看代码，进行栈回溯，查看内存、寄存器、表达式、变量，分析内核线程，设置断点。</p><p><img loading="lazy" alt="1747579318890" src="/assets/images/1747579318890-4d62537ce727f9ad86e25be15f4c99ea.png" width="1473" height="679" class="img_ev3q"></p><p>图21.7　DSTREAM仿真器和DS-5开发环境</p><p>值得一提的是，DS-5也提供了Streamline Performance Analyzer。ARM Streamline性能分析器（见图21.8）为软件开发人员提供了一种用来分析和优化在ARM926、ARM11和Cortex-A系列平台上运行的Linux和Android系统的直观方法。使用Streamline，Linux内核中需包含一个gator模块，用户空间则需要使能gatord后台服务器程序。关于Streamline具体的操作方法可以查看《ARM® DS-5Using ARM Streamline》。</p><p><img loading="lazy" alt="1747579344368" src="/assets/images/1747579344368-0134963fefbf625bb9c59828e7f1e16e.png" width="1488" height="856" class="img_ev3q"></p><p>图21.8　ARMStreamline性能分析器</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.377Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->6 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux的编程中，通常使用GNU工具链编译Bootloader、内核和应用程序。GNU组织维护了GCC、GDB、glibc、Binutils等，分别见于<a href="https://gcc.gnu.org/" target="_blank" rel="noopener noreferrer">https://gcc.gnu.org/</a> ，<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener noreferrer">https://www.gnu.org/software/gdb/</a> ，<a href="https://www.gnu.org/software/libc/" target="_blank" rel="noopener noreferrer">https://www.gnu.org/software/libc/</a> 、<a href="https://www.gnu.org/software/binutils/" target="_blank" rel="noopener noreferrer">https://www.gnu.org/software/binutils/</a> 。</p><p>建立交叉工具链的过程相当烦琐，一般可以通过类似crosstool-ng这样的工具来做。crosstool-ng也采用了与内核相似的menuconfig配置方法。在官网<a href="http://www.crosstool-ng.org/" target="_blank" rel="noopener noreferrer">http://www.crosstool-ng.org/</a> 上下载crosstool-ng的源代码并编译安装后，运行ct-ng menuconfig，会出现如图3.12的配置菜单。在里面我们可以选择目标机处理器型号，支持的内核版本号等。</p><p><img loading="lazy" alt="1742740211566" src="/assets/images/1742740211566-121f583c22b586c384a5f2eac180b844.png" width="1114" height="516" class="img_ev3q"></p><p>图3.12　crosstool-ng的配置菜单</p><p>当然，也可以直接下载第三方编译好的、开放的、针对目标处理器的交叉工具链，如在<a href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/" target="_blank" rel="noopener noreferrer">http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/</a> 上可以下载针对ARM、MIPS、高通Hexagon、Altera Nios II、Intel、AMD64等处理器的工具链，在<a href="http://www.linaro.org/downloads/" target="_blank" rel="noopener noreferrer">http://www.linaro.org/downloads/</a> 可以下载针对ARM的工具链。</p><p>目前，在ARM Linux的开发中，人们趋向于使用Linaro（<a href="http://www.linaro.org/" target="_blank" rel="noopener noreferrer">http://www.linaro.org/</a> ）工具链团队维护的ARM工具链，它以每月一次的形式发布新的版本，编译好的可执行文件可从网址<a href="http://www.linaro.org/downloads/" target="_blank" rel="noopener noreferrer">http://www.linaro.org/downloads/</a> 下载。Linaro是ARM Linux领域中最著名最具技术成就的开源组织，其会员包括ARM、Broadcom、Samsung、TI、Qualcomm等，国内的海思、中兴、全志和中国台湾的MediaTek也是它的会员。</p><p>一个典型的ARM Linux工具链包含arm-linux-gnueabihf-gcc（后续工具省略前缀）、strip、gcc、objdump、ld、gprof、nm、readelf、addr2line等。用strip可以删除可执行文件中的符号表和调试信息等来实现缩减程序体积的目的。gprof在编译过程中在函数入口处插入计数器以收集每个函数的被调用情况和被调用次数，检查程序计数器并在分析时找出与程序计数器对应的函数来统计函数占用的时间。objdump是反汇编工具。nm则用于显示关于对象文件、可执行文件以及对象文件库里的符号信息。其中，前缀中的“hf”显示该工具链是完全的硬浮点，由于目前主流的ARM芯片都自带VFP或者NEON等浮点处理单元（FPU），所以对硬浮点的需求就更加强烈。Linux的浮点处理可以采用完全软浮点，也可以采用与软浮点兼容，但是使用FPU硬件的softfp，以及完全硬浮点。具体的ABI（Application Binary Interface，应用程序二进制接口）通过-mfloat-abi=参数指定，3种情况下的参数分别是-mfloat-abi=soft/softfp/hard。</p><p>在以前，主流的工具链采用“与软浮点兼容，但是使用FPU硬件的softfp”。softfp使用了硬件的FPU，但是函数的参数仍然使用整型寄存器来传递，完全硬浮点则直接使用FPU的寄存器传递参数。</p><p>下面一段程序：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">float mul(float a, float b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return a * b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        printf(&quot;1.1 * 2.3 = %f\n&quot;, mul(1.1, 2.3));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对其使用arm-linux-gnueabihf-gcc编译并反汇编的结果是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">000 08394 &lt;mul&gt;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8394: b480        push  {r7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8396: b083        sub  sp, #12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8398: af00        add  r7, sp, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  839a: ed87 0a01</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vstr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s0, [r7, #4](null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">839e: edc7 0a00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vstr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s1, [r7]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83a2: ed97 7a01   vldr  s14, [r7, #4](null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83a6: edd7 7a00   vldr  s15, [r7]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83aa: ee67 7a27   vmul.f32  s15, s14, s15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83ae: eeb0 0a67   vmov.f32  s0, s15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b2: f107 070c   add.w  r7, r7, #12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b6: 46bd        mov  sp, r7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b8: bc80        pop  {r7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83ba: 4770        bxlr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000 83bc &lt;main&gt;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83bc: b580        push  {r7, lr}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83be: af00        add  r7, sp, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   83c0: ed9f 0a09</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vldr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s0, [pc, #36](null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 83e8 &lt;main+0x2c&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83c4: eddf 0a09</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vldr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">s1, [pc, #36](null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; 83ec &lt;main+0x30&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83c8: f7ff ffe4   b8394 &lt;mul&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83cc: eef0 7a40   vmov.f32  s15, s0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83d0: eeb7 7ae7   vcvt.f64.f32  d7, s15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83d4: f248 4044   movw  r0, #33860  ; 0x8444</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83d8: f2c0 0000   movt  r0, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83dc: ec53 2b17   vmov  r2, r3, d7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83e0: f7ff ef82   blx  82e8 &lt;_init+0x20&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83e4: bd80        pop  {r7, pc}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83e6: bf00        nop</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而使用没有“hf”前缀的arm-linux-gnueabi-gcc编译并反汇编的结果则为</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">000 0838c &lt;mul&gt;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     838c: b480        push  {r7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     838e: b083        sub  sp, #12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     8390: af00        add  r7, sp, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8392: 6078        str  r0, [r7, #4]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8394: 6039        str  r1, [r7, #0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8396: ed97 7a01   vldr  s14, [r7, #4](null)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">839a: edd7 7a00   vldr  s15, [r7]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     839e: ee67 7a27   vmul.f32  s15, s14, s15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83a2: ee17 3a90   vmov  r3, s15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83a6: 4618        mov  r0, r3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83a8: f107 070c   add.w  r7, r7, #12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83ac: 46bd        mov  sp, r7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83ae: bc80        pop  {r7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b0: 4770        bxlr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b2: bf00        nop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">000 083b4 &lt;main&gt;:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b4: b580        push  {r7, lr}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83b6: af00        add  r7, sp, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   83b8: 4808        ldr  r0, [pc, #32]  ; (83dc &lt;main+0x28&gt;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83ba: 4909        ldr  r1, [pc, #36]  ; (83e0 &lt;main+0x2c&gt;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83bc: f7ff ffe6   bl  838c &lt;mul&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83c0: ee07 0a90   vmov  s15, r0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83c4: eeb7 7ae7   vcvt.f64.f32  d7, s15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83c8: f248 4038   movwr0, #33848; 0x8438</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83cc: f2c0 0000   movtr0, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83d0: ec53 2b17   vmovr2, r3, d7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83d4: f7ff ef84   blx  82e0 &lt;_init+0x20&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83d8: bd80        pop  {r7, pc}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     83da: bf00        nop</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>关注其中加粗的行，可以看出前面的汇编使用s0和s1传递参数，后者则仍然使用ARM的r0和r1。测试显示一个含有浮点运算的程序若使用hard ABI会比softfp ABI快5%~40%，如果浮点负载重，结果可能会快200%以上</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.365Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->22 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具，GDB主要可帮助工程师完成下面4个方面的功能。</p><ul><li>·启动程序，可以按照工程师自定义的要求运行程序。</li><li>·让被调试的程序在工程师指定的断点处停住，断点可以是条件表达式。</li><li>·当程序被停住时，可以检查此时程序中所发生的事，并追踪上文。</li><li>·动态地改变程序的执行环境。</li></ul><p>不管是调试Linux内核空间的驱动还是调试用户空间的应用程序，都必须掌握GDB的用法。而且，在调试内核和调试应用程序时使用的GDB命令是完全相同的，下面以代码清单21.1的应用程序为例演示GDB调试器的用法。</p><p>代码清单21.1　GDB调试器用法的演示程序</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int add(int a, int b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int sum[10] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  0, 0, 0, 0, 0, 0, 0, 0, 0, 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 int array1[10] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  48, 56, 77, 33, 33, 11, 226, 544, 78, 90</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 int array2[10] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  sum[i] = add(array1[i], array2[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用命令gcc–g gdb_example.c–o gdb_example编译上述程序，得到包含调试信息的二进制文件example，执行gdb gdb_example命令进入调试状态，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ gdb gdb_example</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GNU gdb (Ubuntu 7.7-0ubuntu3.1) 7.7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Copyright (C) 2014 Free Software Foundation, Inc.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This is free software: you are free to change and redistribute it.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">and &quot;show warranty&quot; for details.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This GDB was configured as &quot;i686-linux-gnu&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Type &quot;show configuration&quot; for configuration details.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For bug reporting instructions, please see:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Find the GDB manual and other documentation resources online at:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For help, type &quot;help&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1list命令">1.list命令<a class="hash-link" href="#1list命令" title="标题的直接链接">​</a></h2><p>在GDB中运行list命令（缩写l）可以列出代码，list的具体形式如下。</p><p>·list  linenum，显示程序第linenum行周围的源程序，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) list 15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       int array1[10] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         48, 56, 77, 33, 33, 11, 226, 544, 78, 90</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       int array2[10] =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         85, 99, 66, 0x199, 393, 11, 1, 2, 3, 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>·list  function，显示函数名为function的函数的源程序，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) list main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3      return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6    main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8      int sum[10];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9      int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     int array1[10] =</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>·list，显示当前行后面的源程序。</p><p>·list-，显示当前行前面的源程序。</p><p>下面演示了使用GDB中的run（缩写为r）、break（缩写为b）、next（缩写为n）命令控制程序的运行，并使用print（缩写为p）命令打印程序中的变量sum的过程：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) break add</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1 at 0x80482f7: file gdb_example.c, line 3.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Starting program: /driver_study/gdb_example</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, add (a=48, b=85) at gdb_example.c:3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">warning: Source file is more recent than executable.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3      return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main () at gdb_example.c:23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      sum[i] = add(array1[i], array2[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) print sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$1 = {133, 0, 0, 0, 0, 0, 0, 0, 0, 0}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2run命令">2.run命令<a class="hash-link" href="#2run命令" title="标题的直接链接">​</a></h2><p>在GDB中，运行程序使用run命令。在程序运行前，我们可以设置如下4方面的工作环境。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1程序运行参数">（1）程序运行参数<a class="hash-link" href="#1程序运行参数" title="标题的直接链接">​</a></h3><p>用set args可指定运行时参数，如set args 10 20 30 40 50；用show args命令可以查看设置好的运行参数。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2运行环境">（2）运行环境<a class="hash-link" href="#2运行环境" title="标题的直接链接">​</a></h3><p>用path&lt; dir&gt;可设定程序的运行路径；用how paths可查看程序的运行路径；用set environment varname<!-- -->[=value]<!-- -->可设置环境变量，如set env USER=baohua；用show environment<!-- -->[varname]<!-- -->则可查看环境变量。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3工作目录">（3）工作目录<a class="hash-link" href="#3工作目录" title="标题的直接链接">​</a></h3><p>cd&lt; dir&gt;相当于shell的cd命令，pwd可显示当前所在的目录。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4程序的输入输出">（4）程序的输入输出<a class="hash-link" href="#4程序的输入输出" title="标题的直接链接">​</a></h3><p>info terminal用于显示程序用到的终端的模式；在GDB中也可以使用重定向控制程序输出，如run&gt;outfile；用tty命令可以指定输入输出的终端设备，如tty/dev/ttyS1。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3break命令">3.break命令<a class="hash-link" href="#3break命令" title="标题的直接链接">​</a></h2><p>在GDB中用break命令来设置断点，设置断点的方法如下。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1break-function">（1）break&lt; function&gt;<a class="hash-link" href="#1break-function" title="标题的直接链接">​</a></h3><p>在进入指定函数时停住，在C++中可以使用class：：function或function（type，type）格式来指定函数名。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2break-linenum">（2）break&lt; linenum&gt;<a class="hash-link" href="#2break-linenum" title="标题的直接链接">​</a></h3><p>在指定行号停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3breakoffsetbreak-offset">（3）break+offset/break-offset。<a class="hash-link" href="#3breakoffsetbreak-offset" title="标题的直接链接">​</a></h3><p>在当前行号的前面或后面的offset行停住，offiset为自然数。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4break-filenamelinenum">（4）break filename：linenum<a class="hash-link" href="#4break-filenamelinenum" title="标题的直接链接">​</a></h3><p>在源文件filename的linenum行处停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5break-filenamefunction">（5）break filename：function<a class="hash-link" href="#5break-filenamefunction" title="标题的直接链接">​</a></h3><p>在源文件filename的function函数的入口处停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6breakaddress">（6）break*address<a class="hash-link" href="#6breakaddress" title="标题的直接链接">​</a></h3><p>在程序运行的内存地址处停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="7break">（7）break<a class="hash-link" href="#7break" title="标题的直接链接">​</a></h3><p>break命令没有参数时，表示在下一条指令处停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="8breakif-condition">（8）break…if&lt; condition&gt;<a class="hash-link" href="#8breakif-condition" title="标题的直接链接">​</a></h3><p>…可以是上述的break&lt; linenum&gt;、break+offset/break–offset中的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i=100，表示当i为100时停住程序。</p><p>查看断点时，可使用info命令，如info breakpoints<!-- -->[n]<!-- -->、info break<!-- -->[n]<!-- -->（n表示断点号）。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4单步命令">4.单步命令<a class="hash-link" href="#4单步命令" title="标题的直接链接">​</a></h2><p>在调试过程中，next命令用于单步执行，类似于VC++中的step over。next的单步不会进入函数的内部，与next对应的step（缩写为s）命令则在单步执行一个函数时，进入其内部，类似于VC++中的step into。下面演示了step命令的执行情况，在第23行的add（）函数调用处执行step会进入其内部的return a+b；语句：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) break 25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1 at 0x8048362: file gdb_example.c, line 25.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Starting program: /driver_study/gdb_example</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, main () at gdb_example.c:25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      sum[i] = add(array1[i], array2[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) step</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">add (a=48, b=85) at gdb_example.c:3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3      return a + b;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>单步执行的更复杂用法如下。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1step-count">（1）step&lt; count&gt;<a class="hash-link" href="#1step-count" title="标题的直接链接">​</a></h3><p>单步跟踪，如果有函数调用，则进入该函数（进入函数的前提是，此函数被编译有debug信息）。step后面不加count表示一条条地执行，加count表示执行后面的count条指令，然后再停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2next-count">（2）next&lt; count&gt;<a class="hash-link" href="#2next-count" title="标题的直接链接">​</a></h3><p>单步跟踪，如果有函数调用，它不会进入该函数。同理，next后面不加count表示一条条地执行，加count表示执行后面的count条指令，然后再停住。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3set-step-mode">（3）set step-mode<a class="hash-link" href="#3set-step-mode" title="标题的直接链接">​</a></h3><p>set step-mode on用于打开step-mode模式，这样，在进行单步跟踪（运行step指令）时，若跨越某没有调试信息的函数，程序的执行则会在该函数的第一条指令处停住，而不会跳过整个函数。这样我们可以查看该函数的机器指令。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4finish">（4）finish<a class="hash-link" href="#4finish" title="标题的直接链接">​</a></h3><p>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址、返回值及参数值等信息。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5until缩写为u">（5）until（缩写为u）<a class="hash-link" href="#5until缩写为u" title="标题的直接链接">​</a></h3><p>一直在循环体内执行单步而退不出来是一件令人烦恼的事情，用until命令可以运行程序直到退出循环体。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6stepi缩写为si和nexti缩写为ni">（6）stepi（缩写为si）和nexti（缩写为ni）<a class="hash-link" href="#6stepi缩写为si和nexti缩写为ni" title="标题的直接链接">​</a></h3><p>stepi和nexti用于单步跟踪一条机器指令。比如，一条C程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令，相反，step和next是C语言级别的命令。</p><p>另外，运行display/i$pc命令后，单步跟踪会在打出程序代码的同时打出机器指令，即汇编代码</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5continue命令">5.continue命令<a class="hash-link" href="#5continue命令" title="标题的直接链接">​</a></h2><p>当程序被停住后，可以使用continue命令（缩写为c，fg命令同continue命令）恢复程序的运行直到程序结束，或到达下一个断点，命令格式为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">continue [ignore-count]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">c [ignore-count]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fg [ignore-count]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ignore-count表示忽略其后多少次断点。</p><p>假设我们设置了函数断点add（），并观察i，则在continue过程中，每次遇到add（）函数或i发生变化，程序就会停住，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) continue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Continuing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hardware watchpoint 3: i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Old value = 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">New value = 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x0804838d in main () at gdb_example.c:23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) continue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Continuing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, main () at gdb_example.c:25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        sum[i] = add(array1[i], array2[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) continue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Continuing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hardware watchpoint 3: i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Old value = 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">New value = 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x0804838d in main () at gdb_example.c:23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       for (i = 0; i &lt; 10; i++)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6print命令">6.print命令<a class="hash-link" href="#6print命令" title="标题的直接链接">​</a></h2><p>在调试程序时，当程序被停住时，可以使用print命令（缩写为p），或是同义命令inspect来查看当前程序的运行数据。print命令的格式如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">print &lt;expr&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print /&lt;f&gt; &lt;expr&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>&lt; expr&gt;是表达式，也是被调试的程序中的表达式，&lt; f&gt;是输出的格式，比如，如果要把表达式按十六进制的格式输出，那么就是/x。在表达式中，有几种GDB所支持的操作符，它们可以用在任何一种语言中，@是一个和数组有关的操作符，：：指定一个在文件或是函数中的变量，{&lt; type&gt;}&lt; addr&gt;表示一个指向内存地址&lt; addr&gt;的类型为type的对象。</p><p>下面演示了查看sum[]数组的值的过程：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) print sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$2 = {133, 155, 0, 0, 0, 0, 0, 0, 0, 0}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, main () at gdb_example.c:25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        sum[i] = add(array1[i], array2[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) print sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$3 = {133, 155, 143, 0, 0, 0, 0, 0, 0, 0}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当需要查看一段连续内存空间的值时，可以使用GDB的@操作符，@的左边是第一个内存地址，@的右边则是想查看内存的长度。例如如下动态申请的内存：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int *array = (int *) malloc (len * sizeof (int));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在GDB调试过程中这样显示这个动态数组的值：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">p *array@len</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>print的输出格式如下。</p><ul><li>·x：按十六进制格式显示变量。</li><li>·d：按十进制格式显示变量。</li><li>·u：按十六进制格式显示无符号整型。</li><li>·o：按八进制格式显示变量。</li><li>·t：按二进制格式显示变量。</li><li>·a：按十六进制格式显示变量。</li><li>·c：按字符格式显示变量。</li><li>·f：按浮点数格式显示变量。</li></ul><p>我们可用display命令设置一些自动显示的变量，当程序停住时，或是单步跟踪时，这些变量会自动显示。</p><p>如果要修改变量，如x的值，可使用如下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">print x=4</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当用GDB的print查看程序运行时数据时，每一个print都会被GDB记录下来。GDB会以$1，$2，$3…这样的方式为每一个print命令编号。我们可以使用这个编号访问以前的表达式，如$1。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7watch命令">7.watch命令<a class="hash-link" href="#7watch命令" title="标题的直接链接">​</a></h2><p>watch一般用来观察某个表达式（变量也是一种表达式）的值是否有了变化，如果有变化，马上停止程序运行。我们有如下几种方法来设置观察点。</p><p>watch&lt; expr&gt;：为表达式（变量）expr设置一个观察点。一旦表达式值有变化时，马上停止程序运行。</p><p>rwatch&lt; expr&gt;：当表达式（变量）expr被读时，停止程序运行。</p><p>awatch&lt; expr&gt;：当表达式（变量）的值被读或被写时，停止程序运行。</p><p>info watchpoints：列出当前所设置的所有观察点。</p><p>下面演示了观察i并在连续运行next时一旦发现i变化，i值就会显示出来的过程：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) watch i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hardware watchpoint 3: i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hardware watchpoint 3: i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Old value = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">New value = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x0804838d in main () at gdb_example.c:23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, main () at gdb_example.c:25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        sum[i] = add(array1[i], array2[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       for (i = 0; i &lt; 10; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) next</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Hardware watchpoint 3: i</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Old value = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">New value = 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x0804838d in main () at gdb_example.c:23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       for (i = 0; i &lt; 10; i++)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="8examine命令">8.examine命令<a class="hash-link" href="#8examine命令" title="标题的直接链接">​</a></h2><p>我们可以使用examine命令（缩写为x）来查看内存地址中的值。examine命令的语法如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x/&lt;n/f/u&gt; &lt;addr&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>&lt; addr&gt;表示一个内存地址。“x/”后的n、f、u都是可选的参数，n是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；f表示显示的格式，如果地址所指的是字符串，那么格式可以是s，如果地址是指令地址，那么格式可以是i；u表示从当前地址往后请求的字节数，如果不指定的话，GDB默认的是4字节。u参数可以被一些字符代替：b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指定的内存地址开始，读写指定字节，并把其当作一个值取出来。n、f、u这3个参数可以一起使用，例如命令x/3uh 0x54320表示从内存地址0x54320开始以双字节为1个单位（h）、16进制方式（u）显示3个单位（3）的内存。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="9set命令">9.set命令<a class="hash-link" href="#9set命令" title="标题的直接链接">​</a></h2><p>examine命令用于查看内存，而set命令用于修改内存。它的命令格式是“set*有类型的指针=value”。</p><p>比如，下列程序，在用gdb运行起来后，通过Ctrl+C停住。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *p = malloc(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们可以在运行中用如下命令来修改p指向的内存。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)p=&#x27;h&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)(p+1)=&#x27;e&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)(p+2)=&#x27;l&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)(p+3)=&#x27;l&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)(p+4)=&#x27;o&#x27;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>看看结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) x/s p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x804b008:      &quot;hello&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>也可以直接使用地址常数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$2 = (void *) 0x804b008</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)0x804b008=&#x27;w&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)0x804b009=&#x27;o&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)0x804b00a=&#x27;r&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)0x804b00b=&#x27;l&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) set *(unsigned char *)0x804b00c=&#x27;d&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) x/s 0x804b008</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x804b008:      &quot;world&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="10jump命令">10.jump命令<a class="hash-link" href="#10jump命令" title="标题的直接链接">​</a></h2><p>一般来说，被调试程序会按照程序代码的运行顺序依次执行，但是GDB也提供了乱序执行的功能，也就是说，GDB可以修改程序的执行顺序，从而让程序随意跳跃。这个功能可以由GDB的jump命令jump&lt; linespec&gt;来指定下一条语句的运行点。&lt; linespec&gt;可以是文件的行号，可以是file：line格式，也可以是+num这种偏移量格式，表示下一条运行语句从哪里开始。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">jump &lt;address&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里的&lt; address&gt;是代码行的内存地址。</p><p>注意： jump命令不会改变当前程序栈中的内容，如果使用jump从一个函数跳转到另一个函数，当跳转到的函数运行完返回，进行出栈操作时必然会发生错误，这可能会导致意想不到的结果，因此最好只用jump在同一个函数中进行跳转。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11signal命令">11.signal命令<a class="hash-link" href="#11signal命令" title="标题的直接链接">​</a></h2><p>使用singal命令，可以产生一个信号量给被调试的程序，如中断信号Ctrl+C。于是，可以在程序运行的任意位置处设置断点，并在该断点处用GDB产生一个信号量，这种精确地在某处产生信号的方法非常有利于程序的调试。</p><p>signal命令的语法是signal&lt; signal&gt;，UNIX的系统信号量通常为1~15，因此&lt; signal&gt;的取值也在这个范围内。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12return命令">12.return命令<a class="hash-link" href="#12return命令" title="标题的直接链接">​</a></h2><p>如果在函数中设置了调试断点，在断点后还有语句没有执行完，这时候我们可以使用return命令强制函数忽略还没有执行的语句并返回。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return &lt;expression&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述return命令用于取消当前函数的执行，并立即返回，如果指定了&lt; expression&gt;，那么该表达式的值会被作为函数的返回值。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="13call命令">13.call命令<a class="hash-link" href="#13call命令" title="标题的直接链接">​</a></h2><p>call命令用于强制调用某函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">call &lt;expr&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>表达式可以是函数，以此达到强制调用函数的目的，它会显示函数的返回值（如果函数返回值不是void）。比如在下列程序执行while（1）的时候：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">main()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        void *p = malloc(16);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们强制要求其执行strcpy（）和printf（）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) call strcpy(p, &quot;hello world&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$3 = 134524936</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) call printf(&quot;%s\n&quot;, p)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hello world</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$4 = 12</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="14info命令">14.info命令<a class="hash-link" href="#14info命令" title="标题的直接链接">​</a></h2><p>info命令可以用来在调试时查看寄存器、断点、观察点和信号等信息。要查看寄存器的值，可以使用如下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">info registers （查看除了浮点寄存器以外的寄存器）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">info all-registers （查看所有寄存器，包括浮点寄存器）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">info registers &lt;regname ...&gt;  （查看所指定的寄存器）</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>要查看断点信息，可以使用如下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">info break要列出当前所设置的所有观察点，可使用如下命令：</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">info watchpoints</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>要查看有哪些信号正在被GDB检测，可使用如下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">info signals</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">info handle</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>也可以使用info line命令来查看源代码在内存中的地址。info line后面可以跟行号、函数名、文件名：行号、文件名：函数名等多种形式，例如用下面的命令会打印出所指定的源码在运行时的内存地址：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">info line tst.c:func</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="15disassemble">15.disassemble<a class="hash-link" href="#15disassemble" title="标题的直接链接">​</a></h2><p>disassemble命令用于反汇编，可用它来查看当前执行时的源代码的机器码，实际上只是把目前内存中的指令冲刷出来。下面的示例用于查看函数func的汇编代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) disassemble func</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Dump of assembler code for function func:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x8048450 &lt;func&gt;:      push   %ebp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x8048451 &lt;func+1&gt;:    mov    %esp,%ebp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x8048453 &lt;func+3&gt;:    sub    $0x18,%esp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x8048456 &lt;func+6&gt;:    movl   $0x0,0xfffffffc(%ebp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">End of assembler dump.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.361Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>DM9000是开发板采用的网络芯片，是一个高度集成且功耗很低的高速网络控制器，可以和CPU直连，支持10/100MB以太网连接，芯片内部自带4KB双字节的SRAM（3KB用来发送，13KB用来接收）。针对不同的处理器，接口支持8位、16位和32位。DM9000一般直接挂在外面的内存总线上。</p><h1>14.9.2　DM9000网卡驱动设计分析</h1><p>DM9000网卡驱动位于内核源代码的drivers/net/dm9000.c中，它基于平台驱动架构，代码清单14.19抽取了它的主干。其核心工作是实现了前文所述net_device结构体中的hard_start_xmit（）、open（）、stop（）、set_multicast_list（）、do_ioctl（）、tx_timeout（）等成员函数，并借助中断辅助进行网络数据包的收发，另外它也实现了ethtool_ops中的成员函数。特别注意代码中的黑体部分，它标明了关键的数据收发流程。</p><p>代码清单14.19　DM9000网卡驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  1static const struct ethtool_ops dm9000_ethtool_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2        .get_drvinfo            = dm9000_get_drvinfo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  3        .get_settings           = dm9000_get_settings,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4        .set_settings           = dm9000_set_settings,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5        .get_msglevel           = dm9000_get_msglevel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  6        .set_msglevel           = dm9000_set_msglevel,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  7        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 10/* Our watchdog timed out. Called by the networking layer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 11static void dm9000_timeout(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 12{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 13        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 14        netif_stop_queue(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 15        dm9000_init_dm9000(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 16        dm9000_unmask_interrupts(db);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 17        /* We can accept TX packets again */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 18        dev-&gt;trans_start = jiffies; /* prevent tx timeout */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 19        netif_wake_queue(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 21        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 24 static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25 dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 26 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 27         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 28         /* TX control: First packet immediately send, second packet queue */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 29         if (db-&gt;tx_pkt_cnt == 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 30                 dm9000_send_packet(dev, skb-&gt;ip_summed, skb-&gt;len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 31         } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 32                 /* Second packet */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 33                 db-&gt;queue_pkt_len = skb-&gt;len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 34                 db-&gt;queue_ip_summed = skb-&gt;ip_summed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 35                 netif_stop_queue(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 36         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 38         spin_unlock_irqrestore(&amp;db-&gt;lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 40         /* free this SKB */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 41         dev_consume_skb_any(skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 43         return NETDEV_TX_OK;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 44 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 46 static void dm9000_tx_done(struct net_device *dev, board_info_t *db)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 47 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 48         int tx_status = ior(db, DM9000_NSR);    /* Got TX status */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 50         if (tx_status &amp; (NSR_TX2END | NSR_TX1END)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 51                 /* One packet sent complete */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 52                 db-&gt;tx_pkt_cnt--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 53                 dev-&gt;stats.tx_packets++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 55                 if (netif_msg_tx_done(db))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 56                         dev_dbg(db-&gt;dev, &quot;tx done, NSR %02x\n&quot;, tx_status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 57</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 58                 /* Queue packet check &amp; send */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 59                 if (db-&gt;tx_pkt_cnt &gt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 60                         dm9000_send_packet(dev, db-&gt;queue_ip_summed,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 61                                            db-&gt;queue_pkt_len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 62                 netif_wake_queue(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 63         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 64 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 65</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 66 static void</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 67 dm9000_rx(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 68 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 69         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 71         /* Check packet ready or not */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 72         do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 73                 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 74</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 75                 /* Move data from DM9000*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 76                 if (GoodPacket &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 77                     ((skb = netdev_alloc_skb(dev, RxLen + 4)) != NULL)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 78                         skb_reserve(skb, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 79                         rdptr = (u8*) skb_put(skb, RxLen - 4);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 81                         /* Read received packet from RX SRAM */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 82</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 83                         (db-&gt;inblk)(db-&gt;io_data, rdptr, RxLen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 84                         dev-&gt;stats.rx_bytes += RxLen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 85</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 86                         /* Pass to upper layer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 87                         skb-&gt;protocol = eth_type_trans(skb, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 88                         if (dev-&gt;features &amp; NETIF_F_RXCSUM) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 89                                 if ((((rxbyte &amp; 0x1c) &lt;&lt; 3) &amp; rxbyte) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 90                                         skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 91                                 else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 92                                         skb_checksum_none_assert(skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 93                         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 94                         netif_rx(skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 95                         dev-&gt;stats.rx_packets++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 96</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 97                 }...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 98         } while (rxbyte &amp; DM9000_PKT_RDY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 99 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">101 static irqreturn_t dm9000_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">102 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">103         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">104         /* Received the coming packet */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">105         if (int_status &amp; ISR_PRS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">106                 dm9000_rx(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">107</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">108         /* Trnasmit Interrupt check */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">109         if (int_status &amp; ISR_PTS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">110                 dm9000_tx_done(dev, db);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">111</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">112         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">113         return IRQ_HANDLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">114 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">115</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">116 static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">117 dm9000_open(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">118 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">119         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">120</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">121         /* Initialize DM9000board */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">122         dm9000_init_dm9000(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">123</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">124         if (request_irq(dev-&gt;irq, dm9000_interrupt, irqflags, dev-&gt;name, dev))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">125                 return -EAGAIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">126         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">127</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">128         mii_check_media(&amp;db-&gt;mii, netif_msg_link(db), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">129         netif_start_queue(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">130</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">131         return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">132 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">133</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">134 static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">135 dm9000_stop(struct net_device *ndev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">136 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">137         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">138</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">139         netif_stop_queue(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">140         netif_carrier_off(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">141</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">142         /* free interrupt */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">143         free_irq(ndev-&gt;irq, ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">144</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">145         dm9000_shutdown(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">146</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">147         return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">148 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">149</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">150 static const struct net_device_ops dm9000_netdev_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">151         .ndo_open               = dm9000_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">152         .ndo_stop               = dm9000_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">153         .ndo_start_xmit         = dm9000_start_xmit,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">154         .ndo_tx_timeout         = dm9000_timeout,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">155         .ndo_set_rx_mode        = dm9000_hash_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">156         .ndo_do_ioctl           = dm9000_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">157         .ndo_change_mtu         = eth_change_mtu,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">158         .ndo_set_features       = dm9000_set_features,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">159         .ndo_validate_addr      = eth_validate_addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">160         .ndo_set_mac_address    = eth_mac_addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">161 #ifdef CONFIG_NET_POLL_CONTROLLER</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">162         .ndo_poll_controller    = dm9000_poll_controller,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">163 #endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">164 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">165</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">166</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">167 /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">168  * Search DM9000board, allocate space and register it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">169  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">170 static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">171 dm9000_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">172 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">173         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">174</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">175         /* Init network device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">176         ndev = alloc_etherdev(sizeof(struct board_info));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">177         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">178</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">179         /* setup board info structure */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">180         db = netdev_priv(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">181</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">182         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">183</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">184         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">185         /* driver system function */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">186         ether_setup(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">187</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">188         ndev-&gt;netdev_ops        = &amp;dm9000_netdev_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">189         ndev-&gt;watchdog_timeo    = msecs_to_jiffies(watchdog);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">190         ndev-&gt;ethtool_ops       = &amp;dm9000_ethtool_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">191</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">192         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">193         ret = register_netdev(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">194</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">195 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">196</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">197 static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">198 dm9000_drv_remove(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">199 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200         struct net_device *ndev = platform_get_drvdata(pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">201</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">202         unregister_netdev(ndev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">203         dm9000_release_board(pdev, netdev_priv(ndev));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">204         free_netdev(ndev);              /* free device structure */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">205         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">206 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">207</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">208 #ifdef CONFIG_OF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">209 static const struct of_device_id dm9000_of_matches[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">210         { .compatible = &quot;davicom,dm9000&quot;, },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">211         { /* sentinel */ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">212 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">213 MODULE_DEVICE_TABLE(of, dm9000_of_matches);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">214 #endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">215</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">216 static struct platform_driver dm9000_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">217         .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">218                 .name    = &quot;dm9000&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">219                 .owner   = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">220                 .pm      = &amp;dm9000_drv_pm_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">221                 .of_match_table = of_match_ptr(dm9000_of_matches),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">222         },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">223         .probe   = dm9000_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">224         .remove  = dm9000_drv_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">225 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">226</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">227 module_platform_driver(dm9000_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>DM9000驱动的实现与具体CPU无关，在将该驱动移植到特定电路板时，只需要在板文件中为与板上DM9000对应的平台设备的寄存器和数据基地址进行赋值，并指定正确的IRQ资源即可，代码清单14.20给出了在arch/arm/mach-at91/board-sam9261ek.c板文件中对DM9000添加的内容。</p><p>代码清单14.20　board-sam9261ek板文件中的DM9000的平台设备</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct resource dm9000_resource[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        [0] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3                .start  = AT91_CHIPSELECT_2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4                .end    = AT91_CHIPSELECT_2+ 3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                .flags  = IORESOURCE_MEM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        [1] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                .start  = AT91_CHIPSELECT_2+ 0x44,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                .end    = AT91_CHIPSELECT_2+ 0xFF,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                .flags  = IORESOURCE_MEM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        [2] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                .flags  = IORESOURCE_IRQ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                        | IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18static struct dm9000_plat_data dm9000_platdata = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        .flags          = DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22static struct platform_device dm9000_device = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        .name           = &quot;dm9000&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        .id             = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        .num_resources  = ARRAY_SIZE(dm9000_resource),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        .resource       = dm9000_resource,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        .dev            = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28                .platform_data  = &amp;dm9000_platdata,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.353Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>块设备的I/O操作方式与字符设备的存在较大的不同，因而引入了request_queue、request、bio等一系列数据结构。在整个块设备的I/O操作中，贯穿始终的就是“请求”，字符设备的I/O操作则是直接进行不绕弯，块设备的I/O操作会排队和整合。</p><p>驱动的任务是处理请求，对请求的排队和整合由I/O调度算法解决，因此，块设备驱动的核心就是请求处理函数或“制造请求”函数。</p><p>尽管在块设备驱动中仍然存在block_device_operations结构体及其成员函数，但不再包含读写类的成员函数，而只是包含打开、释放及I/O控制等与具体读写无关的函数。</p><p>块设备驱动的结构相对复杂，但幸运的是，块设备不像字符设备那样包罗万象，它通常就是存储设备，而且驱动的主体已经由Linux内核提供，针对一个特定的硬件系统，驱动工程师所涉及的工作往往只是编写极其少量的与硬件平台相关的代码。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.349Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>USB OTG标准在完全兼容USB 2.0标准的基础上，它允许设备既可作为主机，也可作为外设操作，OTG新增了主机通令协议（HNP）和对话请求协议（SRP）。</p><p>在OTG中，初始主机设备称为A设备，外设称为B设备。可用电缆的连接方式来决定初始角色。两用设备使用新型Mini-AB插座，从而使Mini-A插头、Mini-B插头和Mini-AB插座增添了第5个引脚（ID），以用于识别不同的电缆端点。Mini-A插头中的ID引脚接地，Mini-B插头中的ID引脚浮空。当OTG设备检测到接地的ID引脚时，表示默认的是A设备（主机），而检测到ID引脚浮空的设备则认为是B设备（外设）。系统一旦连接后，OTG的角色还可以更换，以采用新的HNP协议。而SRP允许B设备请求A设备打开VBUS电源并启动一次对话。一次OTG对话可通过A设备提供VBUS电源的时间来确</p><p>自Linux 2.6.9开始，OTG相关源代码已经被包含在内核中了，新增的主要内容包括：</p><h1>（1）UDC驱动端添加的OTG相关属性和函数</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_gadget {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned            is_otg:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned            is_a_peripheral:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned            b_hnp_enable:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned            a_hnp_support:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned            a_alt_hnp_support:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_vbus_connect(struct usb_gadget *gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_vbus_disconnect(struct usb_gadget *gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 控制USB D+的上拉*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_connect(struct usb_gadget *gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_disconnect(struct usb_gadget *gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 尝试唤醒USB host，它也会尝试SRP会话*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_gadget_wakeup(struct usb_gadget *gadget);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>（2）Gadget驱动端添加的OTG相关属性和函数</h1><p>如果gadget-&gt;is_otg字段为真，则增加一个OTG描述符；通过printk（）、LED等方式报告HNP可用；当挂起开始时，通过用户界面报告HNP切换开始（B-Peripheral到B-Host或A-Peripheral到A-Host）。</p><h1>（3）主机侧添加的OTG相关属性和函数</h1><p>在USB核心中新增了关于OTG设备枚举的信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_bus {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u8 otg_port;               /* 0, or index of OTG/HNP port */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned is_b_host:1;      /* true during some HNP roleswitches */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned b_hnp_enable:1;   /* OTG: did A-Host enable HNP  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了实现HNP需要的挂起/恢复，新增如下通用接口：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_suspend_device(struct usb_device *dev, u32 state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int usb_resume_device(struct usb_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>（4）新增OTG功能切换和协议的描述结构体usb_otg</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_otg {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       u8                   default_a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct phy            *phy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* old usb_phy interface */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct usb_phy        *usb_phy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct usb_bus        *host;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct usb_gadget     *gadget;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       enum usb_otg_state    state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* bind/unbind the host controller */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int    (*set_host)(struct usb_otg *otg, struct usb_bus *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* bind/unbind the peripheral controller */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int    (*set_peripheral)(struct usb_otg *otg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                 struct usb_gadget *gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* effective for A-peripheral, ignored for B devices */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int    (*set_vbus)(struct usb_otg *otg, bool enabled);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* for B devices only:  start session with A-Host */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int    (*start_srp)(struct usb_otg *otg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* start or continue HNP role switch */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int    (*start_hnp)(struct usb_otg *otg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_otg的代码一般在USB的phy端实现，目前，从内核的drivers/usb/musb/musb_gadget.c、drivers/usb/phy/phy-twl6030-usb.c、drivers/usb/phy/phy-isp1301-omap.c、drivers/usb/phy/phy-fsl-usb.c和drivers/usb/musb/musb_gadget.c等驱动中可以找到类似的例子。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.349Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->14 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核源代码包含如下目录。</p><ul><li>·arch：包含和硬件体系结构相关的代码，每种平台占一个相应的目录，如i386、arm、arm64、powerpc、mips等。Linux内核目前已经支持30种左右的体系结构。在arch目录下，存放的是各个平台以及各个平台的芯片对Linux内核进程调度、内存管理、中断等的支持，以及每个具体的SoC和电路板的板级支持代码。</li><li>·block：块设备驱动程序I/O调度。</li><li>·crypto：常用加密和散列算法（如AES、SHA等），还有一些压缩和CRC校验算法。</li><li>·documentation：内核各部分的通用解释和注释。</li><li>·drivers：设备驱动程序，每个不同的驱动占用一个子目录，如char、block、net、mtd、i2c等。</li><li>·fs：所支持的各种文件系统，如EXT、FAT、NTFS、JFFS2等。</li><li>·include：头文件，与系统相关的头文件放置在include/linux子目录下。</li><li>·init：内核初始化代码。著名的start_kernel（）就位于init/main.c文件中。</li><li>·ipc：进程间通信的代码。</li><li>·kernel：内核最核心的部分，包括进程调度、定时器等，而和平台相关的一部分代码放在arch/*/kernel目录下。</li><li>·lib：库文件代码。</li><li>·mm：内存管理代码，和平台相关的一部分代码放在arch/*/mm目录下。</li><li>·net：网络相关代码，实现各种常见的网络协议。</li><li>·scripts：用于配置内核的脚本文件。</li><li>·security：主要是一个SELinux的模块。</li><li>·sound：ALSA、OSS音频设备的驱动核心代码和常用设备驱动。</li><li>·usr：实现用于打包和压缩的cpio等。</li><li>·include：内核API级别头文件。</li></ul><p>内核一般要做到drivers与arch的软件架构分离，驱动中不包含板级信息，让驱动跨平台。同时内核的通用部分（如kernel、fs、ipc、net等）则与具体的硬件（arch和drivers）剥离。</p><h1>3.3.2　Linux内核的组成部分</h1><p>如图3.3所示，Linux内核主要由进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）5个子系统组成。</p><p><img loading="lazy" alt="image-20250323214539708" src="/assets/images/image-20250323214539708-b77e09908e3c5bb8f2c64c69cf6cc253.png" width="700" height="384" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1进程调度">1.进程调度<a class="hash-link" href="#1进程调度" title="标题的直接链接">​</a></h2><p>进程调度控制系统中的多个进程对CPU的访问，使得多个进程能在CPU中“微观串行，宏观并行”地执行。进程调度处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程。</p><p>如图3.4所示，Linux的进程在几个状态间进行切换。在设备驱动编程中，当请求的资源不能得到满足时，驱动一般会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪状态。睡眠分成可中断的睡眠和不可中断的睡眠，两者的区别在于可中断的睡眠在收到信号的时候会醒。</p><p><img loading="lazy" alt="image-20250323214620056" src="/assets/images/image-20250323214620056-964f2094dccd934436eb05f158febbb0.png" width="1473" height="969" class="img_ev3q"></p><p>图3.4　Linux进程状态转换</p><p>完全处于TASK_UNINTERRUPTIBLE状态的进程甚至都无法被“杀死”，所以Linux 2.6.26之后的内核也存在一种TASK_KILLABLE的状态，它等于“TASK_WAKEKILL|TASK_UNINTERRUPTIBLE”，可以响应致命信号。</p><p>在Linux内核中，使用task_struct结构体来描述进程，该结构体中包含描述该进程内存资源、文件系统资源、文件资源、tty资源、信号处理等的指针。Linux的线程采用轻量级进程模型来实现，在用户空间通过pthread_create（）API创建线程的时候，本质上内核只是创建了一个新的task_struct，并将新task_struct的所有资源指针都指向创建它的那个task_struct的资源指针。</p><p>绝大多数进程（以及进程中的多个线程）是由用户空间的应用创建的，当它们存在底层资源和硬件访问的需求时，会通过系统调用进入内核空间。有时候，在内核编程中，如果需要几个并发执行的任务，可以启动内核线程，这些线程没有用户空间。启动内核线程的函数为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2内存管理">2.内存管理<a class="hash-link" href="#2内存管理" title="标题的直接链接">​</a></h2><p>内存管理的主要作用是控制多个进程安全地共享主内存区域。当CPU提供内存管理单元（MMU）时，Linux内存管理对于每个进程完成从虚拟内存到物理内存的转换。Linux 2.6引入了对无MMU CPU的支持。</p><p>如图3.5所示，一般而言，32位处理器的Linux的每个进程享有4GB的内存空间，0~3GB属于用户空间，3~4GB属于内核空间，内核空间对常规内存、I/O设备内存以及高端内存有不同的处理方式。当然，内核空间和用户空间的具体界限是可以调整的，在内核配置选项Kernel Features→Memory split下，可以设置界限为2GB或者3GB。</p><p><img loading="lazy" alt="1742737655147" src="/assets/images/1742737655147-a25a994ab22d3ef2893a8596aef70987.png" width="838" height="462" class="img_ev3q"></p><p>图3.5　Linux进程地址空间</p><p>如图3.6所示，Linux内核的内存管理总体比较庞大，包含底层的Buddy算法，它用于管理每个页的占用情况，内核空间的slab以及用户空间的C库的二次管理。另外，内核也提供了页缓存的支持，用内存来缓存磁盘，per-BDI flusher线程用于刷回脏的页缓存到磁盘。Kswapd（交换进程）则是Linux中用于页面回收（包括file-backed的页和匿名页）的内核线程，它采用最近最少使用（LRU）算法进行内存回收。</p><p><img loading="lazy" alt="1742737696273" src="/assets/images/1742737696273-acd3bfe1c876572800b2ea5c1d9b3165.png" width="1369" height="960" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3虚拟文件系统">3.虚拟文件系统<a class="hash-link" href="#3虚拟文件系统" title="标题的直接链接">​</a></h2><p>如图3.7所示，Linux虚拟文件系统隐藏了各种硬件的具体细节，为所有设备提供了统一的接口。而且，它独立于各个具体的文件系统，是对各种文件系统的一个抽象。它为上层的应用程序提供了统一的vfs_read（）、vfs_write（）等接口，并调用具体底层文件系统或者设备驱动中实现的file_operations结构体的成员函数。</p><p><img loading="lazy" alt="image-20250323214909639" src="/assets/images/image-20250323214909639-bd22b1d744c9a5a1015433f69d9b4f9a.png" width="856" height="477" class="img_ev3q"></p><p>图3.7　Linux虚拟文件系统</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4网络接口">4.网络接口<a class="hash-link" href="#4网络接口" title="标题的直接链接">​</a></h2><p>网络接口提供了对各种网络标准的存取和各种网络硬件的支持。如图3.8所示，在Linux中网络接口可分为网络协议和网络驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序</p><p><img loading="lazy" alt="1742737795680" src="/assets/images/1742737795680-f4640e7bd6f1d0c41246b1726045f143.png" width="1117" height="721" class="img_ev3q"></p><p>图3.8　Linux网络体系结构</p><p>Linux内核支持的协议栈种类较多，如Internet、UNIX、CAN、NFC、Bluetooth、WiMAX、IrDA等，上层的应用程序统一使用套接字接口。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5进程间通信">5.进程间通信<a class="hash-link" href="#5进程间通信" title="标题的直接链接">​</a></h2><p>进程间通信支持进程之间的通信，Linux支持进程间的多种通信机制，包含信号量、共享内存、消息队列、管道、UNIX域套接字等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。在实际的Linux应用中，人们更多地趋向于使用UNIX域套接字，而不是System V IPC中的消息队列等机制。Android内核则新增了Binder进程间通信方式。</p><p>Linux内核5个组成部分之间的依赖关系如下。</p><ul><li>·进程调度与内存管理之间的关系：这两个子系统互相依赖。在多程序环境下，程序要运行，则必须为之创建进程，而创建进程的第一件事情，就是将程序和数据装入内存</li><li>·进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有空间之外，还可以存取共同的内存区域。</li><li>·虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持RAMDISK设备。</li><li>·内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程定期由调度程序调度，这也是内存管理依赖于进程调度的原因。当一个进程存取的内存映射被换出时，内存管理向虚拟文件系统发出请求，同时，挂起当前正在运行的进程。</li></ul><p>除了这些依赖关系外，内核中的所有子系统还要依赖于一些共同的资源。这些资源包括所有子系统都用到的API，如分配和释放内存空间的函数、输出警告或错误消息的函数及系统提供的调试接口等。</p><h1>3.3.3　Linux内核空间与用户空间</h1><p>现代CPU内部往往实现了不同操作模式（级别），不同模式有不同功能，高层程序往往不能访问低级功能，而必须以某种方式切换到低级模式。</p><p>例如，ARM处理器分为7种工作模式。</p><ul><li>·用户模式（usr）：大多数应用程序运行在用户模式下，当处理器运行在用户模式下时，某些被保护的系统资源是不能访问的。</li><li>·快速中断模式（fiq）：用于高速数据传输或通道处理。</li><li>·外部中断模式（irq）：用于通用的中断处理。</li><li>·管理模式（svc）：操作系统使用的保护模式。</li><li>·数据访问中止模式（abt）：当数据或指令预取中止时进入该模式，可用于虚拟存储及存储保护。</li><li>·系统模式（sys）：运行具有特权的操作系统任务。</li><li>·未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</li></ul><p>ARM Linux的系统调用实现原理是采用swi软中断从用户（usr）模式陷入管理模式（svc）。</p><p>又如，x86处理器包含4个不同的特权级，称为Ring 0~Ring 3。在Ring0下，可以执行特权级指令，对任何I/O设备都有访问权等，而Ring3则被限制很多操作。</p><p>Linux系统可充分利用CPU的这一硬件特性，但它只使用了两级。在Linux系统中，内核可进行任何操作，而应用程序则被禁止对硬件的直接访问和对内存的未授权访问。例如，若使用x86处理器，则用户代码运行在特权级3，而系统内核代码则运行在特权级0。</p><p>内核空间和用户空间这两个名词用来区分程序执行的两种不同状态，它们使用不同的地址空间。Linux只能通过系统调用和硬件中断完成从用户空间到内核空间的控制转移。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.341Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->20 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>设备通常会提供一组寄存器来控制设备、读写设备和获取设备状态，即控制寄存器、数据寄存器和状态寄存器。这些寄存器可能位于I/O空间中，也可能位于内存空间中。当位于I/O空间时，通常被称为I/O端口；当位于内存空间时，对应的内存空间被称为I/O内存。</p><h1>11.4.1　Linux I/O端口和I/O内存访问接口</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1io端口">1.I/O端口<a class="hash-link" href="#1io端口" title="标题的直接链接">​</a></h2><p>在Linux设备驱动中，应使用Linux内核提供的函数来访问定位于I/O空间的端口，这些函数包括如下几种。</p><p>1）读写字节端口（8位宽）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned inb(unsigned port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void outb(unsigned char byte, unsigned port);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2）读写字端口（16位宽）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned inw(unsigned port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void outw(unsigned short word, unsigned port);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3）读写长字端口（32位宽）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned inl(unsigned port);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void outl(unsigned longword, unsigned port);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4）读写一串字节。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void insb(unsigned port, void *addr, unsigned long count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void outsb(unsigned port, void *addr, unsigned long count);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5）insb（）从端口port开始读count个字节端口，并将读取结果写入addr指向的内存；outsb（）将addr指向的内存中的count个字节连续写入以port开始的端口。</p><p>6）读写一串字。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void insw(unsigned port, void *addr, unsigned long count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void outsw(unsigned port, void *addr, unsigned long count);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>7）读写一串长字。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void insl(unsigned port, void *addr, unsigned long count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void outsl(unsigned port, void *addr, unsigned long count);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述各函数中I/O端口号port的类型高度依赖于具体的硬件平台，因此，这里只是写出了unsigned。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2io内存">2.I/O内存<a class="hash-link" href="#2io内存" title="标题的直接链接">​</a></h2><p>在内核中访问I/O内存（通常是芯片内部的各个I2 C、SPI、USB等控制器的寄存器或者外部内存总线上的设备）之前，需首先使用ioremap（）函数将设备所处的物理地址映射到虚拟地址上。ioremap（）的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void *ioremap(unsigned long offset, unsigned long size);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ioremap（）与vmalloc（）类似，也需要建立新的页表，但是它并不进行vmalloc（）中所执行的内存分配行为。ioremap（）返回一个特殊的虚拟地址，该地址可用来存取特定的物理地址范围，这个虚拟地址位于vmalloc映射区域。通过ioremap（）获得的虚拟地址应该被iounmap（）函数释放，其原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void iounmap(void * addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ioremap（）有个变体是devm<em>ioremap（），类似于其他以devm</em>开头的函数，通过devm_ioremap（）进行的映射通常不需要在驱动退出和出错处理的时候进行iounmap（）。devm_ioremap（）的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void __iomem *devm_ioremap(struct device *dev, resource_size_t offset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                           unsigned long size);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在设备的物理地址（一般都是寄存器）被映射到虚拟地址之后，尽管可以直接通过指针访问这些地址，但是Linux内核推荐用一组标准的API来完成设备内存映射的虚拟地址的读写。</p><p>读寄存器用readb_relaxed（）、readw_relaxed（）、readl_relaxed（）、readb（）、readw（）、readl（）这一组API，以分别读8bit、16bit、32bit的寄存器，没有_relaxed后缀的版本与有_relaxed后缀的版本的区别是没有_relaxed后缀的版本包含一个内存屏障，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define readb(c)            ({ u8  __v = readb_relaxed(c); __iormb(); __v; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define readw(c)            ({ u16__v = readw_relaxed(c); __iormb(); __v; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define readl(c)            ({ u32 __v = readl_relaxed(c); __iormb(); __v; })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>写寄存器用writeb_relaxed（）、writew_relaxed（）、writel_relaxed（）、writeb（）、writew（）、writel（）这一组API，以分别写8bit、16bit、32bit的寄存器，没有_relaxed后缀的版本与有_relaxed后缀的版本的区别是前者包含一个内存屏障，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define writeb(v,c)         ({ __iowmb(); writeb_relaxed(v,c); })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define writew(v,c)         ({ __iowmb(); writew_relaxed(v,c); })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define writel(v,c)         ({ __iowmb(); writel_relaxed(v,c); })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>11.4.2　申请与释放设备的I/O端口和I/O内存</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1io端口申请">1.I/O端口申请<a class="hash-link" href="#1io端口申请" title="标题的直接链接">​</a></h2><p>Linux内核提供了一组函数以申请和释放I/O端口，表明该驱动要访问这片区域。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct resource *request_region(unsigned long first, unsigned long n, const char *name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数向内核申请n个端口，这些端口从first开始，name参数为设备的名称。如果分配成功，则返回值不是NULL，如果返回NULL，则意味着申请端口失败。</p><p>当用request_region（）申请的I/O端口使用完成后，应当使用release_region（）函数将它们归还给系统，这个函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void release_region(unsigned long start, unsigned long n);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2io内存申请">2.I/O内存申请<a class="hash-link" href="#2io内存申请" title="标题的直接链接">​</a></h2><p>同样，Linux内核也提供了一组函数以申请和释放I/O内存的范围。此处的“申请”表明该驱动要访问这片区域，它不会做任何内存映射的动作，更多的是类似于“reservation”的概念。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct resource *request_mem_region(unsigned long start, unsigned long len, char *name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数向内核申请n个内存地址，这些地址从first开始，name参数为设备的名称。如果分配成功，则返回值不是NULL，如果返回NULL，则意味着申请I/O内存失败。</p><p>当用request_mem_region（）申请的I/O内存使用完成后，应当使用release_mem_region（）函数将它们归还给系统，这个函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void release_mem_region(unsigned long start, unsigned long len);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>request_region（）和request_mem_region（）也分别有变体，其为devm_request_region（）和devm_request_mem_region（）。</p><h1>11.4.3　设备I/O端口和I/O内存访问流程</h1><p>综合11.3节和本节的内容，可以归纳出设备驱动访问I/O端口和I/O内存的步骤。</p><p>I/O端口访问的一种途径是直接使用I/O端口操作函数：在设备打开或驱动模块被加载时申请I/O端口区域，之后使用inb（）、outb（）等进行端口访问，最后，在设备关闭或驱动被卸载时释放I/O端口范围。整个流程如图11.10所示。</p><p><img loading="lazy" alt="1743863298618" src="/assets/images/1743863298618-4a7e7ec8738f0c8e4ea6522316100833.png" width="718" height="424" class="img_ev3q"></p><p>图11.10　I/O端口的访问流程</p><p>I/O内存的访问步骤如图11.11所示，首先是调用request_mem_region（）申请资源，接着将寄存器地址通过ioremap（）映射到内核空间虚拟地址，之后就可以通过Linux设备访问编程接口访问这些设备的寄存器了。访问完成后，应对ioremap（）申请的虚拟地址进行释放，并释放release_mem_region（）申请的I/O内存资源。</p><p><img loading="lazy" alt="image-20250405222900505" src="/assets/images/image-20250405222900505-d7b5478a3afa579f8e7afa5ce524a1a8.png" width="738" height="642" class="img_ev3q"></p><p>图11.11　I/O内存访问流程</p><p>有时候，驱动在访问寄存器或I/O端口前，会省去request_mem_region（）、request_region（）这样的调用。</p><h1>11.4.4　将设备地址映射到用户空间</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1内存映射与vma">1.内存映射与VMA<a class="hash-link" href="#1内存映射与vma" title="标题的直接链接">​</a></h2><p>一般情况下，用户空间是不可能也不应该直接访问设备的，但是，设备驱动程序中可实现mmap（）函数，这个函数可使得用户空间能直接访问设备的物理地址。实际上，mmap（）实现了这样的一个映射过程：它将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，实际上会转化为对设备的访问。</p><p>这种能力对于显示适配器一类的设备非常有意义，如果用户空间可直接通过内存映射访问显存的话，屏幕帧的各点像素将不再需要一个从用户空间到内核空间的复制的过程。</p><p>mmap（）必须以PAGE_SIZE为单位进行映射，实际上，内存只能以页为单位进行映射，若要映射非PAGE_SIZE整数倍的地址范围，要先进行页对齐，强行以PAGE_SIZE的倍数大小进行映射。</p><p>从file_operations文件操作结构体可以看出，驱动中mmap（）函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int(*mmap)(struct file *, struct vm_area_struct*);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>驱动中的mmap（）函数将在用户进行mmap（）系统调用时最终被调用，mmap（）系统调用的原型与file_operations中mmap（）的原型区别很大，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">caddr_t  mmap (caddr_t addr, size_t len, int prot, int flags, int fd, off_t offset);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>参数fd为文件描述符，一般由open（）返回，fd也可以指定为-1，此时需指定flags参数中的MAP_ANON，表明进行的是匿名映射。</p><p>len是映射到调用用户空间的字节数，它从被映射文件开头offset个字节开始算起，offset参数一般设为0，表示从文件头开始映射。</p><p>prot参数指定访问权限，可取如下几个值的“或”：PROT_READ（可读）、PROT_WRITE（可写）、PROT_EXEC（可执行）和PROT_NONE（不可访问）。</p><p>参数addr指定文件应被映射到用户空间的起始地址，一般被指定为NULL，这样，选择起始地址的任务将由内核完成，而函数的返回值就是映射到用户空间的地址。其类型caddr_t实际上就是void*。</p><p>当用户调用mmap（）的时候，内核会进行如下处理。</p><p>1）在进程的虚拟空间查找一块VMA。</p><p>2）将这块VMA进行映射。</p><p>3）如果设备驱动程序或者文件系统的file_operations定义了mmap（）操作，则调用它。</p><p>4）将这个VMA插入进程的VMA链表中。</p><p>file_operations中mmap（）函数的第一个参数就是步骤1）找到的VMA。</p><p>由mmap（）系统调用映射的内存可由munmap（）解除映射，这个函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int munmap(caddr_t addr, size_t len );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>驱动程序中mmap（）的实现机制是建立页表，并填充VMA结构体中vm_operations_struct指针。VMA就是vm_area_struct，用于描述一个虚拟内存区域，VMA结构体的定义如代码清单11.4所示。</p><p>代码清单11.4　VMA结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct vm_area_struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  /* The first cache line has the info for VMA tree walking. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  unsigned long vm_start;         /* Our start address within vm_mm. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  unsigned long vm_end;           /* The first byte after our end address</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6                                     within vm_mm. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  /* linked list of VM areas per task, sorted by address */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  struct vm_area_struct *vm_next, *vm_prev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  struct rb_node vm_rb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  /* Second cache line starts here. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  struct mm_struct *vm_mm;         /* The address space we belong to. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  pgprot_t vm_page_prot;           /* Access permissions of this VMA. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  unsigned long vm_flags;          /* Flags, see mm.h. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  const struct vm_operations_struct *vm_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24  /* Information about our backing store: */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  unsigned long vm_pgoff;          /* Offset (within vm_file) in PAGE_SIZE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26                                      units, *not* PAGE_CACHE_SIZE */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  struct file * vm_file;           /* File we map to (can be NULL). */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  void * vm_private_data;          /* was vm_pte (shared mem) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>VMA结构体描述的虚地址介于vm_start和vm_end之间，而其vm_ops成员指向这个VMA的操作集。针对VMA的操作都被包含在vm_operations_struct结构体中，vm_operations_struct结构体的定义如代码清单11.5所示。</p><p>代码清单11.5　vm_operations_struct结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct vm_operations_struct {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  void (*open)(struct vm_area_struct * area);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  void (*close)(struct vm_area_struct * area);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  void (*map_pages)(struct vm_area_struct *vma, struct vm_fault *vmf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  /* notification that a previously read-only page is about to become</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   * writable, if an error is returned it will cause a SIGBUS */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  int (*page_mkwrite)(struct vm_area_struct *vma, struct vm_fault *vmf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  /* called by access_process_vm when get_user_pages() fails, typically</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   * for use by special VMAs that can switch between memory and hardware</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  int (*access)(struct vm_area_struct *vma, unsigned long addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15            void *buf, int len, int write);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>整个vm_operations_struct结构体的实体会在file_operations的mmap（）成员函数里被赋值给相应的vma-&gt;vm_ops，而上述open（）函数也通常在mmap（）里调用，close（）函数会在用户调用munmap（）的时候被调用到。代码清单11.6给出了一个vm_operations_struct的操作范例。</p><p>代码清单11.6　vm_operations_struct操作范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_mmap(struct file *filp, struct vm_area_struct *vma)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  if (remap_pfn_range(vma, vma-&gt;vm_start, vm-&gt;vm_pgoff, vma-&gt;vm_end - vma</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    -&gt;vm_start, vma-&gt;vm_page_prot))/* 建立页表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    return  -EAGAIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  vma-&gt;vm_ops = &amp;xxx_remap_vm_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  xxx_vma_open(vma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11static void xxx_vma_open(struct vm_area_struct *vma)/* VMA打开函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  printk(KERN_NOTICE &quot;xxx VMA open, virt %lx, phys %lx\n&quot;, vma-&gt;vm_start,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18static void xxx_vma_close(struct vm_area_struct *vma)/* VMA关闭函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  printk(KERN_NOTICE &quot;xxx VMA close.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24static struct vm_operations_struct xxx_remap_vm_ops = {/* VMA操作结构体*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  .open = xxx_vma_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  .close = xxx_vma_close,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第3行调用的remap_pfn_range（）创建页表项，以VMA结构体的成员（VMA的数据成员是内核根据用户的请求自己填充的）作为remap_pfn_range（）的参数，映射的虚拟地址范围是vma-&gt;vm_start至vma-&gt;vm_end。</p><p>remap_pfn_range（）函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          unsigned long pfn, unsigned long size, pgprot_t prot);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中的addr参数表示内存映射开始处的虚拟地址。remap_pfn_range（）函数为addr~addr+size的虚拟地址构造页表。</p><p>pfn是虚拟地址应该映射到的物理地址的页帧号，实际上就是物理地址右移PAGE_SHIFT位。若PAGE_SIZE为4KB，则PAGE_SHIFT为12，因为PAGE_SIZE等于1&lt;&lt;PAGE_SHIFT。</p><p>prot是新页所要求的保护属性。</p><p>在驱动程序中，我们能使用remap_pfn_range（）映射内存中的保留页、设备I/O、framebuffer、camera等内存。在remap_pfn_range（）上又可以进一步封装出io_remap_pfn_range（）、vm_iomap_memory（）等API。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define io_remap_pfn_range remap_pfn_range</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long vm_len, pfn, pages;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    len += start &amp; ~PAGE_MASK;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pfn = start &gt;&gt; PAGE_SHIFT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pages = (len + ~PAGE_MASK) &gt;&gt; PAGE_SHIFT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pfn += vma-&gt;vm_pgoff;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pages -= vma-&gt;vm_pgoff;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Can we fit all of the mapping  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    vm_len = vma-&gt;vm_end - vma-&gt;vm_start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Ok, let it rip */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return io_remap_pfn_range(vma, vma-&gt;vm_start, pfn, vm_len, vma-&gt;vm_page_prot);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单11.7给出了LCD驱动映射framebuffer物理地址到用户空间的典型范例，代码取自drivers/video/fbdev/core/fbmem.c。</p><p>代码清单11.7　LCD驱动映射framebuffer的mmap</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2fb_mmap(struct file *file, struct vm_area_struct * vma)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  struct fb_info *info = file_fb_info(file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  struct fb_ops *fb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  unsigned long mmio_pgoff;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  unsigned long start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  u32len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  if (!info)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  fb = info-&gt;fbops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  if (!fb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  mutex_lock(&amp;info-&gt;mm_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  if (fb-&gt;fb_mmap) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       int res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       res = fb-&gt;fb_mmap(info, vma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19       mutex_unlock(&amp;info-&gt;mm_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   * Ugh. This can be either the frame buffer mapping, or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   * if pgoff points past it, the mmio mapping.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  start = info-&gt;fix.smem_start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  len = info-&gt;fix.smem_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  mmio_pgoff = PAGE_ALIGN((start &amp; ~PAGE_MASK) + len) &gt;&gt; PAGE_SHIFT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  if (vma-&gt;vm_pgoff &gt;= mmio_pgoff) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31       if (info-&gt;var.accel_flags) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32             mutex_unlock(&amp;info-&gt;mm_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33             return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36       vma-&gt;vm_pgoff -= mmio_pgoff;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37       start = info-&gt;fix.mmio_start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38       len = info-&gt;fix.mmio_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40  mutex_unlock(&amp;info-&gt;mm_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42  vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43  fb_pgprotect(file, vma, start);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45  return vm_iomap_memory(vma, start, len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通常，I/O内存被映射时需要是nocache的，这时候，我们应该对vma-&gt;vm_page_prot设置nocache标志之后再映射，如代码清单11.8所示。</p><p>代码清单11.8　以nocache方式将内核空间映射到用户空间</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_nocache_mmap(struct file *filp, struct vm_area_struct *vma)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  vma-&gt;vm_page_prot = pgprot_noncached(vma-&gt;vm_page_prot);/* 赋nocache标志 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  vma-&gt;vm_pgoff = ((u32)map_start &gt;&gt; PAGE_SHIFT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  /* 映射*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  if (remap_pfn_range(vma, vma-&gt;vm_start, vma-&gt;vm_pgoff, vma-&gt;vm_end - vma</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    -&gt;vm_start, vma-&gt;vm_page_prot))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    return  -EAGAIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第3行的pgprot_noncached（）是一个宏，它高度依赖于CPU的体系结构，ARM的pgprot_noncached（）定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define pgprot_noncached(prot) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_UNCACHED)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另一个比pgprot_noncached（）稍微少一些限制的宏是pgprot_writecombine（），它的定义如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define pgprot_writecombine(prot) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __pgprot_modify(prot, L_PTE_MT_MASK, L_PTE_MT_BUFFERABLE)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>pgprot_noncached（）实际禁止了相关页的Cache和写缓冲（Write Buffer），pgprot_writecombine（）则没有禁止写缓冲。ARM的写缓冲器是一个非常小的FIFO存储器，位于处理器核与主存之间，其目的在于将处理器核和Cache从较慢的主存写操作中解脱出来。写缓冲区与Cache在存储层次上处于同一层次，但是它只作用于写主存。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2fault函数">2.fault（）函数<a class="hash-link" href="#2fault函数" title="标题的直接链接">​</a></h2><p>除了remap_pfn_range（）以外，在驱动程序中实现VMA的fault（）函数通常可以为设备提供更加灵活的内存映射途径。当访问的页不在内存里，即发生缺页异常时，fault（）会被内核自动调用，而fault（）的具体行为可以自定义。这是因为当发生缺页异常时，系统会经过如下处理过程。</p><p>1）找到缺页的虚拟地址所在的VMA。</p><p>2）如果必要，分配中间页目录表和页表。</p><p>3）如果页表项对应的物理页面不存在，则调用这个VMA的fault（）方法，它返回物理页面的页描迏符。</p><p>4）将物理页面的地址填充到页表中。</p><p>fault（）函数在Linux的早期版本中命名为nopage（），后来变更为了fault（）。代码清单11.9给出了一个设备驱动中使用fault（）的典型范例。</p><p>代码清单11.9　fault（）函数使用范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_fault(struct vm_area_struct *vma, struct vm_fault *vmf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  unsigned long paddr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  unsigned long pfn;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  pgoff_t index = vmf-&gt;pgoff;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  struct vma_data *vdata = vma-&gt;vm_private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  pfn = paddr &gt;&gt; PAGE_SHIFT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  vm_insert_pfn(vma, (unsigned long)vmf-&gt;virtual_address, pfn);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  return VM_FAULT_NOPAGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15} </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>大多数设备驱动都不需要提供设备内存到用户空间的映射能力，因为，对于串口等面向流的设备而言，实现这种映射毫无意义。而对于显示、视频等设备，建立映射可减少用户空间和内核空间之间的内存复制。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.329Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->8 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>计算机系统的硬件主要由CPU、存储器和外设组成。随着IC制作工艺的发展，目前，芯片的集成度越来越高，往往在CPU内部就集成了存储器和外设适配器。譬如，相当多的ARM、PowerPC、MIPS等处理器都集成了UART、I2 C控制器、SPI控制器、USB控制器、SDRAM控制器等，有的处理器还集成了GPU（图形处理器）、视频编解码器等。</p><p>驱动针对的对象是存储器和外设（包括CPU内部集成的存储器和外设），而不是针对CPU内核。Linux将存储器和外设分为3个基础大类。</p><ul><li>字符设备。</li><li>块设备。</li><li>网络设备。</li></ul><p>字符设备指那些必须以串行顺序依次进行访问的设备，如触摸屏、磁带驱动器、鼠标等。块设备可以按任意顺序进行访问，以块为单位进行操作，如硬盘、eMMC等。字符设备和块设备的驱动设计有出很大的差异，但是对于用户而言，它们都要使用文件系统的操作接口open（）、close（）、read（）、write（）等进行访问。</p><p>在Linux系统中，网络设备面向数据包的接收和发送而设计，它并不倾向于对应于文件系统的节点。内核与网络设备的通信与内核和字符设备、网络设备的通信方式完全不同，前者主要还是使用套接字接口。</p><h1>1.4.2　Linux设备驱动与整个软硬件系统的关系</h1><p>如图1.5所示，除网络设备外，字符设备与块设备都被映射到Linux文件系统的文件和目录，通过文件系统的系统调用接口open（）、write（）、read（）、close（）等即可访问字符设备和块设备。所有字符设备和块设备都统一呈现给用户。Linux的块设备有两种访问方法：一种是类似dd命令对应的原始块设备，如“/dev/sdb1”等；另外一种方法是在块设备上建立FAT、EXT4、BTRFS等文件系统，然后以文件路径如“/home/barry/hello.txt”的形式进行访问。在Linux中，针对NOR、NAND等提供了独立的内存技术设备（Memory Technology Device，MTD）子系统，其上运行YAFFS2、JFFS2、UBIFS等具备擦除和负载均衡能力的文件系统。针对磁盘或者Flash设备的FAT、EXT4、YAFFS2、JFFS2、UBIFS等文件系统定义了文件和目录在存储介质上的组织。而Linux的虚拟文件系统则统一对它们进行了抽象。</p><p><img loading="lazy" alt="image-20250320225422303" src="/assets/images/image-20250320225422303-859ea883ab687ec9bc8312c76e1bad0e.png" width="1348" height="895" class="img_ev3q"></p><p>图1.5　Linux设备驱动与整个软硬件系统的关系</p><p>应用程序可以使用Linux的系统调用接口编程，但也可使用C库函数，出于代码可移植性的目的，后者更值得推荐。C库函数本身也通过系统调用接口而实现，如C库函数fopen（）、fwrite（）、fread（）、fclose（）分别会调用操作系统的API open（）、write（）、read（）、close（）。</p><h1>1.4.3　Linux设备驱动的重点、难点</h1><p>Linux设备驱动的学习是一项浩繁的工程，包含如下重点、难点。</p><ul><li>·编写Linux设备驱动要求工程师有非常好的硬件基础，懂得SRAM、Flash、SDRAM、磁盘的读写方式，UART、I2 C、USB等设备的接口以及轮询、中断、DMA的原理，PCI总线的工作方式以及CPU的内存管理单元（MMU）等。</li><li>·编写Linux设备驱动要求工程师有非常好的C语言基础，能灵活地运用C语言的结构体、指针、函数指针及内存动态申请和释放等。</li><li>·编写Linux设备驱动要求工程师有一定的Linux内核基础，虽然并不要求工程师对内核各个部分有深入的研究，但至少要明白驱动与内核的接口。尤其是对于块设备、网络设备、Flash设备、串口设备等复杂设备，内核定义的驱动体系结构本身就非常复杂。</li><li>·编写Linux设备驱动要求工程师有非常好的多任务并发控制和同步的基础，因为在驱动中会大量使用自旋锁、互斥、信号量、等待队列等并发与同步机制。</li></ul><p>上述经验值的获取并非朝夕之事，因此要求我们有足够的学习恒心和毅力。对这些重点、难点，本书都会在相应章节进行讲解。</p><p>动手实践永远是学习任何软件开发的最好方法，学习Linux设备驱动也不例外。因此，本书使用的是通过QEMU模拟的ARM vexpress电路板，本书中的所有实例均可在该“电路板”上直接执行。</p><p>阅读经典书籍和参与Linux社区的讨论也是非常好的学习方法。Linux内核源代码中包含了一个Documentation目录，其中包含了一批内核设计文档，全部是文本文件。很遗憾，这些文档的组织不太好，内容也不够细致。</p><p>学习Linux设备驱动的一个注意事项是要避免管中窥豹、只见树木不见森林，因为各类Linux设备驱动都从属于一个Linux设备驱动的架构，单纯而片面地学习几个函数、几个数据结构是不可能理清驱动中各组成部分之间的关系的。因此，Linux驱动的分析方法是点面结合，将对函数和数据结构的理解放在整体架构的背景之中。这是本书各章节讲解驱动的方法。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.329Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>PowerTop是一款开源的用于进行电量消耗分析和电源管理诊断的工具，其主页位于Intel开源技术中心的<a href="https://01.org/powertop/" target="_blank" rel="noopener noreferrer">https://01.org/powertop/</a> ，维护者是Arjan van de Ven和Kristen Accardi。PowerTop可分析系统中软件的功耗，以便找到功耗大户，也可显示系统中不同的C状态（与CPUIdle驱动对应）和P状态（与CPUFreq驱动对应）的时间比例，并采用了基于TAB的界面风格，如图19.5所示。</p><p><img loading="lazy" alt="1746024806740" src="/assets/images/1746024806740-85d509df42edb72d4ef4bd9b953f0b74.png" width="1344" height="774" class="img_ev3q"></p><p>图19.5　PowerTOP</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/11"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/13"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>