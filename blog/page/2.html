<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/2"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/2"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/2" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/2" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.097Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->6 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>CPLD（复杂可编程逻辑器件）由完全可编程的与或门阵列以及宏单元构成。</p><p>CPLD中的基本逻辑单元是宏单元，宏单元由一些“与或”阵列加上触发器构成，其中“与或”阵列完成组合逻辑功能，触发器完成时序逻辑功能。宏单元中与阵列的输出称为乘积项，其数量标示着CPLD的容量。乘积项阵列实际上就是一个“与或”阵列，每一个交叉点都是一个可编程熔丝，如果导通就是实现“与”逻辑。在“与”阵列后一般还有一个“或”阵列，用以完成最小逻辑表达式中的“或”关系。图2.19所示为非常典型的CPLD的单个宏单元结构</p><p>图2.20给出了一个典型CPLD的整体结构。这个CPLD由LAB（逻辑阵列模块，由多个宏单元组成）通过PIA（可编程互连阵列）互连组成，而CPLD与外部的接口则由I/O控制模块提供。</p><p><img loading="lazy" alt="image-20250323211447557" src="/assets/images/image-20250323211447557-a84cea64ca86fa3034ead23bf46a77bc.png" width="1486" height="945" class="img_ev3q"></p><p>图2.19　典型的CPLD的单个宏单元结构</p><p><img loading="lazy" alt="1742735704639" src="/assets/images/1742735704639-ad6537430caf4088ba783a81d3920f35.png" width="732" height="768" class="img_ev3q"></p><p>图2.20　典型的CPLD整体架构</p><p>图2.20中宏单元的输出会经I/O控制块送至I/O引脚，I/O控制块控制每一个I/O引脚的工作模式，决定其为输入、输出还是双向引脚，并决定其三态输出的使能端控制</p><p>与CPLD不同，FPGA（现场可编程门阵列）基于LUT（查找表）工艺。查找表本质上是一片RAM，当用户通过原理图或HDL（硬件描述语言）描述了一个逻辑电路以后，FPGA开发软件会自动计算逻辑电路所有可能的结果，并把结果事先写入RAM。这样，输入一组信号进行逻辑运算就等于输入一个地址进行查表以输出对应地址的内容。</p><p>图2.21所示为一个典型FPGA的内部结构。这个FPGA由IOC（输入/输出控制模块）、EAB（嵌入式阵列块）、LAB和快速通道互连构成。</p><p><img loading="lazy" alt="1742735769657" src="/assets/images/1742735769657-750e8a155196c4dbace0fe63d4f4ab2e.png" width="1489" height="946" class="img_ev3q"></p><p>图2.21　典型的FPGA内部结构</p><p>IOC是内部信号到I/O引脚的接口，它位于快速通道的行和列的末端，每个IOC包含一个双向I/O缓冲器和一个既可作为输入寄存器也可作为输出寄存器的触发器。</p><p>EAB（嵌入式存储块）是一种输入输出端带有寄存器的非常灵活的RAM。EAB不仅可以用作存储器，还可以事先写入查表值以用来构成如乘法器、纠错逻辑等电路。当用于RAM时，EAB可配制成8位、4位、2位和1位长度的数据格式。</p><p>LAB主要用于逻辑电路设计，一个LAB包括多个LE（逻辑单元），每个LE包括组合逻辑及一个可编程触发器。一系列LAB构成的逻辑阵列可实现普通逻辑功能，如计数器、加法器、状态机等</p><p>器件内部信号的互连和器件引出端之间的信号互连由快速通道连线提供，快速通道遍布于整个FPGA器件中，是一系列水平和垂直走向的连续式布线通道。</p><p>表2.2所示为一个4输入LUT的实际逻辑电路与LUT实现方式的对应关系。</p><p>表2.2　实际逻辑电路与查找表的实现</p><p><img loading="lazy" alt="1742735831146" src="/assets/images/1742735831146-313b2379ac622a0ebc722c3e9f831390.png" width="1488" height="568" class="img_ev3q"></p><p>CPLD和FPGA的主要厂商有Altera、Xilinx和Lattice等，它们采用专门的开发流程，在设计阶段使用HDL（如VHDL、Verilog HDL）编程。它们可以实现许多复杂的功能，如实现UART、I2 C等I/O控制芯片、通信算法、音视频编解码算法等，甚至还可以直接集成ARM等CPU内核和外围电路。</p><p>对于驱动工程师而言，我们只需要这样看待CPLD和FPGA：如果它完成的是特定的接口和控制功能，我们就直接把它当成由很多逻辑门（与、非、或、D触发器）组成的可完成一系列时序逻辑和组合逻辑的ASIC；如果它完成的是CPU的功能，我们就直接把它当成CPU。驱动工程师眼里的硬件比IC设计师要宏观。</p><p>值得一提的是，Xilinx公司还推出了ZYNQ芯片，内部同时集成了两个Cortex-A9ARM多处理器子系统和可编程逻辑FPGA，同时可编程逻辑可由用户配置。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.093Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux 2.4内核中，模块自身通过MOD_INC_USE_COUNT、MOD_DEC_USE_COUNT宏来管理自己被使用的计数。</p><p>Linux 2.6以后的内核提供了模块计数管理接口try_module_get（&amp;module）和module_put（&amp;module），从而取代Linux 2.4内核中的模块使用计数管理宏。模块的使用计数一般不必由模块自身管理，而且模块计数管理还考虑了SMP与PREEMPT机制的影响。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int try_module_get(struct module *module);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于增加模块使用计数；若返回为0，表示调用失败，希望使用的模块没有被加载或正在被卸载中。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void module_put(struct module *module);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于减少模块使用计数。</p><p>try_module_get（）和module_put（）的引入、使用与Linux 2.6以后的内核下的设备模型密切相关。Linux 2.6以后的内核为不同类型的设备定义了struct module*owner域，用来指向管理此设备的模块。当开始使用某个设备时，内核使用try_module_get（dev-&gt;owner）去增加管理此设备的owner模块的使用计数；当不再使用此设备时，内核使用module_put（dev-&gt;owner）减少对管理此设备的管理模块的使用计数。这样，当设备在使用时，管理此设备的模块将不能被卸载。只有当设备不再被使用时，模块才允许被卸载。</p><p>在Linux 2.6以后的内核下，对于设备驱动而言，很少需要亲自调用try_module_get（）与module_put（），因为此时开发人员所写的驱动通常为支持某具体设备的管理模块，对此设备owner模块的计数管理由内核里更底层的代码（如总线驱动或是此类设备共用的核心模块）来实现，从而简化了设备驱动开发。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.085Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>vmem_disk是一种模拟磁盘，其数据实际上存储在RAM中。它使用通过vmalloc（）分配出来的内存空间来模拟出一个磁盘，以块设备的方式来访问这片内存。该驱动是对字符设备驱动章节中globalmem驱动的块方式改造。</p><p>加载vmem_disk.ko后，在使用默认模块参数的情况下，系统会增加4个块设备节点：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># ls -l /dev/vmem_disk*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">brw-rw---- 1 root disk 252,  0  2月</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25 14:00 /dev/vmem_diska</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">brw-rw---- 1 root disk 252, 16  2月</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25 14:00 /dev/vmem_diskb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">brw-rw---- 1 root disk 252, 32  2月</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25 14:00 /dev/vmem_diskc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">brw-rw---- 1 root disk 252, 48  2月</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25 14:00 /dev/vmem_diskd</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中，mkfs.ext2/dev/vmem_diska命令的执行会回馈如下信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ sudo mkfs.ext2  /dev/vmem_diska</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mke2fs 1.42.9 (4-Feb-2014)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Filesystem label=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">OS type: Linux</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Block size=1024 (log=0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Fragment size=1024 (log=0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Stride=0 blocks, Stripe width=0blocks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64 inodes, 512 blocks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 blocks (4.88%) reserved for the super user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">First data block=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Maximum filesystem blocks=524288</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1 block group</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8192 blocks per group, 8192fragments per group</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64 inodes per group</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Allocating group tables: done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Writing inode tables: done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Writing superblocks and filesystem accounting information: done</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它将/dev/vmem_diska格式化为EXT2文件系统。之后我们可以mount这个分区并在其中进行文件读写。</p><h1>13.7.2　vmem_disk驱动模块的加载与卸载</h1><p>vmem_disk驱动的模块加载函数完成的工作与13.3节给出的模板完全一致，它支持“制造请求”（对应于代码清单13.9）、请求队列（对应于代码清单13.10）两种模式（请注意在请求队列方面又支持简、繁两种模式），使用模块参数request_mode进行区分。代码清单13.13给出了vmem_disk设备驱动的模块加载与卸载函数。</p><p>代码清单13.13　vmem_disk设备驱动的模块加载与卸载函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void setup_device(struct vmem_disk_dev *dev, int which)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    memset (dev, 0, sizeof (struct vmem_disk_dev));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    dev-&gt;size = NSECTORS*HARDSECT_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    dev-&gt;data = vmalloc(dev-&gt;size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    if (dev-&gt;data == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        printk (KERN_NOTICE &quot;vmalloc failure.\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    spin_lock_init(&amp;dev-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     * The I/O queue, depending on whether we are using our own</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14     * make_request function or not.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    switch (request_mode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    case VMEMD_NOQUEUE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        dev-&gt;queue = blk_alloc_queue(GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        if (dev-&gt;queue == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20            goto out_vfree;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        blk_queue_make_request(dev-&gt;queue, vmem_disk_make_request);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        printk(KERN_NOTICE &quot;Bad request mode %d, using simple\n&quot;, request_mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    case VMEMD_QUEUE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        dev-&gt;queue = blk_init_queue(vmem_disk_request, &amp;dev-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        if (dev-&gt;queue == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28            goto out_vfree;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    blk_queue_logical_block_size(dev-&gt;queue, HARDSECT_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32    dev-&gt;queue-&gt;queuedata = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34    dev-&gt;gd = alloc_disk(VMEM_DISK_MINORS);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35    if (!dev-&gt;gd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36        printk (KERN_NOTICE &quot;alloc_disk failure\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        goto out_vfree;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    dev-&gt;gd-&gt;major = vmem_disk_major;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40    dev-&gt;gd-&gt;first_minor = which*VMEM_DISK_MINORS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41    dev-&gt;gd-&gt;fops = &amp;vmem_disk_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42    dev-&gt;gd-&gt;queue = dev-&gt;queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43    dev-&gt;gd-&gt;private_data = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44    snprintf (dev-&gt;gd-&gt;disk_name, 32, &quot;vmem_disk%c&quot;, which + &#x27;a&#x27;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45    set_capacity(dev-&gt;gd, NSECTORS*(HARDSECT_SIZE/KERNEL_SECTOR_SIZE));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    add_disk(dev-&gt;gd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47    return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49out_vfree:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50    if (dev-&gt;data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51        vfree(dev-&gt;data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55static int __init vmem_disk_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59    vmem_disk_major = register_blkdev(vmem_disk_major, &quot;vmem_disk&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60    if (vmem_disk_major &lt;= 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61        printk(KERN_WARNING &quot;vmem_disk: unable to get major number\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62        return -EBUSY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65    devices = kmalloc(NDEVICES*sizeof (struct vmem_disk_dev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66    if (!devices)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67        goto out_unregister;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68    for (i = 0; i &lt; NDEVICES; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69        setup_device(devices + i, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73out_unregister:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74    unregister_blkdev(vmem_disk_major, &quot;sbd&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75    return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77module_init(vmem_disk_init);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意上述代码的第16~30行，我们实际上支持两种I/O请求模式，一种是make_request，另一种是request_queue。make_request的版本直接使用vmem_disk_make_request（）来处理bio，而request_queue的版本则使用vmem_disk_request来处理请求队列。</p><h1>13.7.3　vmem_disk设备驱动的block_device_operations</h1><p>vmem_disk提供block_device_operations结构体中的getgeo（）成员函数，代码清单13.14给出了vmem_disk设备驱动的block_device_operations结构体定义及其成员函数的实现。</p><p>代码清单13.14　vmem_disk设备驱动的block_device_operations结构体及成员函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int vmem_disk_getgeo(struct block_device *bdev, struct hd_geometry *geo)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    long size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    struct vmem_disk_dev *dev = bdev-&gt;bd_disk-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    size = dev-&gt;size*(HARDSECT_SIZE/KERNEL_SECTOR_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    geo-&gt;cylinders = (size &amp; ~0x3f) &gt;&gt; 6;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    geo-&gt;heads = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    geo-&gt;sectors = 16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    geo-&gt;start = 4;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15static struct block_device_operations vmem_disk_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    .getgeo          = vmem_disk_getgeo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>13.7.4　vmem_disk的I/O请求处理</h1><p>在vmem_disk驱动中，通过模块参数request_mode的方式来支持3种不同的请求处理模式以加深读者对它们的理解，代码清单13.15列出了vmem_disk设备驱动的请求处理代码。</p><p>代码清单13.15　vmem_disk设备驱动的请求处理函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 * Handle an I/O request.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4static void vmem_disk_transfer(struct vmem_disk_dev *dev, unsigned long sector,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        unsigned long nsect, char *buffer, int write)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    unsigned long offset = sector*KERNEL_SECTOR_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    unsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    if ((offset + nbytes) &gt; dev-&gt;size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        printk (KERN_NOTICE &quot;Beyond-end write (%ld %ld)\n&quot;, offset, nbytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    if (write)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        memcpy(dev-&gt;data + offset, buffer, nbytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        memcpy(buffer, dev-&gt;data + offset, nbytes);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 * Transfer a single BIO.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23static int vmem_disk_xfer_bio(struct vmem_disk_dev *dev, struct bio *bio)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        struct bio_vec bvec;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        struct bvec_iter iter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        sector_t sector = bio-&gt;bi_iter.bi_sector;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    bio_for_each_segment(bvec, bio, iter) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        char *buffer = __bio_kmap_atomic(bio, iter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31        vmem_disk_transfer(dev, sector, bio_cur_bytes(bio) &gt;&gt; 9,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32            buffer, bio_data_dir(bio) == WRITE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        sector += bio_cur_bytes(bio) &gt;&gt; 9;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34        __bio_kunmap_atomic(buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 * The request_queue version.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42static void vmem_disk_request(struct request_queue *q)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44    struct request *req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45    struct bio *bio;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47    while ((req = blk_peek_request(q)) != NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48        struct vmem_disk_dev *dev = req-&gt;rq_disk-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49        if (req-&gt;cmd_type != REQ_TYPE_FS) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50            printk (KERN_NOTICE &quot;Skip non-fs request\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51            blk_start_request(req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52            __blk_end_request_all(req, -EIO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53            continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56        blk_start_request(req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57        __rq_for_each_bio(bio, req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58            vmem_disk_xfer_bio(dev, bio);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59        __blk_end_request_all(req, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65 * The direct make request version.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67static void vmem_disk_make_request(struct request_queue *q, struct bio *bio)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69    struct vmem_disk_dev *dev = q-&gt;queuedata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70    int status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72    status = vmem_disk_xfer_bio(dev, bio);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73    bio_endio(bio, status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第4行的vmem_disk_transfer（）完成真实的硬件I/O操作（对于本例而言，就是一个memcpy），第23行的vmem_disk_xfer_bio（）函数调用它来完成一个与bio对应的硬件操作，在完成的过程中通过第29行的bio_for_each_segment（）展开了该bio中的每个segment。</p><p>vmem_disk_make_request（）直接调用vmem_disk_xfer_bio（）来完成一个bio操作，而vmem_disk_request（）则通过第47行的blk_peek_request（）先从request_queue拿出一个请求，再通过第57行的__rq_for_each_bio（）从该请求中取出一个bio，之后调用vmem_disk_xfer_bio（）来完成该I/O请求，图13.4描述了这个过程。</p><p><img loading="lazy" src="G:%5Ctypora%E6%96%87%E6%A1%A3%5Clinux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3%5C1744814119520.png" alt="1744814119520" class="img_ev3q"></p><p>图13.4　vmem_disk的I/O处理过程</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.081Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Regulator是Linux系统中电源管理的基础设施之一，用于稳压电源的管理，是各种驱动子系统中设置电压的标准接口。前面介绍的CPUFreq驱动就经常使用它来设定电压，比如代码清单19.2的第57~59行。</p><p>而Regulator则可以管理系统中的供电单元，即稳压器（Low Dropout Regulator，LDO，即低压差线性稳压器），并提供获取和设置这些供电单元电压的接口。一般在ARM电路板上，各个稳压器和设备会形成一个Regulator树形结构，如图19.6所示。</p><p>Linux的Regulator子系统提供如下API以用于注册/注销一个稳压器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">structregulator_dev     *        regulator_register(conststructregulator_desc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*regulator_desc, conststructregulator_config *config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">voidregulator_unregister(structregulator_dev *rdev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>regulator_register（）函数的两个参数分别是regulator_desc结构体和regulator_config结构体的指针。</p><p><img loading="lazy" alt="image-20250430225501894" src="/assets/images/image-20250430225501894-e744352b7ff398de6941b237cec59f8c.png" width="1377" height="769" class="img_ev3q"></p><p>图19.6　Regulator树形结构</p><p>regulator_desc结构体是对这个稳压器属性和操作的封装，如代码清单19.7所示。</p><p>代码清单19.7　regulator_desc结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct regulator_desc {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2       const char *name;                /* Regulator的名字*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       const char *supply_name;         /* Regulator Supply的名字*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       int id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       unsigned n_voltages;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       struct regulator_ops *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       int irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       enum regulator_type type;        /* 是电压还是电流Regulator */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       struct module *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       unsigned int min_uV;             /* 在线性映射情况下最低的Selector的电压*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       unsigned int uV_step;            /* 在线性映射情况下每步增加/减小的电压*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       unsigned int ramp_delay;         /* 电压改变后稳定下来所需时间*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       const unsigned int *volt_table;    /* 基于表映射情况下的电压映射表 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       unsigned int vsel_reg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       unsigned int vsel_mask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19       unsigned int enable_reg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       unsigned int enable_mask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       unsigned int bypass_reg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22       unsigned int bypass_mask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       unsigned int enable_time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述结构体中的regulator_ops指针ops是对这个稳压器硬件操作的封装，其中包含获取、设置电压等的成员函数，如代码清单19.8所示。</p><p>代码清单19.8　regulator_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct regulator_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      /* enumerate supported voltages */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      int (*list_voltage) (struct regulator_dev *, unsigned selector);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      /* get/set regulator voltage */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      int (*set_voltage) (struct regulator_dev *, int min_uV, int max_uV,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                       unsigned *selector);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      int (*map_voltage)(struct regulator_dev *, int min_uV, int max_uV);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      int (*set_voltage_sel) (struct regulator_dev *, unsigned selector);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      int (*get_voltage) (struct regulator_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11      int (*get_voltage_sel) (struct regulator_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      /* get/set regulator current  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      int (*set_current_limit) (struct regulator_dev *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                           int min_uA, int max_uA);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      int (*get_current_limit) (struct regulator_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18      /* enable/disable regulator */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      int (*enable) (struct regulator_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20      int (*disable) (struct regulator_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21      int (*is_enabled) (struct regulator_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在drivers/regulator目录下，包含大量的与电源芯片对应的Regulator驱动，如Dialog的DA9052、Intersil的ISL6271A、ST-Ericsson的TPS61050/61052、Wolfon的WM831x系列等，它同时提供了一个虚拟的Regulator驱动作为参考，如代码清单19.9所示。</p><p>代码清单19.9　虚拟的Regulator驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct regulator_dev *dummy_regulator_rdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2static struct regulator_init_data dummy_initdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3static struct regulator_ops dummy_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4static struct regulator_desc dummy_desc = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       .name = &quot;regulator-dummy&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       .id = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       .type = REGULATOR_VOLTAGE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       .ops = &amp;dummy_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12static int __devinit dummy_regulator_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       struct regulator_config config = { };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       config.dev = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       config.init_data = &amp;dummy_initdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       dummy_regulator_rdev = regulator_register(&amp;dummy_desc, &amp;config);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       if (IS_ERR(dummy_regulator_rdev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22              ret = PTR_ERR(dummy_regulator_rdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23              pr_err(&quot;Failed to register regulator: %d\n&quot;, ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24              return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Linux的Regulator子系统提供消费者（Consumer）API以便让其他的驱动获取、设置、关闭和使能稳压器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">structregulator * regulator_get(structdevice *dev, const char *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">structregulator * devm_regulator_get(structdevice *dev, const char *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">structregulator * regulator_get_exclusive(structdevice *dev, const char *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">voidregulator_put(structregulator *regulator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">voiddevm_regulator_put(structregulator *regulator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">intregulator_enable(structregulator *regulator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">intregulator_disable(structregulator *regulator);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">intregulator_set_voltage(structregulator *regulator, intmin_uV, intmax_uV);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">intregulator_get_voltage(structregulator *regulator);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这些消费者API的地位大致与GPIO子系统的gpio_request（）、时钟子系统的clk_get（）、dmaengine子系统的dmaengine_submit（）等相当，属于基础设施。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.069Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在将Linux移植到目标电路板的过程中，有得会建立外设I/O内存物理地址到虚拟地址的静态映射，这个映射通过在与电路板对应的map_desc结构体数组中添加新的成员来完成，map_desc结构体的定义如代码清单11.10所示。</p><p>代码清单11.10　map_desc结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct map_desc {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2  unsigned long virtual;        /* 虚拟地址*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3  unsigned long pfn ;           /* __phys_to_pfn(phy_addr) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4  unsigned long length;         /* 大小*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5  unsigned int type;            /* 类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>例如，在内核arch/arm/mach-ixp2000/ixdp2x01.c文件对应的Intel IXDP2401和IXDP2801平台上包含一个CPLD，该文件中就进行了CPLD物理地址到虚拟地址的静态映射，如代码清单11.11所示。</p><p>代码清单11.11　在电路板文件中增加物理地址到虚拟地址的静态映射</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct map_desc ixdp2x01_io_desc _ _initdata = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2       .virtual        = IXDP2X01_VIRT_CPLD_BASE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       .pfn            = _ _phys_to_pfn(IXDP2X01_PHYS_CPLD_BASE),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       .length         = IXDP2X01_CPLD_REGION_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       .type           = MT_DEVICE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8static void _ _init ixdp2x01_map_io(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       ixp2000_map_io();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       iotable_init(&amp;ixdp2x01_io_desc, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单11.11中的第11行iotable_init（）是最终建立页映射的函数，它通过MACHINE_START、MACHINE_END宏赋值给电路板的map_io（）函数。将Linux操作系统移植到特定平台上，MACHINE_START（或者DT_MACHINE_START）、MACHINE_END宏之间的定义针对特定电路板而设计，其中的map_io（）成员函数完成I/O内存的静态映射。</p><p>在一个已经移植好操作系统的内核中，驱动工程师可以对非常规内存区域的I/O内存（外设控制器寄存器、MCU内部集成的外设控制器寄存器等）依照电路板的资源使用情况添加到map_desc数组中，但是目前该方法已经不值得推荐。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.057Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->17 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux内核中，使用cdev结构体描述一个字符设备，cdev结构体的定义如代码清单6.1。</p><p>代码清单6.1　cdev结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct cdev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2  struct kobject kobj;             /* 内嵌的kobject对象*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3  struct module *owner;            /* 所属模块*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4  struct file_operations *ops;     /* 文件操作结构体*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5  struct list_head list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6  dev_t dev;                       /* 设备号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7  unsigned int count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>cdev结构体的dev_t成员定义了设备号，为32位，其中12位为主设备号，20位为次设备号。使用下列宏可以从dev_t获得主设备号和次设备号：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MAJOR(dev_t dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MINOR(dev_t dev)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而使用下列宏则可以通过主设备号和次设备号生成dev_t：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MKDEV(int major, int minor)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>cdev结构体的另一个重要成员file_operations定义了字符设备驱动提供给虚拟文件系统的接口函数。</p><p>Linux内核提供了一组函数以用于操作cdev结构体：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void cdev_init(struct cdev *, struct file_operations *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct cdev *cdev_alloc(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void cdev_put(struct cdev *p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int cdev_add(struct cdev *, dev_t, unsigned);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void cdev_del(struct cdev *);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>cdev_init（）函数用于初始化cdev的成员，并建立cdev和file_operations之间的连接，其源代码如代码清单6.2所示。</p><p>代码清单6.2　cdev_init（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1void cdev_init(struct cdev *cdev, struct file_operations *fops)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3    memset(cdev, 0, sizeof *cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4    INIT_LIST_HEAD(&amp;cdev-&gt;list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6    cdev-&gt;ops = fops; /* 将传入的文件操作结构体指针赋值给cdev的ops*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>cdev_alloc（）函数用于动态申请一个cdev内存，其源代码如代码清单6.3所示。</p><p>代码清单6.3　cdev_alloc（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct cdev *cdev_alloc(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3        struct cdev *p = kzalloc(sizeof(struct cdev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4        if (p) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5            INIT_LIST_HEAD(&amp;p-&gt;list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6            kobject_init(&amp;p-&gt;kobj, &amp;ktype_cdev_dynamic);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8        return p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>cdev_add（）函数和cdev_del（）函数分别向系统添加和删除一个cdev，完成字符设备的注册和注销。对cdev_add（）的调用通常发生在字符设备驱动模块加载函数中，而对cdev_del（）函数的调用则通常发生在字符设备驱动模块卸载函数中。</p><h1>6.1.2　分配和释放设备号</h1><p>在调用cdev_add（）函数向系统注册字符设备之前，应首先调用register_chrdev_region（）或alloc_chrdev_region（）函数向系统申请设备号，这两个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int register_chrdev_region(dev_t from, unsigned count, const char *name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              const char *name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>register_chrdev_region（）函数用于已知起始设备的设备号的情况，而alloc_chrdev_region（）用于设备号未知，向系统动态申请未被占用的设备号的情况，函数调用成功之后，会把得到的设备号放入第一个参数dev中。alloc_chrdev_region（）相比于register_chrdev_region（）的优点在于它会自动避开设备号重复的冲突。</p><p>相应地，在调用cdev_del（）函数从系统注销字符设备之后，unregister_chrdev_region（）应该被调用以释放原先申请的设备号，这个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void unregister_chrdev_region(dev_t from, unsigned count);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6.1.3　file_operations结构体</h1><p>file_operations结构体中的成员函数是字符设备驱动程序设计的主体内容，这些函数实际会在应用程序进行Linux的open（）、write（）、read（）、close（）等系统调用时最终被内核调用。file_operations结构体目前已经比较庞大，它的定义如代码清单6.4所示。</p><p>代码清单6.4　file_operations结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct file_operations {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct module *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loff_t (*llseek) (struct file *, loff_t, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*iterate) (struct file *, struct dir_context *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*iterate_shared) (struct file *, struct dir_context *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __poll_t (*poll) (struct file *, struct poll_table_struct *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*mmap) (struct file *, struct vm_area_struct *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long mmap_supported_flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*open) (struct inode *, struct file *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*flush) (struct file *, fl_owner_t id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*release) (struct inode *, struct file *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*fsync) (struct file *, loff_t, loff_t, int datasync);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*fasync) (int, struct file *, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*lock) (struct file *, int, struct file_lock *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*check_flags)(int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*flock) (struct file *, int, struct file_lock *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*setlease)(struct file *, long, struct file_lock **, void **);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long (*fallocate)(struct file *file, int mode, loff_t offset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              loff_t len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifndef CONFIG_MMU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned (*mmap_capabilities)(struct file *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            loff_t, size_t, unsigned int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   struct file *file_out, loff_t pos_out,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   loff_t len, unsigned int remap_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int (*fadvise)(struct file *, loff_t, loff_t, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} __randomize_layout;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面我们对file_operations结构体中的主要成员进行分析。</p><p>llseek（）函数用来修改一个文件的当前读写位置，并将新位置返回，在出错时，这个函数返回一个负值。</p><p>read（）函数用来从设备中读取数据，成功时函数返回读取的字节数，出错时返回一个负值。它与用户空间应用程序中的ssize_t read（int fd，void<em>buf，size_t count）和size_t fread（void</em>ptr，size_t size，size_t nmemb，FILE*stream）对应。</p><p>write（）函数向设备发送数据，成功时该函数返回写入的字节数。如果此函数未被实现，当用户进行write（）系统调用时，将得到-EINVAL返回值。它与用户空间应用程序中的ssize_t write（int fd，const void<em>buf，size_t count）和size_t fwrite（const void</em>ptr，size_t size，size_t nmemb，FILE*stream）对应。</p><p>read（）和write（）如果返回0，则暗示end-of-file（EOF）。</p><p>unlocked_ioctl（）提供设备相关控制命令的实现（既不是读操作，也不是写操作），当调用成功时，返回给调用程序一个非负值。它与用户空间应用程序调用的int fcntl（int fd，int cmd，.../<em>arg</em>/）和int ioctl（int d，int request，...）对应。</p><p>mmap（）函数将设备内存映射到进程的虚拟地址空间中，如果设备驱动未实现此函数，用户进行mmap（）系统调用时将获得-ENODEV返回值。这个函数对于帧缓冲等设备特别有意义，帧缓冲被映射到用户空间后，应用程序可以直接访问它而无须在内核和应用间进行内存复制。它与用户空间应用程序中的void<em>mmap（void</em>addr，size_t length，int prot，int flags，int fd，off_t offset）函数对应。</p><p>当用户空间调用Linux API函数open（）打开设备文件时，设备驱动的open（）函数最终被调用。驱动程序可以不实现这个函数，在这种情况下，设备的打开操作永远成功。与open（）函数对应的是release（）函数。</p><p>poll（）函数一般用于询问设备是否可被非阻塞地立即读写。当询问的条件未触发时，用户空间进行select（）和poll（）系统调用将引起进程的阻塞。</p><p>aio_read（）和aio_write（）函数分别对与文件描述符对应的设备进行异步读、写操作。设备实现这两个函数后，用户空间可以对该设备文件描述符执行SYS_io_setup、SYS_io_submit、SYS_io_getevents、SYS_io_destroy等系统调用进行读写。</p><h1>6.1.4　Linux字符设备驱动的组成</h1><p>在Linux中，字符设备驱动由如下几个部分组成。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1字符设备驱动模块加载与卸载函数">1.字符设备驱动模块加载与卸载函数<a class="hash-link" href="#1字符设备驱动模块加载与卸载函数" title="标题的直接链接">​</a></h2><p>在字符设备驱动模块加载函数中应该实现设备号的申请和cdev的注册，而在卸载函数中应实现设备号的释放和cdev的注销。</p><p>Linux内核的编码习惯是为设备定义一个设备相关的结构体，该结构体包含设备所涉及的cdev、私有数据及锁等信息。常见的设备结构体、模块加载和卸载函数形式如代码清单6.5所示。</p><p>代码清单6.5　字符设备驱动模块加载与卸载函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 设备结构体</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2struct xxx_dev_t {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    struct cdev cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5} xxx_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6/* 设备驱动模块加载函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7static int _ _init xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  cdev_init(&amp;xxx_dev.cdev, &amp;xxx_fops);         /* 初始化cdev */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  xxx_dev.cdev.owner = THIS_MODULE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  /* 获取字符设备号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  if (xxx_major) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      register_chrdev_region(xxx_dev_no, 1, DEV_NAME);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      alloc_chrdev_region(&amp;xxx_dev_no, 0, 1, DEV_NAME);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  ret = cdev_add(&amp;xxx_dev.cdev, xxx_dev_no, 1);  /* 注册设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22/* 设备驱动模块卸载函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23static void _ _exit xxx_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   unregister_chrdev_region(xxx_dev_no, 1);      /* 释放占用的设备号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   cdev_del(&amp;xxx_dev.cdev);                      /* 注销设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2字符设备驱动的file_operations结构体中的成员函数">2.字符设备驱动的file_operations结构体中的成员函数<a class="hash-link" href="#2字符设备驱动的file_operations结构体中的成员函数" title="标题的直接链接">​</a></h2><p>file_operations结构体中的成员函数是字符设备驱动与内核虚拟文件系统的接口，是用户空间对Linux进行系统调用最终的落实者。大多数字符设备驱动会实现read（）、write（）和ioctl（）函数，常见的字符设备驱动的这3个函数的形式如代码清单6.6所示。</p><p>代码清单6.6　字符设备驱动读、写、I/O控制函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 /* 读设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 ssize_t xxx_read(struct file *filp, char __user *buf, size_t count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    loff_t*f_pos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    copy_to_user(buf, ..., ...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 /* 写设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 ssize_t xxx_write(struct file *filp, const char __user *buf, size_t count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11    loff_t *f_pos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    copy_from_user(..., buf, ...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 /* ioctl函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 long xxx_ioctl(struct file *filp, unsigned int cmd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22    switch (cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    case XXX_CMD1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26    case XXX_CMD2:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30         /* 不能支持的命令*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31         return  - ENOTTY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>设备驱动的读函数中，filp是文件结构体指针，buf是用户空间内存的地址，该地址在内核空间不宜直接读写，count是要读的字节数，f_pos是读的位置相对于文件开头的偏移。</p><p>设备驱动的写函数中，filp是文件结构体指针，buf是用户空间内存的地址，该地址在内核空间不宜直接读写，count是要写的字节数，f_pos是写的位置相对于文件开头的偏移。</p><p>由于用户空间不能直接访问内核空间的内存，因此借助了函数copy_from_user（）完成用户空间缓冲区到内核空间的复制，以及copy_to_user（）完成内核空间到用户空间缓冲区的复制，见代码第6行和第14行。</p><p>完成内核空间和用户空间内存复制的copy_from_user（）和copy_to_user（）的原型分别为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long copy_from_user(void *to, const void _ _user *from, unsigned long count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long copy_to_user(void _ _user *to, const void *from, unsigned long count);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数均返回不能被复制的字节数，因此，如果完全复制成功，返回值为0。如果复制失败，则返回负值。</p><p>如果要复制的内存是简单类型，如char、int、long等，则可以使用简单的put_user（）和get_user（），如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int val;                         /* 内核空间整型变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">get_user(val, (int *) arg);      /* 用户→内核，arg是用户空间的地址 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">put_user(val, (int *) arg);      /* 内核→用户，arg是用户空间的地址 */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>读和写函数中的_user是一个宏，表明其后的指针指向用户空间，实际上更多地充当了代码自注释的功能。这个宏定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef _ _CHECKER_ _</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># define _ _user      _ _attribute_ _((noderef, address_space(1)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># define _ _user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>内核空间虽然可以访问用户空间的缓冲区，但是在访问之前，一般需要先检查其合法性，通过access_ok（type，addr，size）进行判断，以确定传入的缓冲区的确属于用户空间，例如</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static ssize_t read_port(struct file *file, char __user *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned long i = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char __user *tmp = buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!access_ok(VERIFY_WRITE, buf, count))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        while (count-- &gt; 0 &amp;&amp; i &lt; 65536) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (__put_user(inb(i), tmp) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                i++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                tmp++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *ppos = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return tmp-buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中引用的<strong>put_user（）与前文讲解的put_user（）的区别在于前者不进行类似access_ok（）的检查，而后者会进行这一检查。在本例中，不使用put_user（）而使用</strong>put_user（）的原因是在<strong>put_user（）调用之前，已经手动检查了用户空间缓冲区（buf指向的大小为count的内存）的合法性。get_user（）和</strong>get_user（）的区别也相似。</p><p>特别要提醒读者注意的是：在内核空间与用户空间的界面处，内核检查用户空间缓冲区的合法性显得尤其必要，Linux内核的许多安全漏洞都是因为遗忘了这一检查造成的，非法侵入者可以伪造一片内核空间的缓冲区地址传入系统调用的接口，让内核对这个evil指针指向的内核空间填充数据。有兴趣的读者可以从<a href="http://www.cvedetails.com/" target="_blank" rel="noopener noreferrer">http://www.cvedetails.com/</a> 网站查阅Linux CVE（Common Vulnerabilities and Exposures）列表。</p><p>其实copy_from_user（）、copy_to_user（）内部也进行了这样的检查：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline unsigned long __must_check copy_from_user(void *to, const void __user</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *from, unsigned long n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (access_ok(VERIFY_READ, from, n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                n = __copy_from_user(to, from, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else /* security hole - plug it */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                memset(to, 0, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline unsigned long __must_check copy_to_user(void __user *to, const void</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *from, unsigned long n)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (access_ok(VERIFY_WRITE, to, n))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                n = __copy_to_user(to, from, n);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>I/O控制函数的cmd参数为事先定义的I/O控制命令，而arg为对应于该命令的参数。例如对于串行设备，如果SET_BAUDRATE是一道设置波特率的命令，那后面的arg就应该是波特率值。</p><p>在字符设备驱动中，需要定义一个file_operations的实例，并将具体设备驱动的函数赋值给file_operations的成员，如代码清单6.7所示。</p><p>代码清单6.7　字符设备驱动文件操作结构体模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct file_operations xxx_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2     .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3     .read = xxx_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4     .write = xxx_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5     .unlocked_ioctl= xxx_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述xxx_fops在代码清单6.5第10行的cdev_init（&amp;xxx_dev.cdev，&amp;xxx_fops）的语句中建立与cdev的连接。</p><p>图6.1所示为字符设备驱动的结构、字符设备驱动与字符设备以及字符设备驱动与用户空间访问该设备的程序之间的关系。</p><p><img loading="lazy" alt="1742913494444" src="/assets/images/1742913494444-cf3980e830bba576f86df2ff2cbbae2c.png" width="1369" height="522" class="img_ev3q"></p><p>图6.1　字符设备驱动的结构</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.041Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->35 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在12.1节，我们已经从感性上认识了Linux驱动软件分层的意义。其实，在分层设计的时候，Linux内核大量使用了面向对象的设计思想。</p><p>在面向对象的程序设计中，可以为某一类相似的事物定义一个基类，而具体的事物可以继承这个基类中的函数。如果对于继承的这个事物而言，某成员函数的实现与基类一致，那它就可以直接继承基类的函数；相反，它也可以重写（Overriding），对父类的函数进行重新定义。若子类中的方法与父类中的某方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。这种面向对象的“多态”设计思想极大地提高了代码的可重用能力，是对现实世界中事物之间关系的一种良好呈现。</p><p>Linux内核完全是由C语言和汇编语言写成，但是却频繁地用到了面向对象的设计思想。在设备驱动方面，往往为同类的设备设计了一个框架，而框架中的核心层则实现了该设备通用的一些功能。同样的，如果具体的设备不想使用核心层的函数，也可以重写。举个例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">return_type core_funca(xxx_device * bottom_dev, param1_type param1, param1_type param2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bottom_dev-&gt;funca)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bottom_dev-&gt;funca(param1, param2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* 核心层通用的funca代码*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述core_funca的实现中，会检查底层设备是否重写了funca（），如果重写了，就调用底层的代码，否则，直接使用通用层的。这样做的好处是，核心层的代码可以处理绝大多数与该类设备的funca（）对应的功能，只有少数特殊设备需要重新实现funca（）。</p><p>再看一个例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">return_type core_funca(xxx_device * bottom_dev, param1_type param1, param1_type param2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /*通用的步骤代码A */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typea_dev_commonA();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* 底层操作ops1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bottom_dev-&gt;funca_ops1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /*通用的步骤代码B */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typea_dev_commonB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* 底层操作ops2 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bottom_dev-&gt;funca_ops2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /*通用的步骤代码C */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typea_dev_commonB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /** 底层操作ops3*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bottom_dev-&gt;funca_ops3();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码假定为了实现funca（），对于同类设备而言，操作流程一致，都要经过“通用代码A、底层ops1、通用代码B、底层ops2、通用代码C、底层ops3”这几步，分层设计带来的明显好处是，对于通用代码A、B、C，具体的底层驱动不需要再实现，而仅仅只要关心其底层的操作ops1、ops2、ops3则可。</p><p>图12.5明确反映了设备驱动的核心层与具体设备驱动的关系，实际上，这种分层可能只有两层（见图12.5a），也可能是多层的（图12.5b）。</p><p><img loading="lazy" alt="1743910600543" src="/assets/images/1743910600543-d02d56ea80fecdd05e5ea57285cff529.png" width="1092" height="768" class="img_ev3q"></p><p>图12.5　Linux设备驱动的分层</p><p>这样的分层化设计在Linux的input、RTC、MTD、I2 C、SPI、tty、USB等诸多类型设备驱动中屡见不鲜。下面的几小节以input、RTC、Framebuffer等为例先进行一番讲解，当然，后续的章节会对与几个大的设备类型对应的驱动层次进行更详细的分析。</p><h1>12.3.2　输入设备驱动</h1><p>输入设备（如按键、键盘、触摸屏、鼠标等）是典型的字符设备，其一般的工作机理是底层在按键、触摸等动作发送时产生一个中断（或驱动通过Timer定时查询），然后CPU通过SPI、I2 C或外部存储器总线读取键值、坐标等数据，并将它们放入一个缓冲区，字符设备驱动管理该缓冲区，而驱动的read（）接口让用户可以读取键值、坐标等数据。</p><p>显然，在这些工作中，只是中断、读键值/坐标值是与设备相关的，而输入事件的缓冲区管理以及字符设备驱动的file_operations接口则对输入设备是通用的。基于此，内核设计了输入子系统，由核心层处理公共的工作。Linux内核输入子系统的框架如图12.6所示。</p><p><img loading="lazy" alt="1743911207521" src="/assets/images/1743911207521-64c305fa927dd1735ac1ade31f2f3d3d.png" width="850" height="984" class="img_ev3q"></p><p>图12.6　Linux内核输入子系统的框架</p><p>输入核心提供了底层输入设备驱动程序所需的API，如分配/释放一个输入设备：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct input_dev *input_allocate_device(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_free_device(struct input_dev *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>input_allocate_device（）返回的是1个input_dev的结构体，此结构体用于表征1个输入设备。</p><p>注册/注销输入设备用的接口如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int __must_check input_register_device(struct input_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_unregister_device(struct input_dev *);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>报告输入事件用的接口如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告指定type、code的输入事件*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告键值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_report_key(struct input_dev *dev, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告相对坐标*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_report_rel(struct input_dev *dev, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告绝对坐标 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_report_abs(struct input_dev *dev, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告同步事件 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_sync(struct input_dev *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而对于所有的输入事件，内核都用统一的数据结构来描述，这个数据结构是input_event，如代码清单12.10所示。</p><p>代码清单12.10　input_event结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct input_event {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2   struct timeval time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3   __u16type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4   __u16code;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5   __s32value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/input/keyboard/gpio_keys.c基于input架构实现了一个通用的GPIO按键驱动。该驱动是基于platform_driver架构的，名为“gpio-keys”。它将与硬件相关的信息（如使用的GPIO号，按下和抬起时的电平等）屏蔽在板文件platform_device的platform_data中，因此该驱动可应用于各个处理器，具有良好的跨平台性。代码清单12.11列出了该驱动的probe（）函数。</p><p>代码清单12.11　GPIO按键驱动的probe（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int gpio_keys_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 struct device *dev = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 const struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct gpio_keys_drvdata *ddata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 struct input_dev *input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 size_t size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int i, error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 int wakeup = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!pdata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     pdata = gpio_keys_get_devtree_pdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     if (IS_ERR(pdata))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         return PTR_ERR(pdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 size = sizeof(struct gpio_keys_drvdata) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         pdata-&gt;nbuttons * sizeof(struct gpio_button_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 ddata = devm_kzalloc(dev, size, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 if (!ddata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     dev_err(dev, &quot;failed to allocate state\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22     return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 input = devm_input_allocate_device(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 if (!input) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27     dev_err(dev, &quot;failed to allocate input device\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28     return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 ddata-&gt;pdata = pdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 ddata-&gt;input = input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 mutex_init(&amp;ddata-&gt;disable_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 platform_set_drvdata(pdev, ddata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 input_set_drvdata(input, ddata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 input-&gt;name = pdata-&gt;name   : pdev-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39 input-&gt;phys = &quot;gpio-keys/input0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 input-&gt;dev.parent = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 input-&gt;open = gpio_keys_open;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 input-&gt;close = gpio_keys_close;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44 input-&gt;id.bustype = BUS_HOST;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45 input-&gt;id.vendor = 0x0001;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46 input-&gt;id.product = 0x0001;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 input-&gt;id.version = 0x0100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 /* Enable auto repeat feature of Linux input subsystem */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 if (pdata-&gt;rep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51     __set_bit(EV_REP, input-&gt;evbit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53 for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54     const struct gpio_keys_button *button = &amp;pdata-&gt;buttons[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55     struct gpio_button_data *bdata = &amp;ddata-&gt;data[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57     error = gpio_keys_setup_key(pdev, input, bdata, button);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58     if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59         return error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61     if (button-&gt;wakeup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62         wakeup = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65 error = sysfs_create_group(&amp;pdev-&gt;dev.kobj, &amp;gpio_keys_attr_group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67 error = input_register_device(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码的第25行分配了1个输入设备，第31~47行初始化了该input_dev的一些属性，第58行注册了这个输入设备。第53~63行则初始化了所用到的GPIO，第67行完成了这个输入设备的注册。</p><p>在注册输入设备后，底层输入设备驱动的核心工作只剩下在按键、触摸等人为动作发生时报告事件。代码清单12.12列出了GPIO按键中断发生时的事件报告代码。</p><p>代码清单12.12　GPIO按键中断发生时的事件报告</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 struct gpio_button_data *bdata = dev_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 const struct gpio_keys_button *button = bdata-&gt;button;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct input_dev *input = bdata-&gt;input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 unsigned long flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 BUG_ON(irq != bdata-&gt;irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 spin_lock_irqsave(&amp;bdata-&gt;lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 if (!bdata-&gt;key_pressed) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     if (bdata-&gt;button-&gt;wakeup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         pm_wakeup_event(bdata-&gt;input-&gt;dev.parent, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16     input_event(input, EV_KEY, button-&gt;code, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     input_sync(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19     if (!bdata-&gt;timer_debounce) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         input_event(input, EV_KEY, button-&gt;code, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21         input_sync(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22         goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     bdata-&gt;key_pressed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 if (bdata-&gt;timer_debounce)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29     mod_timer(&amp;bdata-&gt;timer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30         jiffies + msecs_to_jiffies(bdata-&gt;timer_debounce));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 spin_unlock_irqrestore(&amp;bdata-&gt;lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 return IRQ_HANDLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>GPIO按键驱动通过input_event（）、input_sync（）这样的函数来汇报按键事件以及同步事件。从底层的GPIO按键驱动可以看出，该驱动中没有任何file_operations的动作，也没有各种I/O模型，注册进入系统也用的是input_register_device（）这样的与input相关的API。这是由于与Linux VFS接口的这一部分代码全部都在drivers/input/evdev.c中实现了，代码清单12.13摘取了部分关键代码。</p><p>代码清单12.13　input核心层的file_operations和read（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t evdev_read(struct file *file, char __user *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2            size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct evdev_client *client = file-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct evdev *evdev = client-&gt;evdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 struct input_event event;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 size_t read = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 if (count != 0&amp;&amp; count &lt; input_event_size())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14     if (!evdev-&gt;exist || client-&gt;revoked)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     if (client-&gt;packet_head == client-&gt;tail &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         (file-&gt;f_flags &amp; O_NONBLOCK))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         return -EAGAIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22      * count == 0is special - no IO is done but we check</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23      * for error conditions (see above).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     if (count == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28     while (read + input_event_size() &lt;= count &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29            evdev_fetch_next_event(client, &amp;event)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31         if (input_event_to_user(buffer + read, &amp;event))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32             return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34         read += input_event_size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     if (read)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40     if (!(file-&gt;f_flags &amp; O_NONBLOCK)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41         error = wait_event_interruptible(evdev-&gt;wait,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                 client-&gt;packet_head != client-&gt;tail ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                 !evdev-&gt;exist || client-&gt;revoked);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44         if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45             return error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 return read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52static const struct file_operations evdev_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53 .owner        = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54 .read         = evdev_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55 .write        = evdev_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56 .pol          = evdev_poll,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57 .open         = evdev_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58 .release      = evdev_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59 .unlocked_ioct= evdev_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60#ifdef CONFIG_COMPAT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61 .compat_ioct= evdev_ioctl_compat,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63 .fasync        = evdev_fasync,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64 .flush         = evdev_flush,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65 .llseek        = no_llseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中的17~19行在检查出是非阻塞访问后，立即返回EAGAIN错误，而第29行和第41~43行的代码则处理了阻塞的睡眠情况。回过头来想，其实gpio_keys驱动里面调用的input_event（）、input_sync（）有间接唤醒这个等待队列evdev-&gt;wait的功能，只不过这些代码都隐藏在其内部实现里了。</p><h1>12.3.3　RTC设备驱动</h1><p>RTC（实时钟）借助电池供电，在系统掉电的情况下依然可以正常计时。它通常还具有产生周期性中断以及闹钟（Alarm）中断的能力，是一种典型的字符设备。作为一种字符设备驱动，RTC需要有file_operations中接口函数的实现，如open（）、release（）、read（）、poll（）、ioctl（）等，而典型的IOCTL包括RTC_SET_TIME、RTC_ALM_READ、RTC_ALM_SET、RTC_IRQP_SET、RTC_IRQP_READ等，这些对于所有的RTC是通用的，只有底层的具体实现是与设备相关的。</p><p>因此，drivers/rtc/rtc-dev.c实现了RTC驱动通用的字符设备驱动层，它实现了file_opearations的成员函数以及一些通用的关于RTC的控制代码，并向底层导出rtc_device_register（）、rtc_device_unregister（）以注册和注销RTC；导出rtc_class_ops结构体以描述底层的RTC硬件操作。这个RTC通用层实现的结果是，底层的RTC驱动不再需要关心RTC作为字符设备驱动的具体实现，也无需关心一些通用的RTC控制逻辑，图12.7表明了这种关系。</p><p><img loading="lazy" alt="1743911539487" src="/assets/images/1743911539487-9fa10107f0ad0ca4d3fb8fc16e8f8cd9.png" width="907" height="487" class="img_ev3q"></p><p>图12.7　Linux RTC设备驱动的分层</p><p>drivers/rtc/rtc-s3c.c实现了S3C6410的RTC驱动，其注册RTC以及绑定rtc_class_ops的代码如代码清单12.14所示。</p><p>代码清单12.14　S3C6410RTC驱动的rtc_class_ops实例与RTC注册</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct rtc_class_ops s3c_rtcops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 .read_time     = s3c_rtc_gettime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 .set_time      = s3c_rtc_settime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 .read_alarm    = s3c_rtc_getalarm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 .set_alarm     = s3c_rtc_setalarm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 .proc          = s3c_rtc_proc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 .alarm_irq_enable = s3c_rtc_setaie,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10static int s3c_rtc_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 rtc = devm_rtc_device_register(&amp;pdev-&gt;dev, &quot;s3c&quot;, &amp;s3c_rtcops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               THIS_MODULE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/rtc/rtc-dev.c以及其调用的drivers/rtc/interface.c等RTC核心层相当于把file_operations中的open（）、release（）、读取和设置时间等都间接“转发”给了底层的实例，代码清单12.15摘取了部分RTC核心层调用具体底层驱动callback的过程。</p><p>代码清单12.15　RTC核心层“转发”到底层RTC驱动callback</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int rtc_dev_open(struct inode *inode, struct file *file)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 err = ops-&gt;open   ops-&gt;open(rtc-&gt;dev.parent) : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8static int __rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 int err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!rtc-&gt;ops)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     err = -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 else if (!rtc-&gt;ops-&gt;read_time)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      err = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19int rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 int err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 if (err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 err = __rtc_read_time(rtc, tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32int rtc_set_time(struct rtc_device *rtc, struct rtc_time *tm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 if (!rtc-&gt;ops)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     err = -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 else if (rtc-&gt;ops-&gt;set_time)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39     err = rtc-&gt;ops-&gt;set_time(rtc-&gt;dev.parent, tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44static long rtc_dev_ioctl(struct file *file,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45     unsigned int cmd, unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 case RTC_RD_TIME:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50     mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52     err = rtc_read_time(rtc, &amp;tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53     if (err &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54         return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56     if (copy_to_user(uarg, &amp;tm, sizeof(tm)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57         err = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58     return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60 case RTC_SET_TIME:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61     mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63     if (copy_from_user(&amp;tm, uarg, sizeof(tm)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64         return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66     return rtc_set_time(rtc, &amp;tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>12.3.4　Framebuffer设备驱动</h1><p>Framebuffer（帧缓冲）是Linux系统为显示设备提供的一个接口，它将显示缓冲区抽象，屏蔽图像硬件的底层差异，允许上层应用程序在图形模式下直接对显示缓冲区进行读写操作。对于帧缓冲设备而言，只要在显示缓冲区中与显示点对应的区域内写入颜色值，对应的颜色会自动在屏幕上显示。</p><p>图12.8所示为Linux帧缓冲设备驱动的主要结构，帧缓冲设备提供给用户空间的file_operations结构体由drivers/video/fbdev/core/fbmem.c中的file_operations提供，而特定帧缓冲设备fb_info结构体的注册、注销以及其中成员的维护，尤其是fb_ops中成员函数的实现则由对应的xxxfb.c文件实现，fb_ops中的成员函数最终会操作LCD控制其硬件寄存器。</p><p><img loading="lazy" alt="1743912007495" src="/assets/images/1743912007495-aaa31d8e9aaabef1db450c248aa3f832.png" width="1366" height="805" class="img_ev3q"></p><p>图12.8　Linux帧缓冲设备驱动的程序结构</p><p>多数显存的操作方法都是规范的，可以按照像素点格式的要求顺序写帧缓冲区。但是有少量LCD的显存写法可能比较特殊，这时候，在核心层drivers/video/fbdev/core/fbmem.c实现的fb_write（）中，实际上可以给底层提供一个重写自己的机会，如代码清单12.16所示。</p><p>代码清单12.16　LCD的framebuffer write（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2fb_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned long p = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct fb_info *info = file_fb_info(file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 u8*buffer, *src;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 u8__iomem *dst;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int c, cnt = 0, err = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 unsigned long total_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!info || !info-&gt;screen_base)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 if (info-&gt;state != FBINFO_STATE_RUNNING)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     return -EPERM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 if (info-&gt;fbops-&gt;fb_write)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18     return info-&gt;fbops-&gt;fb_write(info, buf, count, ppos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 total_size = info-&gt;screen_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 if (total_size == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     total_size = info-&gt;fix.smem_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 if (p &gt; total_size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26     return -EFBIG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 if (count &gt; total_size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29     err = -EFBIG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30     count = total_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 if (count + p &gt; total_size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34     if (!err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35         err = -ENOSPC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     count = total_size - p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 buffer = kmalloc((count &gt; PAGE_SIZE)   PAGE_SIZE : count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41          GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 if (!buffer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43     return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45 dst = (u8__iomem *) (info-&gt;screen_base + p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 if (info-&gt;fbops-&gt;fb_sync)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48     info-&gt;fbops-&gt;fb_sync(info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 while (count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51     c = (count &gt; PAGE_SIZE)   PAGE_SIZE : count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52     src = buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54     if (copy_from_user(src, buf, c)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55         err = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59     fb_memcpy_tofb(dst, src, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60     dst += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61     src += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62     *ppos += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63     buf += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64     cnt += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65     count -= c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68 kfree(buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70 return (cnt)   cnt : err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第17~18行是一个检查底层LCD有没有实现自己特殊显存写法的代码，如果有，直接调底层的；如果没有，用中间层标准的显存写法就搞定了底层的那个不特殊的LCD。</p><h1>12.3.5　终端设备驱动</h1><p>在Linux系统中，终端是一种字符型设备，它有多种类型，通常使用tty（Teletype）来简称各种类型的终端设备。对于嵌入式系统而言，最普遍采用的是UART（Universal Asynchronous Receiver/Transmitter）串行端口，日常生活中简称串口。</p><p>Linux内核中tty的层次结构如图12.9所示，它包含tty核心tty_io.c、tty线路规程n_tty.c（实现N_TTY线路规程）和tty驱动实例xxx_tty.c，tty线路规程的工作是以特殊的方式格式化从一个用户或者硬件收到的数据，这种格式化常常采用一个协议转换的形式。</p><p>tty_io.c本身是一个标准的字符设备驱动，它对上有字符设备的职责，实现file_operations成员函数。但是tty核心层对下又定义了tty_driver的架构，这样tty设备驱动的主体工作就变成了填充tty_driver结构体中的成员，实现其中的tty_operations的成员函数，而不再是去实现file_operations这一级的工作。tty_driver结构体和tty_operations的定义分别如代码清单12.17和12.18所示。</p><p><img loading="lazy" alt="1743912094969" src="/assets/images/1743912094969-cca7f97f22f81f9ee17bec2ea8527f3d.png" width="897" height="511" class="img_ev3q"></p><p>图12.9　Linux内核中tty的层次结构</p><p>代码清单12.17　tty_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct tty_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      int     magic;                  /* magic number for this structure */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      struct kref kref;               /* Reference management */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      struct cdev *cdevs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      struct module   *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      const char      *driver_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      const char      *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      int     name_base;              /* offset of printed name */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      int     major;                  /* major device number */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      int     minor_start;            /* start of minor device number */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11      unsigned int    num;            /* number of devices allocated */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12      short   type;                   /* type of tty driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      short   subtype;                /* subtype of tty driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      struct ktermios init_termios;   /* Initial termios */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15      unsigned long   flags;          /* tty driver flags */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      struct proc_dir_entry *proc_entry;   /* /proc fs entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17      struct tty_driver *other;       /* only used for the PTY driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       * Pointer to the tty data structures</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22      struct tty_struct **ttys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23      struct tty_port **ports;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24      struct ktermios **termios;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      void *driver_state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27      /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       * Driver methods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31      const struct tty_operations *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32      struct list_head tty_drivers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单12.18　tty_operations结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct tty_operations {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 struct tty_struct * (*lookup)(struct tty_driver *driver,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          struct inode *inode, int idx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 int  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 void (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 int  (*open)(struct tty_struct * tty, struct file * filp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 void (*close)(struct tty_struct * tty, struct file * filp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 void (*shutdown)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 void (*cleanup)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 int  (*write)(struct tty_struct * tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11           const unsigned char *buf, int count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 int  (*put_char)(struct tty_struct *tty, unsigned char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 void (*flush_chars)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 int  (*write_room)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 int  (*chars_in_buffer)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 int  (*ioctl)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         unsigned int cmd, unsigned long arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 long (*compat_ioctl)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                 unsigned int cmd, unsigned long arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 void (*throttle)(struct tty_struct * tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 void (*unthrottle)(struct tty_struct * tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 void (*stop)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 void (*start)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 void (*hangup)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 int (*break_ctl)(struct tty_struct *tty, int state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 void (*flush_buffer)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 void (*set_ldisc)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 void (*wait_until_sent)(struct tty_struct *tty, int timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30 void (*send_xchar)(struct tty_struct *tty, char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 int (*tiocmget)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 int (*tiocmset)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33         unsigned int set, unsigned int clear);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 int (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 int (*get_icount)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37             struct serial_icounter_struct *icount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38#ifdef CONFIG_CONSOLE_POLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39 int (*poll_init)(struct tty_driver *driver, int line, char *options);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 int (*poll_get_char)(struct tty_driver *driver, int line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 void (*poll_put_char)(struct tty_driver *driver, int line, char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43 const struct file_operations *proc_fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如图12.10所示，tty设备发送数据的流程为：tty核心从一个用户获取将要发送给一个tty设备的数据，tty核心将数据传递给tty线路规程驱动，接着数据被传递到tty驱动，tty驱动将数据转换为可以发送给硬件的格式。接收数据的流程为：从tty硬件接收到的数据向上交给tty驱动，接着进入tty线路规程驱动，再进入tty核心，在这里它被一个用户获取。</p><p><img loading="lazy" alt="1743949417804" src="/assets/images/1743949417804-5fc2c2172627c27de8f4fa2602247a23.png" width="741" height="1062" class="img_ev3q"></p><p>图12.10　tty设备发送、接收数据流的流程</p><p>代码清单12.18中第10行的tty_driver操作集tty_operations的成员函数write（）函数接收3个参数：tty_struct、发送数据指针及要发送的字节数。该函数是被file_operations的write（）成员函数间接触发调用的。从接收角度看，tty驱动一般收到字符后会通过tty_flip_buffer_push（）将接收缓冲区推到线路规程。</p><p>尽管一个特定的底层UART设备驱动完全可以遵循上述tty_driver的方法来设计，即定义tty_driver并实现tty_operations中的成员函数，但是鉴于串口之间的共性，Linux考虑在文件drivers/tty/serial/serial_core.c中实现了UART设备的通用tty驱动层（我们可以称其为串口核心层）。这样，UART驱动的主要任务就进一步演变成了实现serial-core.c中定义的一组uart_xxx接口而不是tty_xxx接口，如图12.11所示。因此，按照面向对象的思想，可以认为tty_driver是字符设备的泛化、serial-core是tty_driver的泛化，而具体的串口驱动又是serial-core的泛化。</p><p><img loading="lazy" alt="1743949470945" src="/assets/images/1743949470945-94ff25cef64847f9b26fde4100476734.png" width="927" height="654" class="img_ev3q"></p><p>图12.11　串口核心层</p><p>串口核心层又定义了新的uart_driver结构体和其操作集uart_ops。一个底层的UART驱动需要创建和通过uart_register_driver（）注册一个uart_driver而不是tty_driver，代码清单12.19给出了uart_driver的定义。</p><p>代码清单12.19　uart_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct uart_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      struct module           *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      const char              *driver_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      const char              *dev_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      int                      major;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      int                      minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      int                      nr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      struct console          *cons;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       * these are private; the low level driver should not</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       * touch these; they should be initialised to NULL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      struct uart_state       *state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15      struct tty_driver       *tty_driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>uart_driver结构体在本质上是派生自uart_driver结构体，因此，它的第15行也包含了一个tty_driver结构体成员。tty_operations在UART这个层面上也被进一步泛化为了uart_ops，其定义如代码清单12.20所示。</p><p>代码清单12.20　uart_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct uart_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 unsigned int    (*tx_empty)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 void        (*set_mctrl)(struct uart_port *, unsigned int mctrl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned int    (*get_mctrl)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 void        (*stop_tx)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 void        (*start_tx)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 void        (*throttle)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 void        (*unthrottle)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 void        (*send_xchar)(struct uart_port *, char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 void        (*stop_rx)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 void        (*enable_ms)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 void        (*break_ctl)(struct uart_port *, int ctl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 int         (*startup)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 void        (*shutdown)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 void        (*flush_buffer)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 void        (*set_termios)(struct uart_port *, struct ktermios *new,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                    struct ktermios *old);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 void        (*set_ldisc)(struct uart_port *, struct ktermios *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 void        (*pm)(struct uart_port *, unsigned int state,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20               unsigned int oldstate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 const char    *(*type)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 void        (*release_port)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 int         (*request_port)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 void        (*config_port)(struct uart_port *, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 int         (*verify_port)(struct uart_port *, struct serial_struct *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 int         (*ioctl)(struct uart_port *, unsigned int, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30#ifdef CONFIG_CONSOLE_POLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 int         (*poll_init)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 void        (*poll_put_char)(struct uart_port *, unsigned char);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 int         (*poll_get_char)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于drivers/tty/serial/serial_core.c是一个tty_driver，因此在serial_core.c中，存在一个tty_operations的实例，这个实例的成员函数会进一步调用struct uart_ops的成员函数，这样就把file_operations里的成员函数、tty_operations的成员函数和uart_ops的成员函数串起来了。</p><h1>12.3.6　misc设备驱动</h1><p>由于Linux驱动倾向于分层设计，所以各个具体的设备都可以找到它归属的类型，从而套到它相应的架构里面去，并且只需要实现最底层的那一部分。但是，也有部分类似globalmem、globalfifo的字符设备，确实不知道它属于什么类型，我们一般推荐大家采用miscdevice框架结构。miscdevice本质上也是字符设备，只是在miscdevice核心层的misc_init（）函数中，通过register_chrdev（MISC_MAJOR，&quot;misc&quot;，&amp;misc_fops）注册了字符设备，而具体miscdevice实例调用misc_register（）的时候又自动完成了device_create（）、获取动态次设备号的动作。</p><p>miscdevice的主设备号是固定的，MISC_MAJOR定义为10，在Linux内核中，大概可以找到200多处使用miscdevice框架结构的驱动。</p><p>miscdevice结构体的定义如代码清单12.21所示，在它的第4行，指向了一个file_operations的结构体。miscdevice结构体内file_operations中的成员函数实际上是由drivers/char/misc.c中misc驱动核心层的misc_fops成员函数间接调用的，比如misc_open（）就会间接调用底层注册的miscdevice的fops-&gt;open。</p><p>代码清单12.21　miscdevice结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct miscdevice  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      int minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      const char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      const struct file_operations *fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      struct list_head list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      struct device *parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      struct device *this_device;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      const char *nodename;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      umode_t mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果上述代码第2行的minor为MISC_DYNAMIC_MINOR，miscdevice核心层会自动找一个空闲的次设备号，否则用minor指定的次设备号。第3行的name是设备的名称。</p><p>miscdevice驱动的注册和注销分别用下面两个API</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int misc_register(struct miscdevice * misc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int misc_deregister(struct miscdevice *misc);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因此miscdevice驱动的一般结构形如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct file_operations xxx_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .unlocked_ioctl = xxx_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .mmap           = xxx_mmap,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct miscdevice xxx_dev = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .minor  = MISC_DYNAMIC_MINOR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .name   = &quot;xxx&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .fops   = &amp;xxx_fops</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int __init xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       pr_info(&quot;ARC Hostlink driver mmap at 0x%p\n&quot;, __HOSTLINK__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return misc_register(&amp;xxx_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在调用misc_register（&amp;xxx_dev）时，该函数内部会自动调用device_create（），而device_create（）会以xxx_dev作为drvdata参数。其次，在miscdevice核心层misc_open（）函数的帮助下，在file_operations的成员函数中，xxx_dev会自动成为file的private_data（misc_open会完成file-&gt;private_data的赋值操作）。</p><p>如果我们用面向对象的封装思想把一个设备的属性、自旋锁、互斥体、等待队列、miscdevice等封装在一个结构体里面：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct xxx_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     unsigned int version;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     unsigned int size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     spinlock_t lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct miscdevice miscdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在file_operations的成员函数中，就可以通过container_of（）和file-&gt;private_data反推出xxx_dev的实例。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static long xxx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct xxx_dev *xxx = container_of(file-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct xxx_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面我们把globalfifo驱动改造成基于platform_driver且采用miscdevice框架的结构体。首先这个新的驱动变成了要通过platform_driver的probe（）函数来初始化，其次不再直接采用register_chrdev（）、cdev_add（）之类的原始API，而采用miscdevice的注册方法。代码清单12.22列出了新的globalfifo驱动相对于第9章globalfifo驱动变化的部分。</p><p>代码清单12.22　新的globalfifo驱动相对于第9章globalfifo驱动变化的部分</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct globalfifo_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    struct miscdevice miscdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6static int globalfifo_fasync(int fd, struct file *filp, int mode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13static long globalfifo_ioctl(struct file *filp, unsigned int cmd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                 unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21static unsigned int globalfifo_poll(struct file *filp, poll_table * wait)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28static ssize_t globalfifo_read(struct file *filp, char __user *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29                   size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36static ssize_t globalfifo_write(struct file *filp, const char __user *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37                size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44static int globalfifo_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    struct globalfifo_dev *gl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    gl = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*gl), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50    if (!gl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51        return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52    gl-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53    gl-&gt;miscdev.name = &quot;globalfifo&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54    gl-&gt;miscdev.fops = &amp;globalfifo_fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56    mutex_init(&amp;gl-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57    init_waitqueue_head(&amp;gl-&gt;r_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58    init_waitqueue_head(&amp;gl-&gt;w_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59    platform_set_drvdata(pdev, gl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61    ret = misc_register(&amp;gl-&gt;miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62    if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63        goto err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66err:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70static int globalfifo_remove(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72    struct globalfifo_dev *gl = platform_get_drvdata(pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73    misc_deregister(&amp;gl-&gt;miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77static struct platform_driver globalfifo_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78    .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79        .name = &quot;globalfifo&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80        .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82    .probe = globalfifo_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83    .remove = globalfifo_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85module_platform_driver(globalfifo_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述代码中，file_operations的各个成员函数都使用container_of（）反向求出private_data，第61行在platform_driver的probe（）函数中完成了miscdev的注册，而在remove（）函数中使用misc_deregister（）完成了miscdev的注销。</p><p>上述代码也改用了platform_device和platform_driver的体系结构。我们增加了一个模块来完成platform_device的注册，在模块初始化的时候通过platform_device_alloc（）和platform_device_add（）分配并添加platform_device，而在模块卸载的时候则通过platform_device_unregister（）注销platform_device，如代码清单12.23所示。</p><p>代码清单12.23　与globalfifo对应的platform_device的注册和注销</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct platform_device *globalfifo_pdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3static int __init globalfifodev_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        globalfifo_pdev = platform_device_alloc(&quot;globalfifo&quot;, -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        if (!globalfifo_pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        ret = platform_device_add(globalfifo_pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                platform_device_put(globalfifo_pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20module_init(globalfifodev_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22static void __exit globalfifodev_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        platform_device_unregister(globalfifo_pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26module_exit(globalfifodev_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>本书配套代码/home/baohua/develop/training/kernel/drivers/globalfifo/ch12中包含了globalfifo driver和device端的两个模块。在该目录运行make，会生成两个模块：globalfifo.ko和globalfifo-dev.ko，把globalfifo.ko和globalfifo-dev.ko先后insmod，会导致platform_driver和platform_device的匹配，globalfifo_probe（）会执行，/dev/globalfifo节点会自动生成，默认情况下需要root权限来访问/dev/globalfifo。</p><p>如果此后我们rmmod globalfifo-dev.ko，则会导致platform_driver的remove（）成员函数，即globalfifo_remove（）函数被执行，/dev/globalfifo节点会自动消失。</p><h1>12.3.7　驱动核心层</h1><p>分析了上述多个实例，我们可以归纳出核心层肩负的3大职责：</p><p>1）对上提供接口。file_operations的读、写、ioctl都被中间层搞定，各种I/O模型也被处理掉了。</p><p>2）中间层实现通用逻辑。可以被底层各种实例共享的代码都被中间层搞定，避免底层重复实现。</p><p>3）对下定义框架。底层的驱动不再需要关心Linux内核VFS的接口和各种可能的I/O模型，而只需处理与具体硬件相关的访问。</p><p>这种分层有时候还不是两层，可以有更多层，在软件上呈现为面向对象里类继承和多态的状态。上一节介绍的终端设备驱动，在软件层次上类似图12.12的效果。</p><p><img loading="lazy" alt="1743949827184" src="/assets/images/1743949827184-2ca392615809b015f21a14e91917ad72.png" width="331" height="550" class="img_ev3q"></p><p>图12.12　tty驱动各层泛化</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.041Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>阻塞与非阻塞访问、poll（）函数提供了较好的解决设备访问的机制，但是如果有了异步通知，整套机制则更加完整了。</p><p>异步通知的意思是：一旦设备就绪，则主动通知应用程序，这样应用程序根本就不需要查询设备状态，这一点非常类似于硬件上“中断”的概念，比较准确的称谓是“信号驱动的异步I/O”。信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。</p><p>阻塞I/O意味着一直等待设备可访问后再访问，非阻塞I/O中使用poll（）意味着查询设备是否可访问，而异步通知则意味着设备通知用户自身可访问，之后用户再进行I/O处理。由此可见，这几种I/O方式可以相互补充。</p><p>图9.1呈现了阻塞I/O，结合轮询的非阻塞I/O及基于SIGIO的异步通知在时间先后顺序上的不同。</p><p><img loading="lazy" alt="image-20250329150836338" src="/assets/images/image-20250329150836338-aebef0f53f8de4dddbc7fd21247af1f8.png" width="1486" height="555" class="img_ev3q"></p><p>图9.1　阻塞、结合轮询的非阻塞I/O和异步通知的区别</p><p>这里要强调的是：阻塞、非阻塞I/O、异步通知本身没有优劣，应该根据不同的应用场景合理选择。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.029Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->13 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>理解Linux内核的锁机制，还需要理解编译器和处理器的特点。比如下面一段代码，写端申请一个新的struct foo结构体并初始化其中的a、b、c，之后把结构体地址赋值给全局gp指针：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct foo *gp = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* . . . */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p = kmalloc(sizeof(*p), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p-&gt;a = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p-&gt;b = 2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">p-&gt;c = 3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">gp = p;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而读端如果简单做如下处理，则程序的运行可能是不符合预期的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">p = gp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (p != NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有两种可能的原因会造成程序出错，一种可能性是编译乱序，另外一种可能性是执行乱序。</p><p>关于编译方面，C语言顺序的“p-&gt;a=1；p-&gt;b=2；p-&gt;c=3；gp=p；”的编译结果的指令顺序可能是gp的赋值指令发生在a、b、c的赋值之前。现代的高性能编译器在目标码优化上都具备对指令进行乱序优化的能力。编译器可以对访存的指令进行乱序，减少逻辑上不必要的访存，以及尽量提高Cache命中率和CPU的Load/Store单元的工作效率。因此在打开编译器优化以后，看到生成的汇编码并没有严格按照代码的逻辑顺序，这是正常的。</p><p>解决编译乱序问题，需要通过barrier（）编译屏障进行。我们可以在代码中设置barrier（）屏障，这个屏障可以阻挡编译器的优化。对于编译器来说，设置编译屏障可以保证屏障前的语句和屏障后的语句不乱“串门”。</p><p>比如，下面的一段代码在e=d<!-- -->[4095]<!-- -->与b=a、c=a之间没有编译屏障：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int a = 0, b, c, d[4096], e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e = d[4095];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;a:%d b:%d c:%d e:%d\n&quot;, a, b, c, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>用“arm-linux-gnueabihf-gcc-O2”优化编译，反汇编结果是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   831c: b530         push  {r4, r5, lr}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   831e: f5ad 4d80    sub.w   sp, sp, #16384   ; 0x4000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8322: b083         sub   sp, #12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8324: 2100         movs  r1, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8326: f50d 4580    add.w   r5, sp, #16384   ; 0x4000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   832a: f248 4018    movw r0, #33816  ; 0x8418</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   832e: 3504         adds r5, #4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8330: 460a         mov  r2, r1         -&gt; b= a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8332: 460b         mov  r3, r1         -&gt; c= a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8334: f2c0 0000    movt r0, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8338: 682c         ldr  r4, [r5, #0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   833a: 9400         str  r4, [sp, #0]      -&gt; e = d[4095];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   833c: f7ff efd4    blx  82e8 &lt;_init+0x20&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>显然，尽管源代码级别b=a、c=a发生在e=d<!-- -->[4095]<!-- -->之后，但是目标代码的b=a、c=a指令发生在e=d<!-- -->[4095]<!-- -->之前。</p><p>假设我们重新编写代码，在e=d<!-- -->[4095]<!-- -->与b=a、c=a之间加上编译屏障：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int a = 0, b, c, d[4096], e;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    e = d[4095];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    barrier();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c = a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printf(&quot;a:%d b:%d c:%d e:%d\n&quot;, a, b, c, e);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>再次用“arm-linux-gnueabihf-gcc-O2”优化编译，反汇编结果是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int main(int argc, char *argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   831c: b510         push {r4, lr}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   831e: f5ad 4d80    sub.w    sp, sp, #16384   ; 0x4000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8322: b082         sub  sp, #8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8324: f50d 4380    add.w     r3, sp, #16384   ; 0x4000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8328: 3304         adds r3, #4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   832a: 681c         ldr  r4, [r3, #0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   832c: 2100         movs r1, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   832e: f248 4018    movw r0, #33816   ; 0x8418</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8332: f2c0 0000    movt r0, #0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8336: 9400         str  r4, [sp, #0]        -&gt; e = d[4095];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8338: 460a         mov  r2, r1            -&gt; b= a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   833a: 460b         mov  r3, r1            -&gt; c= a;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   833c: f7ff efd4    blx  82e8 &lt;_init+0x20&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因为“<strong>asm__</strong>volatile__（&quot;&quot;：：：&quot;memory&quot;）”这个编译屏障的存在，原来的3条指令的顺序“拨乱反正”了。</p><p>关于解决编译乱序的问题，C语言volatile关键字的作用较弱，它更多的只是避免内存访问行为的合并，对C编译器而言，volatile是暗示除了当前的执行线索以外，其他的执行线索也可能改变某内存，所以它的含义是“易变的”。换句话说，就是如果线程A读取var这个内存中的变量两次而没有修改var，编译器可能觉得读一次就行了，第2次直接取第1次的结果。但是如果加了volatile关键字来形容var，则就是告诉编译器线程B、线程C或者其他执行实体可能把var改掉了，因此编译器就不会再把线程A代码的第2次内存读取优化掉了。另外，volatile也不具备保护临界资源的作用。总之，Linux内核明显不太喜欢volatile，这可参考内核源代码下的文档Documentation/volatile-considered-harmful.txt。</p><p>编译乱序是编译器的行为，而执行乱序则是处理器运行时的行为。执行乱序是指即便编译的二进制指令的顺序按照“p-&gt;a=1；p-&gt;b=2；p-&gt;c=3；gp=p；”排放，在处理器上执行时，后发射的指令还是可能先执行完，这是处理器的“乱序执行（Out-of-Order Execution）”策略。高级的CPU可以根据自己缓存的组织特性，将访存指令重新排序执行。连续地址的访问可能会先执行，因为这样缓存命中率高。有的还允许访存的非阻塞，即如果前面一条访存指令因为缓存不命中，造成长延时的存储访问时，后面的访存指令可以先执行，以便从缓存中取数。因此，即使是从汇编上看顺序正确的指令，其执行的顺序也是不可预知的。</p><p>举个例子，ARM v6/v7的处理器会对以下指令顺序进行优化。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LDR r0，[r1] ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">STR r2，[r3] ;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>假设第一条LDR指令导致缓存未命中，这样缓存就会填充行，并需要较多的时钟周期才能完成。老的ARM处理器，比如ARM926EJ-S会等待这个动作完成，再执行下一条STR指令。而ARM v6/v7处理器会识别出下一条指令（STR）且不需要等待第一条指令（LDR）完成（并不依赖于r0的值），即会先执行STR指令，而不是等待LDR指令完成。</p><p>对于大多数体系结构而言，尽管每个CPU都是乱序执行，但是这一乱序对于单核的程序执行是不可见的，因为单个CPU在碰到依赖点（后面的指令依赖于前面指令的执行结果）的时候会等待，所以程序员可能感觉不到这个乱序过程。但是这个依赖点等待的过程，在SMP处理器里面对于其他核是不可见的。比如若在CPU0上执行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">while (f == 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">print x;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>CPU1上执行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">x = 42;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">f = 1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们不能武断地认为CPU0上打印的x一定等于42，因为CPU1上即便“f=1”编译在“x=42”后面，执行时仍然可能先于“x=42”完成，所以这个时候CPU0上打印的x不一定就是42</p><p>处理器为了解决多核间一个核的内存行为对另外一个核可见的问题，引入了一些内存屏障的指令。譬如，ARM处理器的屏障指令包括：</p><ul><li>DMB（数据内存屏障）：在DMB之后的显式内存访问执行前，保证所有在DMB指令之前的内存访问完成；</li><li>DSB（数据同步屏障）：等待所有在DSB指令之前的指令完成（位于此指令前的所有显式内存访问均完成，位于此指令前的所有缓存、跳转预测和TLB维护操作全部完成）；</li><li>ISB（指令同步屏障）：Flush流水线，使得所有ISB之后执行的指令都是从缓存或内存中获得的。</li></ul><p>Linux内核的自旋锁、互斥体等互斥逻辑，需要用到上述指令：在请求获得锁时，调用屏障指令；在解锁时，也需要调用屏障指令。代码清单7.1的汇编代码描绘了一个简单的互斥逻辑，留意其中的第14行和22行。关于ldrex和strex指令的作用，会在7.3节详述。</p><p>代码清单7.1　基于内存屏障指令的互斥逻辑</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1LOCKED   EQU 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2UNLOCKED EQU 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3lock_mutex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4     ; 互斥量是否锁定?</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5     LDREX r1, [r0]         ; 检查是否锁定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6     CMP r1, #LOCKED        ; 和&quot;locked&quot;比较</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7     WFEEQ                  ; 互斥量已经锁定，进入休眠</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8     BEQ lock_mutex         ; 被唤醒，重新检查互斥量是否锁定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9     ; 尝试锁定互斥量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10     MOV r1, #LOCKED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     STREX r2, r1, [r0]     ; 尝试锁定</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     CMP r2, #0x0           ; 检查STR指令是否完成</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     BNE lock_mutex         ; 如果失败，重试</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14     DMB                    ; 进入被保护的资源前需要隔离，保证互斥量已经被更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     BX lr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17unlock_mutex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18     DMB                    ; 保证资源的访问已经结束</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19     MOV r1, #UNLOCKED      ; 向锁定域写&quot;unlocked&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20     STR r1, [r0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22     DSB                    ; 保证在CPU唤醒前完成互斥量状态更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     SEV                    ; 像其他CPU发送事件，唤醒任何等待事件的CPU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     BX lr</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前面提到每个CPU都是乱序执行，但是单个CPU在碰到依赖点的时候会等待，所以执行乱序对单核不一定可见。但是，当程序在访问外设的寄存器时，这些寄存器的访问顺序在CPU的逻辑上构不成依赖关系，但是从外设的逻辑角度来讲，可能需要固定的寄存器读写顺序，这个时候，也需要使用CPU的内存屏障指令。内核文档Documentation/memory-barriers.txt和Documentation/io_ordering.txt对此进行了描述。</p><p>在Linux内核中，定义了读写屏障mb（）、读屏障rmb（）、写屏障wmb（）、以及作用于寄存器读写的<strong>iormb（）、</strong>iowmb（）这样的屏障API。读写寄存器的readl_relaxed（）和readl（）、writel_relaxed（）和writel（）API的区别就体现在有无屏障方面。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define readb(c)                ({ u8  __v = readb_relaxed(c); __iormb(); __v; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define readw(c)                ({ u16 __v = readw_relaxed(c); __iormb(); __v; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define readl(c)                ({ u32 __v = readl_relaxed(c); __iormb(); __v; })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define writeb(v,c)             ({ __iowmb(); writeb_relaxed(v,c); })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define writew(v,c)             ({ __iowmb(); writew_relaxed(v,c); })</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define writel(v,c)             ({ __iowmb(); writel_relaxed(v,c); })</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>比如我们通过writel_relaxed（）写完DMA的开始地址、结束地址、大小之后，我们一定要调用writel（）来启动DMA。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">writel_relaxed(DMA_SRC_REG, src_addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">writel_relaxed(DMA_DST_REG, dst_addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">writel_relaxed(DMA_SIZE_REG, size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">writel (DMA_ENABLE, 1);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:15.017Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>尽管信号量已经可以实现互斥的功能，但是“正宗”的mutex在Linux内核中还是真实地存在着。</p><p>下面代码定义了名为my_mutex的互斥体并初始化它：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct mutex my_mutex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mutex_init(&amp;my_mutex);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面的两个函数用于获取互斥体：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void mutex_lock(struct mutex *lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int mutex_lock_interruptible(struct mutex *lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int mutex_trylock(struct mutex *lock);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mutex_lock（）与mutex_lock_interruptible（）的区别和down（）与down_trylock（）的区别完全一致，前者引起的睡眠不能被信号打断，而后者可以。mutex_trylock（）用于尝试获得mutex，获取不到mutex时不会引起进程睡眠。</p><p>下列函数用于释放互斥体：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void mutex_unlock(struct mutex *lock);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mutex的使用方法和信号量用于互斥的场合完全一样：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct mutex my_mutex;      /* 定义mutex */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mutex_init(&amp;my_mutex);      /* 初始化mutex */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mutex_lock(&amp;my_mutex);      /* 获取mutex */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...                         /* 临界资源*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mutex_unlock(&amp;my_mutex);    /* 释放mutex */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>自旋锁和互斥体都是解决互斥问题的基本手段，面对特定的情况，应该如何取舍这两种手段呢？选择的依据是临界区的性质和系统的特点。</p><p>从严格意义上说，互斥体和自旋锁属于不同层次的互斥手段，前者的实现依赖于后者。在互斥体本身的实现上，为了保证互斥体结构存取的原子性，需要自旋锁来互斥。所以自旋锁属于更底层的手段。</p><p>互斥体是进程级的，用于多个进程之间对资源的互斥，虽然也是在内核中，但是该内核执行路径是以进程的身份，代表进程来争夺资源的。如果竞争失败，会发生进程上下文切换，当前进程进入睡眠状态，CPU将运行其他进程。鉴于进程上下文切换的开销也很大，因此，只有当进程占用资源时间较长时，用互斥体才是较好的选择。</p><p>当所要保护的临界区访问时间比较短时，用自旋锁是非常方便的，因为它可节省上下文切换的时间。但是CPU得不到自旋锁会在那里空转直到其他执行单元解锁为止，所以要求锁不能在临界区里长时间停留，否则会降低系统的效率。</p><p>由此，可以总结出自旋锁和互斥体选用的3项原则。</p><p>1）当锁不能被获取到时，使用互斥体的开销是进程上下文切换时间，使用自旋锁的开销是等待获取自旋锁（由临界区执行时间决定）。若临界区比较小，宜使用自旋锁，若临界区很大，应使用互斥体。</p><p>2）互斥体所保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码的临界区。因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一个进程企图获取本自旋锁，死锁就会发生。</p><p>3）互斥体存在于进程上下文，因此，如果被保护的共享资源需要在中断或软中断情况下使用，则在互斥体和自旋锁之间只能选择自旋锁。当然，如果一定要使用互斥体，则只能通过mutex_trylock（）方式进行，不能获取就立即返回以避免阻塞。</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/3"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>