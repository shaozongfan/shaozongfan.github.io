<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/5"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/5"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/5" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/5" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.893Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux操作系统是UNIX操作系统的一种克隆系统，是一种类UNIX操作系统，诞生于1991年10月5日（第一次正式向外公布的时间），起初的作者是Linus Torvalds。Linux操作系统的诞生、发展和成长过程依赖着5个重要支柱：UNIX操作系统、Minix操作系统、GNU计划、POSIX标准和Internet。</p><h1>1.UNIX操作系统</h1><p>UNIX操作系统是美国贝尔实验室的Ken.Thompson和Dennis Ritchie于1969年夏在DEC PDP-7小型计算机上开发的一个分时操作系统。Linux操作系统可看作UNIX操作系统的一个克隆版本。</p><h1>2.Minix操作系统</h1><p>Minix操作系统也是UNIX的一种克隆系统，它于1987年由著名计算机教授Andrew S.Tanenbaum开发完成。有开放源代码的Minix系统的出现在全世界的大学中刮起了学习UNIX系统的旋风。Linux刚开始就是参照Minix系统于1991年开发的。</p><h1>3.GNU计划</h1><p>GNU计划和自由软件基金会（FSF）是由Richard M.Stallman于1984年创办的，GNU是“GNU&#x27;s Not UNIX”的缩写。到20世纪90年代初，GNU项目已经开发出许多高质量的免费软件，其中包括emacs编辑系统、bash shell程序、gcc系列编译程序、GDB调试程序等。这些软件为Linux操作系统的开发创造了一个合适的环境，是Linux诞生的基础之一。没有GNU软件环境，Linux将寸步难行。因此，严格来说，“Linux”应该称为“GNU/Linux”系统</p><p>下面从左到右依次为前文所提到的5位大师Linus Torvalds、Dennis Ritchie、Ken.Thompson、Andrew S.Tanenbaum、Richard M.Stallman。但愿我们能够追随大师的足迹，让自己不断地成长与进步。Linus Torvalds的一番话甚为有道理：“Most good programmers do programming not because they expect to get paid or get adulation by the public，but because it is fun to program.”技术成长的源动力应该是兴趣而非其他，只有兴趣才可以支撑一个人持续不断地十年如一日地努力与学习。Linus Torvalds本人，虽然已经是一代大师，仍然在不断地管理和合并Linux内核的代码。这点，在国内浮躁的学术氛围之下，几乎是不可思议的。我想，中国梦至少包含每个码农都可以因为技术成长而得到人生出彩的机会。</p><p><img loading="lazy" alt="1742736775006" src="/assets/images/1742736775006-a47c2d5ee82c44fe99e7d53b38828d00.png" width="1441" height="328" class="img_ev3q"></p><h1>4.POSIX标准</h1><p>POSIX（Portable Operating System Interface，可移植的操作系统接口）是由IEEE和ISO/IEC开发的一组标准。该标准基于现有的UNIX实践和经验完成，描述了操作系统的调用服务接口，用于保证编写的应用程序可以在源代码级上在多种操作系统中移植。该标准在推动Linux操作系统朝着正规化发展，是Linux前进的灯塔。</p><h1>5.互联网</h1><p>如果没有互联网，没有遍布全世界的无数计算机骇客的无私奉献，那么Linux最多只能发展到Linux 0.13（0.95）版本的水平。从Linux 0.95版开始，对内核的许多改进和扩充均以其他人为主了，而Linus以及其他维护者的主要任务开始变成对内核的维护和决定是否采用某个补丁程序。</p><p>表3.1描述了Linux操作系统重要版本的变迁历史及各版本的主要特点</p><p><img loading="lazy" alt="image-20250323213354384" src="/assets/images/image-20250323213354384-7c26ea0051556893cd0325ade8c91984.png" width="1486" height="853" class="img_ev3q"></p><p>Linux内核通常以2~3个月为周期更新一次大的版本号，如Linux 2.6.34是在2010年5月发布的，Linux 2.6.35的发布时间则为2010年8月。Linux 2.6的最后一个版本是Linux 2.6.39，之后Linux内核过渡到Linux 3.0版本，同样以2~3个月为周期更新小数点后第一位。因此，内核Linux 3.x时代，Linux 3和Linux 2.6的地位对等，因此，Linux 2.6时代的版本变更是Linux 2.6.N~2.6.N+1以2~3个月为周期递进，而Linux 3.x时代后，则是Linux 3.N~3.N+1以2~3个月为周期递进。Linux 3.x的最后一个版本是Linux 3.19。</p><p>在Linux内核版本发布后，还可以进行一个修复bug或者少量特性的反向移植（Backport，即把新版本中才有的补丁移植到已经发布的老版本中）的工作，这样的版本以小数点后最后一位的形式发布，如Linux 2.6.35.1、Linux 2.6.35.2、Linux 3.10.1和Linux 3.10.2等。此类已经发布的版本的维护版本通常是由Greg Kroah-Hartman等人进行管理的。Greg Kroah-Hartman是名著LDD3（《Linux设备驱动（第3版）》的作者之一。</p><p>关于Linux内核从Linux 2.6.39变更为Linux 3.0的变化，按照Linus Torvalds的解释，并没有什么大的改变：“NOTHING.Absolutely nothing.Sure，we have the usual two thirds driver changes，and a lot of random fixes，but the point is that 3.0is<em>just</em>about renumbering，we are very much<em>not</em>doing a KDE-4or a Gnome-3here.No breakage，no special scary new features，nothing at all like that.”因此，简单来说，版本号变更为“3.x”的原因就是“我喜欢”。</p><p>关于Linux内核每一个版本具体的变更，可以参考网页<a href="http://kernelnewbies.org/LinuxVersions" target="_blank" rel="noopener noreferrer">http://kernelnewbies.org/LinuxVersions</a> ，比如Linux 3.15针对Linux 3.14的变更归纳在：<a href="http://kernelnewbies.org/Linux_3.15" target="_blank" rel="noopener noreferrer">http://kernelnewbies.org/Linux_3.15</a> 。</p><p>就在本书写作的过程中，2015年2月23日，也迎来了Linux 4.0-rc1的诞生，而理由仍然是那么“无厘头”：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">..after extensive statistical analysis of my G+ polling，I&#x27;ve come to the inescapable conclusion that internet polls are bad.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Big surprise.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">But&quot;Hurr durr I&#x27;ma sheep&quot;trounced&quot;I like online polls&quot;by a 62-to-38%margin，in a poll that people weren&#x27;t even supposed to participate in.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Who can argue with solid numbers like that 5796 votes from people who can&#x27;t even follow the most basic directions</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">In contrast，&quot;v4.0&quot;beat out&quot;v3.20&quot;by a slimmer margin of 56-to-44%，but with a total of 29110 votes right now.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Now，arguably，that vote spread is only about 3200 votes，which is less than the almost six thousand votes that the&quot;please ignore&quot;poll got，so it could be considered noise.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">But hey，I asked，so I&#x27;ll honor the votes.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从表3.1可以看出，Linux的开发一直朝着支持更多的CPU、硬件体系结构和外部设备，支持更广泛领域的应用，提供更好的性能这3个方向发展。按照现在的状况，Linux内核本身基本没有大的路线图，完全是根据使用Linux内核的企业和个人的需求，被相应的企业和个人开发出来并贡献给Linux产品线的。简单地说，Linux内核是一个演变而不是一个设计。关于Linux的近期热点和走向，可以参考位于<a href="http://www.linuxfoundation.org/news-media/lwf" target="_blank" rel="noopener noreferrer">http://www.linuxfoundation.org/news-media/lwf</a> 的《Linux Weather </p><p>除了Linux内核本身可提供免费下载以外，一些厂商封装了Linux内核和大量有用的软件包、中间件、桌面环境和应用程序，制定了针对桌面PC和服务器的Linux发行版（Distro），如Ubuntu、Red Hat、Fedora、Debian、SuSe、Gentoo等，国内的红旗Linux开发商中科红旗则已经宣布倒闭。</p><p>再者，针对嵌入式系统的应用，一些集成和优化内核、开发工具、中间件和UI框架的嵌入式Linux被开发出来了，例如MontaVista Linux、Mentor Embedded Linux、MeeGo、Tizen、Firefox OS等。</p><p>Android采用Linux内核，但是在内核里加入了一系列补丁，如Binder、ashmem、wakelock、low memory killer、RAM_CONSOLE等，目前，这些补丁中的绝大多数已经进入Linux的产品线。</p><p>图3.1显示了Linux 2.6.13以来每个内核版本参与的人、组织的情况以及每次版本演进的时候被改变的代码行数和补丁的数量。目前每次版本升级，都有分布于200多个组织超过1000人提交代码，被改变的代码行数超过100万行，补丁数量达1万个。</p><p><img loading="lazy" alt="1742737052939" src="/assets/images/1742737052939-b3567893cdc0cd905f6c12945f4d01d4.png" width="1486" height="1044" class="img_ev3q"></p><p>图3.1　Linux内核开发人员和补丁情况</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.885Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->13 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>USB采用树形拓扑结构，主机侧和设备侧的USB控制器分别称为主机控制器（Host Controller）和USB设备控制器（UDC），每条总线上只有一个主机控制器，负责协调主机和设备间的通信，而设备不能主动向主机发送任何消息。如图16.1所示，在Linux系统中，USB驱动可以从两个角度去观察，一个角度是主机侧，一个角度是设备侧。</p><p>如图16.1的左侧所示，从主机侧去看，在Linux驱动中，处于USB驱动最底层的是USB主机控制器硬件，在其上运行的是USB主机控制器驱动，在主机控制器上的为USB核心层，再上层为USB设备驱动层（插入主机上的U盘、鼠标、USB转串口等设备驱动）。因此，在主机侧的层次结构中，要实现的USB驱动包括两类：USB主机控制器驱动和USB设备驱动，前者控制插入其中的USB设备，后者控制USB设备如何与主机通信。Linux内核中的USB核心负责USB驱动管理和协议处理的主要工作。主机控制器驱动和设备驱动之间的USB核心非常重要，其功能包括：通过定义一些数据结构、宏和功能函数，向上为设备驱动提供编程接口，向下为USB主机控制器驱动提供编程接口；维护整个系统的USB设备信息；完成设备热插拔控制、总线数据传输控制等。</p><p><img loading="lazy" alt="image-20250421222438443" src="/assets/images/image-20250421222438443-1065b95c589fbd144e2b0a44b3485540.png" width="1215" height="666" class="img_ev3q"></p><p>图16.1　Linux USB驱动总体结构</p><p>如图16.1的右侧所示，Linux内核中USB设备侧驱动程序分为3个层次：UDC驱动程序、Gadget Function API和Gadget Function驱动程序。UDC驱动程序直接访问硬件，控制USB设备和主机间的底层通信，向上层提供与硬件相关操作的回调函数。当前Gadget Function API是UDC驱动程序回调函数的简单包装。Gadget Function驱动程序具体控制USB设备功能的实现，使设备表现出“网络连接”、“打印机”或“USB Mass Storage”等特性，它使用Gadget Function API控制UDC实现上述功能。Gadget Function API把下层的UDC驱动程序和上层的Gadget Function驱动程序隔离开，使得在Linux系统中编写USB设备侧驱动程序时能够把功能的实现和底层通信分离。</p><h1>16.1.2　设备、配置、接口、端点</h1><p>在USB设备的逻辑组织中，包含设备、配置、接口和端点4个层次。</p><p>每个USB设备都提供不同级别的配置信息，可以包含一个或多个配置，不同的配置使设备表现出不同的功能组合（在探测/连接期间需从其中选定一个），配置由多个接口组成。</p><p>在USB协议中，接口由多个端点组成，代表一个基本的功能，是USB设备驱动程序控制的对象，一个功能复杂的USB设备可以具有多个接口。每个配置中可以有多个接口，而设备接口是端点的汇集（Collection）。例如，USB扬声器可以包含一个音频接口以及对旋钮和按钮的接口。一个配置中的所有接口可以同时有效，并可被不同的驱动程序连接。每个接口可以有备用接口，以提供不同质量的服务参数。</p><p>端点是USB通信的最基本形式，每一个USB设备接口在主机看来就是一个端点的集合。主机只能通过端点与设备进行通信，以使用设备的功能。在USB系统中每一个端点都有唯一的地址，这是由设备地址和端点号给出的。每个端点都有一定的属性，其中包括传输方式、总线访问频率、带宽、端点号和数据包的最大容量等。一个USB端点只能在一个方向上承载数据，从主机到设备（称为输出端点）或者从设备到主机（称为输入端点），因此端点可看作是一个单向的管道。端点0通常为控制端点，用于设备初始化参数等。只要设备连接到USB上并且上电，端点0就可以被访问。端点1、2等一般用作数据端点，存放主机与设备间往来的数据。</p><p>总体而言，USB设备非常复杂，由许多不同的逻辑单元组成，如图16.2所示，这些单元之间的关系如下：</p><p><img loading="lazy" alt="1745245932552" src="/assets/images/1745245932552-0338ce34a4e40141d321c098ee0ae38a.png" width="1197" height="484" class="img_ev3q"></p><p>图16.2　USB设备、配置、接口和端点</p><ul><li>·设备通常有一个或多个配置；</li><li>·配置通常有一个或多个接口；</li><li>·接口通常有一个或多个设置；</li><li>·接口有零个或多个端点。</li></ul><p>这种层次化配置信息在设备中通过一组标准的描述符来描述，如下所示。</p><ul><li>·设备描述符：关于设备的通用信息，如供应商ID、产品ID和修订ID，支持的设备类、子类和适用的协议以及默认端点的最大包大小等。在Linux内核中，USB设备用usb_device结构体来描述，USB设备描述符定义为usb_device_descriptor结构体，位于include/uapi/linux/usb/ch9.h文件中，如代码清单16.1所示。</li></ul><p>代码清单16.1　usb_device_descriptor结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_device_descriptor  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   __u8  bLength;           /* 描述符长度*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   __u8  bDescriptorType;   /* 描述符类型编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   __le16 bcdUSB;           /* USB版本号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   __u8  bDeviceClass;      /* USB分配的设备类code */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   __u8  bDeviceSubClass;   /* USB分配的子类code */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   __u8  bDeviceProtocol;   /* USB分配的协议code */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   __u8  bMaxPacketSize0;   /* endpoint0最大包大小*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   __le16 idVendor;         /* 厂商编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   __le16 idProduct;        /* 产品编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   __le16 bcdDevice;        /* 设备出厂编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   __u8  iManufacturer;     /* 描述厂商字符串的索引*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   __u8  iProduct;          /* 描述产品字符串的索引*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   __u8  iSerialNumber;     /* 描述设备序列号字符串的索引*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   __u8  bNumConfigurations;/* 可能的配置数量*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17} __attribute__ ((packed));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>·配置描述符：此配置中的接口数、支持的挂起和恢复能力以及功率要求。USB配置在内核中使用usb_host_config结构体描述，而USB配置描述符定义为结构体usb_config_descriptor，如代码清单16.2所示。</li></ul><p>代码清单16.2　usb_config_descriptor结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_config_descriptor  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   __u8  bLength;               /* 描述符长度*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   __u8  bDescriptorType;       /* 描述符类型编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   __le16 wTotalLength;         /* 配置所返回的所有数据的大小*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   __u8  bNumInterfaces;        /* 配置所支持的接口数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   __u8  bConfigurationValue;   /* Set_Configuration命令需要的参数值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   __u8  iConfiguration;        /* 描述该配置的字符串的索引值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   __u8  bmAttributes;          /* 供电模式的选择*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   __u8  bMaxPower;             /* 设备从总线提取的最大电流 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12} _ attribute__ ((packed));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>·接口描述符：接口类、子类和适用的协议，接口备用配置的数目和端点数目。USB接口在内核中使用usb_interface结构体描述，而USB接口描述符定义为结构体usb_interface_descriptor，如代码清单16.3所示。</li></ul><p>代码清单16.3　usb_interface_descriptor结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_interface_descriptor  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   __u8  bLength;               /* 描述符长度*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   __u8  bDescriptorType;       /* 描述符类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   __u8  bInterfaceNumber;      /* 接口的编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   __u8  bAlternateSetting;     /* 备用的接口描述符编号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   __u8  bNumEndpoints;         /* 该接口使用的端点数，不包括端点0 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   __u8  bInterfaceClass;       /* 接口类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   __u8  bInterfaceSubClass;    /* 接口子类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   __u8  bInterfaceProtocol;    /* 接口所遵循的协议*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   __u8  iInterface;            /* 描述该接口的字符串索引值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13} __attribute__ ((packed));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>·端点描述符：端点地址、方向和类型，支持的最大包大小，如果是中断类型的端点则还包括轮询频率。在Linux内核中，USB端点使用usb_host_endpoint结构体来描述，而USB端点描述符定义为usb_endpoint_descriptor结构体，如代码清单16.4所示。</li></ul><p>代码清单16.4　usb_endpoint_descriptor结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1  struct usb_endpoint_descriptor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   __u8  bLength;              /* 描述符长度*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   __u8  bDescriptorType;      /* 描述符类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   __u8  bEndpointAddress;     /* 端点地址：0~3位是端点号，第7位是方向(0为输出,1为输入) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   __u8  bmAttributes;         /* 端点属性：bit[0:1] 的值为00表示控制，为01表示同步，为02表示批量，为03表示中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   __le16 wMaxPacketSize;      /* 本端点接收或发送的最大信息包的大小*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   __u8  bInterval;            /* 轮询数据传送端点的时间间隔*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                               /* 对于批量传送的端点以及控制传送的端点，此域忽略*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                               /* 对于同步传送的端点，此域必须为1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                               /* 对于中断传送的端点，此域值的范围为1~255 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   __u8  bRefresh;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   __u8  bSynchAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14} __attribute__ ((packed));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>·字符串描述符：在其他描述符中会为某些字段提供字符串索引，它们可被用来检索描述性字符串，可以以多种语言形式提供。字符串描述符是可选的，有的设备有，有的设备没有，字符串描述符对应于usb_string_descriptor结构体，如代码清单16.5所示。</li></ul><p>代码清单16.5　usb_string_descriptor结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_string_descriptor {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   __u8  bLength;            /* 描述符长度*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   __u8  bDescriptorType;    /* 描述符类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   __le16 wData[1];          /* 以UTF-16LE编码*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7} __attribute__ ((packed));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>例如，笔者在PC上插入一个SanDisk U盘后，通过lsusb命令得到与这个U盘相关的描述符，从中可以显示这个U盘包含了一个设备描述符、一个配置描述符、一个接口描述符、批量输入和批量输出两个端点描述符。呈现出来的信息内容直接对应于usb_device_descriptor、usb_config_descriptor、usb_interface_descriptor、usb_endpoint_descriptor、usb_string_descriptor结构体，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Bus 001 Device 004: ID 0781:5151 SanDisk Corp.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Device Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bLength              18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bDescriptorType        1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bcdUSB             2.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bDeviceClass           0 Interface</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bDeviceSubClass         0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bDeviceProtocol         0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bMaxPacketSize0        64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> idVendor          0x0781 SanDisk Corp.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> idProduct         0x5151</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bcdDevice           0.10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> iManufacturer          1 SanDisk Corporation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> iProduct              2 Cruzer Micro</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> iSerial               3 20060877500A1BE1FDE1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bNumConfigurations      1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Configuration Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bLength                 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bDescriptorType        2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  wTotalLength          32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bNumInterfaces         1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bConfigurationValue     1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  iConfiguration         0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  bmAttributes        0x80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  MaxPower            200mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  Interface Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bLength               9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bDescriptorType        4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bInterfaceNumber       0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bAlternateSetting      0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bNumEndpoints         2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bInterfaceClass        8 Mass Storage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bInterfaceSubClass     6 SCSI</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bInterfaceProtocol    80 Bulk (Zip)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   iInterface           0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength              7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType       5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bEndpointAddress    0x81  EP 1 IN</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bmAttributes          2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Transfer Type         Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Synch Type           none</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wMaxPacketSize      512</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterval            0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Endpoint Descriptor:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bLength              7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bDescriptorType       5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bEndpointAddress    0x01  EP 1 OUT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bmAttributes          2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Transfer Type           Bulk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     Synch Type             none</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wMaxPacketSize       512</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bInterval             1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> Language IDs: (length=4)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   0409 English(US)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.881Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->11 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在X86处理器中存在着I/O空间的概念，I/O空间是相对于内存空间而言的，它通过特定的指令in、out来访问。端口号标识了外设的寄存器地址。Intel语法中的in、out指令格式如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">IN 累加器, {端口号│DX}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">OUT {端口号│DX},累加器</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>目前，大多数嵌入式微控制器（如ARM、PowerPC等）中并不提供I/O空间，而仅存在内存空间。内存空间可以直接通过地址、指针来访问，程序及在程序运行中使用的变量和其他数据都存在于内存空间中。</p><p>内存地址可以直接由C语言指针操作，例如在186处理器中执行如下代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned char *p = (unsigned char *)0xF000FF00;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*p=11; </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以上程序的意义是在绝对地址0xF0000+0xFF00（186处理器使用16位段地址和16位偏移地址）中写入11。</p><p>而在ARM、PowerPC等未采用段地址的处理器中，p指向的内存空间就是0xF000FF00，而*p=11就是在该地址写入11。</p><p>再如，186处理器启动后会在绝对地址0xFFFF0（对应的C语言指针是0xF000FFF0，0xF000为段地址，0xFFF0为段内偏移）中执行，请看下面的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef void (*lpFunction) ( );    /* 定义一个无参数、无返回类型的函数指针类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lpFunction lpReset = (lpFunction)0xF000FFF0; /* 定义一个函数指针，指向*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* CPU启动后所执行的第一条指令的位置*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lpReset();     /* 调用函数*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在以上程序中，没有定义任何一个函数实体，但是程序却执行了这样的函数调用：lpReset（），它实际上起到了“软重启”的作用，跳转到CPU启动后第一条要执行的指令的位置。因此，可以通过函数指针调用一个没有函数体的“函数”，这本质上只是换一个地址开始执行。</p><p>即便是在X86处理器中，虽然提供了I/O空间，如果由我们自己设计电路板，外设仍然可以只挂接在内存空间中。此时，CPU可以像访问一个内存单元那样访问外设I/O端口，而不需要设立专门的I/O指令。因此，内存空间是必需的，而I/O空间是可选的。图11.1给出了内存空间和I/O空间的对比。</p><p><img loading="lazy" alt="1743604691202" src="/assets/images/1743604691202-0c95bb32207bca17dbbdd7a29ecde2bf.png" width="991" height="573" class="img_ev3q"></p><p>图11.1　内存空间和I/O空间</p><h1>11.1.2　内存管理单元</h1><p>高性能处理器一般会提供一个内存管理单元（MMU），该单元辅助操作系统进行内存管理，提供虚拟地址和物理地址的映射、内存访问权限保护和Cache缓存控制等硬件支持。操作系统内核借助MMU可以让用户感觉到程序好像可以使用非常大的内存空间，从而使得编程人员在写程序时不用考虑计算机中物理内存的实际容量。</p><p>为了理解基本的MMU操作原理，需先明晰几个概念。</p><p>1）TLB（Translation Lookaside Buffer）：即转换旁路缓存，TLB是MMU的核心部件，它缓存少量的虚拟地址与物理地址的转换关系，是转换表的Cache，因此也经常被称为“快表”。</p><p>2）TTW（Translation Table walk）：即转换表漫游，当TLB中没有缓冲对应的地址转换关系时，需要通过对内存中转换表（大多数处理器的转换表为多级页表，如图11.2所示）的访问来获得虚拟地址和物理地址的对应关系。TTW成功后，结果应写入TLB</p><p><img loading="lazy" alt="image-20250402223913713" src="/assets/images/image-20250402223913713-9d1abe7b46ea74d299d666a4aef02d81.png" width="1084" height="534" class="img_ev3q"></p><p>图11.2　内存中的转换表</p><p>图11.3给出了一个典型的ARM处理器访问内存的过程，其他处理器也执行类似过程。当ARM要访问存储器时，MMU先查找TLB中的虚拟地址表。如果ARM的结构支持分开的数据TLB（DTLB）和指令TLB（ITLB），则除了取指令使用ITLB外，其他的都使用DTLB。ARM处理器的MMU如图11.3所示。</p><p><img loading="lazy" alt="image-20250402223937691" src="/assets/images/image-20250402223937691-8e76ca0c479ae1e415259202581ace09.png" width="913" height="445" class="img_ev3q"></p><p>图11.3　ARM处理器的MMU</p><p>若TLB中没有虚拟地址的入口，则转换表遍历硬件并从存放于主存储器内的转换表中获取地址转换信息和访问权限（即执行TTW），同时将这些信息放入TLB，它或者被放在一个没有使用的入口或者替换一个已经存在的入口。之后，在TLB条目中控制信息的控制下，当访问权限允许时，对真实物理地址的访问将在Cache或者在内存中发生，如图11.4所示。</p><p><img loading="lazy" alt="image-20250402224028190" src="/assets/images/image-20250402224028190-35dc8f0b580a90aa78360192e2a85e06.png" width="1000" height="1378" class="img_ev3q"></p><p>图11.4　ARM CPU进行数据访问的流程</p><p>ARM内TLB条目中的控制信息用于控制对对应地址的访问权限以及Cache的操作。</p><ul><li>·C（高速缓存）和B（缓冲）位被用来控制对应地址的高速缓存和写缓冲，并决定是否进行高速缓存。</li><li>·访问权限和域位用来控制读写访问是否被允许。如果不允许，MMU则向ARM处理器发送一个存储器异常，否则访问将被允许进行。</li></ul><p>上述描述的MMU机制针对的虽然是ARM处理器，但PowerPC、MIPS等其他处理器也均有类似的操作。</p><p>MMU具有虚拟地址和物理地址转换、内存访问权限保护等功能，这将使得Linux操作系统能单独为系统的每个用户进程分配独立的内存空间并保证用户空间不能访问内核空间的地址，为操作系统的虚拟内存管理模块提供硬件基础。</p><p>在Linux 2.6.11之前，Linux内核硬件无关层使用了三级页表PGD、PMD和PTE；从Linux 2.6.11开始，为了配合64位CPU的体系结构，硬件无关层则使用了4级页表目录管理的方式，即PGD、PUD、PMD和PTE。注意这仅仅是一种软件意义上的抽象，实际硬件的页表级数可能少于4。代码清单11.1给出了一个典型的从虚拟地址得到PTE的页表查询（Page Table Walk）过程，它取自arch/arm/lib/uaccess_with_memcpy.c。</p><p>代码清单11.1　Linux的四级页表与页表查询</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2pin_page_for_write(const void __user *_addr, pte_t **ptep, spinlock_t **ptlp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned long addr = (unsigned long)_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 pgd_t *pgd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 pmd_t *pmd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 pte_t *pte;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 pud_t *pud;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 spinlock_t *ptl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 pgd = pgd_offset(current-&gt;mm, addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 if (unlikely(pgd_none(*pgd) || pgd_bad(*pgd)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 pud = pud_offset(pgd, addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 if (unlikely(pud_none(*pud) || pud_bad(*pud)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 pmd = pmd_offset(pud, addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 if (unlikely(pmd_none(*pmd)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24  * A pmd can be bad if it refers to a HugeTLB or THP page.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  * Both THP and HugeTLB pages have the same pmd layout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  * and should not be manipulated by the pte functions.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  * Lock the page table for the destination and check</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  * to see that it&#x27;s still huge and whether or not we will</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31  * need to fault on write, or if we have a splitting THP.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 if (unlikely(pmd_thp_or_huge(*pmd))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34     ptl = &amp;current-&gt;mm-&gt;page_table_lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35     spin_lock(ptl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36     if (unlikely(!pmd_thp_or_huge(*pmd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37         || pmd_hugewillfault(*pmd)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38         || pmd_trans_splitting(*pmd))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39         spin_unlock(ptl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40         return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43     *ptep = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44     *ptlp = ptl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45     return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48 if (unlikely(pmd_bad(*pmd)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51 pte = pte_offset_map_lock(current-&gt;mm, pmd, addr, &amp;ptl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52 if (unlikely(!pte_present(*pte) || !pte_young(*pte) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53     !pte_write(*pte) || !pte_dirty(*pte))) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54     pte_unmap_unlock(pte, ptl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58 *ptep = pte;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59 *ptlp = ptl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61 return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第1行的类型为struct，mm_struct的参数mm用于描述Linux进程所占有的内存资源。上述代码中的pgd_offset、pud_offset、pmd_offset分别用于得到一级页表、二级页表和三级页表的入口，最后通过pte_offset_map_lock得到目标页表项pte。而且第33行还通过pmd_thp_or_huge（）判断是否有巨页的情况，如果是巨页，就直接访问pmd。</p><p>但是，MMU并不是对所有的处理器都是必需的，例如常用的SAMSUNG基于ARM7TDMI系列的S3C44B0X不附带MMU，新版的Linux 2.6支持不带MMU的处理器。在嵌入式系统中，仍存在大量无MMU的处理器，Linux 2.6为了更广泛地应用于嵌入式系统，融合了mClinux，以支持这些无MMU系统，如Dragonball、ColdFire、Hitachi H8/300、Blackfin等。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.877Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>由于I2 C总线控制器通常是在内存上的，所以它本身也连接在platform总线上，要通过platform_driver和platform_device的匹配来执行。因此尽管I2 C适配器给别人提供了总线，它自己也被认为是接在platform总线上的一个客户。Linux的总线、设备和驱动模型实际上是一个树形结构，每个节点虽然可能成为别人的总线控制器，但是自己也被认为是从上一级总线枚举出来的。</p><p>通常我们会在与I2 C适配器所对应的platform_driver的probe（）函数中完成两个工作。</p><ul><li>·初始化I2 C适配器所使用的硬件资源，如申请I/O地址、中断号、时钟等。</li><li>·通过i2c_add_adapter（）添加i2c_adapter的数据结构，当然这个i2c_adapter数据结构的成员已经被xxx适配器的相应函数指针所初始化。</li></ul><p>通常我们会在platform_driver的remove（）函数中完成与加载函数相反的工作。</p><ul><li>·释放I2 C适配器所使用的硬件资源，如释放I/O地址、中断号、时钟等。</li><li>·通过i2c_del_adapter（）删除i2c_adapter的数据结构。</li></ul><p>代码清单15.9所示为I2 C适配器驱动的注册和注销模板。</p><p>代码清单15.9　I2 C适配置驱动的注册和注销模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_i2c_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         struct i2c_adapter *adap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         xxx_adpater_hw_init()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         adap-&gt;dev.parent = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         adap-&gt;dev.of_node = pdev-&gt;dev.of_node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         rc = i2c_add_adapter(adap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14static int xxx_i2c_remove(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         xxx_adpater_hw_free()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         i2c_del_adapter(&amp;dev-&gt;adapter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23static const struct of_device_id xxx_i2c_of_match[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24         {.compatible = &quot;vendor,xxx-i2c&quot;,},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27MODULE_DEVICE_TABLE(of, xxx_i2c_of_match);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29static struct platform_driver xxx_i2c_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30         .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31                   .name = &quot;xxx-i2c&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32                   .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33                   .of_match_table = xxx_i2c_of_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34                   },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35         .probe = xxx_i2c_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36         .remove = xxx_i2c_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38module_platform_driver(xxx_i2c_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中的xxx_adpater_hw_init（）和xxx_adpater_hw_free（）函数的实现都与具体的CPU和I2 C适配器硬件直接相关。</p><h1>15.3.2　I2 C总线的通信方法</h1><p>我们需要为特定的I2 C适配器实现通信方法，主要是实现i2c_algorithm的functionality（）函数和master_xfer（）函数。</p><p>functionality（）函数非常简单，用于返回algorithm所支持的通信协议，如I2C_FUNC_I2C、I2C_FUNC_10BIT_ADDR、I2C_FUNC_SMBUS_READ_BYTE、I2C_FUNC_SMBUS_WRITE_BYTE等。</p><p>master_xfer（）函数在I2 C适配器上完成传递给它的i2c_msg数组中的每个I2 C消息，代码清单15.10所示为xxx设备的master_xfer（）函数模板。</p><p>代码清单15.10　master_xfer（）函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int i2c_adapter_xxx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2    int num)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    for (i = 0; i &lt; num; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      i2c_adapter_xxx_start();                                          /* 产生开始位*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      /*是读消息*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      if (msgs[i]-&gt;flags &amp;I2C_M_RD) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        i2c_adapter_xxx_setaddr((msg-&gt;addr &lt;&lt; 1) | 1);                  /* 发送从设备读地址*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        i2c_adapter_xxx_wait_ack();                                     /* 获得从设备的ack */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        i2c_adapter_xxx_readbytes(msgs[i]-&gt;buf, msgs[i]-&gt;len);          /* 读取msgs[i] -&gt;len</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          长的数据到msgs[i]-&gt;buf */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      } else {                                                          /* 是写消息*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        i2c_adapter_xxx_setaddr(msg-&gt;addr &lt;&lt; 1);                        /* 发送从设备写地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        i2c_adapter_xxx_wait_ack();                                     /* 获得从设备的ack */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        i2c_adapter_xxx_writebytes(msgs[i]-&gt;buf, msgs[i]-&gt;len);         /* 读取msgs[i]-&gt;len</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17          长的数据到msgs[i]-&gt;buf */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    i2c_adapter_xxx_stop();                                             /* 产生停止位*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码实际上给出了一个master_xfer（）函数处理I2 C消息数组的流程，对于数组中的每个消息，先判断消息类型，若为读消息，则赋从设备地址为（msg-&gt;addr&lt;&lt;1）|1，否则为msg-&gt;addr&lt;&lt;1。对每个消息产生一个开始位，紧接着传送从设备地址，然后开始数据的发送或接收，且对最后的消息还需产生一个停止位。图15.3所示为整个master_xfer（）完成的时序。</p><p><img loading="lazy" alt="1745070496677" src="/assets/images/1745070496677-6ec19e762a2f032d160919fe29141aac.png" width="1387" height="342" class="img_ev3q"></p><p>图15.3　master_xfer（）完成的时序</p><p>master_xfer（）函数模板中的i2c_adapter_xxx_start（）、i2c_adapter_xxx_setaddr（）、i2c_adapter_xxx_wait_ack（）、i2c_adapter_xxx_readbytes（）、i2c_adapter_xxx_writebytes（）和i2c_adapter_xxx_stop（）函数用于完成适配器的底层硬件操作，与I2 C适配器和CPU的具体硬件直接相关，需要由工程师根据芯片的数据手册来实现。</p><p>i2c_adapter_xxx_readbytes（）用于从从设备上接收一串数据，i2c_adapter_xxx_writebytes（）用于向从设备写入一串数据，这两个函数的内部也会涉及I2 C总线协议中的ACK应答。</p><p>master_xfer（）函数的实现形式会很多种，多数驱动以中断方式来完成这个流程，比如发起硬件操作请求后，将自己调度出去，因此中间会伴随着睡眠的动作。</p><p>多数I2 C总线驱动会定义一个xxx_i2c结构体，作为i2c_adapter的algo_data（类似“私有数据”），其中包含I2 C消息数组指针、数组索引及I2 C适配器Algorithm访问控制用的自旋锁、等待队列等，而master_xfer（）函数在完成i2c_msg数组中消息的处理时，也经常需要访问xxx_i2c结构体的成员以获取寄存器基地址、锁等信息。代码清单15.11所示为一个典型的xxx_i2c结构体的定义，与图15.2中的xxx_i2c是对应的，具体的实现因硬件而异。</p><p>代码清单15.11　xxx_i2c结构体模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct xxx_i2c {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   spinlock_t     lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   wait_queue_head_t wait;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   struct i2c_msg    *msg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   unsigned int      msg_num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   unsigned int      msg_idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   unsigned int      msg_ptr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   struct i2c_adapter    adap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.865Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux支持STANDBY、挂起到RAM、挂起到硬盘等形式的待机，如图19.9所示。一般的嵌入式产品仅仅只实现了挂起到RAM（也简称为s2ram，或常简称为STR），即将系统的状态保存于内存中，并将SDRAM置于自刷新状态，待用户按键等操作后再重新恢复系统。少数嵌入式Linux系统会实现挂起到硬盘（简称STD），它与挂起到RAM的不同是s2ram并不关机，STD则把系统的状态保持于磁盘，然后关闭整个系统。</p><p><img loading="lazy" alt="1747061022345" src="/assets/images/1747061022345-2354eb9d7c4f8a53961707068432fccc.png" width="828" height="682" class="img_ev3q"></p><p>图19.9　Linux的待机模式</p><p>在Linux下，这些行为通常是由用户空间触发的，通过向/sys/power/state写入mem可开始挂起到RAM的流程。当然，许多Linux产品会有一个按键，一按就进入挂起到RAM。这通常是由于与这个按键对应的输入设备驱动汇报了一个和电源相关的input_event，用户空间的电源管理daemon进程收到这个事件后，再触发s2ram的。当然，内核也有一个INPUT_APMPOWER驱动，位于drivers/input/apm-power.c下，它可以在内核级别侦听EV_PWR类事件，并通过apm_queue_event（APM_USER_SUSPEND）自动引发s2ram：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void system_power_event(unsigned int keycode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">switch (keycode) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case KEY_SUSPEND:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             apm_queue_event(APM_USER_SUSPEND);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             pr_info(&quot;Requesting system suspend...\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void apmpower_event(struct input_handle *handle, unsigned int type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int code, int value)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">switch (type) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">case EV_PWR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              system_power_event(code);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">break;…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux内核中，大致的挂起到RAM的挂起和恢复流程如图19.10所示（牵涉的操作包括同步文件系统、freeze进程、设备驱动挂起以及系统的挂起入口等）。</p><p>在Linux内核的device_driver结构中，含有一个pm成员，它是一个dev_pm_ops结构体指针，在该结构体中，封装了挂起到RAM和挂起到硬盘所需要的回调函数，如代码清单19.13所示。</p><p>代码清单19.13　dev_pm_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 struct dev_pm_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        int (*prepare)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        void (*complete)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        int (*suspend)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int (*resume)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int (*freeze)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        int (*thaw)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        int (*poweroff)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        int (*restore)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        int (*suspend_late)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        int (*resume_early)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        int (*freeze_late)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int (*thaw_early)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        int (*poweroff_late)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int (*restore_early)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int (*suspend_noirq)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        int (*resume_noirq)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        int (*freeze_noirq)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        int (*thaw_noirq)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        int (*poweroff_noirq)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        int (*restore_noirq)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        int (*runtime_suspend)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        int (*runtime_resume)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        int (*runtime_idle)(struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>图19.10实际上也给出了在挂起到RAM的时候这些PM回调函数的调用时机。</p><p><img loading="lazy" alt="1747061123361" src="/assets/images/1747061123361-8f0db27b2eefe095386c1b4842ded450.png" width="798" height="1228" class="img_ev3q"></p><p>图19.10　Linux挂起到RAM流程</p><p>目前比较推荐的做法是在platform_driver、i2c_driver和spi_driver等xxx_driver结构体实例的driver成员中，以上述结构体的形式封装PM回调函数，并赋值到driver的pm字段。如代码清单19.14中的第50行，在drivers/spi/spi-s3c64xx.c中，platform_driver中的pm成员被赋值。</p><p>代码清单19.14　设备驱动中的pm成员</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#ifdef CONFIG_PM_SLEEP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2static int s3c64xx_spi_suspend(struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct spi_master *master = dev_get_drvdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 int ret = spi_master_suspend(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 if (ret)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9     return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!pm_runtime_suspended(dev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     clk_disable_unprepare(sdd-&gt;clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     clk_disable_unprepare(sdd-&gt;src_clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 sdd-&gt;cur_speed = 0; /* 输出时钟停止*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21static int s3c64xx_spi_resume(struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 struct spi_master *master = dev_get_drvdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 struct s3c64xx_spi_driver_data *sdd = spi_master_get_devdata(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 struct s3c64xx_spi_info *sci = sdd-&gt;cntrlr_info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 if (sci-&gt;cfg_gpio)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28     sci-&gt;cfg_gpio();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30 if (!pm_runtime_suspended(dev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31     clk_prepare_enable(sdd-&gt;src_clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32     clk_prepare_enable(sdd-&gt;clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 s3c64xx_spi_hwinit(sdd, sdd-&gt;port_id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37 return spi_master_resume(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39#endif /* CONFIG_PM_SLEEP */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41static const struct dev_pm_ops s3c64xx_spi_pm = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 SET_SYSTEM_SLEEP_PM_OPS(s3c64xx_spi_suspend, s3c64xx_spi_resume)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43 SET_RUNTIME_PM_OPS(s3c64xx_spi_runtime_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44            s3c64xx_spi_runtime_resume, NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47static struct platform_driver s3c64xx_spi_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48 .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49     .name= &quot;s3c64xx-spi&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50     .pm = &amp;s3c64xx_spi_pm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51     .of_match_table = of_match_ptr(s3c64xx_spi_dt_match),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53 .probe = s3c64xx_spi_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54 .remove = s3c64xx_spi_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55 .id_table = s3c64xx_spi_driver_ids,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>s3c64xx_spi_suspend（）完成了时钟的禁止，s3c64xx_spi_resume（）则完成了硬件的重新初始化、时钟的使能等工作。第42行的SET_SYSTEM_SLEEP_PM_OPS是一个快捷宏，它完成suspend、resume等成员函数的赋值：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .suspend = suspend_fn, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .resume = resume_fn, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .freeze = suspend_fn, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .thaw = resume_fn, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .poweroff = suspend_fn, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .restore = resume_fn,</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了上述推行的做法以外，在platform_driver、i2c_driver、spi_driver等xxx_driver结构体中仍然保留了过时（Legacy）的suspend、resume入口函数（目前不再推荐使用过时的接口，而是推荐赋值xxx_driver中的driver的pm成员），譬如代码清单19.15给出的platform_driver就包含了过时的suspend、resume等。</p><p>代码清单19.15　设备驱动中过时的PM成员函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct platform_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2       int (*probe)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       int (*remove)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       void (*shutdown)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       int (*suspend)(struct platform_device *, pm_message_t state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       int (*resume)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       struct device_driver driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       const struct platform_device_id *id_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux的核心层中，实际上是优先选择执行xxx_driver.driver.pm.suspend（）成员函数，在前者不存在的情况下，执行过时的xxx_driver.suspend（），如platform_pm_suspend（）的逻辑如代码清单19.16所示</p><p>代码清单19.16　驱动核心层寻找PM回调的顺序</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int platform_pm_suspend(struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      struct device_driver *drv = dev-&gt;driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      if (!drv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7            return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      if (drv-&gt;pm) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10             if (drv-&gt;pm-&gt;suspend)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                    ret = drv-&gt;pm-&gt;suspend(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12      } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13             ret = platform_legacy_suspend(dev, PMSG_SUSPEND);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>一般来讲，在设备驱动的挂起入口函数中，会关闭设备、关闭该设备的时钟输入，甚至是关闭设备的电源，在恢复时则完成相反的的操作。在挂起到RAM的挂起和恢复过程中，系统恢复后要求所有设备的驱动都工作正常。为了调试这个过程，可以使能内核的PM_DEBUG选项，如果想在挂起和恢复的过程中，看到内核的打印信息以关注具体的详细流程，可以在Bootloader传递给内核的bootargs中设置标志no_console_suspend。</p><p>在将Linux移植到一个新的ARM SoC的过程中，最终系统挂起的入口需由芯片供应商在相应的arch/arm/mach-xxx中实现platform_suspend_ops的成员函数，一般主要实现其中的enter和valid成员，并将整个platform_suspend_ops结构体通过内核通用API suspend_set_ops（）注册进系统，如arch/arm/mach-prima2/pm.c中prima2SoC级挂起流程的逻辑如代码清单19.17所示。</p><p>代码清单19.17　系统挂起到RAM的SoC级代码</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int sirfsoc_pm_enter(suspend_state_t state)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      switch (state) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      case PM_SUSPEND_MEM:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5             sirfsoc_pre_suspend_power_off();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7             outer_flush_all();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8             outer_disable();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9             /* go zzz */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10              cpu_suspend(0, sirfsoc_finish_suspend);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11              outer_resume();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12              break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14              return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 static const struct platform_suspend_ops sirfsoc_pm_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        .enter = sirfsoc_pm_enter,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        .valid = suspend_valid_only_mem,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 int __init sirfsoc_pm_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26       suspend_set_ops(&amp;sirfsoc_pm_ops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中第5行的sirfsoc_pre_suspend_power_off（）的实现如代码清单19.18所示，它会将系统恢复回来后重新开始执行的物理地址存入与SoC相关的寄存器中。与本例对应的寄存器为SIRFSOC_PWRC_SCRATCH_PAD1，并向该寄存器写入了virt_to_phys（cpu_resume）。在系统重新恢复中，会执行cpu_resume这段汇编，并进行设置唤醒源等操作。</p><p>代码清单19.18　SoC设置恢复回来时的执行地址</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int sirfsoc_pre_suspend_power_off(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      u32 wakeup_entry = virt_to_phys(cpu_resume);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      sirfsoc_rtc_iobrg_writel(wakeup_entry, sirfsoc_pwrc_base +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6             SIRFSOC_PWRC_SCRATCH_PAD1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      sirfsoc_set_wakeup_source();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      sirfsoc_set_sleep_mode(SIRFSOC_DEEP_SLEEP_MODE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而cpu_suspend（0，sirfsoc_finish_suspend）以及其中调用的与SoC相关的用汇编实现的函数sirfsoc_finish_suspend（）真正完成最后的待机并将系统置于深度睡眠，同时置SDRAM于自刷新状态的过程，具体的代码高度依赖于特定的芯片，其实现一般是一段汇编。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.853Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>根据图12.4，Linux倾向于将主机端的驱动与外设端的驱动分离，而通过一个核心层将某种总线的协议进行抽象，外设端的驱动调用核心层API间接过渡到对主机驱动传输函数的调用。对于I2 C、SPI这类不具备热插拔能力的总线而言，一般在arch/arm/mach-xxx或者arch/arm/boot/dts中会有相应的板级描述信息，描述外设与主机的连接情况。</p><p>Linux的各个子系统都呈现为相同的特点，表17.1类比了I2 C、SPI、USB驱动架构，其他的PCI等都是类似的。</p><p>表17.1　I2 C、SPI、USB驱动架构的类比</p><p><img loading="lazy" alt="1745505837492" src="/assets/images/1745505837492-3ff46a99080ff1d1592e0dbf2fa9f471.png" width="1474" height="657" class="img_ev3q"></p><p>对于USB、PCI等总线而言，由于它们具备热插拔能力，所以实际上不存在类似I2 C、SPI这样的板级描述信息。换句话说，即便是有这类信息，其实也没有什么用，因为如果写了板子上有个U盘，但实际上没有，其实反而是制造了麻烦；相反，如果没有写，U盘一旦插入，Linux USB子系统会自动探测到一个U盘。</p><p>同时我们注意到，I2 C、SPI、USB控制器虽然给别人提供了总线，但是其实自己也是由它自身依附的总线枚举出来的。比如，对于SoC而言，这些控制器一般是直接集成在芯片内部，通过内存访问指令来访问的，因此它们自身是通过platform_driver、platform_device这种模型枚举进来的。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.853Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核有两种导出符号的方法给模块使用，一种方法是EXPORT_SYMBOL（），另外一种是EXPORT_SYMBOL_GPL（）。这一点和模块A导出符号给模块B用是一致的。</p><p>内核的Documentation/DocBook/kernel-hacking.tmpl明确表明“the symbols exported by EXPORT_SYMBOL_GPL（）can only be seen by modules with a MODULE_LICENSE（）that specifies a GPL compatible license.”由此可见内核用EXPORT_SYMBOL_GPL（）导出的符号是不可以被非GPL模块引用的。</p><p>由于相当多的内核符号都是以EXPORT_SYMBOL_GPL（）导出的，所以历史上曾经有一些公司把内核的EXPORT_SYMBOL_GPL（）直接改为EXPORT_SYMBOL（），然后将修改后的内核以GPL形式发布。这样修改内核之后，模块不再使用内核的EXPORT_SYMBOL_GPL（）符号，因此模块不再需要GPL。对此Linus的回复是：“I think both them said that anybody who were to change a xyz_GPL to the non-GPL one in order to use it with a non-GPL module would almost immediately fall under the“willful infringement”thing，and that it would make it MUCH easier to get triple damages and/or injunctions，since they clearly knew about it”。因此，这种做法可能构成“蓄意侵权（willful infringement）”。</p><p>另外一种做法是写一个wrapper内核模块（这个模块遵循GPL），把EXPORT_SYMBOL_GPL（）导出的符号封装一次后再以EXPORT_SYMBOL（）形式导出，而其他的模块不直接调用内核而是调用wrapper函数，如图4.1所示。这种做法也具有争议。</p><p><img loading="lazy" alt="image-20250323224837473" src="/assets/images/image-20250323224837473-24fdc1a90bd735401b625bb46b1bbda9.png" width="1102" height="547" class="img_ev3q"></p><p>图4.1　将EXPORT_SYMBOL_GPL重新以EXPORT_SYMBOL导出</p><p>一般认为，保守的做法是Linux内核不能使用非GPL许可权</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.841Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>我们可以用“module_param（参数名，参数类型，参数读/写权限）”为模块定义一个参数，例如下列代码定义了1个整型参数和1个字符指针参数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static char *book_name = &quot;dissecting Linux Device Driver&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_param(book_name, charp, S_IRUGO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int book_num = 4000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_param(book_num, int, S_IRUGO);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在装载内核模块时，用户可以向模块传递参数，形式为“insmode（或modprobe）模块名参数名=参数值”，如果不传递，参数将使用模块内定义的缺省值。如果模块被内置，就无法insmod了，但是bootloader可以通过在bootargs里设置“模块名.参数名=值”的形式给该内置的模块传递参数。</p><p>参数类型可以是byte、short、ushort、int、uint、long、ulong、charp（字符指针）、bool或invbool（布尔的反），在模块被编译时会将module_param中声明的类型与变量定义的类型进行比较，判断是否一致</p><p>除此之外，模块也可以拥有参数数组，形式为“module_param_array（数组名，数组类型，数组长，参数读/写权限）”。</p><p>模块被加载后，在/sys/module/目录下将出现以此模块名命名的目录。当“参数读/写权限”为0时，表示此参数不存在sysfs文件系统下对应的文件节点，如果此模块存在“参数读/写权限”不为0的命令行参数，在此模块的目录下还将出现parameters目录，其中包含一系列以参数名命名的文件节点，这些文件的权限值就是传入module_param（）的“参数读/写权限”，而文件的内容为参数的值。</p><p>运行insmod或modprobe命令时，应使用逗号分隔输入的数组元素。</p><p>现在我们定义一个包含两个参数的模块（如代码清单4.4，位于本书配套源代码/kernel/drivers/param目录下），并观察模块加载时被传递参数和不传递参数时的输出。</p><p>代码清单4.4　带参数的内核模块</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 #include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 #include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 static char *book_name = &quot;dissecting Linux Device Driver&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 module_param(book_name, charp, S_IRUGO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 static int book_num = 4000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 module_param(book_num, int, S_IRUGO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 static int __init book_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   printk(KERN_INFO &quot;book name:%s\n&quot;, book_name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   printk(KERN_INFO &quot;book num:%d\n&quot;, book_num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 module_init(book_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 static void __exit book_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20   printk(KERN_INFO &quot;book module exit\n &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 module_exit(book_exit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 MODULE_AUTHOR(&quot;Barry Song &lt;baohua@kernel.org&gt;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 MODULE_DESCRIPTION(&quot;A simple Module for testing module params&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 MODULE_VERSION(&quot;V1.0&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对上述模块运行“insmod book.ko”命令加载，相应输出都为模块内的默认值，通过查看“/var/log/messages”日志文件可以看到内核的输出</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># tail -n 2 /var/log/messages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Jul  2 01:03:10 localhost kernel:  &lt;6&gt; book name:dissecting Linux Device Driver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Jul  2 01:03:10 localhost kernel:  book num:4000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当用户运行“insmod book.ko book_name=&#x27;GoodBook&#x27;book_num=5000”命令时，输出的是用户传递的参数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># tail -n 2 /var/log/messages</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Jul  2 01:06:21 localhost kernel:  &lt;6&gt; book name:GoodBook</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Jul  2 01:06:21 localhost kernel:  book num:5000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，在/sys目录下，也可以看到book模块的参数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">barry@barry-VirtualBox:/sys/module/book/parameters$ tree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> book_name└──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> book_num</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>并且我们可以通过“cat book_name”和“cat book_num”查看它们的值。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.825Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>网络设备驱动的注册与注销由register_netdev（）和unregister_netdev（）函数完成，这两个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int register_netdev(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void unregister_netdev(struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这两个函数都接收一个net_device结构体指针为参数，可见net_device数据结构在网络设备驱动中的核心地位。</p><p>net_device的生成和成员的赋值并不一定要由工程师亲自动手逐个完成，可以利用下面的宏帮助我们填充：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define alloc_netdev(sizeof_priv, name, setup) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         alloc_netdev_mqs(sizeof_priv, name, setup, 1, 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define alloc_etherdev_mq(sizeof_priv, count) alloc_etherdev_mqs(sizeof_priv,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    count, count)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>alloc_netdev以及alloc_etherdev宏引用的alloc_netdev_mqs（）函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct net_device *alloc_netdev_mqs(int sizeof_priv, const char *name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                void (*setup)(struct net_device *),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unsigned int txqs, unsigned int rxqs);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>alloc_netdev_mqs（）函数生成一个net_device结构体，对其成员赋值并返回该结构体的指针。第一个参数为设备私有成员的大小，第二个参数为设备名，第三个参数为net_device的setup（）函数指针，第四、五个参数为要分配的发送和接收子队列的数量。setup（）函数接收的参数也为struct net_device指针，用于预置net_device成员的值。</p><p>free_netdev（）完成与alloc_enetdev（）和alloc_etherdev（）函数相反的功能，即释放net_device结构体的函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void free_netdev(struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>net_device结构体的分配和网络设备驱动的注册需在网络设备驱动程序初始化时进行，而net_device结构体的释放和网络设备驱动的注销在设备或驱动被移除的时候执行，如代码清单14.4所示。</p><p>代码清单14.4　网络设备驱动程序的注册和注销</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_register(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  /* 分配net_device结构体并对其成员赋值</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  xxx_dev = alloc_netdev(sizeof(struct xxx_priv), &quot;sn%d&quot;, xxx_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  if (xxx_dev == NULL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  ... /* 分配net_device失败*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  /* 注册net_device结构体 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    if ((result = register_netdev(xxx_dev)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14static void xxx_unregister(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  /* 注销net_device结构体*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  unregister_netdev(xxx_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  /* 释放net_device结构体*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  free_netdev(xxx_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.825Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>充斥着ARM社区的大量垃圾代码导致Linus盛怒，因此该社区在2011~2012年进行了大量的修整工作。ARM Linux开始围绕设备树展开，设备树有自己的独立语法，它的源文件为.dts，编译后得到.dtb，Bootloader在引导Linux内核的时候会将.dtb地址告知内核。之后内核会展开设备树并创建和注册相关的设备，因此arch/arm/mach-xxx和arch/arm/plat-xxx中的大量用于注册platform、I2 C、SPI等板级信息的代码被删除，而驱动也以新的方式与在.dts中定义的设备节点进行匹配。</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/4"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/6"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>