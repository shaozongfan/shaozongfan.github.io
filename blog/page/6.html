<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/6"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/6"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/6" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/6" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.825Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>存储器主要可分类为只读储存器（ROM）、闪存（Flash）、随机存取存储器（RAM）、光/磁介质储存器。</p><p>ROM还可再细分为不可编程ROM、可编程ROM（PROM）、可擦除可编程ROM（EPROM）和电可擦除可编程ROM（E2PROM），E2PROM完全可以用软件来擦写，已经非常方便了。</p><p>NOR（或非）和NAND（与非）是市场上两种主要的Flash闪存技术。Intel于1988年首先开发出NOR Flash技术，彻底改变了原先由EPROM和EEPROM一统天下的局面。紧接着，1989年，东芝公司发表了NAND Flash结构，每位的成本被大大降低。</p><p>NOR Flash和CPU的接口属于典型的类SRAM接口（如图2.5所示），不需要增加额外的控制电路。NOR Flash的特点是可芯片内执行（eXecute In Place，XIP），程序可以直接在NOR内运行。而NAND Flash和CPU的接口必须由相应的控制电路进行转换，当然也可以通过地址线或GPIO产生NAND Flash接口的信号。NAND Flash以块方式进行访问，不支持芯片内执行。</p><p><img loading="lazy" alt="image-20250323161236990" src="/assets/images/image-20250323161236990-c6b884361ef00cc82dd5ebfcb6df2b1f.png" width="1045" height="598" class="img_ev3q"></p><p>图2.5　典型的类SRAM接口</p><p>公共闪存接口（Common Flash Interface，CFI）是一个从NOR Flash器件中读取数据的公开、标准接口。它可以使系统软件查询已安装的Flash器件的各种参数，包括器件阵列结构参数、电气和时间参数以及器件支持的功能等。如果芯片不支持CFI，就需使用JEDEC（Joint Electron Device Engineering Council，电子电器设备联合会）了。JEDEC规范的NOR则无法直接通过命令来读出容量等信息，需要读出制造商ID和设备ID，以确定Flash的大小</p><p>与NOR Flash的类SRAM接口不同，一个NAND Flash的接口主要包含如下信号。</p><ul><li>·I/O总线：地址、指令和数据通过这组总线传输，一般为8位或16位。</li><li>·芯片启动（Chip Enable，CE#）：如果没有检测到CE信号，NAND器件就保持待机模式，不对任何控制信号做出响应。</li><li>·写使能（Write Enable，WE#）：WE#负责将数据、地址或指令写入NAND之中。</li><li>·读使能（Read Enable，RE#）：RE#允许数据输出。</li><li>·指令锁存使能（Command Latch Enable，CLE）：当CLE为高电平时，在WE#信号的上升沿，指令将被锁存到NAND指令寄存器中。</li><li>·地址锁存使能（Address Latch Enable，ALE）：当ALE为高电平时，在WE#信号的上升沿，地址将被锁存到NAND地址寄存器中。</li><li>·就绪/忙（Ready/Busy，R/B#）：如果NAND器件忙，R/B#信号将变为低电平。该信号是漏极开路，需要采用上拉电阻。</li></ul><p>NAND Flash较NOR Flash容量大，价格低；NAND Flash中每个块的最大擦写次数是100万次，而NOR的擦写次数是10万次；NAND Flash的擦除、编程速度远超过NOR Flash。</p><p>Flash的编程原理都是只能将1写为0，而不能将0写为1。因此在Flash编程之前，必须将对应的块擦除，而擦除的过程就是把所有位都写为1的过程，块内的所有字节变为0xFF。另外，Flash还存在一个负载均衡的问题，不能老是在同一块位置进行擦除和写的动作，这样容易导致坏块。</p><p>值得一提的是，目前NOR Flash可以使用SPI接口进行访问以节省引脚。相对于传统的并行NOR Flash而言，SPI NOR Flash只需要6个引脚就能够实现单I/O、双I/O和4个I/O口的接口通信，有的SPI NOR Flash还支持DDR模式，能进一步提高访问速度到80MB/s。</p><p>IDE（Integrated Drive Electronics）接口可连接硬盘控制器或光驱，IDE接口的信号与SRAM类似。人们通常也把IDE接口称为ATA（Advanced Technology Attachment）接口，不过，从技术角度而言，这并不准确。其实，ATA接口发展至今，已经经历了ATA-1（IDE）、ATA-2（Enhanced IDE/Fast ATA，EIDE）、ATA-3（FastATA-2）、Ultra ATA、Ultra ATA/33、Ultra ATA/66、Ultra ATA/100及Serial ATA（SATA）的发展过程。</p><p>很多SoC集成了一个eFuse电编程熔丝作为OTP（One-Time Programmable，一次性可编程）存储器。eFuse可以通过计算机对芯片内部的参数和功能进行配置，这一般是在芯片出厂的时候已经设置好了。</p><p>以上所述的各种ROM、Flash和磁介质存储器都属于非易失性存储器（NVM）的范畴，掉电时信息不会丢失，而RAM则与此相反。</p><p>RAM也可再分为静态RAM（SRAM）和动态RAM（DRAM）。DRAM以电荷形式进行存储，数据存储在电容器中。由于电容器会因漏电而出现电荷丢失，所以DRAM器件需要定期刷新。SRAM是静态的，只要供电它就会保持一个值，SRAM没有刷新周期。每个SRAM存储单元由6个晶体管组成，而DRAM存储单元由1个晶体管和1个电容器组成。</p><p>通常所说的SDRAM、DDR SDRAM皆属于DRAM的范畴，它们采用与CPU外存控制器同步的时钟工作（注意，不是与CPU的工作频率一致）。与SDRAM相比，DDR SDRAM同时利用了时钟脉冲的上升沿和下降沿传输数据，因此在时钟频率不变的情况下，数据传输频率加倍。此外，还存在使用RSL（Rambus Signaling Level，Rambus发信电平）技术的RDRAM（Rambus DRAM）和Direct RDRAM。</p><p>针对许多特定场合的应用，嵌入式系统中往往还使用了一些特定类型的RAM。</p><h1>1.DPRAM：双端口RAM</h1><p>DPRAM的特点是可以通过两个端口同时访问，具有两套完全独立的数据总线、地址总线和读写控制线，通常用于两个处理器之间交互数据，如图2.6所示。当一端被写入数据后，另一端可以通过轮询或中断获知，并读取其写入的数据。由于双CPU同时访问DPRAM时的仲裁逻辑电路集成在DPRAM内部，所以需要硬件工程师设计的电路原理比较简单。</p><p><img loading="lazy" alt="1742717776065" src="/assets/images/1742717776065-004a9c630752b19b2ffac9190e98f587.png" width="1348" height="478" class="img_ev3q"></p><p>图2.6　双端口RAM</p><p>DPRAM的优点是通信速度快、实时性强、接口简单，而且两边处理器都可主动进行数据传输。除了双端口RAM以外，目前IDT等芯片厂商还推出了多端口RAM，可以供3个以上的处理器互通数据</p><h1>2.CAM：内容寻址RAM</h1><p>CAM是以内容进行寻址的存储器，是一种特殊的存储阵列RAM，它的主要工作机制就是同时将一个输入数据项与存储在CAM中的所有数据项自动进行比较，判别该输入数据项与CAM中存储的数据项是否相匹配，并输出该数据项对应的匹配信息。</p><p>如图2.7所示，在CAM中，输入的是所要查询的数据，输出的是数据地址和匹配标志。若匹配（即搜寻到数据），则输出数据地址。CAM用于数据检索的优势是软件无法比拟的，它可以极大地提高系统性能。</p><p><img loading="lazy" alt="1742717832648" src="/assets/images/1742717832648-1c0b74afe550a773dba3c662ed342329.png" width="832" height="442" class="img_ev3q"></p><p>图2.7　CAM的输入与输出</p><h1>3.FIFO：先进先出队列</h1><p>FIFO存储器的特点是先进先出，进出有序，FIFO多用于数据缓冲。FIFO和DPRAM类似，具有两个访问端口，但是FIFO两边的端口并不对等，某一时刻只能设置为一边作为输入，一边作为输出。</p><p>如果FIFO的区域共有n个字节，我们只能通过循环n次读取同一个地址才能将该片区域读出，不能指定偏移地址。对于有n个数据的FIFO，当循环读取m次之后，下一次读时会自动读取到第m+1个数据，这是由FIFO本身的特性决定的。</p><p>总结2.2节的内容，可得出如图2.8所示的存储器分类。</p><p><img loading="lazy" alt="1742717901303" src="/assets/images/1742717901303-57f759f79b0dc11beca984edc066420d.png" width="816" height="1023" class="img_ev3q"></p><p>图2.8　存储器分类</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.825Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->25 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>RS-232、RS-422与RS-485都是串行数据接口标准，最初都是由电子工业协会（EIA）制订并发布的。</p><p>RS-232在1962年发布，命名为EIA-232-E。之后发布的RS-422定义了一种平衡通信接口，它是一种单机发送、多机接收的单向、平衡传输规范，被命名为TIA/EIA-422-A标准。RS-422改进了RS-232通信距离短、速率低的缺点。为进一步扩展应用范围，EIA又于1983年在RS-422的基础上制定了RS-485标准，增加了多点、双向通信能力，即允许多个发送器连接到同一条总线上，同时增加了发送器的驱动能力和冲突保护特性，并扩展了总线共模范围，被命名为TIA/EIA-485-A标准。</p><p>1969年发布的RS-232修改版RS-232C是嵌入式系统中应用最广泛的串行接口，它为连接DTE（数据终端设备）与DCE（数据通信设备）而制定。RS-232C标准接口有25条线（4条数据线、11条控制线、3条定时线、7条备用和未定义线），常用的只有9根，它们是RTS/CTS（请求发送/清除发送流控制）、RxD/TxD（数据收发）、DSR/DTR（数据终端就绪/数据设置就绪流控制）、DCD（数据载波检测，也称RLSD，即接收线信号检出）、Ringing-RI（振铃指示）、SG（信号地）信号。RTS/CTS、RxD/TxD、DSR/DTR等信号的定义如下。</p><ul><li>·RTS：用来表示DTE请求DCE发送数据，当终端要发送数据时，使该信号有效。</li><li>·CTS：用来表示DCE准备好接收DTE发来的数据，是对RTS的响应信号。</li><li>·RxD：DTE通过RxD接收从DCE发来的串行数据。</li><li>·TxD：DTE通过TxD将串行数据发送到DCE。</li><li>·DSR：有效（ON状态）表明DCE可以使用。</li><li>·DTR：有效（ON状态）表明DTE可以使用。</li><li>·DCD：当本地DCE设备收到对方DCE设备送来的载波信号时，使DCD有效，通知DTE准备接收，并且由DCE将接收到的载波信号解调为数字信号，经RxD线送给DTE。</li><li>·Ringing-RI：当调制解调器收到交换台送来的振铃呼叫信号时，使该信号有效（ON状态），通知终端，已被呼叫。</li></ul><p>最简单的RS-232C串口只需要连接RxD、TxD、SG这3个信号，并使用XON/XOFF软件流控。</p><p>组成一个RS-232C串口的硬件原理如图2.9所示，从CPU到连接器依次为CPU、UART（通用异步接收器发送器，作用是完成并/串转换）、CMOS/TTL电平与RS-232C电平转换、DB9/DB25或自定义连接器。</p><p><img loading="lazy" alt="1742718057594" src="/assets/images/1742718057594-d68bf50ab59c830a9291dfdb209fcbe5.png" width="1239" height="477" class="img_ev3q"></p><p>图2.9　RS-232C串口电路原理</p><h1>2.3.2　I2 C</h1><p>I2 C（内置集成电路）总线是由Philips公司开发的两线式串行总线，产生于20世纪80年代，用于连接微控制器及其外围设备。I2 C总线简单而有效，占用的PCB（印制电路板）空间很小，芯片引脚数量少，设计成本低。I2 C总线支持多主控（Multi-Mastering）模式，任何能够进行发送和接收的设备都可以成为主设备。主控能够控制数据的传输和时钟频率，在任意时刻只能有一个主控。</p><p>组成I2 C总线的两个信号为数据线SDA和时钟SCL。为了避免总线信号的混乱，要求各设备连接到总线的输出端必须是开漏输出或集电极开路输出的结构。总线空闲时，上拉电阻使SDA和SCL线都保持高电平。根据开漏输出或集电极开路输出信号的“线与”逻辑，I2 C总线上任意器件输出低电平都会使相应总线上的信号线变低。</p><p>线与”逻辑指的是两个或两个以上的输出直接互连就可以实现“与”的逻辑功能，只有输出端是开漏（对于CMOS器件）输出或集电极开路（对于TTL器件）输出时才满足此条件。工程师一般以“OC门”简称开漏或集电极开路。</p><p>I2 C设备上的串行数据线SDA接口电路是双向的，输出电路用于向总线上发送数据，输入电路用于接收总线上的数据。同样地，串行时钟线SCL也是双向的，作为控制总线数据传送的主机要通过SCL输出电路发送时钟信号，并检测总线上SCL上的电平以决定什么时候发下一个时钟脉冲电平；作为接收主机命令的从设备需按总线上SCL的信号发送或接收SDA上的信号，它也可以向SCL线发出低电平信号以延长总线时钟信号周期。</p><p>当SCL稳定在高电平时，SDA由高到低的变化将产生一个开始位，而由低到高的变化则产生一个停止位，如图2.10所示。</p><p>开始位和停止位都由I2 C主设备产生。在选择从设备时，如果从设备采用7位地址，则主设备在发起传输过程前，需先发送1字节的地址信息，前7位为设备地址，最后1位为读写标志。之后，每次传输的数据也是1字节，从MSB开始传输。每个字节传完后，在SCL的第9个上升沿到来之前，接收方应该发出1个ACK位。SCL上的时钟脉冲由I2 C主控方发出，在第8个时钟周期之后，主控方应该释放SDA，I2 C总线的时序如图2.11所示。</p><p><img loading="lazy" alt="image-20250323162212364" src="/assets/images/image-20250323162212364-d7a7cbec2cd4f305f52c1e8a7f7d1b42.png" width="993" height="360" class="img_ev3q"></p><p>图2.10　I2 C总线的开始位和停止位</p><p><img loading="lazy" alt="image-20250323162236449" src="/assets/images/image-20250323162236449-0baf4351e6cf9d8c3d798d1e59e59978.png" width="1504" height="427" class="img_ev3q"></p><p>图2.11　I2 C总线的时序</p><h1>2.3.3　SPI</h1><p>SPI（Serial Peripheral Interface，串行外设接口）总线系统是一种同步串行外设接口，它可以使CPU与各种外围设备以串行方式进行通信以交换信息。一般主控SoC作为SPI的“主”，而外设作为SPI的“从”。</p><p>SPI接口一般使用4条线：串行时钟线（SCLK）、主机输入/从机输出数据线MISO、主机输出/从机输入数据线MOSI和低电平有效的从机选择线SS（在不同的文献里，也常称为nCS、CS、CSB、CSN、nSS、STE、SYNC等）。图2.12演示了1个主机连接3个SPI外设的硬件连接图。</p><p><img loading="lazy" alt="1742718205025" src="/assets/images/1742718205025-ddc6328329d7a33fa66ddede0b15b5b3.png" width="775" height="586" class="img_ev3q"></p><p>图2.12　SPI主、从硬件连接图</p><p>如图2.13所示，在SPI总线的传输中，SS信号是低电平有效的，当我们要与某外设通信的时候，需要将该外设上的SS线置低。此外，特别要注意SPI从设备支持的SPI总线最高时钟频率（决定了SCK的频率）以及外设的CPHA、CPOL模式，这决定了数据与时钟之间的偏移、采样的时刻以及触发的边沿是上升沿还是下降沿。</p><p><img loading="lazy" alt="image-20250323162353183" src="/assets/images/image-20250323162353183-6e4799ab0c0aeb523ec77d00d48c8dbb.png" width="949" height="553" class="img_ev3q"></p><p>SPI模块为了和外设进行数据交换，根据外设工作要求，其输出串行同步时钟极性（CPOL）和相位（CPHA）可以进行配置。如果CPOL=0，串行同步时钟的空闲状态为低电平；如果CPOL=1，串行同步时钟的空闲状态为高电平。如果CPHA=0，在串行同步时钟的第一个跳变沿（上升或下降）数据被采样；如果CPHA=1，在串行同步时钟的第二个跳变沿（上升或下降）数据被采样。</p><h1>2.3.4　USB</h1><p>USB（通用串行总线）是Intel、Microsoft等厂商为解决计算机外设种类的日益增加与有限的主板插槽和端口之间的矛盾而于1995年提出的，它具有数据传输率高、易扩展、支持即插即用和热插拔的优点，目前已得到广泛应用。</p><p>USB 1.1包含全速和低速两种模式，低速方式的速率为1.5Mbit/s，支持一些不需要很大数据吞吐量和很高实时性的设备，如鼠标等。全速模式为12Mbit/s，可以外接速率更高的外设。在USB 2.0中，增加了一种高速方式，数据传输率达到480Mbit/s，半双工，可以满足更高速外设的需要。而USB 3.0（也被认为是Super Speed USB）的最大传输带宽高达5.0Gbit/s（即640MB/s），全双工。</p><p>USB 2.0总线的机械连接非常简单，采用4芯的屏蔽线，一对差分线（D+、D-）传送信号，另一对（VBUS、电源地）传送+5V的直流电。USB 3.0线缆则设计了8条内部线路，除VBUS、电源地之外，其余3对均为数据传输线路。其中保留了D+与D-这两条兼容USB 2.0的线路，新增了SSRX与SSTX专为USB 3.0所设的线路。</p><p>在嵌入式系统中，电路板若需要挂接USB设备，则需提供USB主机（Host）控制器和连接器；若电路板需要作为USB设备，则需提供USB设备适配器和连接器。目前，大多数SoC集成了USB主机控制器（以连接USB外设）和设备适配器（以将本嵌入式系统作为其他计算机系统的USB外设，如手机充当U盘）。由USB主机、设备和Hub组成的USB系统的物理拓扑结构如图2.14所示。</p><p><img loading="lazy" alt="image-20250323162522113" src="/assets/images/image-20250323162522113-2fb9268db8d765327b82bc5a2750991a.png" width="1044" height="612" class="img_ev3q"></p><p>图2.14　USB的物理拓扑结构</p><p>每一个USB设备会有一个或者多个逻辑连接点在里面，每个连接点叫端点。USB提供了多种传输方式以适应各种设备的需要，一个端点可以选择如下一种传输方式。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1控制control传输方式">1.控制（Control）传输方式<a class="hash-link" href="#1控制control传输方式" title="标题的直接链接">​</a></h2><p>控制传输是双向传输，数据量通常较小，主要用来进行查询、配置和给USB设备发送通用命令。所有USB设备必须支持标准请求（Standard Request），控制传输方式和端点0。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2同步isochronous传输方式">2.同步（Isochronous）传输方式<a class="hash-link" href="#2同步isochronous传输方式" title="标题的直接链接">​</a></h2><p>同步传输提供了确定的带宽和间隔时间，它用于时间要求严格并具有较强容错性的流数据传输，或者用于要求恒定数据传送率的即时应用。例如进行语音业务传输时，使用同步传输方式是很好的选择。同步传输也常称为“Streaming Real-time”传输。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3中断interrupt传输方式">3.中断（Interrupt）传输方式<a class="hash-link" href="#3中断interrupt传输方式" title="标题的直接链接">​</a></h2><p>中断方式传送是单向的，对于USB主机而言，只有输入。中断传输方式主要用于定时查询设备是否有中断数据要传送，该传输方式应用在少量分散的、不可预测的数据传输场合，键盘、游戏杆和鼠标属于这一类型</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4批量bulk传输方式">4.批量（Bulk）传输方式<a class="hash-link" href="#4批量bulk传输方式" title="标题的直接链接">​</a></h2><p>批量传输主要应用在没有带宽、间隔时间要求的批量数据的传送和接收中，它要求保证传输。打印机和扫描仪属于这种类型。</p><p>而USB 3.0则增加了一种Bulk Streams传输模式，USB 2.0的Bulk模式只支持1个数据流，而Bulk Streams传输模式则可以支持多个数据流，每个数据流被分配一个Stream ID（SID），每个SID与一个主机缓冲区对应。</p><p>在USB架构中，集线器负责检测设备的连接和断开，利用其中断IN端点（Interrupt IN Endpoint）来向主机报告。一旦获悉有新设备连接上来，主机就会发送一系列请求给设备所挂载的集线器，再由集线器建立起一条连接主机和设备之间的通信通道。然后主机以控制传输的方式，通过端点0对设备发送各种请求，设备收到主机发来的请求后回复相应的信息，进行枚举（Enumerate）操作。因此USB总线具备热插拔的能力。</p><h1>2.3.5　以太网接口</h1><p>以太网接口由MAC（以太网媒体接入控制器）和PHY（物理接口收发器）组成。以太网MAC由IEEE 802.3以太网标准定义，实现了数据链路层。常用的MAC支持10Mbit/s或100Mbit/s两种速率。吉比特以太网（也称为千兆位以太网）是快速以太网的下一代技术，将网速提高到了1000Mbit/s。千兆位以太网以IEEE 802.3z和802.3ab发布，作为IEEE 802.3标准的补充。</p><p>MAC和PHY之间采用MII（媒体独立接口）连接，它是IEEE-802.3定义的以太网行业标准，包括1个数据接口与MAC和PHY之间的1个管理接口。数据接口包括分别用于发送和接收的两条独立信道，每条信道都有自己的数据、时钟和控制信号，MII数据接口总共需要16个信号。MII管理接口包含两个信号，一个是时钟信号，另一个是数据信号。通过管理接口，上层能监视和控制PHY</p><p>一个以太网接口的硬件电路原理如图2.15所示，从CPU到最终接口依次为CPU、MAC、PHY、以太网隔离变压器、RJ45插座。以太网隔离变压器是以太网收发芯片与连接器之间的磁性组件，在其两者之间起着信号传输、阻抗匹配、波形修复、信号杂波抑制和高电压隔离作用</p><p><img loading="lazy" alt="1742719479213" src="/assets/images/1742719479213-928121640489aa712a5c0a3f79477c79.png" width="1399" height="430" class="img_ev3q"></p><p>图2.15　以太网接口的硬件电路原理</p><p>许多处理器内部集成了MAC或同时集成了MAC和PHY，另有许多以太网控制芯片也集成了MAC和PHY。</p><h1>2.3.6　PCI和PCI-E</h1><p>PCI（外围部件互连）是由Intel于1991年推出的一种局部总线，作为一种通用的总线接口标准，它在目前的计算机系统中得到了非常广泛应用。PCI总线具有如下特点。</p><ul><li>·数据总线为32位，可扩充到64位。</li><li>·可进行突发（Burst）模式传输。突发方式传输是指取得总线控制权后连续进行多个数据的传输。突发传输时，只需要给出目的地的首地址，访问第1个数据后，第2~n个数据会在首地址的基础上按一定规则自动寻址和传输。与突发方式对应的是单周期方式，它在1个总线周期只传送1个数据。</li><li>·总线操作与处理器—存储器子系统操作并行。</li><li>·采用中央集中式总线仲裁。</li><li>·支持全自动配置、资源分配，PCI卡内有设备信息寄存器组为系统提供卡的信息，可实现即插即用。</li><li>·PCI总线规范独立于微处理器，通用性好。</li><li>·PCI设备可以完全作为主控设备控制总线。</li></ul><p>图2.16给出了一个典型的基于PCI总线的计算机系统逻辑示意图，系统的各个部分通过PCI总线和PCI-PCI桥连接在一起。CPU和RAM通过PCI桥连接到PCI总线0（即主PCI总线），而具有PCI接口的显卡则可以直接连接到主PCI总线上。PCI-PCI桥是一个特殊的PCI设备，它负责将PCI总线0和PCI总线1（即从PCI主线）连接在一起，通常PCI总线1称为PCI-PCI桥的下游（Downstream），而PCI总线0则称为PCI-PCI桥的上游（Upstream）。为了兼容旧的ISA总线标准，PCI总线还可以通过PCI-ISA桥来连接ISA总线，从而支持以前的ISA设备。</p><p><img loading="lazy" alt="image-20250323164722794" src="/assets/images/image-20250323164722794-dff44aab052ecfc0401ed65092a76d83.png" width="1078" height="526" class="img_ev3q"></p><p>图2.16　基于PCI总线的计算机系统逻辑示意图</p><p>当PCI卡刚加电时，卡上配置空间即可以被访问。PCI配置空间保存着该卡工作时所需的所有信息，如厂家、卡功能、资源要求、处理能力、功能模块数量、主控卡能力等。通过对这个空间信息的读取与编程，可完成对PCI卡的配置。如图2.17所示，PCI配置空间共为256字节，主要包括如下信息。</p><ul><li>·制造商标识（Vendor ID）：由PCI组织分配给厂家。</li><li>·设备标识（Device ID）：按产品分类给本卡的编号。</li><li>·分类码（Class Code）：本卡功能的分类码，如图卡、显示卡、解压卡等。·申请存储器空间：PCI卡内有存储器或以存储器编址的寄存器和I/O空间，为使驱动程序和应用程序能访问它们，需申请CPU的一段存储区域以进行定位。配置空间的基地址寄存器用于此目的。</li><li>·申请I/O空间：配置空间中的基地址寄存器用来进行系统I/O空间的申请。</li><li>·中断资源申请：配置空间中的中断引脚和中断线用来向系统申请中断资源。偏移3Dh处为中断引脚寄存器，其值表明PCI设备使用了哪一个中断引脚，对应关系为1—INTA#、2—INTB#、3—INTC#、4—INTD#。</li></ul><p><img loading="lazy" alt="image-20250323164820583" src="/assets/images/image-20250323164820583-e3e03727f276c094a7c50813fc769b55.png" width="1074" height="1044" class="img_ev3q"></p><p>图2.17　PCI配置空间</p><p>PCI-E（PCI Express）是Intel公司提出的新一代的总线接口，PCI Express采用了目前业内流行的点对点串行连接，比起PCI以及更早的计算机总线的共享并行架构，每个设备都有自己的专用连接，采用串行方式传输数据，不需要向整个总线请求带宽，并可以把数据传输率提高到一个很高的频率，达到PCI所不能提供的高带宽。</p><p>PCI Express在软件层面上兼容目前的PCI技术和设备，支持PCI设备和内存模组的初始化，也就是说无须推倒目前的驱动程序、操作系统，就可以支持PCI Express设备。</p><h1>2.3.7　SD和SDIO</h1><p>SD（Secure Digital）是一种关于Flash存储卡的标准，也就是一般常见的SD记忆卡，在设计上与MMC（Multi-Media Card）保持了兼容。SDHC（SD High Capacity）是大容量SD卡，支持的最大容量为32GB。2009年发布的SDXC（SD eXtended Capacity）则支持最大2TB大小的容量</p><p>SDIO（Secure Digital Input and Output Card，安全数字输入输出卡）在SD标准的基础上，定义了除存储卡以外的外设接口。SDIO主要有两类应用——可移动和不可移动。不可移动设备遵循相同的电气标准，但不要求符合物理标准。现在已经有非常多的手机或者手持装置都支持SDIO的功能，以连接WiFi、蓝牙、GPS等模块。</p><p>一般情况下，芯片内部集成的SD控制器同时支持MMC、SD卡，又支持SDIO卡，但是SD和SDIO的协议还是有不一样的地方，支持的命令也会有不同。</p><p>SD/SDIO的传输模式有：</p><ul><li>·SPI模式</li><li>·1位模式</li><li>·4位模式</li></ul><p>表2.1显示了SDIO接口的引脚定义。其中CLK为时钟引脚，每个时钟周期传输一个命令或数据位；CMD是命令引脚，命令在CMD线上串行传输，是双向半双工的（命令从主机到从卡，而命令的响应是从卡发送到主机）；DAT<!-- -->[0]<!-- -->~DAT<!-- -->[3]<!-- -->为数据线引脚；在SPI模式中，第8脚位被当成中断信号。图2.18给出了一个SDIO单模块读、写的典型时序。</p><p>表2.1　SDIO接口引脚定义</p><p><img loading="lazy" alt="1742719820380" src="/assets/images/1742719820380-47c34cd1e1ebee417b10e821344d4ed0.png" width="1480" height="490" class="img_ev3q"></p><p><img loading="lazy" alt="1742719837200" src="/assets/images/1742719837200-6c722f60be239f6d67b57cd787cd2d9e.png" width="1353" height="871" class="img_ev3q"></p><p>图2.18　SDIO单模块读、写的典型时序</p><p>eMMC（Embedded Multi Media Card）是当前移动设备本地存储的主流解决方案，目的在于简化手机存储器的设计。eMMC就是NAND Flash、闪存控制芯片和标准接口封装的集合，它把NAND和控制芯片直接封装在一起成为一个多芯片封装（Multi-Chip Package，MCP）芯片。eMMC支持DAT<!-- -->[0]<!-- -->~DAT<!-- -->[7]<!-- -->8位的数据线。上电或者复位后，默认处于1位模式，只使用DAT<!-- -->[0]<!-- -->，后续可以配置为4位或者8位模式。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.821Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>内核中有许多地方调用类似BUG（）的语句，它非常像一个内核运行时的断言，意味着本来不该执行到BUG（）这条语句，一旦执行即抛出Oops。BUG（）的定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define BUG() do { \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       printk(&quot;BUG: failure at %s:%d/%s()!\n&quot;, __FILE__, __LINE__, __func__); \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       panic(&quot;BUG!&quot;); \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} while (0)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中的panic（）定义在kernel/panic.c中，会导致内核崩溃，并打印Oops。比如arch/arm/kernel/dma.c中的enable_dma（）函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void enable_dma (unsigned int chan)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       dma_t *dma = dma_channel(chan);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       if (!dma-&gt;lock)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              goto free_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       if (dma-&gt;active == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             dma-&gt;active = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             dma-&gt;d_ops-&gt;enable(chan, dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">free_dma:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       printk(KERN_ERR &quot;dma%d: trying to enable free DMA\n&quot;, chan);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       BUG();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码的含义是，如果在dma-&gt;lock不成立的情况下，驱动直接调用了enable_dma（），实际上意味着内核的一个bug。</p><p>BUG（）还有一个变体叫BUG_ON（），它的内部会引用BUG（），形式为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define BUG_ON(condition) do { if (unlikely(condition)) BUG(); } while (0)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于BUG_ON（）而言，只有当括号内的条件成立的时候，才抛出Oops。比如drivers/char/random.c中的类似代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void push_to_pool(struct work_struct *work)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct entropy_store *r = container_of(work, struct entropy_store,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       push_work);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       BUG_ON(!r);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        _xfer_secondary_pool(r, random_read_wakeup_bits/8);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        trace_push_to_pool(r-&gt;name, r-&gt;entropy_count &gt;&gt; ENTROPY_SHIFT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        r-&gt;pull-&gt;entropy_count &gt;&gt; ENTROPY_SHIFT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了BUG_ON（）外，内核有个稍微弱一些WARN_ON（），在括号中的条件成立的时候，内核会抛出栈回溯，但是不会panic（），这通常用于内核抛出一个警告，暗示某种不太合理的事情发生了。如在kernel/locking/mutex-debug.c中的debug_mutex_unlock（）函数发现mutex_unlock（）的调用者和mutex_lock（）的调用者不是同一个线程的时候或者mutex的owner为空的时候，会抛出警告信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void debug_mutex_unlock(struct mutex *lock)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (likely(debug_locks)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             DEBUG_LOCKS_WARN_ON(lock-&gt;magic != lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             if (!lock-&gt;owner)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   DEBUG_LOCKS_WARN_ON(!lock-&gt;owner);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   DEBUG_LOCKS_WARN_ON(lock-&gt;owner != current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             DEBUG_LOCKS_WARN_ON(!lock-&gt;wait_list.prev &amp;&amp; !lock-&gt;wait_list.next);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             mutex_clear_owner(lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有时候，WARN_ON（）也可以作为一个调试技巧。比如，我们进到内核某个函数后，不知道这个函数是怎么一级一级被调用进来的，那可以在该函数中加入一个WARN_ON（1）。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.817Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核的PM QoS系统针对内核和应用程序提供了一套接口，通过这个接口，用户可以设定自身对性能的期望。一类是系统级的需求，通过cpu_dma_latency、network_latency和network_throughput这些参数来设定；另一类是单个设备可以根据自身的性能需求发起per-device的PM QoS请求。</p><p>在内核空间，通过pm_qos_add_request（）函数可以注册PM QoS请求：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void pm_qos_add_request(struct pm_qos_request *req,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int pm_qos_class, s32 value);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过pm_qos_update_request（）函数可以更新已注册的PM QoS请求：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void pm_qos_update_request(struct pm_qos_request *req,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                      s32 new_value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void pm_qos_update_request_timeout(struct pm_qos_request *req, s32 new_value,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long timeout_us);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过pm_qos_remove_request（）函数可以删除已注册的PM QoS请求：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void pm_qos_remove_request(struct pm_qos_request *req);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>譬如在drivers/media/platform/via-camera.c这个摄像头驱动中，当摄像头开启后，通过如下语句可以阻止CPU进入C3级别的深度Idle：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int viacam_streamon(struct file *filp, void *priv, enum v4l2_buf_type t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pm_qos_add_request(&amp;cam-&gt;qos_request, PM_QOS_CPU_DMA_LATENCY, 50);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这是因为，在CPUIdle子系统中，会根据PM_QOS_CPU_DMA_LATENCY请求的情况选择合适的C状态，如drivers/cpuidle/governors/ladder.c中的ladder_select_state（）就会判断目标C状态的exit_latency与QoS要求的关系，如代码清单19.11所示。</p><p>代码清单19.11　CPUIdle LADDER governor对QoS的判断</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int ladder_select_state(struct cpuidle_driver *drv,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                          struct cpuidle_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      int latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      /* consider promotion */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      if (last_idx &lt; drv-&gt;state_count - 1 &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         !drv-&gt;states[last_idx + 1].disabled &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         !dev-&gt;states_usage[last_idx + 1].disable &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         last_residency &gt; last_state-&gt;threshold.promotion_time &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         drv-&gt;states[last_idx + 1].exit_latency &lt;= latency_req) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15            last_state-&gt;stats.promotion_count++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16            last_state-&gt;stats.demotion_count = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17            if(last_state-&gt;stats.promotion_count&gt;=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18             last_state-&gt;threshold.promotion_count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                  ladder_do_selection(ldev, last_idx, last_idx + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                  return last_idx + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23      …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>LADDER在选择是否进入更深层次的C状态时，会比较C状态的exit_latency要小于通过pm_qos_request（PM_QOS_CPU_DMA_LATENCY）得到的PM QoS请求的延迟，见代码清单19.11的第14行。</p><p>同样的逻辑也出现于drivers/cpuidle/governors/menu.c中，如代码清单19.12的第18~19行。</p><p>代码清单19.12　CPUIdle MENU governor对QoS的判断</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       struct menu_device *data = &amp;__get_cpu_var(menu_devices);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       int latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        * Find the idle state with the lowest power while satisfying</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        * our constraints.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       for (i = CPUIDLE_DRIVER_STATE_START; i &lt; drv-&gt;state_count; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11              struct cpuidle_state *s = &amp;drv-&gt;states[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12              struct cpuidle_state_usage *su = &amp;dev-&gt;states_usage[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14              if (s-&gt;disabled || su-&gt;disable)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                     continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16              if (s-&gt;target_residency &gt; data-&gt;predicted_us)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                     continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18              if ( s-&gt;exit_latency &gt; latency_req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                      continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20              if (s-&gt;exit_latency * multiplier &gt; data-&gt;predicted_us)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                     continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23              if (s-&gt;power_usage &lt; power_usage) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                     power_usage = s-&gt;power_usage;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25                     data-&gt;last_state_idx = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26                     data-&gt;exit_us = s-&gt;exit_latency;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27              }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       return data-&gt;last_state_idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>还是回到drivers/media/platform/via-camera.c中，当摄像头关闭后，它会通过如下语句告知上述代码对PM_QOS_CPU_DMA_LATENCY的性能要求取消：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int viacam_streamon(struct file *filp, void *priv, enum v4l2_buf_type t)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pm_qos_remove_request(&amp;cam-&gt;qos_request);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>类似的在设备驱动中申请QoS特性的例子还包括drivers/net/wireless/ipw2x00/ipw2100.c、drivers/tty/serial/omap-serial.c、drivers/net/ethernet/intel/e1000e/netdev.c等。</p><p>应用程序则可以通过向/dev/cpu_dma_latency和/dev/network_latency这样的设备节点写入值来发起QoS的性能请求。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.805Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>I2 C控制器所在驱动的platform_driver与arch/arm/mach-xxx中的platform_device（或者设备树中的节点）通过platform总线的match（）函数匹配导致platform_driver.probe（）执行，从而完成I2 C控制器的注册；而I2 C上面挂的触摸屏依附的i2c_driver与arch/arm/mach-xxx中的i2c_board_info指向的设备（或者设备树中的节点）通过I2 C总线的match（）函数匹配导致i2c_driver.probe（）执行，从而使触摸屏展开。</p><p>图17.1虚线上方部分是i2c_adapater眼里的Linux世界；下方部分是i2c_client眼里的Linux世界。其实，Linux中的每一个设备通过它依附的总线被枚举出来，尽管它自身可能给别人提供总线。</p><p><img loading="lazy" alt="1745505905169" src="/assets/images/1745505905169-01a95b916b71fb19c1ec5dec62341bf6.png" width="1105" height="1036" class="img_ev3q"></p><p>图17.1　I2 C主机和外设眼里的Linux世界</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.805Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->9 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux 2.6内核是Linux开发者群落一个寄予厚望的版本，从2003年12月直至2011年7月，内核重新进行了版本的编号，从而过渡到Linux 3.x版本直到成书时的Linux 4.0-rc1。</p><p>Linux 2.6相对于Linux 2.4有相当大的改进，主要体现在如下几个方面。</p><h1>1.新的调度器</h1><p>Linux 2.6以后版本的Linux内核使用了新的进程调度算法，它在高负载的情况下有极其出色的性能，并且当有很多处理器时也可以很好地扩展。在Linux内核2.6的早期采用了O（1）算法，之后转移到CFS（Completely Fair Scheduler，完全公平调度）算法。在Linux 3.14中，也增加了一个新的调度类：SCHED_DEADLINE，它实现了EDF（Earliest Deadline First，最早截止期限优先）调度算法。</p><h1>2.内核抢占</h1><p>在Linux 2.6以后版本的Linux内核中，一个内核任务可以被抢占，从而提高系统的实时性。这样做最主要的优势在于，可以极大地增强系统的用户交互性，用户将会觉得鼠标单击和击键的事件得到了更快速的响应。Linux 2.6以后的内核版本还是存在一些不可抢占的区间，如中断上下文、软中断上下文和自旋锁锁住的区间，如果给Linux内核打上RT-Preempt补丁，则中断和软中断都被线程化了，自旋锁也被互斥体替换，Linux内核变得能支持硬实时。</p><p>如图3.2所示，左侧是Linux 2.4，右侧是Linux 2.6以后的内核。在Linux 2.4的内核中，在IRQ1的中断服务程序唤醒RT（实时）任务后，必须要等待前面一个Normal（普通）任务的系统调用完成，返回用户空间的时候，RT任务才能切入；而在Linux 2.6内核中，Normal任务的关键部分（如自旋锁）结束的时候，RT任务就从内核切入了。不过也可以看出，Linux 2.6以后的内核仍然存在中断、软中断、自旋锁等原子上下文进程无法抢占执行的情况，这是Linux内核本身只提供软实时能力的原因。</p><p><img loading="lazy" alt="image-20250323213848102" src="/assets/images/image-20250323213848102-d312a8653b99e588247ba3be0b2e3176.png" width="1389" height="550" class="img_ev3q"></p><p>图3.2　Linux 2.4和2.6以后的内核在抢占上的区别</p><h1>3.改进的线程模型</h1><p>Linux 2.6以后版本中的线程采用NPTL（Native POSIX Thread Library，本地POSIX线程库）模型，操作速度得以极大提高，相比于Linux 2.4内核时代的LinuxThreads模型，它也更加遵循POSIX规范的要求。NPTL没有使用LinuxThreads模型中采用的管理线程，内核本身也增加了FUTEX（Fast Userspace Mutex，快速用户态互斥体），从而减小多线程的通信开销。</p><h1>4.虚拟内存的变化</h1><p>从虚拟内存的角度来看，新内核融合了r-map（反向映射）技术，显著改善虚拟内存在一定大小负载下的性能。在Linux 2.4中，要回收页时，内核的做法是遍历每个进程的所有PTE以判断该PTE是否与该页建立了映射，如果建立了，则取消该映射，最后无PTE与该页相关联后才回收该页。在Linux 2.6后，则建立反向映射，可以通过页结构体快速寻找到页面的映射。</p><h1>5.文件系统</h1><p>Linux 2.6版内核增加了对日志文件系统功能的支持，解决了Linux 2.4版本在这方面的不足。Linux 2.6版内核在文件系统上的关键变化还包括对扩展属性及POSIX标准访问控制的支持。ext2/ext3/ext4作为大多数Linux系统默认安装的文件系统，在Linux 2.6版内核中增加了对扩展属性的支持，可以给指定的文件在文件系统中嵌入元数据。</p><p>在文件系统方面，当前的研究热点是基于B树的Btrfs，Btrfs称为是下一代Linux文件系统，它在扩展性、数据一致性、多设备管理和针对SSD的优化等方面都优于ext4</p><h1>6.音频</h1><p>高级Linux音频体系结构（Advanced Linux Sound Architecture，ALSA）取代了缺陷很多旧的OSS（Open Sound System）。ALSA支持USB音频和MIDI设备，并支持全双工重放等功能。</p><h1>7.总线、设备和驱动模型</h1><p>在Linux 2.6以后的内核中，总线、设备、驱动三者之间因为一定的联系性而实现对设备的控制。总线是三者联系起来的基础，通过一种总线类型，将设备和驱动联系起来。总线类型中的match（）函数用来匹配设备和驱动，当匹配操作完成之后就会执行驱动程序中的probe（）函数。</p><h1>8.电源管理</h1><p>支持高级配置和电源接口（Advanced Configuration and Power Interface，ACPI），用于调整CPU在不同的负载下工作于不同的时钟频率以降低功耗。目前，Linux内核的电源管理（PM）相对比较完善了，包括CPUFreq、CPUIdle、CPU热插拔、设备运行时（runtime）PM、Linux系统挂起到内存和挂起到硬盘等全套的支持，在ARM上的支持也较完备。</p><h1>9.联网和IPSec</h1><p>Linux 2.6内核中加入了对IPSec的支持，删除了原来内核内置的HTTP服务器khttpd，加入了对新的NFSv4（网络文件系统）客户机/服务器的支持，并改进了对IPv6的支持。</p><h1>10.用户界面层</h1><p>Linux 2.6内核重写了帧缓冲/控制台层，人机界面层还加入了对近乎所有接口设备的支持（从触摸屏到盲人用的设备和各种各样的鼠标）。</p><p>在设备驱动程序方面，Linux 2.6相对于Linux 2.4也有较大的改动，这主要表现在内核API中增加了不少新功能（例如内存池）、sysfs文件系统、内核模块从.o变为.ko、驱动模块编译方式、模块使用计数、模块加载和卸载函数的定义等方面。</p><h1>11.Linux 3.0后ARM架构的变更</h1><p>Linus Torvalds在2011年3月17日的ARM Linux邮件列表中宣称“this whole ARM thing is a f*cking pain in the ass”，这引发了ARM Linux社区的地震，随后ARM社区进行了一系列重大修正。社区必须改变这种局面，于是PowerPC等其他体系结构下已经使用的FDT（Flattened Device Tree）进入到了ARM社区的视野。</p><p>此外，ARM Linux的代码在时钟、DMA、pinmux、计时器刻度等诸多方面都进行了优化和调整，也删除了arch/arm/mach-xxx/include/mach头文件目录，以至于Linux 3.7以后的内核可以支持多平台，即用同一份内核镜像运行于多家SoC公司的多个芯片，实现“一个Linux可适用于所有的ARM系统”。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.801Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->9 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux不是为了某单一电路板而设计的操作系统，它可以支持约30种体系结构下一定数量的硬件，因此，它的驱动架构很显然不能像RTOS下或者无操作系统下那么小儿科的做法。</p><p>Linux设备驱动非常重视软件的可重用和跨平台能力。譬如，如果我们写下一个DM9000网卡的驱动，Linux的想法是这个驱动应该最好一行都不要改就可以在任何一个平台上跑起来。为了做到这一点（看似很难，因为每个板子连接DM9000的基地址，中断号什么的都可能不一样），驱动中势必会有类似这样的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef  BOARD_XXX</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DM9000_BASE 0x10000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DM9000_IRQ 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#elif defined(BOARD_YYY)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DM9000_BASE 0x20000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DM9000_IRQ 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#elif defined(BOARD_ZZZ)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DM9000_BASE 0x30000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define DM9000_IRQ 9…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码主要有如下问题：</p><p>1）此段代码看起来面目可憎，如果有100个板子，就要if/else 100次，到了第101个板子，又得重新加if/else。代码进行着简单的“复制—粘贴”，“复制—粘贴”式的简单重复通常意味着代码编写者的水平很差。</p><p>2）非常难做到一个驱动支持多个设备，如果某个电路板上有两个DM9000网卡，则DM9000_BASE这个宏就不够用了，此时势必要定义出来DM9000_BASE 1、DM9000_BASE 2、DM9000_IRQ 1、DM9000_IRQ 2类的宏；定义了DM9000_BASE 1、DM9000_BASE 2后，如果又有第3个DM9000网卡加到板子上，前面的代码就又不适用了。</p><p>3）依赖于make menuconfig选择的项目来编译内核，因此，在不同的硬件平台下要依赖于所选择的BOARD_XXX、BOARD_YYY选项来决定代码逻辑。这不符合ARM Linux 3.x一个映像适用于多个硬件的目标。实际上，我们可能同时选择了BOARD_XXX、BOARD_YYY、BOARD_ZZZ。</p><p>我们按照上面的方法编写代码的时候，相信自己编着编着也会觉得奇怪，闻到了代码里不好的味道。这个时候，请停下你飞奔的脚步，等一等你的灵魂。我们有没有办法把设备端的信息从驱动里面剥离出来，让驱动以某种标准方法拿到这些平台信息呢Linux总线、设备和驱动模型实际上可以做到这一点，驱动只管驱动，设备只管设备，总线则负责匹配设备和驱动，而驱动则以标准途径拿到板级信息，这样，驱动就可以放之四海而皆准了，如图12.1所示。</p><p>Linux的字符设备驱动需要编写file_operations成员函数，并负责处理阻塞、非组塞、多路复用、SIGIO等复杂事物。但是，当我们面对一个真实的硬件驱动时，假如要编写一个按键的驱动，作为一个“懒惰”的程序员，你真的只想做最简单的工作，譬如，收到一个按键中断、汇报一个按键值，至于什么file_operations、几种I/O模型，那是Linux的事情，为什么要我管Linux也是程序员写出来的，因此，程序员怎么想，它必然要怎么做。于是，这里就衍生出来了一个软件分层的想法，尽管file_operations、I/O模型不可或缺，但是关于此部分的代码，全世界恐怕所有的输入设备都是一样的，为什么不提炼一个中间层出来，把这些事情搞定，也就是在底层编写驱动的时候，搞定具体的硬件操作呢？</p><p>将软件进行分层设计应该是软件工程最基本的一个思想，如果提炼一个input的核心层出来，把跟Linux接口以及整个一套input事件的汇报机制都在这里面实现，如图12.2所示，显然是非常好的。</p><p><img loading="lazy" alt="1743865208630" src="/assets/images/1743865208630-2ba75a9e74e49df98d86f7ee41b671d8.png" width="1260" height="672" class="img_ev3q"></p><p>图12.1　Linux设备和驱动的分离</p><p><img loading="lazy" alt="1743865244408" src="/assets/images/1743865244408-844f24a7944df3652286fb59ce2fa59b.png" width="1044" height="1045" class="img_ev3q"></p><p>图12.2　Linux驱动的分层</p><p>在Linux设备驱动框架的设计中，除了有分层设计以外，还有分隔的思想。举一个简单的例子，假设我们要通过SPI总线访问某外设，假设CPU的名字叫XXX1，SPI外设叫YYY1。在访问YYY1外设的时候，要通过操作CPU XXX1上的SPI控制器的寄存器才能达到访问SPI外设YYY1的目的，最简单的代码逻辑是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_write()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spi_client_yyy1_work1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_write()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spi_client_yyy1_work2()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果按照这种方式来设计驱动，结果对于任何一个SPI外设来讲，它的驱动代码都是与CPU相关的。也就是说，当代码用在CPU XXX1上的时候，它访问XXX1的SPI主机控制寄存器，当用在XXX2上的时候，它访问XXX2的SPI主机控制寄存器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx2_spi_reg_write()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx2_spi_reg_read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spi_client_yyy1_work1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx2_spi_reg_write()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx2_spi_reg_read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spi_client_yyy1_work2()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这显然是不被接受的，因为这意味着外设YYY1用在不同的CPU XXX1和XXX2上的时候需要不同的驱动。同时，如果CPU XXX1除了支持YYY1以外，还要支持外设YYY2、YYY3、YYY4等，这个XXX的代码就要重复出现在YYY1、YYY2、YYY3、YYY4的驱动里面：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_write()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spi_client_yyy2_work1()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_write()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_xxx1_spi_reg_read()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">spi_client_yyy2_work2()…</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>按照这样的逻辑，如果要让N个不同的YYY在M个不同的CPU XXX上跑起来，需要M*N份代码。这是一种典型的强耦合，不符合软件工程“高内聚、低耦合”和“信息隐蔽”的基本原则。</p><p>这种软件架构是一种典型的网状耦合，网状耦合一般不太适合人类的思维逻辑，会把我们的思维搞乱。对于网状耦合的M∶N，我们一般要提炼出一个中间“1”，让M与“1”耦合，N也与这个“1”耦合，如图12.3所示。</p><p><img loading="lazy" alt="image-20250406110107110" src="/assets/images/image-20250406110107110-a285b93a696ce2b3fe04948dd68a4f0a.png" width="604" height="687" class="img_ev3q"></p><p>图12.3　将M∶N耦合转化为M∶1∶N耦合</p><p>那么，我们可以用如图12.4所示的思想对主机控制器驱动和外设驱动进行分离。这样的结果是，外设YYY1、YYY2、YYY3、YYY4的驱动与主机控制器XXX1、XXX2、XXX3、XXX4的驱动不相关，主机控制器驱动不关心外设，而外设驱动也不关心主机，外设只是访问核心层的通用API进行数据传输，主机和外设之间可以进行任意组合。</p><p><img loading="lazy" alt="1743908490270" src="/assets/images/1743908490270-04df8bc8144c97c7636af747bd19f900.png" width="840" height="651" class="img_ev3q"></p><p>图12.4　Linux设备驱动的主机、外设驱动分离</p><p>如果我们不进行如图12.4所示的主机和外设分离，外设YYY1、YYY2、YYY3和主机XXX1、XXX2、XXX3进行组合的时候，需要9个不同的驱动。设想一共有m个主机控制器，n个外设，分离的结果是需要m+n个驱动，不分离则需要m*n个驱动。因为，m个主机控制器，n个外设的驱动都可以被充分地复用了。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.785Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux的中断处理分为两个半部，顶半部处理紧急的硬件操作，底半部处理不紧急的耗时操作。tasklet和工作队列都是调度中断底半部的良好机制，tasklet基于软中断实现。内核定时器也依靠软中断实现。</p><p>内核中的延时可以采用忙等待或睡眠等待，为了充分利用CPU资源，使系统有更好的吞吐性能，在对延迟时间的要求并不是很精确的情况下，睡眠等待通常是值得推荐的，而ndelay（）、udelay（）忙等待机制在驱动中通常是为了配合硬件上的短时延迟要求。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.773Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>引导Linux系统的过程包括很多阶段，这里将以引导ARM Linux为例来进行讲解（见图3.11）。一般的SoC内嵌入了bootrom，上电时bootrom运行。对于CPU0而言，bootrom会去引导bootloader，而其他CPU则判断自己是不是CPU0，进入WFI的状态等待CPU0来唤醒它。CPU0引导bootloader，bootloader引导Linux内核，在内核启动阶段，CPU0会发中断唤醒CPU1，之后CPU0和CPU1都投入运行。CPU0导致用户空间的init程序被调用，init程序再派生其他进程，派生出来的进程再派生其他进程。CPU0和CPU1共担这些负载，进行负载均衡。</p><p><img loading="lazy" alt="1742738971868" src="/assets/images/1742738971868-4ac9d6538162d8100f16497d6bda7340.png" width="745" height="663" class="img_ev3q"></p><p>图3.11　ARM上的Linux引导流程</p><p>bootrom是各个SoC厂家根据自身情况编写的，目前的SoC一般都具有从SD、eMMC、NAND、USB等介质启动的能力，这证明这些bootrom内部的代码具备读SD、NAND等能力。</p><p>嵌入式Linux领域最著名的bootloader是U-Boot，其代码仓库位于<a href="http://git.denx.de/u-boot.git/" target="_blank" rel="noopener noreferrer">http://git.denx.de/u-boot.git/</a> 。早前，bootloader需要将启动信息以ATAG的形式封装，并且把ATAG的地址填充在r2寄存器中，机型号填充在r1寄存器中，详见内核文档Documentation/arm/booting。在ARM Linux支持设备树（Device Tree）后，bootloader则需要把dtb的地址放入r2寄存器中。当然，ARM Linux也支持直接把dtb和zImage绑定在一起的模式（内核ARM_APPENDED_DTB选项“Use appended device tree blob to zImage”），这样r2寄存器就不再需要填充dtb地址了。</p><p>类似zImage的内核镜像实际上是由没有压缩的解压算法和被压缩的内核组成，所以在bootloader跳入zImage以后，它自身的解压缩逻辑就把内核的镜像解压缩出来了。关于内核启动，与我们关系比较大的部分是每个平台的设备回调函数和设备属性信息，它们通常包装在DT_MACHINE_START和MACHINE_END之间，包含reserve（）、map_io（）、init_machine（）、init_late（）、smp等回调函数或者属性。这些回调函数会在内核启动过程中被调用。后续章节会进一步介绍。</p><p>用户空间的init程序常用的有busybox init、SysVinit、systemd等，它们的职责类似，把整个系统启动，最后形成一个进程树，比如Ubuntu上运行的pstree：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">init─┬─ModemManager───2*[{ModemManager}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─NetworkManager─┬─dhclient</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │                ├─dnsmasq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │                └─3*[{NetworkManager}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─accounts-daemon───2*[{accounts-daemon}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─acpid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─atd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─atop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─avahi-daemon───avahi-daemon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─bluetoothd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─colord───2*[{colord}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─console-kit-dae───64*[{console-kit-dae}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─cron</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─cups-browsed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─cupsd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─dbus-daemon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─docker───6*[{docker}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─6*[getty]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─gnome-keyring-d───4*[{gnome-keyring-d}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─in.tftpd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─kerneloops</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─lightdm─┬─Xorg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         ├─lightdm─┬─init─┬─at-spi-bus-laun─┬─dbus-daemon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │                 └─3*[{at-spi-bus-laun}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─at-spi2-registr───{at-spi2-registr}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─dbus-daemon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─dconf-service───2*[{dconf-service}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─evolution-calen───4*[{evolution-calen}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─evolution-sourc───2*[{evolution-sourc}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gconfd-2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gnome-screensav───3*[{gnome-screensav}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gnome-session─┬─compiz─┬─gnome-terminal─┬─bash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               │        │                ├─gnome-pty-helpe</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               │        │                └─3*[{gnome-terminal}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               │        ├─gtk-window-deco───2*[{gtk-window-deco}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               │        └─3*[{compiz}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─deja-dup-monito───2*[{deja-dup-monito}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─gnome-panel───3*[{gnome-panel}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─indicator-appli───{indicator-appli}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─indicator-bluet───2*[{indicator-bluet}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─initctl</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─nautilus───3*[{nautilus}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─nm-applet───2*[{nm-applet}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─polkit-gnome-au───2*[{polkit-gnome-au}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─telepathy-indic───2*[{telepathy-indic}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─unity-fallback-───2*[{unity-fallback-}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─update-notifier───3*[{update-notifier}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               ├─zeitgeist-datah───3*[{zeitgeist-datah}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │               └─3*[{gnome-session}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfs-afc-volume───2*[{gvfs-afc-volume}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfs-gphoto2-vo───{gvfs-gphoto2-vo}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfs-mtp-volume───{gvfs-mtp-volume}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfs-udisks2-vo───2*[{gvfs-udisks2-vo}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfsd───{gvfsd}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfsd-fuse───5*[{gvfsd-fuse}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─gvfsd-trash───4*[{gvfsd-trash}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─ibus-daemon─┬─ibus-dconf───3*[{ibus-dconf}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │             ├─ibus-engine-sim───2*[{ibus-engine-sim}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │             ├─ibus-ui-gtk3───3*[{ibus-ui-gtk3}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      │             └─2*[{ibus-daemon}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─ibus-x11───3*[{ibus-x11}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-apple───2*[{indicator-apple}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-datet───5*[{indicator-datet}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-keybo───2*[{indicator-keybo}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-messa───3*[{indicator-messa}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-power───2*[{indicator-power}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-sessi───2*[{indicator-sessi}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─indicator-sound───3*[{indicator-sound}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─mission-control───2*[{mission-control}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─notify-osd───2*[{notify-osd}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─pulseaudio───2*[{pulseaudio}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─unity-settings-───3*[{unity-settings-}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─update-manager───2*[{update-manager}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─2*[upstart-dbus-br]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─upstart-event-b</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─upstart-file-br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─window-stack-br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      ├─zeitgeist-daemo───{zeitgeist-daemo}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │      └─zeitgeist-fts─┬─cat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         │                      └─{zeitgeist-fts}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         │         └─{lightdm}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │         └─2*[{lightdm}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─lttng-sessiond───9*[{lttng-sessiond}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─netserver</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─polkitd───2*[{polkitd}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─rpc.idmapd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─rpc.mountd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─rpc.statd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─rpcbind</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─rsyslogd───3*[{rsyslogd}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─rtkit-daemon───2*[{rtkit-daemon}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─sshd─┬─sshd───sshd─┬─bash───pstree</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │      │             └─bash───sleep</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     │      └─sshd───sshd───sftp-server</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─systemd-logind</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─systemd-udevd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─udisksd───4*[{udisksd}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─upowerd───2*[{upowerd}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─upstart-file-br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─upstart-socket-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ├─upstart-udev-br</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     └─whoopsie───2*[{whoopsie}]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.765Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux MMC/SD存储卡是一种典型的块设备，它的实现位于drivers/mmc。drivers/mmc下又分为card、core和host这3个子目录。card实际上跟Linux的块设备子系统对接，实现块设备驱动以及完成请求，但是具体的协议经过core层的接口，最终通过host完成传输，因此整个MMC子系统的框架结构如图13.5所示。另外，card目录除了实现标准的MMC/SD存储卡以外，该目录还包含一些SDIO外设的卡驱动，如drivers/mmc/card/sdio_uart.c。core目录除了给card提供接口外，实际上也定义好了host驱动的框架。</p><p><img loading="lazy" alt="1744814170429" src="/assets/images/1744814170429-3008c9f0dbfb9aa7ab977cce89b200af.png" width="336" height="661" class="img_ev3q"></p><p>图13.5　Linux MMC子系统</p><p>drivers/mmc/card/queue.c的mmc_init_queue（）函数通过blk_init_queue（mmc_request_fn，lock）绑定了请求处理函数mmc_request_fn（）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   spinlock_t *lock, const char *subname)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        mq-&gt;queue = blk_init_queue(mmc_request_fn, lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而mmc_request_fn（）函数会唤醒与MMC对应的内核线程来处理请求，与该线程对应的处理函数mmc_queue_thread（）执行与MMC对应的mq-&gt;issue_fn（mq，req）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int mmc_queue_thread(void *d)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                req = blk_fetch_request(q);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                mq-&gt;mqrq_cur-&gt;req = req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (req || mq-&gt;mqrq_prev-&gt;req) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        set_current_state(TASK_RUNNING);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cmd_flags = req   req-&gt;cmd_flags : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        mq-&gt;issue_fn(mq, req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于存储设备而言，mq-&gt;issue_fn（）函数指向drivers/mmc/card/block.c中的mmc_blk_issue_rq（）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              struct device *parent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              sector_t size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              bool default_ro,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              const char *subname,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                              int area_type)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        md-&gt;queue.issue_fn = mmc_blk_issue_rq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        md-&gt;queue.data = md;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中的mmc_blk_issue_rw_rq（）等函数最终会调用drivers/mmc/core/core.c中的mmc_start_req（）这样的函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                areq = mmc_start_req(card-&gt;host, areq, (int *) &amp;status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mmc_start_req（）反过来又调用host驱动的host-&gt;ops-&gt;pre_req（）、host-&gt;ops-&gt;enable（）、host-&gt;ops-&gt;disable（）、host-&gt;ops-&gt;request（）等成员函数，这些函数实现于drivers/mm/host目录中。</p><p>host-&gt;ops实际上是一个MMC host操作的集合，对应的结构体为mmc_host_ops，它的定义如代码清单13.16所示。MMC主机驱动的主体工作就是实现该结构体的成员函数，如drivers/mmc/host/mmc_spi.c、drivers/mmc/host/bfin_sdh.c、drivers/mmc/host/sdhci.c等。</p><p>代码清单13.16　mmc_host_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct mmc_host_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         * &#x27;enable&#x27; is called when the host is claimed and &#x27;disable&#x27; is called</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         * when the host is released. &#x27;enable&#x27; and &#x27;disable&#x27; are deprecated.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int (*enable)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        int (*disable)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         * It is optional for the host to implement pre_req and post_req in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         * order to support double buffering of requests (prepare one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         * request while another request is active).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         * pre_req() must always be followed by a post_req().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * To undo a call made to pre_req(), call post_req() with</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         * a nonzero err condition.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        void    (*post_req)(struct mmc_host *host, struct mmc_request *req,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                            int err);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        void    (*pre_req)(struct mmc_host *host, struct mmc_request *req,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                           bool is_first_req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        void    (*request)(struct mmc_host *host, struct mmc_request *req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22         * Avoid calling these three functions too often or in a &quot;fast path&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23         * since underlaying controller might implement them in an expensive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24         * and/or slow way.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         * Also note that these functions might sleep, so don&#x27;t call them</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         * in the atomic contexts!</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29         * Return values for the get_ro callback should be:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30         *   0for a read/write card</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31         *   1for a read-only card</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32         *   -ENOSYS when not supported (equal to NULL callback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33         *   or a negative errno value when something bad happened</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34         *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35         * Return values for the get_cd callback should be:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36         *   0for a absent card</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37         *   1for a present card</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38         *   -ENOSYS when not supported (equal to NULL callback)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39         *   or a negative errno value when something bad happened</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41        void    (*set_ios)(struct mmc_host *host, struct mmc_ios *ios);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42        int     (*get_ro)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43        int     (*get_cd)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45        void    (*enable_sdio_irq)(struct mmc_host *host, int enable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47        /* optional callback for HC quirks */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48        void    (*init_card)(struct mmc_host *host, struct mmc_card *card);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50        int     (*start_signal_voltage_switch)(struct mmc_host *host, struct                   mmc_ios *ios);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52        /* Check if the card is pulling dat[0:3] low */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53        int     (*card_busy)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55        /* The tuning command opcode value is different for SD and eMMC cards */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56        int     (*execute_tuning)(struct mmc_host *host, u32opcode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58        /* Prepare HS400target operating frequency depending host driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59        int     (*prepare_hs400_tuning)(struct mmc_host *host, struct mmc_ios *ios);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60        int     (*select_drive_strength)(unsigned int max_dtr, int host_drv,                   int card_drv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61        void    (*hw_reset)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62        void    (*card_event)(struct mmc_host *host);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于目前大多数SoC内嵌的MMC/SD/SDIO控制器是SDHCI（Secure Digital Host Controller Interface），所以更多是直接重用drivers/mmc/host/sdhci.c驱动，很多芯片甚至还可以进一步使用基于drivers/mmc/host/sdhci.c定义的drivers/mmc/host/sdhci-pltfm.c框架。</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/5"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/7"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>