<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/7"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/7"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/7" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/7" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.761Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->15 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux 2.6以后的设备驱动模型中，需关心总线、设备和驱动这3个实体，总线将设备和驱动绑定。在系统每注册一个设备的时候，会寻找与之匹配的驱动；相反的，在系统每注册一个驱动的时候，会寻找与之匹配的设备，而匹配由总线完成。</p><p>一个现实的Linux设备和驱动通常都需要挂接在一种总线上，对于本身依附于PCI、USB、I2 C、SPI等的设备而言，这自然不是问题，但是在嵌入式系统里面，在SoC系统中集成的独立外设控制器、挂接在SoC内存空间的外设等却不依附于此类总线。基于这一背景，Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform_device，而驱动成为platform_driver</p><p>注意： 所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段，例如，我们通常把在SoC内部集成的I2 C、RTC、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。platform_device结构体的定义如代码清单12.1所示。</p><p>代码清单12.1　platform_device结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct platform_device {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  const char    *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  int        id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  boo    id_auto;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  struct devicedev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  u32       num_resources;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  struct resource    *resource;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  const struct platform_device_id    *id_entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  char *driver_override; /* Driver name to force a match */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  /* MFD cell pointer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  struct mfd_cell *mfd_cell;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  /* arch specific additions */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  struct pdev_archdata    archdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>platform_driver这个结构体中包含probe（）、remove（）、一个device_driver实例、电源管理函数suspend（）、resume（），如代码清单12.2所示。</p><p>代码清单12.2　platform_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct platform_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 int (*probe)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 int (*remove)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 void (*shutdown)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 int (*suspend)(struct platform_device *, pm_message_t state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 int (*resume)(struct platform_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 struct device_driver driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 const struct platform_device_id *id_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 bool prevent_deferred_probe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>直接填充platform_driver的suspend（）、resume（）做电源管理回调的方法目前已经过时，较好的做法是实现platform_driver的device_driver中的dev_pm_ops结构体成员（后续的Linux电源管理章节会对此进行更细致的介绍），代码清单12.3给出了device_driver的定义。</p><p>代码清单12.3　device_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct device_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2       const char              *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       struct bus_type         *bus;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       struct module           *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       const char              *mod_name;  /* used for built-in modules */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       bool suppress_bind_attrs;           /* disables bind/unbind via sysfs */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       const struct of_device_id           *of_match_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       const struct acpi_device_id         *acpi_match_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       int (*probe) (struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       int (*remove) (struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       void (*shutdown) (struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       int (*suspend) (struct device *dev, pm_message_t state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       int (*resume) (struct device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       const struct attribute_group **groups;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       const struct dev_pm_ops *pm;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22       struct driver_private *p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与platform_driver地位对等的i2c_driver、spi_driver、usb_driver、pci_driver中都包含了device_driver结构体实例成员。它其实描述了各种xxx_driver（xxx是总线名）在驱动意义上的一些共性。</p><p>系统为platform总线定义了一个bus_type的实例platform_bus_type，其定义位于drivers/base/platform.c下，如代码清单12.4所示</p><p>代码清单12.4　platform总线的bus_type实例platform_bus_type</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct bus_type platform_bus_type = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2       .name           = &quot;platform&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3       .dev_groups     = platform_dev_groups,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4       .match          = platform_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5       .uevent         = platform_uevent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6       .pm             = &amp;platform_dev_pm_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里要重点关注其match（）成员函数，正是此成员函数确定了platform_device和platform_driver之间是如何进行匹配，如代码清单12.5所示。</p><p>代码清单12.5　platform_bus_type的match（）成员函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int platform_match(struct device *dev, struct device_driver *drv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       struct platform_device *pdev = to_platform_device(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       struct platform_driver *pdrv = to_platform_driver(drv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       /* Attempt an OF style match first */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       if (of_driver_match_device(dev, drv))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8              return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       /* Then try ACPI style match */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       if (acpi_driver_match_device(dev, drv))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       /* Then try to match against the id table */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       if (pdrv-&gt;id_table)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       /* fall-back to driver name match */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19       return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从代码清单12.5可以看出，匹配platform_device和platform_driver有4种可能性，</p><ul><li>一是基于设备树风格的匹配；</li><li>二是基于ACPI风格的匹配；</li><li>三是匹配ID表（即platform_device设备名是否出现在platform_driver的ID表内）；</li><li>第四种是匹配platform_device设备名和驱动的名字。</li></ul><p>对于Linux 2.6ARM平台而言，对platform_device的定义通常在BSP的板文件中实现，在板文件中，将platform_device归纳为一个数组，最终通过platform_add_devices（）函数统一注册。platform_add_devices（）函数可以将平台设备添加到系统中，这个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int platform_add_devices(struct platform_device **devs, int num);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数的第一个参数为平台设备数组的指针，第二个参数为平台设备的数量，它内部调用了platform_device_register（）函数以注册单个的平台设备。</p><p>Linux 3.x之后，ARM Linux不太喜欢人们以编码的形式去填写platform_device和注册，而倾向于根据设备树中的内容自动展开platform_device。</p><h1>12.2.2　将globalfifo作为platform设备</h1><p>现在我们将前面章节的globalfifo驱动挂接到platform总线上，这要完成两个工作。</p><p>1）将globalfifo移植为platform驱动。</p><p>2）在板文件中添加globalfifo这个platform设备。</p><p>为完成将globalfifo移植到platform驱动的工作，需要在原始的globalfifo字符设备驱动中套一层platform_driver的外壳，如代码清单12.6所示。注意进行这一工作后，并没有改变globalfifo是字符设备的本质，只是将其挂接到了platform总线上。</p><p>代码清单12.6　为globalfifo添加platform_driver</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int globalfifo_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       dev_t devno = MKDEV(globalfifo_major, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       if (globalfifo_major)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7              ret = register_chrdev_region(devno, 1, &quot;globalfifo&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9              ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalfifo&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10              globalfifo_major = MAJOR(devno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13              return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15           globalfifo_devp = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*globalfifo_devp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       if (!globalfifo_devp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17              ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18              goto fail_malloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       globalfifo_setup_cdev(globalfifo_devp, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       mutex_init(&amp;globalfifo_devp-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       init_waitqueue_head(&amp;globalfifo_devp-&gt;r_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       init_waitqueue_head(&amp;globalfifo_devp-&gt;w_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       unregister_chrdev_region(devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31       return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34static int globalfifo_remove(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36       cdev_del(&amp;globalfifo_devp-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37       unregister_chrdev_region(MKDEV(globalfifo_major, 0), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42static struct platform_driver globalfifo_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43       .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44               .name = &quot;globalfifo&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45               .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46       },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47       .probe = globalfifo_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48       .remove = globalfifo_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51module_platform_driver(globalfifo_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在代码清单12.6中，module_platform_driver（）宏所定义的模块加载和卸载函数仅仅通过platform_driver_register（）、platform_driver_unregister（）函数进行platform_driver的注册与注销，而原先注册和注销字符设备的工作已经被移交到platform_driver的probe（）和remove（）成员函数中。</p><p>代码清单12.6未列出的部分与原始的globalfifo驱动相同，都是实现作为字符设备驱动核心的file_operations的成员函数。注册完globalfifo对应的platform_driver后，我们会发现/sys/bus/platform/drivers目录下多出了一个名字叫globalfifo的子目录。</p><p>为了完成在板文件中添加globalfifo这个platform设备的工作，需要在板文件arch/arm/mach-&lt;soc名&gt;/mach-&lt;板名&gt;.c）中添加相应的代码，如代码清单12.7所示。</p><p>代码清单12.7　与globalfifo对应的platform_device</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static struct platform_device globalfifo_device = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2  .name         = &quot;globalfifo&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3  .id         = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>并最终通过类似于platform_add_devices（）的函数把这个platform_device注册进系统。如果一切顺利，我们会在/sys/devices/platform目录下看到一个名字叫globalfifo的子目录，/sys/devices/platform/globalfifo中会有一个driver文件，它是指向/sys/bus/platform/drivers/globalfifo的符号链接，这证明驱动和设备匹配上了。</p><h1>12.2.3　platform设备资源和数据</h1><p>留意一下代码清单12.1中platform_device结构体定义的第6~7行，它们描述了platform_device的资源，资源本身由resource结构体描述，其定义如代码清单12.8所示。</p><p>代码清单12.8　resource结构体定义</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct resource {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2  resource__size_t start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3  resource_size_t end;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4  const char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5  unsigned long flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6  struct resource *parent, *sibling, *child;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们通常关心start、end和flags这3个字段，它们分别标明了资源的开始值、结束值和类型，flags可以为IORESOURCE_IO、IORESOURCE_MEM、IORESOURCE_IRQ、IORE-SOURCE_DMA等。start、end的含义会随着flags而变更，如当flags为IORESOURCE_MEM时，start、end分别表示该platform_device占据的内存的开始地址和结束地址；当flags为IORESOURCE_IRQ时，start、end分别表示该platform_device使用的中断号的开始值和结束值，如果只使用了1个中断号，开始和结束值相同。对于同种类型的资源而言，可以有多份，例如说某设备占据了两个内存区域，则可以定义两个IORESOURCE_MEM资源。</p><p>对resource的定义也通常在BSP的板文件中进行，而在具体的设备驱动中通过platform_get_resource（）这样的API来获取，此API的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct resource *platform_get_resource(struct platform_device *, unsigned int,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>例如在arch/arm/mach-at91/board-sam9261ek.c板文件中为DM9000网卡定义了如下resouce：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct resource dm9000_resource[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       [0] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .start  = AT91_CHIPSELECT_2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .end    = AT91_CHIPSELECT_2+ 3,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .flags  = IORESOURCE_MEM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       [1] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .start  = AT91_CHIPSELECT_2+ 0x44,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .end    = AT91_CHIPSELECT_2+ 0xFF,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .flags  = IORESOURCE_MEM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       [2] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .flags  = IORESOURCE_IRQ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       | IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在DM9000网卡的驱动中则是通过如下办法拿到这3份资源：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">db-&gt;addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db-&gt;data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">db-&gt;irq_res  = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于IRQ而言，platform_get_resource（）还有一个进行了封装的变体platform_get_irq（），其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int platform_get_irq(struct platform_device *dev, unsigned int num);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它实际上调用了“platform_get_resource（dev，IORESOURCE_IRQ，num）；”。</p><p>设备除了可以在BSP中定义资源以外，还可以附加一些数据信息，因为对设备的硬件描述除了中断、内存等标准资源以外，可能还会有一些配置信息，而这些配置信息也依赖于板，不适宜直接放置在设备驱动上。因此，platform也提供了platform_data的支持，platform_data的形式是由每个驱动自定义的，如对于DM9000网卡而言，platform_data为一个dm9000_plat_data结构体，完成定义后，就可以将MAC地址、总线宽度、板上有无EEPROM信息等放入platform_data中，如代码清单12.9所示。</p><p>代码清单12.9　platform_data的使用</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct dm9000_plat_data dm9000_platdata = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .flags          = DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5static struct platform_device dm9000_device = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .name           = &quot;dm9000&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .id             = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .num_resources  = ARRAY_SIZE(dm9000_resource),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        .resource       = dm9000_resource,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .dev            = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                .platform_data  = &amp;dm9000_platdata,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>[插图]<!-- -->而在DM9000网卡的驱动drivers/net/ethernet/davicom/dm9000.c的probe（）中，通过如下方式就拿到了platform_data：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct dm9000_plat_data *pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中，pdev为platform_device的指针。</p><p>由以上分析可知，在设备驱动中引入platform的概念至少有如下好处。</p><p>1）使得设备被挂接在一个总线上，符合Linux 2.6以后内核的设备模型。其结果是使配套的sysfs节点、设备电源管理都成为可能。</p><p>2）隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体配置信息，而在驱动中，只需要通过通用API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</p><p>3）让一个驱动支持多个设备实例。譬如DM9000的驱动只有一份，但是我们可以在板级添加多份DM9000的platform_device，它们都可以与唯一的驱动匹配。</p><p>在Linux 3.x之后的内核中，DM9000驱动实际上已经可以通过设备树的方法被枚举，可以参见补丁net：dm9000：Allow instantiation using device tree（内核commit的ID是0b8bf1ba）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">index a2408c8..dd243a1 100644</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">--- a/drivers/net/ethernet/davicom/dm9000.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+++ b/drivers/net/ethernet/davicom/dm9000.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -29,6+29,8@@</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/spinlock.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/crc32.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/mii.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+#include &lt;linux/of.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+#include &lt;linux/of_net.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/ethtool.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/dm9000.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/delay.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -1351,6+1353,31@@ static const struct net_device_ops dm9000_netdev_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+static struct dm9000_plat_data *dm9000_parse_dt(struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+ …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">* Search DM9000board, allocate space and register it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -1366,6+1393,12@@ dm9000_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">u32id_val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+ if (!pdata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+     pdata = dm9000_parse_dt(&amp;pdev-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+     if (IS_ERR(pdata))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+         return PTR_ERR(pdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* Init network device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ndev = alloc_etherdev(sizeof(struct board_info));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (!ndev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -1676,11+1709,20@@ dm9000_drv_remove(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+#ifdef CONFIG_OF</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+static const struct of_device_id dm9000_of_matches[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+   { .compatible = &quot;davicom,dm9000&quot;, },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+   { /* sentinel */ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+MODULE_DEVICE_TABLE(of, dm9000_of_matches);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct platform_driver dm9000_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .name = &quot;dm9000&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    .pm = &amp;dm9000_drv_pm_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+      .of_match_table = of_match_ptr(dm9000_of_matches),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.probe = dm9000_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.remove = dm9000_drv_remove,</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>改为设备树后，在板上添加DM9000网卡的动作就变成了简单地修改dts文件，如arch/arm/boot/dts/s3c6410-mini6410.dts中就有这样的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">srom-cs1@18000000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compatible = &quot;simple-bus&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #size-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reg = &lt;0x180000000x8000000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ranges;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ethernet@18000000{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                compatible = &quot;davicom,dm9000&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                reg = &lt;0x180000000x20x180000040x2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interrupt-parent = &lt;&amp;gpn&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interrupts = &lt;7IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                davicom,no-eeprom;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.761Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->9 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux系统中，“/proc”文件系统十分有用，它被内核用于向用户导出信息。“/proc”文件系统是一个虚拟文件系统，通过它可以在Linux内核空间和用户空间之间进行通信。在/proc文件系统中，我们可以将对虚拟文件的读写作为与内核中实体进行通信的一种手段，与普通文件不同的是，这些虚拟文件的内容都是动态创建的。</p><p>“/proc”下的绝大多数文件是只读的，以显示内核信息为主。但是“/proc”下的文件也并不是完全只读的，若节点可写，还可用于一定的控制或配置目的，例如前面介绍的写/proc/sys/kernel/printk可以改变printk（）的打印级别。</p><p>Linux系统的许多命令本身都是通过分析“/proc”下的文件来完成的，如ps、top、uptime和free等。例如，free命令通过分析/proc/meminfo文件得到可用内存信息，下面显示了对应的meminfo文件和free命令的结果。</p><h1>1.meminfo文件</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[root@localhost proc]# cat meminfo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MemTotal:        29516 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MemFree:          1472 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Buffers:          4096 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Cached:          12648 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SwapCached:          0 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Active:          14208 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Inactive:         8844 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HighTotal:           0 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">HighFree:            0 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LowTotal:        29516 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LowFree:          1472 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SwapTotal:      265064 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SwapFree:       265064 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Dirty:              20 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Writeback:           0 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Mapped:          10052 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Slab:             3864 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CommitLimit:    279820 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Committed_AS:    13760 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">PageTables:        444 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">VmallocTotal:   999416 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">VmallocUsed:       560 kB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">VmallocChunk:   998580 kB</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>2. free命令</h1><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">[root@localhost proc]# free</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           total       used      free     shared    buffers     cached</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Mem:       29516       28104     1412     0         4100        12700</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-/+ buffers/cache:     11304     18212</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Swap:      265064      0         265064</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux 3.9以及之前的内核版本中，可用如下函数创建“/proc”节点：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct proc_dir_entry *create_proc_entry(const char *name, mode_t mode,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            struct proc_dir_entry *parent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct proc_dir_entry *create_proc_read_entry(const char *name, mode_t mode,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            struct proc_dir_entry *base, read_proc_t *read_proc, void * data);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>create_proc_entry（）函数用于创建“/proc”节点，而create_proc_read_entry（）调用create_proc_entry（）创建只读的“/proc”节点。参数name为“/proc”节点的名称，parent/base为父目录的节点，如果为NULL，则指“/proc”目录，read_proc是“/proc”节点的读函数指针。当read（）系统调用在“/proc”文件系统中执行时，它映像到一个数据产生函数，而不是一个数据获取函数。</p><p>下列函数用于创建“/proc”目录：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>结合create_proc_entry（）和proc_mkdir（），代码清单21.5中的程序可用于先在/proc下创建一个目录procfs_example，而后在该目录下创建一个文件example_file。</p><p>代码清单21.5　proc_mkdir（）和create_proc_entry（）函数使用范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 创建/proc下的目录 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2example_dir = proc_mkdir(&quot;procfs_example&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3if (example_dir == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 rv =  -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8example_dir-&gt;owner = THIS_MODULE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10/* 创建一个/proc文件 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11example_file = create_proc_entry(&quot;example_file&quot;, 0666, example_dir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12if (example_file == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 rv =  -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17example_file-&gt;owner = THIS_MODULE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18example_file-&gt;read_proc = example_file_read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19example_file-&gt;write_proc = example_file_write</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>作为上述函数返回值的proc_dir_entry结构体包含了“/proc”节点的读函数指针（read_proc_t<em>read_proc）、写函数指针（write_proc_t</em>write_proc）以及父节点、子节点信息等。</p><p>/proc节点的读写函数的类型分别为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef int (read_proc_t)(char *page, char **start, off_t off,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  int count, int *eof, void *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef int (write_proc_t)(struct file *file, const char __user *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                  unsigned long count, void *data);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>[插图]<!-- -->读函数中page指针指向用于写入数据的缓冲区，start用于返回实际的数据并写到内存页的位置，eof是用于返回读结束标志，offset是读的偏移，count是要读的数据长度。start参数比较复杂，对于/proc只包含简单数据的情况，通常不需要在读函数中设置*start，这意味着内核将认为数据保存在内存页偏移0的地方。</p><p>写函数与file_operations中的write（）成员函数类似，需要一次从用户缓冲区到内存空间的复制过程。</p><p>在Linux系统中可用如下函数删除/proc节点：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void remove_proc_entry(const char *name, struct proc_dir_entry *parent);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux系统中已经定义好的可使用的/proc节点宏包括：proc_root_fs（/proc）、proc_net（/proc/net）、proc_bus（/proc/bus）、proc_root_driver（/proc/driver）等，proc_root_fs实际上就是NULL。</p><p>代码清单21.6所示为一个简单的“/proc”文件系统使用范例，这段代码在模块加载函数中创建/proc/test_dir目录，并在该目录中创建/proc/test_dir/test_rw文件节点，在模块卸载函数中撤销“/proc”节点，而/proc/test_dir/test_rw文件中只保存了一个32位的整数。</p><p>代码清单21.6　/proc文件系统使用范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;linux/kernel.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;linux/proc_fs.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6static unsigned int variable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7static struct proc_dir_entry *test_dir, *test_entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9static int test_proc_read(char *buf, char **start, off_t off, int count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      int *eof, void *data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 unsigned int *ptr_var = data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 return sprintf(buf, &quot;%u\n&quot;, *ptr_var);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16static int test_proc_write(struct file *file, const char *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17      unsigned long count, void *data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 unsigned int *ptr_var = data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 *ptr_var = simple_strtoul(buffer, NULL, 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26static __init int test_proc_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 test_dir = proc_mkdir(&quot;test_dir&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 if (test_dir) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30     test_entry = create_proc_entry(&quot;test_rw&quot;, 0666, test_dir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31     if (test_entry) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32         test_entry-&gt;nlink = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33         test_entry-&gt;data = &amp;variable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34         test_entry-&gt;read_proc = test_proc_read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35         test_entry-&gt;write_proc = test_proc_write;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36         return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42module_init(test_proc_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44static __exit void test_proc_cleanup(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46 remove_proc_entry(&quot;test_rw&quot;, test_dir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 remove_proc_entry(&quot;test_dir&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49module_exit(test_proc_cleanup);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51MODULE_AUTHOR(&quot;Barry Song &lt;baohua@kernel.org&gt;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52MODULE_DESCRIPTION(&quot;proc exmaple&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第21行调用的simple_strtoul（）用于将用户输入的字符串转换为无符号长整数，第3个参数10意味着转化方式是十进制。</p><p>编译上述简单的proc.c为proc.ko，运行insmod proc.ko加载该模块后，“/proc”目录下将多出一个目录test_dir，该目录下包含一个test_rw，ls–l的结果如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ ls -l /proc/test_dir/test_rw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-rw-rw-rw- 1 root root 0 Aug 16 20:45 /proc/test_dir/test_rw</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>测试/proc/test_dir/test_rw的读写：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cat /proc/test_dir/test_rw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ echo 111 &gt; /proc/test_dir/test_rw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$ cat /proc/test_dir/test_rw</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>说明我们上一步执行的写操作是正确的。</p><p>在Linux 3.10及以后的版本中，“/proc”的内核API和实现架构变更较大，create_proc_entry（）、create_proc_read_entry（）之类的API都被删除了，取而代之的是直接使用proc_create（）、proc_create_data（）API。同时，也不再存在read_proc（）、write_proc（）之类的针对proc_dir_entry的成员函数了，而是直接把file_operations结构体的指针传入proc_create（）或者proc_create_data（）函数中，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline struct proc_dir_entry *proc_create(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *name, umode_t mode, struct proc_dir_entry *parent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const struct file_operations *proc_fops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct proc_dir_entry *proc_create_data(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *name, umode_t mode, struct proc_dir_entry *parent,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const struct file_operations *proc_fops, void *data);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们把代码清单21.6的范例改造为同时支持Linux 3.10以前的内核和Linux3.10以后的内核。改造结果如代码清单21.7所示。#if LINUX_VERSION_CODE&lt;KERNEL_VERSION（3，10，0）中的部分是旧版本的代码，与21.6相同，所以省略了。</p><p>代码清单21.7　支持Linux 3.10以后内核的/proc文件系统使用范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;linux/kernel.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;linux/version.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#include &lt;linux/proc_fs.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#include &lt;linux/seq_file.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8static unsigned int variable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9static struct proc_dir_entry *test_dir, *test_entry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(3, 10, 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14static int test_proc_show(struct seq_file *seq, void *v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 unsigned int *ptr_var = seq-&gt;private;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 seq_printf(seq, &quot;%u\n&quot;, *ptr_var);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21static ssize_t test_proc_write(struct file *file, const char __user *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22      size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 struct seq_file *seq = file-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 unsigned int *ptr_var = seq-&gt;private;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 *ptr_var = simple_strtoul(buffer, NULL, 10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 return count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31static int test_proc_open(struct inode *inode, struct file *file)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 return single_open(file, test_proc_show, PDE_DATA(inode));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36static const struct file_operations test_proc_fops =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39 .open = test_proc_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 .read = seq_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 .write = test_proc_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 .llseek = seq_lseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43 .release = single_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47static __init int test_proc_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 test_dir = proc_mkdir(&quot;test_dir&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 if (test_dir) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(3, 10, 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52      ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54 test_entry = proc_create_data(&quot;test_rw&quot;,0666, test_dir, &amp;test_proc_fops, &amp;variable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55 if (test_entry)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60 return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62module_init(test_proc_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64static __exit void test_proc_cleanup(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 remove_proc_entry(&quot;test_rw&quot;, test_dir);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67 remove_proc_entry(&quot;test_dir&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69module_exit(test_proc_cleanup);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.761Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>阻塞与非阻塞访问是I/O操作的两种不同模式，前者在暂时不可进行I/O操作时会让进程睡眠，后者则不然。</p><p>在设备驱动中阻塞I/O一般基于等待队列或者基于等待队列的其他Linux内核API来实现，等待队列可用于同步驱动中事件发生的先后顺序。使用非阻塞I/O的应用程序也可借助轮询函数来查询设备是否能立即被访问，用户空间调用select（）、poll（）或者epoll接口，设备驱动提供poll（）函数。设备驱动的poll（）本身不会阻塞，但是与poll（）、select（）和epoll相关的系统调用则会阻塞地等待至少一个文件描述符集合可访问或超时。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.749Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>字符设备与块设备I/O操作的不同如下。</p><p>1）块设备只能以块为单位接收输入和返回输出，而字符设备则以字节为单位。大多数设备是字符设备，因为它们不需要缓冲而且不以固定块大小进行操作。</p><p>2）块设备对于I/O请求有对应的缓冲区，因此它们可以选择以什么顺序进行响应，字符设备无须缓冲且被直接读写。对于存储设备而言，调整读写的顺序作用巨大，因为在读写连续的扇区的存储速度比分离的扇区更快。</p><p>3）字符设备只能被顺序读写，而块设备可以随机访问。</p><p>虽然块设备可随机访问，但是对于磁盘这类机械设备而言，顺序地组织块设备的访问可以提高性能，如图13.1所示，对扇区1、10、3、2的请求被调整为对扇区1、2、3、10的请求。</p><p>在Linux中，我们通常通过磁盘文件系统EXT4、UBIFS等访问磁盘，但是磁盘也有一种原始设备的访问方式，如直接访问/dev/sdb1等。所有的EXT4、UBIFS、原始块设备又都工作于VFS之下，而EXT4、UBIFS、原始块设备之下又包含块I/O调度层以进行排序和合并（见图13.2）。</p><p><img loading="lazy" alt="1744296926021" src="/assets/images/1744296926021-a33eca913c6bcada0ff6acb291457353.png" width="679" height="487" class="img_ev3q"></p><p>图13.1　调整块设备I/O操作的顺序</p><p><img loading="lazy" alt="1744296945055" src="/assets/images/1744296945055-0e46cf8020a3585a07133705186b6e5e.png" width="619" height="510" class="img_ev3q"></p><p>图13.2　Linux块设备子系统</p><p>I/O调度层的基本目的是将请求按照它们对应在块设备上的扇区号进行排列，以减少磁头的移动，提高效率。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.729Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>drivers/misc/eeprom/at24.c文件支持大多数I2 C接口的EEPROM，正如我们之前所述，一个具体的I2 C设备驱动由i2c_driver的形式进行组织，用于将设备挂接于I2 C总线，组织好了后，再完成设备本身所属类型的驱动。对于EEPROM而言，设备本身的驱动以bin_attribute二进制sysfs节点形式呈现。代码清单15.25给出了该驱动的框架。</p><p>代码清单15.25　AT24xx EEPROM驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct at24_data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2          struct at24_platform_data chip;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          struct bin_attribute bin;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8static const struct i2c_device_id at24_ids[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9          /* needs 8 addresses as A0-A2 are ignored */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          { &quot;24c00&quot;, AT24_DEVICE_MAGIC(128 / 8, AT24_FLAG_TAKE8ADDR) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11          /* old variants can&#x27;t be handled with this generic entry! */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          { &quot;24c01&quot;, AT24_DEVICE_MAGIC(1024 / 8, 0) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13          { &quot;24c02&quot;, AT24_DEVICE_MAGIC(2048 / 8, 0) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15          { /* END OF LIST */ }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17MODULE_DEVICE_TABLE(i2c, at24_ids);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19static ssize_t at24_eeprom_read(struct at24_data *at24, char *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                  unsigned offset, size_t count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22          struct i2c_msg msg[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24          i2c_transfer(client-&gt;adapter, msg, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28static ssize_t at24_read(struct at24_data *at24,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29                  char *buf, loff_t off, size_t count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33          status = at24_eeprom_read(at24, buf, off, count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36          return retval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39static ssize_t at24_bin_read(struct file *filp, struct kobject *kobj,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40                  struct bin_attribute *attr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41                  char *buf, loff_t off, size_t count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43          struct at24_data *at24;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45          at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46          return at24_read(at24, buf, off, count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54          sysfs_bin_attr_init(&amp;at24-&gt;bin);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55          at24-&gt;bin.attr.name = &quot;eeprom&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56          at24-&gt;bin.attr.mode = chip.flags &amp; AT24_FLAG_IRUGO   S_IRUGO : S_IRUSR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57          at24-&gt;bin.read = at24_bin_read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58          at24-&gt;bin.size = chip.byte_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61          return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64static int at24_remove(struct i2c_client *client)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67          sysfs_remove_bin_file(&amp;client-&gt;dev.kobj, &amp;at24-&gt;bin);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70          return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73static struct i2c_driver at24_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74          .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75                  .name = &quot;at24&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76                  .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78          .probe = at24_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79          .remove = at24_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80          .id_table = at24_ids,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83static int __init at24_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85          ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">86          return i2c_add_driver(&amp;at24_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">87}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">88module_init(at24_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">89</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">90static void __exit at24_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">91{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">92          i2c_del_driver(&amp;at24_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">93}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">94module_exit(at24_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/misc/eeprom/at24.c不依赖于具体的CPU和I2 C控制器的硬件特性，因此，如果某一电路板包含该外设，只需要在板级文件中添加对应的i2c_board_info，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct i2c_board_info i2c_devs0[] __initdata = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     { I2C_BOARD_INFO(&quot;24c02&quot;, 0x57), },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在支持设备树的情况下，简单地在.dts文件中添加一个节点即可：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">i2c@11000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       eeprom@57 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               compatible = &quot;atmel,24c02&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               reg = &lt;0x57&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.721Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->9 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux CPU热插拔的功能已经存在相当长的时间了，Linux 3.8之后的内核里一个小小的改进就是CPU0也可以热插拔。</p><p>一般来讲，在用户空间可以通过/sys/devices/system/cpu/cpun/online节点来操作一个CPU的在线和离线：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo 0&gt;/sys/devices/system/cpu/cpu3/online</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CPU 3 is now offline</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># echo1 &gt;/sys/devices/system/cpu/cpu3/online</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过echo0&gt;/sys/devices/system/cpu/cpu3/online关闭CPU3的时候，CPU3上的进程都会被迁移到其他的CPU上，以保证这个拔除CPU3的过程中，系统仍然能正常运行。一旦通过echo 1&gt;/sys/devices/system/cpu/cpu3/online再次开启CPU3，CPU3又可以参与系统的负载均衡，分担系统中的任务。</p><p>在嵌入式系统中，CPU热插拔可以作为一种省电的方式，在系统负载小的时候，动态关闭CPU，在系统负载增大的时候，再开启之前离线的CPU。目前各个芯片公司可能会根据自身SoC的特点，对内核进行调整，来实现运行时“热插拔”。这里以Nvidia的Tegra3为例进行说明。</p><p>Tegra3采用vSMP（variableSymmetric Multiprocessing）架构，共有5个Cortex-A9处理器，其中4个为高性能设计的G核，1个为低功耗设计的LP核，如图19.7所示。</p><p><img loading="lazy" alt="1746974605116" src="/assets/images/1746974605116-82fb8b5865b86461598cbe0e4dd424d1.png" width="652" height="618" class="img_ev3q"></p><p>图19.7　Tegra3的架构</p><p>在系统运行过程中，Tegra3的Linux内核会根据CPU负载切换低功耗处理器和高功耗处理器。除此之外，4个高性能ARM核心也会根据运行情况，动态借用Linux内核支持的CPU热插拔进行CPU的插入/拔出操作。</p><p>用华硕EeePad运行高负载、低负载应用，通过dmesg查看内核消息也确实验证了多核的热插拔以及G核和LP核之间的动态切换：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104626.426957] CPU1: Booted secondary processor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;7&gt;[104627.427412] tegra CPU: force EDP limit 720000 kHz</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104627.427670] CPU2: Booted secondary processor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104628.537005] stop_machine_cpu_stop cpu=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104628.537017] stop_machine_cpu_stop cpu=2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104628.537059] stop_machine_cpu_stop cpu=1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104628.537702] __stop_cpus: wait_for_completion_timeout+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104628.537810] __stop_cpus: smp=0 done.executed=1 done.ret =0-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;5&gt;[104628.537960] CPU1: clean shutdown</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104630.537092] stop_machine_cpu_stop cpu=0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104630.537172] stop_machine_cpu_stop cpu=2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104630.537739] __stop_cpus: wait_for_completion_timeout+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104630.538060] __stop_cpus: smp=0 done.executed=1 done.ret =0-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;5&gt;[104630.538203] CPU2: clean shutdown</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104631.306984] tegra_watchdog_touch</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>高性能处理器和低功耗处理器切换：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;3&gt;[104666.799152] LP=&gt;G: prolog 22 us, switch 2129 us, epilog 24 us, total 2175 us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;3&gt;[104667.807273] G=&gt;LP: prolog 18 us, switch 157 us, epilog 25 us, total 200 us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104671.407008] tegra_watchdog_touch</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;4&gt;[104671.408816] nct1008_get_temp: ret temp=35C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;3&gt;[104671.939060] LP=&gt;G: prolog 17 us, switch 2127 us, epilog 22 us, total 2166 us</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;3&gt;[104672.938091] G=&gt;LP: prolog 18 us, switch 156 us, epilog 24 us, total 198 us</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在运行过程中，我们发现4个G核会动态热插拔，而4个G核和1个LP核之间，会根据运行负载进行集群切换。这一部分都是在内核里面实现的，和tegra的CPUF req驱动（DVFS驱动）紧密关联。相关代码可见于<a href="http://nv-tegra.nvidia.com/gitweb/?p=linux-2.6.git;a=tree;f=arch/arm/mach-tegra;h=e5d1ff2;hb=rel-14r7" target="_blank" rel="noopener noreferrer">http://nv-tegra.nvidia.com/gitweb/?p=linux-2.6.git;a=tree;f=arch/arm/mach-tegra;h=e5d1ff2;hb=rel-14r7</a></p><h1>1.如何判断自己是什么核</h1><p>每个核都可以通过调用is_lp_cluster（）来判断当前正在执行的CPU是LP还是G处理器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline unsigned int is_lp_cluster(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int reg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reg =readl(FLOW_CTRL_CLUSTER_CONTROL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return (reg&amp; 1); /* 0 == G, 1 == LP */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>即读FLOW_CTRL_CLUSTER_CONTROL寄存器判断自己是G核还是LP核。</p><h1>2.G核和LP核集群的切换时机</h1><p>［场景1］何时从LP核切换给G核：当前执行于LP集群，CPUFreq驱动判断出LP核需要增频率到超过高值门限，即TEGRA_HP_UP：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">caseTEGRA_HP_UP:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(is_lp_cluster() &amp;&amp; !no_lp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               if(!clk_set_parent(cpu_clk, cpu_g_clk)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       hp_stats_update(CONFIG_NR_CPUS, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       hp_stats_update(0, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        /* catch-upwith governor target speed */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       tegra_cpu_set_speed_cap(NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>［场景2］何时从G核切换给LP核：当前执行于G集群，CPUFreq驱动判断出某G核需要降频率到低于低值门限，即TEGRA_HP_DOWN，且最慢的CPUID不小于nr_cpu_ids（实际上代码逻辑跟踪等价于只有CPU0还活着的情况）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">caseTEGRA_HP_DOWN:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cpu= tegra_get_slowest_cpu_n();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(cpu &lt; nr_cpu_ids) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else if(!is_lp_cluster() &amp;&amp; !no_lp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               if(!clk_set_parent(cpu_clk, cpu_lp_clk)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       hp_stats_update(CONFIG_NR_CPUS, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       hp_stats_update(0, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        /* catch-upwith governor target speed */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       tegra_cpu_set_speed_cap(NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               } else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       queue_delayed_work(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               hotplug_wq, &amp;hotplug_work, down_delay);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       break;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>切换实际上就发生在clk_set_parent（）更改CPU的父时钟里面，这部分代码写得比较不好，1个函数完成n个功能，实际上不仅切换了时钟，还切换了G和LP集群：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">clk_set_parent(cpu_clk, cpu_lp_clk) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         tegra3_cpu_cmplx_clk_set_parent(structclk *c, struct clk *p) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   tegra_cluster_control(unsigned int us, unsigned int flags) -&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                            tegra_cluster_switch_prolog()-&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">tegra_cluster_switch_epilog()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>3.G核动态热插拔</h1><p>何时进行G核的动态插拔，具体如下。</p><p>［场景3］当前执行于G集群，CPUFreq驱动判断出某G核需要降频率到低于低值门限，即TEGRA_HP_DOWN，且最慢的CPUID小于nr_cpu_ids（实际上等价于还有两个或两个以上的G核活着的情况），关闭最慢的CPU，留意tegra_get_slowest_cpu_n（）不会返回0，这意味着CPU0要么活着，要么切换给了LP核，对应于［场景2］：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">caseTEGRA_HP_DOWN:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cpu= tegra_get_slowest_cpu_n();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(cpu &lt; nr_cpu_ids) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               up = false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               queue_delayed_work(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        hotplug_wq,&amp;hotplug_work, down_delay);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               hp_stats_update(cpu, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>［场景4］当前执行于G集群，CPUFreq驱动判断出某G核需要设置频率大于高值门限，即TEGRA_HP_UP，如果负载平衡状态为TEGRA_CPU_SPEED_BALANCED，再开一个核；如果状态为TEGRA_CPU_SPEED_SKEWED，则关一个核。TEGRA_CPU_SPEED_BALANCED的含义是当前所有G核要求的频率都高于最高频率的50%，TEGRA_CPU_SPEED_SKEWED的含义是当前至少有两个G核要求的频率低于门限的25%，即CPU频率的要求在各个核之间有倾斜。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">caseTEGRA_HP_UP:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if(is_lp_cluster() &amp;&amp; !no_lp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               switch (tegra_cpu_speed_balance()) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               /* cpu speed is up and balanced - one more on-line */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               case TEGRA_CPU_SPEED_BALANCED:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       cpu =cpumask_next_zero(0, cpu_online_mask);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if(cpu &lt;nr_cpu_ids) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                up =true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               hp_stats_update(cpu, true);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               /* cpu speed is up, but skewed - remove one core */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               case TEGRA_CPU_SPEED_SKEWED:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        cpu =tegra_get_slowest_cpu_n();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if(cpu &lt; nr_cpu_ids) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                up =false;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               hp_stats_update(cpu, false);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               /* cpu speed is up, butunder-utilized - do nothing */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               case TEGRA_CPU_SPEED_BIASED:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中TEGRA_CPU_SPEED_BIASED路径的含义是有1个以上G核的频率低于最高频率的50%但是还未形成“SKEWED”条件，即只是“BIASED”，还没有达到“SKEWED”的程度，因此暂时什么都不做。</p><p>目前，ARM和Linux社区都在从事关于big.LITTLE架构下，CPU热插拔以及调度器方面有针对性的改进工作。在big.LITTLE架构中，将高性能且功耗也较高的Cortex-A15和稍低性能且功耗低的Cortex-A7进行了结合，或者在64位下，进行Cortex-A57和Cortex-A53的组合，如图19.8所示。</p><p>big.LITTLE架构的设计旨在为适当的作业分配恰当的处理器。Cortex-A15处理器是目前已开发的性能最高的低功耗ARM处理器，而Cortex-A7处理器是目前已开发的最节能的ARM应用程序处理器。可以利用Cortex-A15处理器的性能来承担繁重的工作负载，而用Cortex-A7可以最有效地处理智能手机的大部分工作负载。这些操作包括操作系统活动、用户界面和其他持续运行、始终连接的任务。</p><p><img loading="lazy" alt="1747060960088" src="/assets/images/1747060960088-caa07910574d9a1fbfea8f0ffd7aca11.png" width="987" height="520" class="img_ev3q"></p><p>图19.8　ARM的big.LITTLE架构</p><p>三星在2013年CES（国际消费电子展）大会上发布了Exynos 5Octa 8核移动处理器，这款处理器也是采用big.LITTLE架构的第一款CPU。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.709Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->8 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>除了保证程序的正确性以外，在项目开发中往往还关心性能和稳定性。这时候，我们往往要对内核、应用程序或整个系统进行性能优化。在性能优化中常用的手段如下。</p><h1>1.使用top、vmstat、iostat、sysctl等常用工具</h1><p>top命令用于显示处理器的活动状况。在缺省情况下，显示占用CPU最多的任务，并且每隔5s做一次刷新；</p><p>vmstat命令用于报告关于内核线程、虚拟内存、磁盘、陷阱和CPU活动的统计信息；</p><p>iostat命令用于分析各个磁盘的传输闲忙状况；</p><p>netstat是用来检测网络信息的工具；</p><p>sar用于收集、报告或者保存系统活动信息，其中，sar用于显示数据，sar1和sar2用于收集和保存数据。</p><p>sysctl是一个可用于改变正在运行中的Linux系统的接口。用sysctl可以读取几百个以上的系统变量，例如用sysctl–a可读取所有变量。</p><p>sysctl的实现原理是：所有的内核参数在/proc/sys中形成一个树状结构，sysctl系统调用的内核函数是sys_sysctl，匹配项目后，最后的读写在do_sysctl_strategy中完成，如</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo &quot;1&quot; &gt; /proc/sys/net/ipv4/ip_forward</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>就等价于：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sysctl –w net.ipv4.ip_forward =&quot;1&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>2.使用高级分析手段，如OProfile、gprof</h1><p>OProfile可以帮助用户识别诸如模块的占用时间、循环的展开、高速缓存的使用率低、低效的类型转换和冗余操作、错误预测转移等问题。它收集有关处理器事件的信息，其中包括TLB的故障、停机、存储器访问以及缓存命中和未命中的指令的攫取数量。</p><p>OProfile支持两种采样方式：基于事件的采样（Event Based）和基于时间的采样（Time Based）。基于事件的采样是OProfile只记录特定事件（比如L2缓存未命中）的发生次数，当达到用户设定的定值时Oprofile就记录一下（采一个样）。这种方式需要CPU内部有性能计数器（Performace Counter）。基于时间的采样是OProfile借助OS时钟中断的机制，在每个时钟中断，OProfile都会记录一次（采一次样）。引入它的目的在于，提供对没有性能计数器的CPU的支持，其精度相对于基于事件的采样要低，因为要借助OS时钟中断的支持，对于禁用中断的代码，OProfile不能对其进行分析</p><p>OProfile在Linux上分两部分，一个是内核模块（oprofile.ko），另一个是用户空间的守护进程（oprofiled）。前者负责访问性能计数器或者注册基于时间采样的函数，并将采样值置于内核的缓冲区内。后者在后台运行，负责从内核空间收集数据，写入文件。其运行步骤如下。</p><p>1）初始化opcontrol--init</p><p>2）配置opcontrol--setup--event=...</p><p>3）启动opcontrol--start</p><p>4）运行待分析的程序xxx</p><p>5）取出数据opcontrol--dumpopcontrol--stop</p><p>6）分析结果opreport-l./xxx</p><p>用GNU gprof可以打印出程序运行中各个函数消耗的时间，以帮助程序员找出众多函数中耗时最多的函数；还可产生程序运行时的函数调用关系，包括调用次数，以帮助程序员分析程序的运行流程。</p><p>GNU gprof的实现原理：在编译和链接程序的时候（使用-pg编译和链接选项），gcc在应用程序的每个函数中都加入名为mcount（_mcount或__mcount，依赖于编译器或操作系统）的函数，也就是说应用程序里的每一个函数都会调用mcount，而mcount会在内存中保存一张函数调用图，并通过函数调用堆栈的形式查找子函数和父函数的地址。这张调用图也保存了所有与函数相关的调用时间、调用次数等的所有信息。</p><p>GNU gprof的基本用法如下。</p><p>1）使用-pg编译和链接应用程序。</p><p>2）执行应用程序并使它生成供gprof分析的数据。</p><p>3）使用gprof程序分析应用程序生成的数据。</p><h1>3.进行内核跟踪，如LTTng</h1><p>LTTng（Linux Trace Toolkit-next generation，官方网站为<a href="http://lttng.org/" target="_blank" rel="noopener noreferrer">http://lttng.org/</a> ）是一个用于跟踪系统详细运行状态和流程的工具，它可以跟踪记录系统中的特定事件。这些事件包括：系统调用的进入和退出；陷阱/中断（Trap/Irq）的进入和退出；进程调度事件；内核定时器；进程管理相关事件—创建、唤醒、信号处理等；文件系统相关事件—open/read/write/seek/ioctl等；内存管理相关事件—内存分配/释放等；其他IPC/套接字/网络等事件。而对于这些记录，我们可以通过图形的方式经由lttv-gui查看，如图21.9所示。</p><h1>4.使用LTP进行压力测试</h1><p>LTP（Linux Test Project，官方网站为<a href="http://ltp.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://ltp.sourceforge.net/</a> ）是一个由SGI发起并由IBM负责维护的合作计划。它的目的是为开源社区提供测试套件来验证Linux的可靠性、健壮性和稳定性。它通过压力测试来判断系统的稳定性和可靠性，在工程中我们可使用LTP测试套件对Linux操作系统进行超长时间的测试，它可进行文件系统压力测试、硬盘I/O测试、内存管理压力测试、IPC压力测试、SCHED测试、命令功能的验证测试、系统调用功能的验证测试等。</p><p><img loading="lazy" alt="1747579791527" src="/assets/images/1747579791527-33d6221eae191ba8233e658a2a7dad22.png" width="1494" height="768" class="img_ev3q"></p><p>图21.9　LTTng形成的时序图</p><h1>5.使用Benchmark评估系统</h1><p>可用于Linux的Benchmark的包括lmbench、UnixBench、AIM9、Netperf、SSLperf、dbench、Bonnie、Bonnie++、Iozone、BYTEmark等，它们可用于评估操作系统、网络、I/O子系统、CPU等的性能，参考网址<a href="http://lbs.sourceforge.net/" target="_blank" rel="noopener noreferrer">http://lbs.sourceforge.net/</a> 列出了许多Benchmark工具。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.689Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->15 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux中的SPI、I2 C、USB等子系统都利用了典型的把主机驱动和外设驱动分离的想法，让主机端只负责产生总线上的传输波形，而外设端只是通过标准的API来让主机端以适当的波形访问自身。因此这里面就涉及了4个软件模块：</p><p>1）主机端的驱动。根据具体的I2 C、SPI、USB等控制器的硬件手册，操作具体的I2C、SPI、USB等控制器，产生总线的各种波形。</p><p>2）连接主机和外设的纽带。外设不直接调用主机端的驱动来产生波形，而是调一个标准的API。由这个标准的API把这个波形的传输请求间接“转发”给了具体的主机端驱动。当然，在这里，最好把关于波形的描述也以某种数据结构标准化。</p><p>3）外设端的驱动。外设接在I2 C、SPI、USB这样的总线上，但是它们本身可以是触摸屏、网卡、声卡或者任意一种类型的设备。我们在相关的i2c_driver、spi_driver、usb_driver这种xxx_driver的probe（）函数中去注册它具体的类型。当这些外设要求I2 C、SPI、USB等去访问它的时候，它调用“连接主机和外设的纽带”模块的标准API。</p><p>4）板级逻辑。板级逻辑用来描述主机和外设是如何互联的，它相当于一个“路由表”。假设板子上有多个SPI控制器和多个SPI外设，那究竟谁接在谁上面管理互联关系，既不是主机端的责任，也不是外设端的责任，这属于板级逻辑的责任。这部分通常出现在arch/arm/mach-xxx下面或者arch/arm/boot/dts下面。</p><p>什么叫良好的软件设计一言以蔽之，让正确的代码出现在正确的位置。不要在错误的时间、错误的地点，编写一段错误的代码。在LKML中，关于代码出现在错误的位置，常见的台词是代码“out of place”。</p><p>Linux通过上述的设计方法，把一堆杂乱不友好的代码变成了4个轻量级的小模块，每个模块都各得其所。每个模块都觉得很“爽”，站在主机端想一想，它其实也是很“爽”的，因为它的职责本来就是产生波形，而现在我们就让它只产生波形不干别的；站在外设端想一想，它也变得一身轻松，因为它根本就不需要知道自己接在主机的哪个控制器上，根本不关心对方是张三、李四、王五还是六麻子；站在板级逻辑的角度上，你做了一个板子，自己自然要知道谁接在谁上面了。</p><p>下面以SPI子系统为例来展开说明，后续章节的I2 C、USB等是类似的。</p><h1>12.4.2　Linux SPI主机和设备驱动</h1><p>在Linux中，用代码清单12.24的spi_master结构体来描述一个SPI主机控制器驱动，其主要成员是主机控制器的序号（系统中可能存在多个SPI主机控制器）、片选数量、SPI模式、时钟设置用到的和数据传输用到的函数等。</p><p>代码清单12.24　spi_master结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct spi_master {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 struct devicedev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 s16           bus_num;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 /* chipselects will be integral to many controllers; some others</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  * might use board-specific GPIOs.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 u16           num_chipselect;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 /* limits on transfer speed */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 u32           min_speed_hz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 u32           max_speed_hz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 /* Setup mode and clock, etc (spi driver may call many times).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  * IMPORTANT:  this may be called when transfers to another</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  * device are active.  DO NOT UPDATE SHARED REGISTERS in ways</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  * which could break those transfers.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 int            (*setup)(struct spi_device *spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 /* bidirectional bulk transfers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  * + The transfer() method may not sleep; its main role is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  *   just to add the message to the queue.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31  * + For now there&#x27;s no remove-from-queue operation, or</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  *   any other request management</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33  * + To a given spi_device, message queueing is pure fifo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  * + The master&#x27;s main job is to process its message queue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36  *   selecting a chip then transferring data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37  * + If there are multiple spi_device children, the i/o queue</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38  *   arbitration algorithm is unspecified (round robin, fifo,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39  *   priority, reservations, preemption, etc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41  * + Chipselect stays active during the entire message</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42  *   (unless modified by spi_transfer.cs_change != 0).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43  * + The message transfers use clock and SPI mode parameters</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44  *   previously established by setup() for this device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46 int            (*transfer)(struct spi_device *spi,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47                     struct spi_message *mesg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 /* called on release() to free memory provided by spi_master */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 void         (*cleanup)(struct spi_device *spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54 /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55  * These hooks are for drivers that use a generic implementation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56  * of transfer_one_message() provied by the core.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58 void (*set_cs)(struct spi_device *spi, bool enable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59 int (*transfer_one)(struct spi_master *master, struct spi_device *spi,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60             struct spi_transfer *transfer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62 /* gpio chip select */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63 int            *cs_gpios;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>分配、注册和注销SPI主机的API由SPI核心提供：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct spi_master * spi_alloc_master(struct device *host, unsigned size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int spi_register_master(struct spi_master *master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void spi_unregister_master(struct spi_master *master);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux中，用代码清单12.25的spi_driver结构体来描述一个SPI外设驱动，这个外设驱动可以认为是spi_master的客户端驱动。</p><p>代码清单12.25　spi_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct spi_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 const struct spi_device_id *id_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 int            (*probe)(struct spi_device *spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4 int            (*remove)(struct spi_device *spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 void            (*shutdown)(struct spi_device *spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6 int            (*suspend)(struct spi_device *spi, pm_message_t mesg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7 int            (*resume)(struct spi_device *spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8 struct device_driver    driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以看出，spi_driver结构体和platform_driver结构体有极大的相似性，都有probe（）、remove（）、suspend（）、resume（）这样的接口和device_driver的实例。是的，这几乎是一切客户端驱动的常用模板。</p><p>代码清单12.26　spi_transfer结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct spi_transfer {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 /* it&#x27;s ok if tx_buf == rx_buf (right )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  * for MicroWire, one buffer must be null</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  * buffers must work with dma_*map_single() calls, unless</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  *   spi_message.is_dma_mapped reports a pre-existing mapping</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 const void    *tx_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 void        *rx_buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 unsigned    len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 dma_addr_t    tx_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 dma_addr_t    rx_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 struct sg_table tx_sg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 struct sg_table rx_sg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 unsigned    cs_change:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 unsigned    tx_nbits:3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 unsigned    rx_nbits:3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19#define    SPI_NBITS_SINGLE    0x01/* 1bit transfer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20#define    SPI_NBITS_DUA       0x02/* 2bits transfer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21#define    SPI_NBITS_QUAD      0x04/* 4bits transfer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 u8       bits_per_word;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 u16       delay_usecs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 u32       speed_hz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 struct list_head transfer_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而一次完整的SPI传输流程可能不是只包含一次spi_transfer，它可能包含一个或多个spi_transfer，这些spi_transfer最终通过spi_message组织在一起，其定义如代码清单12.27所示。</p><p>代码清单12.27　spi_message结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct spi_message {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 struct list_head    transfers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct spi_device    *spi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 unsigned        is_dma_mapped:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 /* REVISIT:  we might want a flag affecting the behavior of the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  * last transfer ... allowing things like &quot;read 16bit length L&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  * immediately followed by &quot;read L bytes&quot;.  Basically imposing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  * a specific message scheduling algorithm.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  * Some controller drivers (message-at-a-time queue processing)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  * could provide that as their default scheduling algorithm.  But</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  * others (with multi-message pipelines) could need a flag to</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  * tell them about such special cases.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 /* completion is reported through a callback */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    void            (*complete)(void *context);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 void            *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 unsigned        frame_length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 unsigned        actual_length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 int            status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 /* for optional use by whatever driver currently owns the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  * spi_message ...  between calls to spi_async and then later</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  * complete(), that&#x27;s the spi_master controller driver.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30 struct list_head    queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 void            *state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过spi_message_init（）可以初始化spi_message，而将spi_transfer添加到spi_message队列的方法则是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>发起一次spi_message的传输有同步和异步两种方式，使用同步API时，会阻塞等待这个消息被处理完。同步操作时使用的API是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int spi_sync(struct spi_device *spi, struct spi_message *message);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用异步API时，不会阻塞等待这个消息被处理完，但是可以在spi_message的complete字段挂接一个回调函数，当消息被处理完成后，该函数会被调用。在异步操作时使用的API是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int spi_async(struct spi_device *spi, struct spi_message *message);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单12.28是非常典型的初始化spi_transfer、spi_message并进行SPI数据传输的例子，同时spi_write（）、spi_read（）也是SPI核心层的两个通用快捷API，在SPI外设驱动中可以直接调用它们进行简单的纯写和纯读操作。</p><p>代码清单12.28　SPI传输实例spi_write（）、spi_read（）API</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 static inline int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 spi_write(struct spi_device *spi, const u8*buf, size_t len)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         struct spi_transfer     t = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                         .tx_buf         = buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6                         .len            = len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         struct spi_message      m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        spi_message_init(&amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        spi_message_add_tail(&amp;t, &amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        return spi_sync(spi, &amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15static inline int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16spi_read(struct spi_device *spi, u8*buf, size_t len)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        struct spi_transfer     t = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                        .rx_buf         = buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                        .len            = len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21               };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22       struct spi_message      m;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       spi_message_init(&amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       spi_message_add_tail(&amp;t, &amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26       return spi_sync(spi, &amp;m);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>SPI主机控制器驱动位于drivers/spi/，这些驱动的主体是实现了spi_master的transfer（）、transfer_one（）、setup（）这样的成员函数，当然，也可能是实现spi_bitbang的txrx_bufs（）、setup_transfer（）、chipselect（）这样的成员函数。代码清单12.29摘取了drivers/spi/spi-pl022.c的部分代码。</p><p>代码清单12.29　SPI主机端驱动完成的波形传输</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int pl022_transfer_one_message(struct spi_master *master,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                      struct spi_message *msg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct pl022*pl022= spi_master_get_devdata(master);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 /* Initial message state */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 pl022-&gt;cur_msg = msg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 msg-&gt;state = STATE_START;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 pl022-&gt;cur_transfer = list_entry(msg-&gt;transfers.next,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                  struct spi_transfer, transfer_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 /* Setup the SPI using the per chip configuration */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 pl022-&gt;cur_chip = spi_get_ctldata(msg-&gt;spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 pl022-&gt;cur_cs = pl022-&gt;chipselects[msg-&gt;spi-&gt;chip_select];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 restore_state(pl022);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 flush(pl022);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 if (pl022-&gt;cur_chip-&gt;xfer_type == POLLING_TRANSFER)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     do_polling_transfer(pl022);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     do_interrupt_dma_transfer(pl022);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28static int pl022_setup(struct spi_device *spi)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 /* Stuff that is common for all versions */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 if (spi-&gt;mode &amp; SPI_CPOL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33     tmp = SSP_CLK_POL_IDLE_HIGH;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35     tmp = SSP_CLK_POL_IDLE_LOW;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 SSP_WRITE_BITS(chip-&gt;cr0, tmp, SSP_CR0_MASK_SPO, 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 if (spi-&gt;mode &amp; SPI_CPHA)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39     tmp = SSP_CLK_SECOND_EDGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41     tmp = SSP_CLK_FIRST_EDGE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 SSP_WRITE_BITS(chip-&gt;cr0, tmp, SSP_CR0_MASK_SPH, 7);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47static int pl022_probe(struct amba_device *adev, const struct amba_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51 /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52  * Bus Number Which has been Assigned to this SSP controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53  * on this board</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54  */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55 master-&gt;bus_num = platform_info-&gt;bus_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56 master-&gt;num_chipselect = num_cs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57 master-&gt;cleanup = pl022_cleanup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58 master-&gt;setup = pl022_setup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59 master-&gt;auto_runtime_pm = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60 master-&gt;transfer_one_message = pl022_transfer_one_message;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61 master-&gt;unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62 master-&gt;rt = platform_info-&gt;rt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63 master-&gt;dev.of_node = dev-&gt;of_node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>SPI外设驱动遍布于内核的drivers、sound的各个子目录之下，SPI只是一种总线，spi_driver的作用只是将SPI外设挂接在该总线上，因此在spi_driver的probe（）成员函数中，将注册SPI外设本身所属设备驱动的类型。</p><p>和platform_driver对应着一个platform_device一样，spi_driver也对应着一个spi_device；platform_device需要在BSP的板文件中添加板信息数据，而spi_device也同样需要。spi_device的板信息用spi_board_info结构体描述，该结构体记录着SPI外设使用的主机控制器序号、片选序号、数据比特率、SPI传输模式（即CPOL、CPHA）等。诺基亚770上的两个SPI设备的板信息数据如代码清单12.30所示，位于板文件arch/arm/mach-omap1/board-nokia770.c中。</p><p>代码清单12.30　诺基亚770板文件中的spi_board_info</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct spi_board_info nokia770_spi_board_info[] __initdata = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   [0] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3           .modalias           = &quot;lcd_mipid&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4           .bus_num            = 2,          /* 用到的SPI主机控制器序号*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5           .chip_select        = 3,          /* 使用哪个片选*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6           .max_speed_hz       = 12000000,   /* SPI数据传输比特率*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7           .platform_data      = &amp;nokia770_mipid_platform_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   [1] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10           .modalias           = &quot;ads7846&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11           .bus_num            = 2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12           .chip_select        = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13           .max_speed_hz       = 2500000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14           .irq                = OMAP_GPIO_IRQ(15),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15           .platform_data      = &amp;nokia770_ads7846_platform_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux启动过程中，在机器的init_machine（）函数中，会通过如下语句注册这些spi_board_info：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">spi_register_board_info(nokia770_spi_board_info,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                       ARRAY_SIZE(nokia770_spi_board_info));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这一点和启动时通过platform_add_devices（）添加platform_device非常相似。</p><p>ARM Linux 3.x之后的内核在改为设备树后，不再需要在arch/arm/mach-xxx中编码SPI的板级信息了，而倾向于在SPI控制器节点下填写子节点，如代码清单12.31给出了arch/arm/boot/dts/omap3-overo-common-lcd43.dtsi中包含的ads7846节点。</p><p>代码清单12.31　通过设备树添加SPI外设</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1&amp;mcspi1{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      pinctrl-names = &quot;default&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      pinctrl-0= &lt;&amp;mcspi1_pins&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      /* touch controller */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      ads7846@0{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7              pinctrl-names = &quot;default&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8              pinctrl-0= &lt;&amp;ads7846_pins&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10              compatible = &quot;ti,ads7846&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11              vcc-supply = &lt;&amp;ads7846reg&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13              reg = &lt;0&gt;;               /* CS0*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14              spi-max-frequency = &lt;1500000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16              interrupt-parent = &lt;&amp;gpio4&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17              interrupts = &lt;180&gt;;    /* gpio_114*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18              pendown-gpio = &lt;&amp;gpio4180&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20              ti,x-min = /bits/ 16&lt;0x0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21              ti,x-max = /bits/ 16&lt;0x0fff&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22              ti,y-min = /bits/ 16&lt;0x0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23              ti,y-max = /bits/ 16&lt;0x0fff&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24              ti,x-plate-ohms = /bits/ 16&lt;180&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25              ti,pressure-max = /bits/ 16&lt;255&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27              linux,wakeup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.689Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->17 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux中最常用的输入/输出（I/O）模型是同步I/O。在这个模型中，当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是一种很好的解决方案，调用应用程序在等待I/O请求完成时不需要占用CPU。但是在许多应用场景中，I/O请求可能需要与CPU消耗产生交叠，以充分利用CPU和I/O提高吞吐率。</p><p>图9.3描绘了异步I/O的时序，应用程序发起I/O动作后，直接开始执行，并不等待I/O结束，它要么过一段时间来查询之前的I/O请求完成情况，要么I/O请求完成了会自动被调用与I/O完成绑定的回调函数。</p><p><img loading="lazy" alt="image-20250329162852016" src="/assets/images/image-20250329162852016-f73873f65ad99eced05bc485ccb4c906.png" width="1033" height="688" class="img_ev3q"></p><p>图9.3　异步I/O的时序</p><p>Linux的AIO有多种实现，其中一种实现是在用户空间的glibc库中实现的，它本质上是借用了多线程模型，用开启新的线程以同步的方法来做I/O，新的AIO辅助线程与发起AIO的线程以pthread_cond_signal（）的形式进行线程间的同步。glibc的AIO主要包括如下函数。</p><p>1.aio_read（）</p><p>aio_read（）函数请求对一个有效的文件描述符进行异步读操作。这个文件描述符可以表示一个文件、套接字，甚至管道。aio_read函数的原型如下</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_read( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>aio_read（）函数在请求进行排队之后会立即返回（尽管读操作并未完成）。如果执行成功，返回值就为0；如果出现错误，返回值就为-1，并设置errno的值。</p><p>参数aiocb（AIO I/O Control Block）结构体包含了传输的所有信息，以及为AIO操作准备的用户空间缓冲区。在产生I/O完成通知时，aiocb结构就被用来唯一标识所完成的I/O操作。</p><p>2.aio_write（）</p><p>aio_write（）函数用来请求一个异步写操作。其函数原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_write( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>aio_write（）函数会立即返回，并且它的请求已经被排队（成功时返回值为0，失败时返回值为-1，并相应地设置errno）。</p><p>3.aio_error（）</p><p>aio_error（）函数被用来确定请求的状态。其原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_error( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数可以返回以下内容。</p><p>EINPROGRESS：说明请求尚未完成。</p><p>ECANCELED：说明请求被应用程序取消了。</p><p>-1：说明发生了错误，具体错误原因由errno记录。</p><p>4.aio_return（）</p><p>异步I/O和同步阻塞I/O方式之间的一个区别是不能立即访问这个函数的返回状态，因为异步I/O并没有阻塞在read（）调用上。在标准的同步阻塞read（）调用中，返回状态是在该函数返回时提供的。但是在异步I/O中，我们要使用aio_return（）函数。这个函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t aio_return( struct aiocb *aiocbp );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>只有在aio_error（）调用确定请求已经完成（可能成功，也可能发生了错误）之后，才会调用这个函数。aio_return（）的返回值就等价于同步情况中read（）或write（）系统调用的返回值（所传输的字节数如果发生错误，返回值为负数）。</p><p>代码清单9.12给出了用户空间应用程序进行异步读操作的一个例程，它首先打开文件，然后准备aiocb结构体，之后调用aio_read（&amp;my_aiocb）进行提出异步读请求，当aio_error（&amp;my_aiocb）==EINPROGRESS，即操作还在进行中时，一直等待，结束后通过aio_return（&amp;my_aiocb）获得返回值。</p><p>代码清单9.12　用户空间异步读例程</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 #include &lt;aio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 int fd, ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct aiocb my_aiocb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 fd = open(&quot;file.txt&quot;, O_RDONLY);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 if (fd &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    perror(&quot;open&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10/* 清零aiocb结构体 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11bzero(&amp;my_aiocb, sizeof(struct aiocb));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13/* 为aiocb请求分配数据缓冲区*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14my_aiocb.aio_buf = malloc(BUFSIZE + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15if (!my_aiocb.aio_buf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   perror(&quot;malloc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18/* 初始化aiocb的成员 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19my_aiocb.aio_fildes = fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20my_aiocb.aio_nbytes = BUFSIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21my_aiocb.aio_offset = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23ret = aio_read(&amp;my_aiocb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   perror(&quot;aio_read&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27while (aio_error(&amp;my_aiocb) == EINPROGRESS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30if ((ret = aio_return(&amp;my_iocb)) &gt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31   /* 获得异步读的返回值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32} else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33   /* 读失败，分析errorno */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5.aio_suspend（）</p><p>用户可以使用aio_suspend（）函数来阻塞调用进程，直到异步请求完成为止。调用者提供了一个aiocb引用列表，其中任何一个完成都会导致aio_suspend（）返回。aio_suspend（）的函数原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_suspend( const struct aiocb *const cblist[],</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          int n, const struct timespec *timeout );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单9.13给出了用户空间进行异步读操作时使用aio_suspend（）函数的例子。</p><p>代码清单9.13　用户空间异步I/O aio_suspend（）函数使用例程</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct aioct *cblist[MAX_LIST]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2/* 清零aioct结构体链表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3bzero( (char *)cblist, sizeof(cblist) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4/* 将一个或更多的aiocb放入aioct的结构体链表中*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5cblist[0] = &amp;my_aiocb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6ret = aio_read(&amp;my_aiocb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7ret = aio_suspend(cblist, MAX_LIST, NULL );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当然，在glibc实现的AIO中，除了上述同步的等待方式以外，也可以使用信号或者回调机制来异步地标明AIO的完成。</p><p>6.aio_cancel（）</p><p>aio_cancel（）函数允许用户取消对某个文件描述符执行的一个或所有I/O请求。其原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int aio_cancel(int fd, struct aiocb *aiocbp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>要取消一个请求，用户需提供文件描述符和aiocb指针。如果这个请求被成功取消了，那么这个函数就会返回AIO_CANCELED。如果请求完成了，这个函数就会返回AIO_NOTCANCELED。</p><p>要取消对某个给定文件描述符的所有请求，用户需要提供这个文件的描述符，并将aiocbp参数设置为NULL。如果所有的请求都取消了，这个函数就会返回AIO_CANCELED；如果至少有一个请求没有被取消，那么这个函数就会返回AIO_NOT_CANCELED；如果没有一个请求可以被取消，那么这个函数就会返回AIO_ALLDONE。然后，可以使用aio_error（）来验证每个AIO请求，如果某请求已经被取消了，那么aio_error（）就会返回-1，并且errno会被设置为ECANCELED。</p><p>7.lio_listio（）</p><p>lio_listio（）函数可用于同时发起多个传输。这个函数非常重要，它使得用户可以在一个系统调用中启动大量的I/O操作。lio_listio API函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int lio_listio( int mode, struct aiocb *list[], int nent, struct sigevent *sig );</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>mode参数可以是LIO_WAIT或LIO_NOWAIT。LIO_WAIT会阻塞这个调用，直到所有的I/O都完成为止。但是若是LIO_NOWAIT模型，在I/O操作进行排队之后，该函数就会返回。list是一个aiocb引用的列表，最大元素的个数是由nent定义的。如果list的元素为NULL，lio_listio（）会将其忽略。</p><p>代码清单9.14给出了用户空间进行异步I/O操作时使用lio_listio（）函数的例子。</p><p>代码清单9.14　用户空间异步I/O lio_listio（）函数使用例程</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct aiocb aiocb1, aiocb2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2struct aiocb *list[MAX_LIST];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4/* 准备第一个aiocb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5aiocb1.aio_fildes = fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6aiocb1.aio_buf = malloc( BUFSIZE+1 );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7aiocb1.aio_nbytes = BUFSIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8aiocb1.aio_offset = next_offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9aiocb1.aio_lio_opcode = LIO_READ;                    /* 异步读操作*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10...  /* 准备多个aiocb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11bzero( (char *)list, sizeof(list) );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13/* 将aiocb填入链表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14list[0] = &amp;aiocb1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15list[1] = &amp;aiocb2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17ret = lio_listio( LIO_WAIT, list, MAX_LIST, NULL );  /* 发起大量I/O操作*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第9行中，因为是进行异步读操作，所以操作码为LIO_READ，对于写操作来说，应该使用LIO_WRITE作为操作码，而LIO_NOP意味着空操作。</p><p>网页<a href="http://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html" target="_blank" rel="noopener noreferrer">http://www.gnu.org/software/libc/manual/html_node/Asynchronous-I_002fO.html</a> 包含了AIO库函数的详细信息。</p><h1>9.4.2　Linux内核AIO与libaio</h1><p>Linux AIO也可以由内核空间实现，异步I/O是Linux 2.6以后版本内核的一个标准特性。对于块设备而言，AIO可以一次性发出大量的read/write调用并且通过通用块层的I/O调度来获得更好的性能，用户程序也可以减少过多的同步负载，还可以在业务逻辑中更灵活地进行并发控制和负载均衡。相较于glibc的用户空间多线程同步等实现也减少了线程的负载和上下文切换等。对于网络设备而言，在socket层面上，也可以使用AIO，让CPU和网卡的收发动作充分交叠以改善吞吐性能。选择正确的I/O模型对系统性能的影响很大，有兴趣的读者可以参阅著名的C10K问题（指的是服务器同时支持成千上万个客户端的问题），详见网址<a href="http://www.kegel.com/c10k.html" target="_blank" rel="noopener noreferrer">http://www.kegel.com/c10k.html</a> 。</p><p>在用户空间中，我们一般要结合libaio来进行内核AIO的系统调用。内核AIO提供的系统调用主要包括：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int io_setup(int maxevents, io_context_t *ctxp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_destroy(io_context_t ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_submit(io_context_t ctx, long nr, struct iocb *ios[]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_cancel(io_context_t ctx, struct iocb *iocb, struct io_event *evt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int io_getevents(io_context_t ctx_id, long min_nr, long nr, struct io_event *events,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec *timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_set_callback(struct iocb *iocb, io_callback_t cb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_pwritev(struct iocb *iocb, int fd, const struct iovec *iov, int iovcnt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long long offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void io_prep_preadv(struct iocb *iocb, int fd, const struct iovec *iov, int iovcnt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long long offset);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>AIO的读写请求都用io_submit（）下发。下发前通过io_prep_pwrite（）和io_prep_pread（）生成iocb的结构体，作为io_submit（）的参数。这个结构体指定了读写类型、起始地址、长度和设备标志符等信息。读写请求下发之后，使用io_getevents（）函数等待I/O完成事件。io_set_callback（）则可设置一个AIO完成的回调函数。</p><p>代码清单9.15演示了一个简单的利用libaio向内核发起AIO请求的模版。该程序位于本书源代码的/kernel/drivers/globalfifo/ch9/aior.c下，使用命令gcc aior.c-o aior–laio编译，运行时带1个文本文件路径作为参数，该程序会打印该文本文件前4096个字节的内容。</p><p>代码清单9.15　使用libaio调用内核AIO的范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define _GNU_SOURCE     /* O_DIRECT is not POSIX */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;stdio.h&gt;      /* for perror() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;unistd.h&gt;     /* for syscall() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;fcntl.h&gt;      /* O_RDWR */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#include &lt;string.h&gt;     /* memset() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#include &lt;inttypes.h&gt;   /* uint64_t */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#include &lt;libaio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#define BUF_SIZE 4096</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13int main(int argc, char **argv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  io_context_t ctx = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  struct iocb cb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  struct iocb *cbs[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  unsigned char *buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  struct io_event events[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  int fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  if (argc &lt; 2) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       printf(&quot;the command format: aior [FILE]\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       exit(1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  fd = open(argv[1], O_RDWR | O_DIRECT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  if (fd &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       perror(&quot;open error&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31       goto err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34  /* Allocate aligned memory */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  ret = posix_memalign((void **)&amp;buf, 512, (BUF_SIZE + 1));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36  if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37       perror(&quot;posix_memalign failed&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38       goto err1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40  memset(buf, 0, BUF_SIZE + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42  ret = io_setup(128, &amp;ctx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43  if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44       printf(&quot;io_setup error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45       goto err2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48  /* setup I/O control block */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49  io_prep_pread(&amp;cb, fd, buf, BUF_SIZE, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51  cbs[0] = &amp;cb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52  ret = io_submit(ctx, 1, cbs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53  if (ret != 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54       if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55            printf(&quot;io_submit error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56       } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57            fprintf(stderr, &quot;could not sumbit IOs&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59       goto err3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62  /* get the reply */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63  ret = io_getevents(ctx, 1, 1, events, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64  if (ret != 1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65       if (ret &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66            printf(&quot;io_getevents error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67       } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68            fprintf(stderr, &quot;could not get Events&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70       goto err3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72  if (events[0].res2 == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73       printf(&quot;%s\n&quot;, buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75       printf(&quot;AIO error:%s&quot;, strerror(-events[0].res));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76       goto err3;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79  if ((ret = io_destroy(ctx)) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80       printf(&quot;io_destroy error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81       goto err2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84  free(buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85  close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">86  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">87</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">88 err3:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">89  if ((ret = io_destroy(ctx)) &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">90       printf(&quot;io_destroy error:%s&quot;, strerror(-ret));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">91 err2:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">92  free(buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">93 err1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">94  close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">95 err:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">96  return -1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">97}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>9.4.3　AIO与设备驱动</h1><p>用户空间调用io_submit（）后，对应于用户传递的每一个iocb结构，内核会生成一个与之对应的kiocb结构。file_operations包含3个与AIO相关的成员函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_read) (struct kiocb *iocb, const struct iovec *iov, unsigned long</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    nr_segs, loff_t pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_write) (struct kiocb *iocb, const struct iovec *iov, unsigned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    long nr_segs, loff_t pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int (*aio_fsync) (struct kiocb *iocb, int datasync);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>io_submit（）系统调用间接引起了file_operations中的aio_read（）和aio_write（）的调用。</p><p>在早期的Linux内核中，aio_read（）和aio_write（）的原型是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_read) (struct kiocb *iocb, char __user *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         size_t size, loff_t pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ssize_t (*aio_write) (struct kiocb *iocb, const char *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size_t count, loff_t offset);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这个老的原型里，只含有一个缓冲区指针，而在新的原型中，则可以传递一个向量iovec，它含有多段缓冲区。详见位于<a href="https://lwn.net/Articles/170954/" target="_blank" rel="noopener noreferrer">https://lwn.net/Articles/170954/</a> 的文档《Asynchronous I/O and vectored operations》。</p><p>AIO一般由内核空间的通用代码处理，对于块设备和网络设备而言，一般在Linux核心层的代码已经解决。字符设备驱动一般不需要实现AIO支持。Linux内核中对字符设备驱动实现AIO的特例包括drivers/char/mem.c里实现的null、zero等，由于zero这样的虚拟设备其实也不存在在要去读的时候读不到东西的情况，所以aio_read_zero（）本质上也不包含异步操作，不过从代码清单9.16我们可以一窥iovec的全貌。</p><p>代码清单9.16　zero设备的aio_read实现</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t aio_read_zero(struct kiocb *iocb, const struct iovec *iov,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                             unsigned long nr_segs, loff_t pos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        size_t written = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        unsigned long i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        ssize_t ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        for (i = 0; i &lt; nr_segs; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                ret = read_zero(iocb-&gt;ki_filp, iov[i].iov_base, iov[i].iov_len,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                                &amp;pos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                written += ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        return written   written : -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.669Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->14 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>这里的USB设备控制器（UDC）驱动指的是作为其他USB主机控制器外设的USB硬件设备上底层硬件控制器的驱动，该硬件和驱动负责将一个USB设备依附于一个USB主机控制器上。例如，当某运行Linux系统的手机作为PC的U盘时，手机中的底层USB控制器行使USB设备控制器的功能，这时候运行在底层的是UDC驱动，而手机要成为U盘，在UDC驱动之上仍然需要另外一个驱动，对于USB大容量存储器而言，这个驱动为File Storage驱动，称为Function驱动。从图16.1左边可以看出，USB设备驱动调用USB核心的API，因此具体驱动与SoC无关；同样，从图16.1右边可以看出，Function驱动调用通用的Gadget Function API，因此具体Function驱动也变得与SoC无关。软件分层设计的好处再一次得到了深刻的体现</p><p>UDC驱动和Function驱动都位于内核的drivers/usb/gadget目录中，如drivers/usb/gadget/udc下面的fsl_mxc_udc.c、omap_udc.c、s3c2410_udc.c等是对应SoC平台上的UDC驱动，而drivers/usb/gadget/function子目录的f_serial.c、f_mass_storage.c、f_rndis.c等文件实现了一些Gadget功能，重要的Function驱动如下所示。</p><p>Ethernet over USB：该驱动模拟以太网网口，它支持多种运行方式—CDC Ethernet（实现标准的Communications Device Class&quot;Ethernet Model&quot;协议）、CDC Subset以及RNDIS（微软公司对CDC Ethernet的变种实现）。</p><p>File-Backed Storage Gadget：最常见的U盘功能实现。</p><p>Serial Gadget：包括Generic Serial实现（只需要Bulk-in/Bulk-out端点+ep0）和CDC ACM规范实现。内核源代码中的Documentation/usb/gadget_serial.txt文档讲解了如何将Serial Gadget与Windows和Linux主机连接。</p><p>Gadget MIDI：暴露ALSA MIDI接口。</p><p>USB Video Class Gadget驱动：让Linux系统成为另外一个系统的USB视频采集源</p><p>另外，drivers/usb/gadget源代码还实现了一个Gadget文件系统（GadgetFS），可以将Gadget API接口暴露给应用层，以便在应用层实现用户空间的驱动。</p><p>在USB设备控制器驱动中，我们主要关心几个核心的数据结构，这些数据结构包括描述一个USB设备控制器的usb_gadget、UDC操作usb_gadget_ops、描述一个端点的usb_ep以及描述端点操作的usb_ep_ops结构体。UDC驱动围绕这些数据结构及其成员函数而展开，代码清单16.30列出了这些关键的数据结构，它们都定义于include/linux/usb/gadget.h文件。</p><p>代码清单16.30　UDC驱动的关键数据结构</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_gadget {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        struct work_struct              work;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /* readonly to gadget driver    */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        const struct usb_gadget_ops       *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        struct usb_ep                   *ep0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        struct list_head                ep_list;        /* of usb_ep */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        enum usb_device_speed            speed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        enum usb_device_speed            max_speed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        enum usb_device_state            state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        const char                      *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        struct device                   dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        unsigned                       out_epnum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        unsigned                       in_epnum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        unsigned                       sg_supported:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        unsigned                       is_otg:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        unsigned                       is_a_peripheral:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        unsigned                       b_hnp_enable:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        unsigned                       a_hnp_support:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        unsigned                       a_alt_hnp_support:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        unsigned                       quirk_ep_out_aligned_size:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        unsigned                       is_selfpowered:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25struct usb_ep {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        void                   *driver_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        const char              *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        const struct usb_ep_ops   *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        struct list_head        ep_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31        unsigned               maxpacket:16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        unsigned               maxpacket_limit:16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        unsigned               max_streams:16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34        unsigned               mult:2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35        unsigned               maxburst:5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36        u8                    address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        const struct usb_endpoint_descriptor    *desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38        const struct usb_ss_ep_comp_descriptor  *comp_desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41struct usb_gadget_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42        int    (*get_frame)(struct usb_gadget *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43        int    (*wakeup)(struct usb_gadget *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44        int    (*set_selfpowered) (struct usb_gadget *, int is_selfpowered);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45        int    (*vbus_session) (struct usb_gadget *, int is_active);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46        int    (*vbus_draw) (struct usb_gadget *, unsigned mA);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47        int    (*pullup) (struct usb_gadget *, int is_on);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48        int    (*ioctl)(struct usb_gadget *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49                            unsigned code, unsigned long param);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50        void   (*get_config_params)(struct usb_dcd_config_params *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51        int    (*udc_start)(struct usb_gadget *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52                     struct usb_gadget_driver *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53        int    (*udc_stop)(struct usb_gadget *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55struct usb_ep_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56        int (*enable) (struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57               const struct usb_endpoint_descriptor *desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58        int (*disable) (struct usb_ep *ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60        struct usb_request *(*alloc_request) (struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61               gfp_t gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62        void (*free_request) (struct usb_ep *ep, struct usb_request *req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64        int (*queue) (struct usb_ep *ep, struct usb_request *req,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65               gfp_t gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66        int (*dequeue) (struct usb_ep *ep, struct usb_request *req);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68        int (*set_halt) (struct usb_ep *ep, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69        int (*set_wedge) (struct usb_ep *ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71        int (*fifo_status) (struct usb_ep *ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72        void (*fifo_flush) (struct usb_ep *ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在具体的UDC驱动中，需要封装usb_gadget和每个端点usb_ep，实现usb_gadget的usb_gadget_ops并实现端点的usb_ep_ops，完成usb_request。这些事情都搞定后，就可以注册一个UDC，它是通过usb_add_gadget_udc（）API来进行的，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在注册UDC之前，我们需要先把usb_gadget这个结构体类的ep_list，即端点链表填充好，并填充好usb_gadget的usb_gadget_ops以及每个端点的usb_gadget_ops。</p><p>而Gadget的Function这边，则需要自己填充usb_interface_descriptor、usb_endpoint_descriptor，合成一些usb_descriptor_header，并实现usb_function结构体的成员函数，usb_function结构体定义于include/linux/usb/composite.h中，其形式如代码清单16.31所示。</p><p>代码清单16.31　usb_function结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_function {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   const char            *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   struct usb_gadget_strings  **strings;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   struct usb_descriptor_header   **fs_descriptors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   struct usb_descriptor_header   **hs_descriptors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   struct usb_descriptor_header   **ss_descriptors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   struct usb_configuration  *config;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   struct usb_os_desc_table  *os_desc_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   unsigned                  os_desc_n;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   /* configuration management:  bind/unbind */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   int          (*bind)(struct usb_configuration *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                    struct usb_function *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   void         (*unbind)(struct usb_configuration *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                    struct usb_function *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   void         (*free_func)(struct usb_function *f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   struct module    *mod;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   /* runtime state management */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22   int          (*set_alt)(struct usb_function *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                    unsigned interface, unsigned alt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   int          (*get_alt)(struct usb_function *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25                    unsigned interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   void         (*disable)(struct usb_function *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27   int          (*setup)(struct usb_function *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28                    const struct usb_ctrlrequest *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29   void         (*suspend)(struct usb_function *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30   void         (*resume)(struct usb_function *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32   /* USB 3.0 additions */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33   int          (*get_status)(struct usb_function *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34   int          (*func_suspend)(struct usb_function *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                        u8 suspend_opt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36   /* private: */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37   /* internals */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38   struct list_head     list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39   DECLARE_BITMAP(endpoints, 32);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40   const struct usb_function_instance *fi;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第4行的fs_descriptors是全速和低速的描述符表；第5行的hs_descriptors是高速描述符表；ss_descriptors是超高速描述符。bind（）完成在Gadget注册时获取I/O缓冲、端点等资源。</p><p>在usb_function的成员函数以及各种描述符准备好后，在内核通过usb_function_register（）API来完成Gadget Function的注册，该API的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_function_register(struct usb_function_driver *newf);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Gadget驱动中，用usb_request结构体来描述一次传输请求，这个结构体的地位类似于USB主机侧的URB。usb_request结构体的定义如代码清单16.32所示。</p><p>代码清单16.32　usb_request结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_request {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        void                   *buf; /* Buffer used for data */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        unsigned               length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        dma_addr_t             dma;  /* DMA address corresponding to &#x27;buf&#x27; */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        struct scatterlist       *sg; /* a scatterlist for SG-capable controllers */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        unsigned              num_sgs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        unsigned              num_mapped_sgs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        unsigned              stream_id:16;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        unsigned              no_interrupt:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        unsigned              zero:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        unsigned              short_not_ok:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        void                  (*complete)(struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16            struct usb_request *req);  /* Function called when request completes */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        void                  *context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        struct list_head        list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        int                   status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        unsigned               actual;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在include/linux/usb/gadget.h文件中，还封装了一些常用的API，以供Gadget Function驱动调用，从而便于它们操作端点，如下所示。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1使能和禁止端点">（1）使能和禁止端点<a class="hash-link" href="#1使能和禁止端点" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int usb_ep_enable(struct usb_ep *ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline int usb_ep_disable(struct usb_ep *ep);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它们分别调用了“ep-&gt;ops-&gt;enable（ep，desc）；”和“ep-&gt;ops-&gt;disable（ep）；”。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2分配和释放usb_request">（2）分配和释放usb_request<a class="hash-link" href="#2分配和释放usb_request" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_request *alloc_ep_req(struct usb_ep *ep, int len, int default_len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline struct usb_request *usb_ep_alloc_request(struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                       gfp_t gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void usb_ep_free_request(struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       struct usb_request *req);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_ep_alloc_request（）和usb_ep_free_request（）分别调用了“ep-&gt;ops-&gt;alloc_request（ep，gfp_flags）；”和“ep-&gt;ops-&gt;free_request（ep，req）；”，以用于分配和释放一个依附于某端点的usb_request，而alloc_ep_req（）则是内嵌了对usb_ep_alloc_request（ep，GFP_ATOMIC）的调用，同时自动申请了usb_request的缓冲器的内存。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3提交和取消usb_request">（3）提交和取消usb_request<a class="hash-link" href="#3提交和取消usb_request" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int usb_ep_queue(struct usb_ep *ep,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                               struct usb_request *req, gfp_t gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline int usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4端点fifo管理">（4）端点FIFO管理<a class="hash-link" href="#4端点fifo管理" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int usb_ep_fifo_status(struct usb_ep *ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void usb_ep_fifo_flush(struct usb_ep *ep);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前者调用“ep-&gt;ops-&gt;fifo_status（ep）”返回目前FIFO中的字节数，后者调用“ep-&gt;ops-&gt;fifo_flush（ep）”以冲刷掉FIFO中的数据。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5端点自动配置">（5）端点自动配置<a class="hash-link" href="#5端点自动配置" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_ep *usb_ep_autoconfig(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      struct usb_gadget               *gadget,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      struct usb_endpoint_descriptor  *desc);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>根据端点描述符及控制器端点情况，分配一个合适的端点。</p><h1>16.4.2　实例：Chipidea USB UDC驱动</h1><p>drivers/usb/chipidea/udc.c是Chipidea USB UDC驱动的主体代码，代码清单16.33列出了它的初始化流程部分。它定义了usb_ep_ops、usb_gadget_ops，在最终进行usb_add_gadget_udc（）之前填充好了UDC的端点列表。</p><p>代码清单16.33　Chipidea USB UDC驱动实例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct usb_ep_ops usb_ep_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2    .enable          = ep_enable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    .disable       = ep_disable,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    .alloc_request  = ep_alloc_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    .free_request  = ep_free_request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    .queue         = ep_queue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    .dequeue      = ep_dequeue,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    .set_halt     = ep_set_halt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    .set_wedge    = ep_set_wedge,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    .fifo_flush   = ep_fifo_flush,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13static const struct usb_gadget_ops usb_gadget_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    .vbus_session= ci_udc_vbus_session,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    .wakeup      = ci_udc_wakeup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    .set_selfpowered = ci_udc_selfpowered,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    .pullup      = ci_udc_pullup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    .vbus_draw   = ci_udc_vbus_draw,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    .udc_start   = ci_udc_start,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    .udc_stop    = ci_udc_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23static int init_eps(struct ci_hdrc *ci)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    int retval = 0, i, j;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27    for (i = 0; i &lt; ci-&gt;hw_ep_max/2; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        for (j = RX; j &lt;= TX; j++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29            int k = i + j * ci-&gt;hw_ep_max/2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30            struct ci_hw_ep *hwep = &amp;ci-&gt;ci_hw_ep[k];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34            hwep-&gt;ep.name      = hwep-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35            hwep-&gt;ep.ops       = &amp;usb_ep_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37            usb_ep_set_maxpacket_limit(&amp;hwep-&gt;ep, (unsigned short)~0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39            ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41            /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42             * set up shorthands for ep0 out and in endpoints,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43             * don&#x27;t add to gadget&#x27;s ep_list</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44             */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45            if (i == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46                if (j == RX)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47                ci-&gt;ep0out = hwep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48            else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49                ci-&gt;ep0in = hwep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51            usb_ep_set_maxpacket_limit(&amp;hwep-&gt;ep, CTRL_PAYLOAD_MAX);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52            continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55        list_add_tail(&amp;hwep-&gt;ep.ep_list, &amp;ci-&gt;gadget.ep_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58return retval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61static int udc_start(struct ci_hdrc *ci)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64    ci-&gt;gadget.ops    = &amp;usb_gadget_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65    ci-&gt;gadget.speed     = USB_SPEED_UNKNOWN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66    ci-&gt;gadget.max_speed  = USB_SPEED_HIGH;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67    ci-&gt;gadget.is_otg    = ci-&gt;is_otg   1 : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68    ci-&gt;gadget.name     = ci-&gt;platdata-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70    INIT_LIST_HEAD(&amp;ci-&gt;gadget.ep_list);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74    retval = init_eps(ci);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75    if (retval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76        goto free_pools;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78    ci-&gt;gadget.ep0 = &amp;ci-&gt;ep0in-&gt;ep;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80    retval = usb_add_gadget_udc(dev, &amp;ci-&gt;gadget);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>16.4.3　实例：Loopback Function驱动</h1><p>drivers/usb/gadget/function/f_loopback.c实现了一个最简单的Loopback驱动，它完成的主要工作如下。</p><p>1）实现usb_function实例及其中的成员函数bind（）、set_alt（）、disable（）、free_func（）等成员函数。</p><p>2）准备USB外设的配置描述符接口描述符usb_interface_descriptor、端点描述符usb_endpoint_descriptor等。</p><p>3）发起usb_request处理usb_request的完成并回环。</p><p>代码清单16.34是抽取了drivers/usb/gadget/function/f_loopback.c文件中能反映一个Function驱动主体结构的少量代码。</p><p>代码清单16.34　Loopback USB Gadget Function驱动实例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  1static struct usb_interface_descriptor loopback_intf = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2        .bLength =            sizeof loopback_intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  3        .bDescriptorType =     USB_DT_INTERFACE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5        .bNumEndpoints =       2,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  6        .bInterfaceClass =     USB_CLASS_VENDOR_SPEC,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  7        /* .iInterface = DYNAMIC */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 10static struct usb_endpoint_descriptor fs_loop_source_desc = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 11        .bLength =            USB_DT_ENDPOINT_SIZE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 12        .bDescriptorType =     USB_DT_ENDPOINT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 14        .bEndpointAddress =    USB_DIR_IN,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 15        .bmAttributes =       USB_ENDPOINT_XFER_BULK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 16};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 17static struct usb_descriptor_header *fs_loopback_descs[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 18        (struct usb_descriptor_header *) &amp;loopback_intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 19        (struct usb_descriptor_header *) &amp;fs_loop_sink_desc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 20        (struct usb_descriptor_header *) &amp;fs_loop_source_desc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 21        NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 22};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 23static struct usb_string strings_loopback[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 24        [0].s = &quot;loop input to output&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25        {  }                              /* end of list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 26};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 28static struct usb_gadget_strings stringtab_loop = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 29        .language      = 0x0409,          /* en-us */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 30        .strings       = strings_loopback,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 31};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 33static struct usb_gadget_strings *loopback_strings[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 34        &amp;stringtab_loop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 35        NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 36};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 38static int loopback_bind(struct usb_configuration *c, struct usb_function *f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 39{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 40...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 41loop-&gt;in_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_loop_source_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 42...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 43loop-&gt;out_ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;fs_loop_sink_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 44if (!loop-&gt;out_ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 45      goto autoconf_fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 46loop-&gt;out_ep-&gt;driver_data = cdev;/* claim */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 48/* support high speed hardware */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 49hs_loop_source_desc.bEndpointAddress =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 50      fs_loop_source_desc.bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 51hs_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 53/* support super speed hardware */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 54ss_loop_source_desc.bEndpointAddress =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 55      fs_loop_source_desc.bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 56ss_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 57</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 58ret = usb_assign_descriptors(f, fs_loopback_descs, hs_loopback_descs,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 59            ss_loopback_descs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 60...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 61return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 62}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 63</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 64static void lb_free_func(struct usb_function *f)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 65{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 66...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 67usb_free_all_descriptors(f);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 68kfree(func_to_loop(f));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 69}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 70</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 71static struct usb_function *loopback_alloc(struct usb_function_instance *fi)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 72{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 73       ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 74       loop-&gt;function.name = &quot;loopback&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 75       loop-&gt;function.bind = loopback_bind;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 76       loop-&gt;function.set_alt = loopback_set_alt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 77       loop-&gt;function.disable = loopback_disable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 78       loop-&gt;function.strings = loopback_strings;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 79</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 80       loop-&gt;function.free_func = lb_free_func;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 81</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 82       return &amp;loop-&gt;function;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 83}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 84</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 85static void loopback_complete(struct usb_ep *ep, struct usb_request *req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 86{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 87...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 88}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 89</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 90static int enable_endpoint(struct usb_composite_dev *cdev, struct f_loopback *loop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 91                          struct usb_ep *ep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 92{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 93struct usb_request           *req;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 94...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 95result = config_ep_by_speed(cdev-&gt;gadget, &amp;(loop-&gt;function), ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 96</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 97result = usb_ep_enable(ep);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 98</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 99ep-&gt;driver_data = loop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">101for (i = 0; i &lt; qlen &amp;&amp; result == 0; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">102      req = lb_alloc_ep_req(ep, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">103      if (!req)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">104          goto fail1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">105</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">106      req-&gt;complete = loopback_complete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">107      result = usb_ep_queue(ep, req, GFP_ATOMIC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">108      if (result) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">109          ERROR(cdev, &quot;%s queue req --&gt; %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">110                  ep-&gt;name, result);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">111          goto fail1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">112      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">113}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">114</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">115...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">116}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/6"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/8"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>