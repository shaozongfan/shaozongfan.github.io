<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/14"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/14"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/14" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/14" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.237Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在嵌入式系统中，由于目标机资源有限，因此往往在主机上先编译好程序，再在目标机上运行。用户所有的开发工作都在主机开发环境下完成，包括编码、编译、连接、下载和调试等。目标机和主机通过串口、以太网、仿真器或其他通信手段通信，主机用这些接口控制目标机，调试目标机上的程序。</p><p>调试嵌入式Linux内核的方法如下。</p><p>1）目标机“插桩”，如打上KGDB补丁，这样主机上的GDB可与目标机的KGDB通过串口或网口通信。</p><p>2）使用仿真器，仿真器可直接连接目标机的JTAG/BDM，这样主机的GDB就可以通过与仿真器的通信来控制目标机。</p><p>3）在目标板上通过printk（）、Oops、strace等软件方法进行“观察”调试，这些方法不具备查看和修改数据结构、断点、单步等功能。</p><p>21.4~21.7节将对这些调试方法进行一一讲解。</p><p>不管是目标机“插桩”还是使用仿真器连接目标机JTAG/SWD/BDM，在主机上，调试工具一般都采用GDB。</p><p>GDB可以直接把Linux内核当成一个整体来调试，这个过程实际上可以被QEMU模拟出来。进入本书配套Ubuntu的/home/baohua/develop/linux/extra目录下，修改run-nolcd.sh的脚本，将其从</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">   qemu-system-arm -nographic -sd vexpress.img -M vexpress-a9 -m 512M -kernel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">zImage -dtb vexpress-v2p-ca9.dtb  -smp 4 -append &quot;init=/linuxrc root=/dev/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mmcblk0p1 rw rootwait e  arlyprintk console=ttyAMA0&quot; 2&gt;/dev/null</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>改为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">   qemu-system-arm –s –S -nographic -sd vexpress.img -M vexpress-a9 -m 512M -kernel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">zImage -dtb vexpress-v2p-ca9.dtb  -smp 4 -append &quot;init=/linuxrc root=/dev/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mmcblk0p1 rw rootwait e  arlyprintk console=ttyAMA0&quot; 2&gt;/dev/null</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>即添加-s–S选项，则会使嵌入式ARM Linux系统等待GDB远程连入。在终端1运行新的./run-nolcd.sh，这样嵌入式ARM Linux的模拟平台在1234端口侦听。开一个新的终端2，进入/home/baohua/develop/linux/，执行如下代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">baohua@baohua-VirtualBox:~/develop/linux$ arm-linux-gnueabihf-gdb ./vmlinux</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">GNU gdb (crosstool-NG linaro-1.13.1-4.8-2013.05 - Linaro GCC 2013.05) 7.6-2013.05</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Copyright (C) 2013 Free Software Foundation, Inc.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This is free software: you are free to change and redistribute it.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">and &quot;show warranty&quot; for details.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">This GDB was configured as &quot;--host=i686-build_pc-linux-gnu --target=arm-linux-gnueabihf&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">For bug reporting instructions, please see:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;https://bugs.launchpad.net/gcc-linaro&gt;...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Reading symbols from /home/baohua/develop/linux/vmlinux...done.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接下来我们远程连接127.0.0.1：1234</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) target remote 127.0.0.1:1234</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Remote debugging using 127.0.0.1:1234</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0x60000000 in ?? ()</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>设置一个断点到start_kernel（）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) b start_kernel</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1 at 0x805fd8ac: file init/main.c, line 490.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>继续运行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Continuing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Breakpoint 1, start_kernel () at init/main.c:490</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">490  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>断点停在了内核启动过程中的start_kernel（）函数，这个时候我们按下Ctrl+X，A键，可以看到代码，如图21.4所示。</p><p>进一步，可以看看jiffies值之类的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p jiffies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$1 = 775612</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Continuing.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">^C</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Program received signal SIGINT, Interrupt.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cpu_v7_do_idle () at arch/arm/mm/proc-v7.S:74</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74       ret lr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb) p jiffies</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">$2 = 775687</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">(gdb)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1747576833697" src="/assets/images/1747576833697-f0a980e7039264228905a447b780d3c7.png" width="1486" height="729" class="img_ev3q"></p><p>图21.4　GDB调试内核</p><p>尽管采用“插桩”和仿真器结合GDB的方式可以查看和修改数据结构、断点、单步等，而printk（）这种最原始的方法却应用得更广泛。</p><p>printk（）这种方法很原始，但是一般可以解决工程中95%以上的问题。因此具体何时打印，以及打印什么东西，需要工程师逐步建立敏锐的嗅觉。加深对内核的认知，深入理解自己正在调试的模块，这才是快速解决问题的“王道”。工具只是一个辅助手段，无法代替工程师的思维。</p><p>工程师不能抱着得过且过的心态，也不能总是一知半解地进行低水平的重复建设。求知欲望对工程师技术水平的提升有着最关键的作用。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.233Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->8 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>有了设备树后，不再需要大量的板级信息，譬如过去经常在arch/arm/plat-xxx和arch/arm/mach-xxx中实施如下事情。</p><h1>1.注册platform_device，绑定resource，即内存、IRQ等板级信息</h1><p>通过设备树后，形如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct resource xxx_resources[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       [0] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .start  = …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .end    = …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .flags   = IORESOURCE_MEM,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       [1] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .start  = …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .end    = …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               .flags   = IORESOURCE_IRQ,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct platform_device xxx_device = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .name           = &quot;xxx&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .id             = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .dev            = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .platform_data          = &amp;xxx_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .resource       = xxx_resources,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .num_resources  = ARRAY_SIZE(xxx_resources),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之类的platform_device代码都不再需要，其中platform_device会由内核自动展开。而这些resource实际来源于.dts中设备节点的reg、interrupts属性。</p><p>典型的，大多数总线都与“simple_bus”兼容，而在与SoC对应的设备的.init_machine成员函数中，调用of_platform_bus_probe（NULL，xxx_of_bus_ids，NULL）；即可自动展开所有的platform_device。</p><h1>2.注册i2c_board_info，指定IRQ等板级信息</h1><p>形如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct i2c_board_info __initdata afeb9260_i2c_devices[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                I2C_BOARD_INFO(&quot;tlv320aic23&quot;, 0x1a),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                I2C_BOARD_INFO(&quot;fm3130&quot;, 0x68),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }, {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                I2C_BOARD_INFO(&quot;24c64&quot;, 0x50),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之类的i2c_board_info代码目前不再需要出现，现在只需要把tlv320aic23、fm3130、24c64这些设备节点填充作为相应的I2 C控制器节点的子节点即可，类似于前面的代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">        i2c@1,0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;acme,a1234-i2c-bus&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rtc@58 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;maxim,ds1338&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt;58&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interrupts = &lt; 7 3 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>设备树中的I2 C客户端会通过在I2 C host驱动的probe（）函数中调用的of_i2c_register_devices（&amp;i2c_dev-&gt;adapter）；被自动展开。</p><h1>3.注册spi_board_info，指定IRQ等板级信息</h1><p>形如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct spi_board_info afeb9260_spi_devices[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        {       /* DataFlash chip */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .modalias       = &quot;mtd_dataflash&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .chip_select    = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .max_speed_hz   = 15 * 1000 * 1000,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                .bus_num        = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之类的spi_board_info代码目前不再需要出现，与I2 C类似，现在只需要把mtd_dataflash之类的节点作为SPI控制器的子节点即可，SPI host驱动的probe（）函数通过spi_register_master（）注册主机的时候，会自动展开依附于它的从机，spear1310-evb.dts中的st，m25p80SPI接口的NOR Flash节点如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">spi0: spi@e0100000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">num-cs = &lt;3&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        m25p80@1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;st,m25p80&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>4.多个针对不同电路板的设备，以及相关的回调函数</h1><p>在过去，ARM Linux针对不同的电路板会建立由MACHINE_START和MACHINE_END包围的设备，引入设备树之后，MACHINE_START变更为DT_MACHINE_START，其中含有一个.dt_compat成员，用于表明相关的设备与.dts中根节点的兼容属性的兼容关系。</p><p>这样可以显著改善代码的结构并减少冗余的代码，在不支持设备树的情况下，光是一个S3C24xx就存在多个板文件，譬如mach-amlm5900.c、mach-gta02.c、mach-smdk2410.c、mach-qt2410.c、mach-rx3715.c等，其累计的代码量是相当大的，板级信息都用C语言来实现。而采用设备树后，我们可以对多个SoC和板子使用同一个DT_MACHINE和板文件，板子和板子之间的差异更多只是通过不同的.dts文件来体现。</p><h1>5.设备与驱动的匹配方式</h1><p>使用设备树后，驱动需要与在.dts中描述的设备节点进行匹配，从而使驱动的probe（）函数执行。新的驱动、设备的匹配变成了设备树节点的兼容属性和设备驱动中的OF匹配表的匹配。</p><h1>6.设备的平台数据属性化</h1><p>在Linux 2.6下，驱动习惯自定义platform_data，在arch/arm/mach-xxx注册platform_device、i2c_board_info、spi_board_info等的时候绑定platform_data，而后驱动通过标准API获取平台数据。譬如，在arch/arm/mach-at91/board-sam9263ek.c下用如下代码注册gpio_keys设备，它通过gpio_keys_platform_data结构体来定义platform_data。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct gpio_keys_button ek_buttons[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {    /* BP1, &quot;leftclic&quot; */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .code          = BTN_LEFT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .gpio          = AT91_PIN_PC5,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .active_low    = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .desc          = &quot;left_click&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .wakeup        = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   {    /* BP2, &quot;rightclic&quot; */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct gpio_keys_platform_data ek_button_data = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .buttons       = ek_buttons,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .nbuttons      = ARRAY_SIZE(ek_buttons),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct platform_device ek_button_device = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .name          = &quot;gpio-keys&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .id            = -1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .num_resources = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   .dev           = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           .platform_data= &amp;ek_button_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>设备驱动drivers/input/keyboard/gpio_keys.c则通过如下简单方法取得这个信息。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int gpio_keys_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct device *dev = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在转移到设备树后，platform_data便不再喜欢放在arch/arm/mach-xxx中了，它需要从设备树的属性中获取，比如一个电路板上有gpio_keys，则只需要在设备树中添加类似arch/arm/boot/dts/exynos4210-origen.dts中的如代码清单18.17所示的信息则可。</p><p>代码清单18.17　在设备树中添加GPIO按键信息</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1gpio_keys {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        compatible = &quot;gpio-keys&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        #size-cells = &lt;0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        up {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7               label = &quot;Up&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8               gpios = &lt;&amp;gpx2 0 1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               linux,code = &lt;KEY_UP&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10               gpio-key,wakeup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        down {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               label = &quot;Down&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15               gpios = &lt;&amp;gpx2 1 1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16               linux,code = &lt;KEY_DOWN&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17               gpio-key,wakeup;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而drivers/input/keyboard/gpio<em>keys.c则通过以of</em>开头的读属性的API来读取这些信息，并组织出gpio_keys_platform_data结构体，如代码清单18.18所示。</p><p>代码清单18.18　在GPIO按键驱动中获取.dts中的键描</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct gpio_keys_platform_data *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2gpio_keys_get_devtree_pdata(struct device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         struct device_node *node, *pp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         struct gpio_keys_platform_data *pdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         struct gpio_keys_button *button;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         int error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         int nbuttons;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         node = dev-&gt;of_node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         if (!node)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                 return ERR_PTR(-ENODEV);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         nbuttons = of_get_child_count(node);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16         if (nbuttons == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                 return ERR_PTR(-ENODEV);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         pdata = devm_kzalloc(dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                              sizeof(*pdata) + nbuttons * sizeof(*button),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                              GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22         if (!pdata)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                 return ERR_PTR(-ENOMEM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         pdata-&gt;buttons = (struct gpio_keys_button *)(pdata + 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         pdata-&gt;nbuttons = nbuttons;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28         pdata-&gt;rep = !!of_get_property(node, &quot;autorepeat&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30         i = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31         for_each_child_of_node(node, pp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32                 int gpio;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33                 enum of_gpio_flags flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                 if (!of_find_property(pp, &quot;gpios&quot;, NULL)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36                         pdata-&gt;nbuttons--;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37                         dev_warn(dev, &quot;Found button without gpios\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38                         continue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39                 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41                 gpio = of_get_gpio_flags(pp, 0, &amp;flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                 if (gpio &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                         error = gpio;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44                         if (error != -EPROBE_DEFER)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45                                 dev_err(dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46                                         &quot;Failed to get gpio flags, error: %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47                                         error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48                         return ERR_PTR(error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49                 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51                 button = &amp;pdata-&gt;buttons[i++];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53                 button-&gt;gpio = gpio;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54                 button-&gt;active_low = flags &amp; OF_GPIO_ACTIVE_LOW;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56                 if (of_property_read_u32(pp, &quot;linux,code&quot;, &amp;button-&gt;code)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57                         dev_err(dev, &quot;Button without keycode: 0x%x\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58                                 button-&gt;gpio);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59                         return ERR_PTR(-EINVAL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60                 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62                 button-&gt;desc = of_get_property(pp, &quot;label&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64                 if (of_property_read_u32(pp, &quot;linux,input-type&quot;, &amp;button-&gt;type))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65                         button-&gt;type = EV_KEY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67                 button-&gt;wakeup = !!of_get_property(pp, &quot;gpio-key,wakeup&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69                 if (of_property_read_u32(pp, &quot;debounce-interval&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70                                          &amp;button-&gt;debounce_interval))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71                         button-&gt;debounce_interval = 5;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74         if (pdata-&gt;nbuttons == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75                 return ERR_PTR(-EINVAL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77         return pdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码通过第31行的for_each_child_of_node（）遍历gpio_keys节点下的所有子节点，并通过of_get_gpio_flags（）、of_property_read_u32（）等API读取出来与各个子节点对应的GPIO、与每个GPIO对应的键盘键值等。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.221Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>网络设备接收数据的主要方法是由中断引发设备的中断处理函数，中断处理函数判断中断类型，如果为接收中断，则读取接收到的数据，分配sk_buffer数据结构和数据缓冲区，将接收到的数据复制到数据缓冲区，并调用netif_rx（）函数将sk_buffer传递给上层协议。代码清单14.9所示为完成这个过程的函数模板。</p><p>代码清单14.9　网络设备驱动的中断处理函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void xxx_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  switch (status &amp;ISQ_EVENT_MASK) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  case ISQ_RECEIVER_EVENT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      /* 获取数据包*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      xxx_rx(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      /* 其他类型的中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12static void xxx_rx(struct xxx_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  length = get_rev_len (...);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  /* 分配新的套接字缓冲区*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  skb = dev_alloc_skb(length + 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  skb_reserve(skb, 2); /* 对齐*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  skb-&gt;dev = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  /* 读取硬件上接收到的数据*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  insw(ioaddr + RX_FRAME_PORT, skb_put(skb, length), length &gt;&gt; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24  if (length &amp;1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    skb-&gt;data[length - 1] = inw(ioaddr + RX_FRAME_PORT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  /* 获取上层协议类型*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  skb-&gt;protocol = eth_type_trans(skb, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  /* 把数据包交给上层*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31  netif_rx(skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33  /* 记录接收时间戳*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34  dev-&gt;last_rx = jiffies;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上述代码的第4~7行可以看出，当设备的中断处理程序判断中断类型为数据包接收中断时，它调用第12~36行定义的xxx_rx（）函数完成更深入的数据包接收工作。xxx_rx（）函数代码中的第15行从硬件读取到接收数据包有效数据的长度，第16~19行分配sk_buff和数据缓冲区，第22~25行读取硬件上接收到的数据并放入数据缓冲区，第27~28行解析接收数据包上层协议的类型，最后，第30~31行代码将数据包上交给上层协议。</p><p>如果是NAPI兼容的设备驱动，则可以通过poll方式接收数据包。在这种情况下，我们需要为该设备驱动提供作为netif_napi_add（）参数的xxx_poll（）函数，如代码清单14.10所示。</p><p>代码清单14.10　网络设备驱动的xxx_poll（）函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_poll(struct napi_struct *napi, int budget)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  int npackets = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  struct sk_buff *skb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  struct xxx_priv *priv = container_of(napi, struct xxx_priv, napi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  struct xxx_packet *pkt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  while (npackets &lt; budget &amp;&amp; priv-&gt;rx_queue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    /* 从队列中取出数据包*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    pkt = xxx_dequeue_buf(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    /* 接下来的处理和中断触发的数据包接收一致*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13    skb = dev_alloc_skb(pkt-&gt;datalen + 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    skb_reserve(skb, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    memcpy(skb_put(skb, pkt-&gt;datalen), pkt-&gt;data, pkt-&gt;datalen);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    skb-&gt;dev = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    skb-&gt;protocol = eth_type_trans(skb, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    /* 调用netif_receive_skb，而不是net_rx, 将数据包交给上层协议*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    netif_receive_skb(skb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22    /* 更改统计数据*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    priv-&gt;stats.rx_packets++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24    priv-&gt;stats.rx_bytes += pkt-&gt;datalen;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    xxx_release_buffer(pkt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26    npackets++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  if (npackets &lt; budget) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29      napi_complete(napi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30      xxx_enable_rx_int (…); /* 再次启动网络设备的接收中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  return npackets;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中的budget是在初始化阶段分配给接口的weight值，xxx_poll（）函数每次只能接收最多budget个数据包。第8行的while（）循环读取设备的接收缓冲区，同时读取数据包并提交给上层。这个过程和中断触发的数据包接收过程一致，但是最后使用的是netif_receive_skb（）函数而不是netif_rx（）函数将数据包提交给上层。这里体现出了中断处理机制和轮询机制之间的差别。</p><p>当一个轮询过程结束时，第29行代码调用napi_complete（）宣布这一消息，而第30行代码则再次启动网络设备的接收中断。</p><p>虽然NAPI兼容的设备驱动以xxx_poll（）方式接收数据包，但是仍然需要首次数据包接收中断来触发这个过程。与数据包的中断接收方式不同的是，以轮询方式接收数据包时，当第一次中断发生后，中断处理程序要禁止设备的数据包接收中断并调度NAPI，如代码清单14.11所示。</p><p>代码清单14.11　网络设备驱动的poll中断处理</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void xxx_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  switch (status &amp;ISQ_EVENT_MASK) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  case ISQ_RECEIVER_EVENT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      … /* 获取数据包*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      xxx_disable_rx_int(...);  /* 禁止接收中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      napi_schedule(&amp;priv-&gt;napi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    … /* 其他类型的中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第7行的napi_schedule（）函数被轮询方式驱动的中断程序调用，将设备的poll方法添加到网络层的poll处理队列中，排队并且准备接收数据包，最终触发一个NET_RX_SOFTIRQ软中断，从而通知网络层接收数据包。图14.3所示为NAPI驱动程序各部分的调用关系。</p><p><img loading="lazy" alt="1744902006741" src="/assets/images/1744902006741-c5b83eecc6bb858c56dc51f801b8d813.png" width="978" height="427" class="img_ev3q"></p><p>图14.3　NAPI驱动程序各部分的调用关系</p><p>在支持NAPI的网络设备驱动中，通常还会进行如下与NAPI相关的工作。</p><p>1）在私有数据结构体（如xxx_priv）中增加一个成员：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct napi_struct napi;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在代码中就可以方便地使用container_of（）通过NAPI成员反向获得对应的xxx_priv指针。</p><p>2）通常会在设备驱动初始化时调用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">netif_napi_add(dev, napi, xxx_poll, XXX_NET_NAPI_WEIGHT);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3）通常会在net_device结构体的open（）和stop（）成员函数中分别调用napi_enable（）和napi_disable（）。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.213Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>DEBUG_LL对应内核的Kernel low-level debugging功能，EARLY_PRINTK则对应内核中一个早期的控制台。为了在内核的drivers/tty/serial下的控制台驱动初始化之前支持打印，可以选择DEBUG_LL和EARLY_PRINTK这两个配置选项。另外，也需要在bootargs中设置earlyprintk的选项。</p><p>对于LDDD3_vexpress而言，没有DEBUG_LL和EARLY_PRINTK的时候，我们看到的内核最早的打印是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Booting Linux on physical CPU 0x0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Initializing cgroup subsys cpuset</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Linux version …</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果我们使能DEBUG_LL和EARLY_PRINTK，选择如图21.5所示的“Use PL011UART0at 0x10009000（V2P-CA9core tile）”这个低级别调试口，并在bootargs中设置earlyprintk，则我们看到了更早的打印信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Uncompressing Linux... done, booting the kernel.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1747578131194" src="/assets/images/1747578131194-1b5e3d3e8ded233bc17010a3ddd1324d.png" width="1467" height="748" class="img_ev3q"></p><p>图21.5　选择低级别调试UART</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.197Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->42 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>整个设备树牵涉面比较广，即增加了新的用于描述设备硬件信息的文本格式，又增加了编译这个文本的工具，同时Bootloader也需要支持将编译后的设备树传递给Linux内核。</p><h1>18.2.1DTS、DTC和DTB等</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1dts">1.DTS<a class="hash-link" href="#1dts" title="标题的直接链接">​</a></h2><p>文件.dts是一种ASCII文本格式的设备树描述，此文本格式非常人性化，适合人类的阅读习惯。基本上，在ARM Linux中，一个.dts文件对应一个ARM的设备，一般放置在内核的arch/arm/boot/dts/目录中。值得注意的是，在arch/powerpc/boot/dts、arch/powerpc/boot/dts、arch/c6x/boot/dts、arch/openrisc/boot/dts等目录中，也存在大量的.dts文件，这证明DTS绝对不是ARM的专利。</p><p>由于一个SoC可能对应多个设备（一个SoC可以对应多个产品和电路板），这些.dts文件势必须包含许多共同的部分，Linux内核为了简化，把SoC公用的部分或者多个设备共同的部分一般提炼为.dtsi，类似于C语言的头文件。其他的设备对应的.dts就包括这个.dtsi。譬如，对于VEXPRESS而言，vexpress-v2m.dtsi就被vexpress-v2p-ca9.dts所引用，vexpress-v2p-ca9.dts有如下一行代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/include/ &quot;vexpress-v2m.dtsi&quot;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当然，和C语言的头文件类似，.dtsi也可以包括其他的.dtsi，譬如几乎所有的ARM SoC的.dtsi都引用了skeleton.dtsi。</p><p>文件.dts（或者其包括的.dtsi）的基本元素即为前文所述的节点和属性，代码清单18.1给出了一个设备树结构的模版。</p><p>代码清单18.1　设备树结构模版</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/ {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      node1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          a-string-property = &quot;A string&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          a-string-list-property = &quot;first string&quot;, &quot;second string&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5          a-byte-data-property = [0x01 0x23 0x34 0x56];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6          child-node1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7              first-child-property;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8              second-child-property = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9              a-string-property = &quot;Hello, world&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11          child-node2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      node2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15          an-empty-property;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16          a-cell-property = &lt;1 2 3 4&gt;; /* each number (cell) is a uint32 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17          child-node1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述.dts文件并没有什么真实的用途，但它基本表征了一个设备树源文件的结构：</p><p>1个root节点&quot;/&quot;；root节点下面含一系列子节点，本例中为node1和node2；节点node1下又含有一系列子节点，本例中为child-node1和child-node2；各节点都有一系列属性。这些属性可能为空，如an-empty-property；可能为字符串，如a-string-property；可能为字符串数组，如a-string-list-property；可能为Cells（由u32整数组成），如second-child-property；可能为二进制数，如a-byte-data-property。</p><p>下面以一个最简单的设备为例来看如何写一个.dts文件。如图18.1所示，假设此设备的配置如下：</p><p><img loading="lazy" alt="1745506107529" src="/assets/images/1745506107529-43f169d48871c14057abddf2bee720bb.png" width="1332" height="930" class="img_ev3q"></p><p>图18.1　设备树参考硬件结构图</p><p>1个双核ARM Cortex-A932位处理器；ARM本地总线上的内存映射区域分布有两个串口（分别位于0x101F1000和0x101F2000）、GPIO控制器（位于0x101F3000）、SPI控制器（位于0x10170000）、中断控制器（位于0x10140000）和一个外部总线桥；外部总线桥上又连接了SMC SMC91111以太网（位于0x10100000）、I2 C控制器（位于0x10160000）、64MB NOR Flash（位于0x30000000）；外部总线桥上连接的I2 C控制器所对应的I2 C总线上又连接了Maxim DS1338实时钟（I2 C地址为0x58）。</p><p>对于图18.1所示硬件结构图，如果用“.dts”描述，则其对应的“.dts”文件如代码清单18.2所示。</p><p>代码清单18.2　参考硬件的设备树文件</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/ {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      compatible = &quot;acme,coyotes-revenge&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      #size-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      interrupt-parent = &lt;&amp;intc&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      cpus {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8          #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9          #size-cells = &lt;0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          cpu@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11              compatible = &quot;arm,cortex-a9&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12              reg = &lt;0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14          cpu@1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15              compatible = &quot;arm,cortex-a9&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16              reg = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20      serial@101f0000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21          compatible = &quot;arm,pl011&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22          reg = &lt;0x101f0000 0x1000 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23          interrupts = &lt; 1 0 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26      serial@101f2000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27          compatible = &quot;arm,pl011&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28          reg = &lt;0x101f2000 0x1000 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29          interrupts = &lt; 2 0 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32      gpio@101f3000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33          compatible = &quot;arm,pl061&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34          reg = &lt;0x101f3000 0x1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                 0x101f4000 0x0010&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36          interrupts = &lt; 3 0 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39      intc: interrupt-controller@10140000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40          compatible = &quot;arm,pl190&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41          reg = &lt;0x10140000 0x1000 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42          interrupt-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43          #interrupt-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46      spi@10115000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47          compatible = &quot;arm,pl022&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48          reg = &lt;0x10115000 0x1000 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49          interrupts = &lt; 4 0 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52      external-bus {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53          #address-cells = &lt;2&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54          #size-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55          ranges = &lt;0 0  0x10100000  0x10000     // Chipselect 1, Ethernet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56                    1 0  0x10160000  0x10000        // Chipselect 2, i2c controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57                    2 0  0x30000000  0x1000000&gt;; // Chipselect 3, NOR Flash</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59          ethernet@0,0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60              compatible = &quot;smc,smc91c111&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61              reg = &lt;0 0 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62              interrupts = &lt; 5 2 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65          i2c@1,0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66              compatible = &quot;acme,a1234-i2c-bus&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67              #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68              #size-cells = &lt;0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69              reg = &lt;1 0 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70              interrupts = &lt; 6 2 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71              rtc@58 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72                  compatible = &quot;maxim,ds1338&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73                  reg = &lt;58&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74                  interrupts = &lt; 7 3 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75              };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78          flash@2,0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79              compatible = &quot;samsung,k8f1315ebm&quot;, &quot;cfi-flash&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80              reg = &lt;2 0 0x4000000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81          };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82      };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述.dts文件中，可以看出external-bus是根节点的子节点，而I2 C又是external-bus的子节点，RTC又进一步是I2 C的子节点。每一级节点都有一些属性信息，本章后续部分会进行详细解释。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2dtcdevice-tree-compiler">2.DTC（Device Tree Compiler）<a class="hash-link" href="#2dtcdevice-tree-compiler" title="标题的直接链接">​</a></h2><p>DTC是将.dts编译为.dtb的工具。DTC的源代码位于内核的scripts/dtc目录中，在Linux内核使能了设备树的情况下，编译内核的时候主机工具DTC会被编译出来，对应于scripts/dtc/Makefile中“hostprogs-y：=dtc”这一hostprogs的编译目标。</p><p>当然，DTC也可以在Ubuntu中单独安装，命令如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo apt-get install device-tree-compiler</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux内核的arch/arm/boot/dts/Makefile中，描述了当某种SoC被选中后，哪些.dtb文件会被编译出来，如与VEXPRESS对应的.dtb包括：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dtb-$(CONfiG_ARCH_VEXPRESS) += vexpress-v2p-ca5s.dtb \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vexpress-v2p-ca9.dtb \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vexpress-v2p-ca15-tc1.dtb \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vexpress-v2p-ca15_a7.dtb \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xenvm-4.2.dtb</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux下，我们可以单独编译设备树文件。当我们在Linux内核下运行make dtbs时，若我们之前选择了ARCH_VEXPRESS，上述.dtb都会由对应的.dts编译出来，因为arch/arm/Makefile中含有一个.dtbs编译目标项目。</p><p>DTC除了可以编译.dts文件以外，其实也可以“反汇编”.dtb文件为.dts文件，其指令格式为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./scripts/dtc/dtc -I dtb -O dts -o xxx.dts arch/arm/boot/dts/xxx.dtb</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3dtbdevice-tree-blob">3.DTB（Device Tree Blob）<a class="hash-link" href="#3dtbdevice-tree-blob" title="标题的直接链接">​</a></h2><p>文件.dtb是.dts被DTC编译后的二进制格式的设备树描述，可由Linux内核解析，当然U-Boot这样的bootloader也是可以识别.dtb的。</p><p>通常在我们为电路板制作NAND、SD启动映像时，会为.dtb文件单独留下一个很小的区域以存放之，之后bootloader在引导内核的过程中，会先读取该.dtb到内存。</p><p>Linux内核也支持一种变通的模式，可以不把.dtb文件单独存放，而是直接和zImage绑定在一起做成一个映像文件，类似cat zImage xxx.dtb&gt;zImage_with_dtb的效果。当然内核编译时候要使能CONFIG_ARM_APPENDED_DTB这个选项，以支持“Use appended device tree blob to zImage”（见Linux内核中的菜单）。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4绑定binding">4.绑定（Binding）<a class="hash-link" href="#4绑定binding" title="标题的直接链接">​</a></h2><p>对于设备树中的节点和属性具体是如何来描述设备的硬件细节的，一般需要文档来进行讲解，文档的后缀名一般为.txt。在这个.txt文件中，需要描述对应节点的兼容性、必需的属性和可选的属性。</p><p>这些文档位于内核的Documentation/devicetree/bindings目录下，其下又分为很多子目录。譬如，Documentation/devicetree/bindings/i2c/i2c-xiic.txt描述了Xilinx的I2 C控制器，其内容如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Xilinx IIC controller:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Required properties:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- compatible : Must be &quot;xlnx,xps-iic-2.00.a&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- reg : IIC register location and length</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- interrupts : IIC controller unterrupt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- #address-cells = &lt;1&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- #size-cells = &lt;0&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional properties:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- Child nodes conforming to i2c bus binding</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Example:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        axi_iic_0: i2c@40800000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;xlnx,xps-iic-2.00.a&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interrupts = &lt; 1 2 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt; 0x40800000 0x10000 &gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                #size-cells = &lt;0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>基本可以看出，设备树绑定文档的主要内容包括：</p><ul><li>·关于该模块最基本的描述。</li><li>·必需属性（Required Properties）的描述。</li><li>·可选属性（Optional Properties）的描述。</li><li>·一个实例。</li></ul><p>Linux内核下的scripts/checkpatch.pl会运行一个检查，如果有人在设备树中新添加了compatible字符串，而没有添加相应的文档进行解释，checkpatch程序会报出警告：UNDOCUMENTED_DT_STRINGDT compatible string xxx appears un-documented，因此程序员要养成及时写DT Binding文档的习惯。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5bootloader">5.Bootloader<a class="hash-link" href="#5bootloader" title="标题的直接链接">​</a></h2><p>Uboot设备从v1.1.3开始支持设备树，其对ARM的支持则是和ARM内核支持设备树同期完成。</p><p>为了使能设备树，需要在编译Uboot的时候在config文件中加入：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define CONfiG_OF_LIBFDT</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Uboot中，可以从NAND、SD或者TFTP等任意介质中将.dtb读入内存，假设.dtb放入的内存地址为0x71000000，之后可在Uboot中运行fdt addr命令设置.dtb的地址，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">UBoot&gt; fdt addr 0x71000000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>fdt的其他命令就变得可以使用，如fdt resize、fdt print等。</p><p>对于ARM来讲，可以通过bootz kernel_addr initrd_address dtb_address的命令来启动内核，即dtb_address作为bootz或者bootm的最后一次参数，第一个参数为内核映像的地址，第二个参数为initrd的地址，若不存在initrd，可以用“-”符号代替。</p><h1>18.2.2根节点兼容性</h1><p>上述.dts文件中，第2行根节点&quot;/&quot;的兼容属性compatible=&quot;acme，coyotes-revenge&quot;；定义了整个系统（设备级别）的名称，它的组织形式为：manufacturer，model。</p><p>Linux内核通过根节点&quot;/&quot;的兼容属性即可判断它启动的是什么设备。在真实项目中，这个顶层设备的兼容属性一般包括两个或者两个以上的兼容性字符串，首个兼容性字符串是板子级别的名字，后面一个兼容性是芯片级别（或者芯片系列级别）的名字。</p><p>譬如板子arch/arm/boot/dts/vexpress-v2p-ca9.dts兼容于arm，vexpress，v2p-ca9和“arm，vexpress”：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;arm,vexpress,v2p-ca9&quot;, &quot;arm,vexpress&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>板子arch/arm/boot/dts/vexpress-v2p-ca5s.dts的兼容性则为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;arm,vexpress,v2p-ca5s&quot;, &quot;arm,vexpress&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>板子arch/arm/boot/dts/vexpress-v2p-ca15_a7.dts的兼容性为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;arm,vexpress,v2p-ca15_a7&quot;, &quot;arm,vexpress&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>可以看出，上述各个电路板的共性是兼容于arm，vexpress，而特性是分别兼容于arm，vexpress，v2p-ca9、arm，vexpress，v2p-ca5s和arm，vexpress，v2p-ca15_a7。</p><p>进一步地看，arch/arm/boot/dts/exynos4210-origen.dts的兼容性字段如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;insignal,origen&quot;, &quot;samsung,exynos4210&quot;, &quot;samsung,exynos4&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第一个字符串是板子名字（很特定），第2个字符串是芯片名字（比较特定），第3个字段是芯片系列的名字（比较通用）。</p><p>作为类比，arch/arm/boot/dts/exynos4210-universal_c210.dts的兼容性字段则如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;samsung,universal_c210&quot;, &quot;samsung,exynos4210&quot;, &quot;samsung,exynos4&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由此可见，它与exynos4210-origen.dts的区别只在于第1个字符串（特定的板子名字）不一样，后面芯片名和芯片系列的名字都一样。</p><p>在Linux 2.6内核中，ARM Linux针对不同的电路板会建立由MACHINE_START和MACHINE_END包围起来的针对这个设备的一系列回调函数，如代码清单18.3所示。</p><p>代码清单18.3　ARM Linux 2.6时代的设备</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1MACHINE_START(VEXPRESS, &quot;ARM-Versatile Express&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2         .atag_offset    = 0x100,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         .smp            = smp_ops(vexpress_smp_ops),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         .map_io         = v2m_map_io,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         .init_early     = v2m_init_early,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         .init_irq       = v2m_init_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         .timer          = &amp;v2m_timer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         .handle_irq     = gic_handle_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         .init_machine   = v2m_init,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         .restart        = vexpress_restart,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11MACHINE_END</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这些不同的设备会有不同的MACHINE ID，Uboot在启动Linux内核时会将MACHINE ID存放在r1寄存器，Linux启动时会匹配Bootloader传递的MACHINE ID和MACHINE_START声明的MACHINE ID，然后执行相应设备的一系列初始化函数。</p><p>ARM Linux 3.x在引入设备树之后，MACHINE_START变更为DT_MACHINE_START，其中含有一个.dt_compat成员，用于表明相关的设备与.dts中根节点的兼容属性兼容关系。如果Bootloader传递给内核的设备树中根节点的兼容属性出现在某设备的.dt_compat表中，相关的设备就与对应的兼容匹配，从而引发这一设备的一系列初始化函数被执行。一个典型的DT_MACHINE如代码清单18.4所示。</p><p>代码清单18.4　ARM Linux 3.x时代的设备</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const char * const v2m_dt_match[] __initconst = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2         &quot;arm,vexpress&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         &quot;xen,xenvm&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6DT_MACHINE_START(VEXPRESS_DT, &quot;ARM-Versatile Express&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         .dt_compat      = v2m_dt_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         .smp            = smp_ops(vexpress_smp_ops),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         .map_io         = v2m_dt_map_io,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         .init_early     = v2m_dt_init_early,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         .init_irq       = v2m_dt_init_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         .timer          = &amp;v2m_dt_timer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         .init_machine   = v2m_dt_init,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         .handle_irq     = gic_handle_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         .restart        = vexpress_restart,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16MACHINE_END</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Linux倡导针对多个SoC、多个电路板的通用DT设备，即一个DT设备的.dt_compat包含多个电路板.dts文件的根节点兼容属性字符串。之后，如果这多个电路板的初始化序列不一样，可以通过int of_machine_is_compatible（const char*compat）API判断具体的电路板是什么。在Linux内核中，常常使用如下API来判断根节点的兼容性：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int of_machine_is_compatible(const char *compat);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此API判断目前运行的板子或者SoC的兼容性，它匹配的是设备树根节点下的兼容属性。例如drivers/cpufreq/exynos-cpufreq.c中就有判断运行的CPU类型是exynos4210、exynos4212、exynos4412还是exynos5250的代码，进而分别处理，如代码清单18.5所示。</p><p>代码清单18.5　of_machine_is_compatible（）的案例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 static int exynos_cpufreq_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         int ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         exynos_info = kzalloc(sizeof(*exynos_info), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         if (!exynos_info)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                 return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         exynos_info-&gt;dev = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         if (of_machine_is_compatible(&quot;samsung,exynos4210&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                 exynos_info-&gt;type = EXYNOS_SOC_4210;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                 ret = exynos4210_cpufreq_init(exynos_info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         } else if (of_machine_is_compatible(&quot;samsung,exynos4212&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                 exynos_info-&gt;type = EXYNOS_SOC_4212;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                 ret = exynos4x12_cpufreq_init(exynos_info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         } else if (of_machine_is_compatible(&quot;samsung,exynos4412&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                 exynos_info-&gt;type = EXYNOS_SOC_4412;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                 ret = exynos4x12_cpufreq_init(exynos_info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         } else if (of_machine_is_compatible(&quot;samsung,exynos5250&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                 exynos_info-&gt;type = EXYNOS_SOC_5250;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22                 ret = exynos5250_cpufreq_init(exynos_info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23         } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                 pr_err(&quot;%s: Unknown SoC type\n&quot;, __func__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25                 return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果一个兼容包含多个字符串，譬如对于前面介绍的根节点兼容compatible=&quot;samsung，universal_c210&quot;，&quot;samsung，exynos4210&quot;，&quot;samsung，exynos4&quot;的情况，如下3个表达式都是成立的。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">of_machine_is_compatible(&quot;samsung,universal_c210&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">of_machine_is_compatible(&quot;samsung,exynos4210&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">of_machine_is_compatible(&quot;samsung,exynos4&quot;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>18.2.3设备节点兼容性</h1><p>在.dts文件的每个设备节点中，都有一个兼容属性，兼容属性用于驱动和设备的绑定。兼容属性是一个字符串的列表，列表中的第一个字符串表征了节点代表的确切设备，形式为&quot;manufacturer，model&quot;，其后的字符串表征可兼容的其他设备。可以说前面的是特指，后面的则涵盖更广的范围。如在vexpress-v2m.dtsi中的Flash节点如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">flash@0,00000000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;arm,vexpress-flash&quot;, &quot;cfi-flash&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt;0 0x00000000 0x04000000&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;1 0x00000000 0x04000000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bank-width = &lt;4&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>兼容属性的第2个字符串&quot;cfi-flash&quot;明显比第1个字符串&quot;arm，vexpress-flash&quot;涵盖的范围更广。</p><p>再如，Freescale MPC8349SoC含一个串口设备，它实现了国家半导体（National Sem-iconductor）的NS16550寄存器接口。则MPC8349串口设备的兼容属性为compatible=&quot;fsl，mpc8349-uart&quot;，&quot;ns16550&quot;。其中，fsl，mpc8349-uart指代了确切的设备，ns16550代表该设备与NS16550UART保持了寄存器兼容。因此，设备节点的兼容性和根节点的兼容性是类似的，都是“从具体到抽象”。</p><p>使用设备树后，驱动需要与.dts中描述的设备节点进行匹配，从而使驱动的probe（）函数执行。对于platform_driver而言，需要添加一个OF匹配表，如前文的.dts文件的&quot;acme，a1234-i2c-bus&quot;兼容I2 C控制器节点的OF匹配表，具体代码清单18.6所示。</p><p>代码清单18.6　platform设备驱动中的of_match_table</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct of_device_id a1234_i2c_of_match[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2          { .compatible = &quot;acme,a1234-i2c-bus&quot;, },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          {},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5MODULE_DEVICE_TABLE(of, a1234_i2c_of_match);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7static struct platform_driver i2c_a1234_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8          .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                  .name = &quot;a1234-i2c-bus&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                  .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                  .of_match_table = a1234_i2c_of_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13          .probe = i2c_a1234_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14          .remove = i2c_a1234_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16module_platform_driver(i2c_a1234_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于I2 C和SPI从设备而言，同样也可以通过of_match_table添加匹配的.dts中的相关节点的兼容属性，如sound/soc/codecs/wm8753.c中的针对WolfsonWM8753的of_match_table，具体如代码清单18.7所示。</p><p>代码清单18.7　I2 C、SPI设备驱动中的of_match_table</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct of_device_id wm8753_of_match[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2          { .compatible = &quot;wlf,wm8753&quot;, },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          { }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5MODULE_DEVICE_TABLE(of, wm8753_of_match);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6static struct spi_driver wm8753_spi_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                  .name   = &quot;wm8753&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                  .owner  = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                  .of_match_table = wm8753_of_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          .probe          = wm8753_spi_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13          .remove         = wm8753_spi_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15static struct i2c_driver wm8753_i2c_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16          .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                  .name = &quot;wm8753&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                  .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                  .of_match_table = wm8753_of_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20          },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21          .probe =    wm8753_i2c_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22          .remove =   wm8753_i2c_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23          .id_table = wm8753_i2c_id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中的第2行显示WM8753的供应商是“wlf”，它其实是对应于Wolfson Microe-lectronics的前缀。详细的前缀可见于内核文档：Documentation/devicetree/bindings/vendor-prefixes.txt</p><p>对于I2 C、SPI还有一点需要提醒的是，I2 C和SPI外设驱动和设备树中设备节点的兼容属性还有一种弱式匹配方法，就是“别名”匹配。兼容属性的组织形式为manufacturer，model，别名其实就是去掉兼容属性中manufacturer前缀后的model部分。关于这一点，可查看drivers/spi/spi.c的源代码，函数spi_match_device（）暴露了更多的细节，如果别名出现在设备spi_driver的id_table里面，或者别名与spi_driver的name字段相同，SPI设备和驱动都可以匹配上，代码清单18.8显示了SPI的别名匹配。</p><p>代码清单18.8　SPI的别名匹配</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int spi_match_device(struct device *dev, struct device_driver *drv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          const struct spi_device *spi = to_spi_device(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          const struct spi_driver *sdrv = to_spi_driver(drv);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6          /* Attempt an OF style match */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          if (of_driver_match_device(dev, drv))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                  return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          /* Then try ACPI */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11           if (acpi_driver_match_device(dev, drv))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                   return 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14           if (sdrv-&gt;id_table)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                   return !!spi_match_id(sdrv-&gt;id_table, spi);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17           return strcmp(spi-&gt;modalias, drv-&gt;name) == 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19static const struct spi_device_id *spi_match_id(const struct spi_device_id *id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                                              const struct spi_device *sdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        while (id-&gt;name[0]) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23               if (!strcmp(sdev-&gt;modalias, id-&gt;name))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                       return id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25               id++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        return NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过这个别名匹配，实际上，SPI和I2 C的外设驱动即使没有of_match_table，还是可以和设备树中的节点匹配上的。</p><p>一个驱动可以在of_match_table中兼容多个设备，在Linux内核中常常使用如下API来判断具体的设备是什么：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int of_device_is_compatible(const struct device_node *device,const char *compat);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此函数用于判断设备节点的兼容属性是否包含compat指定的字符串。这个API多用于一个驱动支持两个以上设备的时候。</p><p>当一个驱动支持两个或多个设备的时候，这些不同.dts文件中设备的兼容属性都会写入驱动OF匹配表。因此驱动可以通过Bootloader传递给内核设备树中的真正节点的兼容属性以确定究竟是哪一种设备，从而根据不同的设备类型进行不同的处理。如arch/powerpc/platforms/83xx/usb.c中的mpc831x_usb_cfg（）就进行了类似处理：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (immr_node &amp;&amp; (of_device_is_compatible(immr_node, &quot;fsl,mpc8315-immr&quot;) ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                of_device_is_compatible(immr_node, &quot;fsl,mpc8308-immr&quot;)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clrsetbits_be32(immap + MPC83XX_SCCR_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        MPC8315_SCCR_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        MPC8315_SCCR_USB_DRCM_01);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clrsetbits_be32(immap + MPC83XX_SCCR_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        MPC83XX_SCCR_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        MPC83XX_SCCR_USB_DRCM_11);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* Configure pin mux for ULPI.  There is no pin mux for UTMI */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (prop &amp;&amp; !strcmp(prop, &quot;ulpi&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">if (of_device_is_compatible(immr_node, &quot;fsl,mpc8308-immr&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                clrsetbits_be32(immap + MPC83XX_SICRH_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC8308_SICRH_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC8308_SICRH_USB_ULPI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (of_device_is_compatible(immr_node, &quot;fsl,mpc8315-immr&quot;)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                clrsetbits_be32(immap + MPC83XX_SICRL_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC8315_SICRL_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC8315_SICRL_USB_ULPI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                clrsetbits_be32(immap + MPC83XX_SICRH_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC8315_SICRH_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC8315_SICRH_USB_ULPI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                clrsetbits_be32(immap + MPC83XX_SICRL_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC831X_SICRL_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC831X_SICRL_USB_ULPI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                clrsetbits_be32(immap + MPC83XX_SICRH_OFFS,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC831X_SICRH_USB_MASK,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                MPC831X_SICRH_USB_ULPI);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它根据具体的设备是fsl，mpc8315-immr和fsl，mpc8308-immr、中的哪一种来进行不同的处理。</p><p>当一个驱动可以兼容多种设备的时候，除了of_device_is_compatible（）这种判断方法以外，还可以采用在驱动的of_device_id表中填充.data成员的形式。譬如，arch/arm/mm/cache-l2x0.c支持“arm，l210-cache”“arm，pl310-cache”“arm，l220-cache”等多种设备，其of_device_id表如代码清单18.9所示。</p><p>代码清单18.9　支持多个兼容性以及.data成员的of_device_id表</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define L2C_ID(name, fns) { .compatible = name, .data = (void *)&amp;fns }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2static const struct of_device_id l2x0_ids[] __initconst = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          L2C_ID(&quot;arm,l210-cache&quot;, of_l2c210_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          L2C_ID(&quot;arm,l220-cache&quot;, of_l2c220_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5          L2C_ID(&quot;arm,pl310-cache&quot;, of_l2c310_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6          L2C_ID(&quot;brcm,bcm11351-a2-pl310-cache&quot;, of_bcm_l2x0_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          L2C_ID(&quot;marvell,aurora-outer-cache&quot;, of_aurora_with_outer_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8          L2C_ID(&quot;marvell,aurora-system-cache&quot;, of_aurora_no_outer_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9          L2C_ID(&quot;marvell,tauros3-cache&quot;, of_tauros3_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          /* Deprecated IDs */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11          L2C_ID(&quot;bcm,bcm11351-a2-pl310-cache&quot;, of_bcm_l2x0_data),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12          {}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在驱动中，通过如代码清单18.10的方法拿到了对应于L2缓存类型的.data成员，其中主要用到了of_match_node（）这个API。</p><p>代码清单18.10　通过of_match_node（）找到.data</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int __init l2x0_of_init(u32 aux_val, u32 aux_mask)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          const struct l2c_init_data *data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          struct device_node *np;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6          np = of_find_matching_node(NULL, l2x0_ids);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          if (!np)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                  return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9          …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10          data = of_match_node(l2x0_ids, np)-&gt;data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果电路板的.dts文件中L2缓存是arm，pl310-cache，那么上述代码第10行找到的data就是of_l2c310_data，它是l2c_init_data结构体的一个实例。l2c_init_data是一个由L2缓存驱动自定义的数据结构，在其定义中既可以保护数据成员，又可以包含函数指针，如代码清单18.11所示。</p><p>代码清单18.11　与兼容对应的特定data实例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct l2c_init_data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2          const char *type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          unsigned way_size_0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          unsigned num_lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5          void (*of_parse)(const struct device_node *, u32 *, u32 *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6          void (*enable)(void __iomem *, u32, unsigned);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7          void (*fixup)(void __iomem *, u32, struct outer_cache_fns *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8          void (*save)(void __iomem *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9          struct outer_cache_fns outer_cache;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过这种方法，驱动可以把与某个设备兼容的私有数据寻找出来，如此体现了一种面向对象的设计思想，避免了大量的if，else或者switch，case语句。</p><h1>18.2.4设备节点及label的命名</h1><p>代码清单18.2的.dts文件中，根节点“/”的cpus子节点下面又包含两个cpu子节点，描述了此设备上的两个CPU，并且两者的兼容属性为：&quot;arm，cortex-a9&quot;。注意cpus和cpus的两个cpu子节点的命名，它们遵循的组织形式为&lt; name&gt;<!-- -->[@&lt; unit-address&gt;]<!-- -->，&lt;   &gt;中的内容是必选项，<!-- -->[   ]<!-- -->中的则为可选项。name是一个ASCII字符串，用于描述节点对应的设备类型，如3com Ethernet适配器对应的节点name宜为ethernet，而不是3com509。如果一个节点描述的设备有地址，则应该给出@unit-address。多个相同类型设备节点的name可以一样，只要unit-address不同即可，如本例中含有cpu@0、cpu@1以及serial@101f0000与serial@101f2000这样的同名节点。设备的unit-address地址也经常在其对应节点的reg属性中给出。对于挂在内存空间的设备而言，@字符后跟的一般就是该设备在内存空间的基地址，譬如arch/arm/boot/dts/exynos4210.dtsi中存在的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sysram@02020000 {       </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;mmio-sram&quot;;     </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt;0x02020000 0x20000&gt;;      </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述节点的reg属性的开始位置与@后面的地址一样。</p><p>对于挂在I2 C总线上的外设而言，@后面一般跟的是从设备的I2 C地址，譬如arch/arm/boot/dts/exynos4210-trats.dts中的mms114-touchscreen：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">i2c@13890000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       mms114-touchscreen@48 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              compatible = &quot;melfas,mms114&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              reg = &lt;0x48&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述节点的reg属性标示的I2 C从地址与@后面的地址一样。</p><p>具体的节点命名规范可见ePAPR（embedded Power Architecture Platform Reference）标准，在<a href="https://www.power.org" target="_blank" rel="noopener noreferrer">https://www.power.org</a> 中可下载该标准。</p><p>我们还可以给一个设备节点添加label，之后可以通过&amp;label的形式访问这个label，这种引用是通过phandle（pointer handle）进行的。</p><p>例如，在arch/arm/boot/dts/omap5.dtsi中，第3组GPIO有gpio3这个label，如代码清单18.12所示。</p><p>代码清单18.12　在设备树中定义label</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1gpio3: gpio@48057000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2         compatible = &quot;ti,omap4-gpio&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         reg = &lt;0x48057000 0x200&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         interrupts = &lt;GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         ti,hwmods = &quot;gpio3&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         gpio-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         #gpio-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         interrupt-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         #interrupt-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而hsusb2_phy这个USB的PHY复位GPIO用的是这组GPIO中的一个，所以它通过phandle引用了“gpio3”，如代码清单18.13所示。</p><p>代码清单18.13　通过phandle引用其他节点</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* HS USB Host PHY on PORT 2 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2hsusb2_phy: hsusb2_phy {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          compatible = &quot;usb-nop-xceiv&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          reset-gpios = &lt;&amp;gpio3 12 GPIO_ACTIVE_LOW&gt;; /* gpio3_76 HUB_RESET */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单18.12第1行的gpio3是gpio@48057000节点的label，而代码清单18.13的hsusb2_phy则通过&amp;gpio3引用了这个节点，表明自己要使用这一组GPIO中的第12个GPIO。很显然，这种phandle引用其实表明硬件之间的一种关联性。</p><p>再举一例，在arch/arm/boot/dts/omap5.dtsi中，我们可以看到类似如下的label，从这些实例可以看出，label习惯以&lt;设备类型&gt;&lt; index&gt;进行命名：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">i2c1: i2c@48070000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i2c2: i2c@48072000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i2c3: i2c@48060000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}…</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>读者也许发现了一个奇怪的现象，就是代码清单18.13中居然引用了GPIO_ACTIVE_LOW这个类似C语言的宏。文件.dts的编译过程确实支持C的预处理，相应的.dts文件也包括了包含GPIO_ACTIVE_LOW这个宏定义的头文件：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;dt-bindings/gpio/gpio.h&gt;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于ARM而言，dt-bindings头文件位于内核的arch/arm/boot/dts/include/dt-bindings目录中。观察该目录的属性，它实际上是一个符号链接：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">baohua@baohua-VirtualBox:~/develop/linux/arch/arm/boot/dts/include$ ls -l dt-</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bindings</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lrwxrwxrwx 1 baohua baohua 34 11月</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 28 00:16 dt-bindings -&gt; ../../../../../</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    include/dt-bindings</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从内核的scripts/Makefile.lib这个文件可以看出，文件.dts的编译过程确实是支持C预处理的。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cmd_dtc = $(CPP) $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $&lt; ; \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        $(objtree)/scripts/dtc/dtc -O dtb -o $@ -b 0 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                -i $(dir $&lt;) $(DTC_FLAGS) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                -d $(depfile).dtc.tmp $(dtc-tmp) ; \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cat $(depfile).pre.tmp $(depfile).dtc.tmp &gt; $(depfile)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它是先做了$（CPP）$（dtc_cpp_flags）-x assembler-with-cpp-o$（dtc-tmp）$&lt;，再做的.dtc编译。</p><h1>18.2.5地址编码</h1><p>可寻址的设备使用如下信息在设备树中编码地址信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">reg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #address-cells</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    #size-cells</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中，reg的组织形式为reg=&lt;address1length1 <!-- -->[address2 length2][ address3 length3]<!-- -->...&gt;，其中的每一组address length表明了设备使用的一个地址范围。address为1个或多个32位的整型（即cell），而length的意义则意味着从address到address+length–1的地址范围都属于该节点。若#size-cells=0，则length字段为空。</p><p>address和length字段是可变长的，父节点的#address-cells和#size-cells分别决定了子节点reg属性的address和length字段的长度。</p><p>在代码清单18.2中，根节点的#address-cells=&lt;1&gt;；和#size-cells=&lt;1&gt;；决定了serial、gpio、spi等节点的address和length字段的长度分别为1。</p><p>cpus节点的#address-cells=&lt;1&gt;；和#size-cells=&lt;0&gt;；决定了两个cpu子节点的address为1，而length为空，于是形成了两个cpu的reg=&lt;0&gt;；和reg=&lt;1&gt;；。</p><p>external-bus节点的#address-cells=&lt;2&gt;和#size-cells=&lt;1&gt;；决定了其下的ethernet、i2c、flash的reg字段形如reg=&lt;0 0 0x1000&gt;；、reg=&lt;1 0 0x1000&gt;；和reg=&lt;2 0 0x4000000&gt;；。其中，address字段长度为2，开始的第一个cell（即“&lt;”后的0、1、2）是对应的片选，第2个cell（即&lt;0 0 0x1000&gt;、&lt;1 0 0x1000&gt;和&lt;2 00x1000000&gt;中间的0，0，0）是相对该片选的基地址，第3个cell（即“&gt;”前的0x1000、0x1000、0x1000000）为length。</p><p>特别要留意的是i2c节点中定义的#address-cells=&lt;1&gt;；和#size-cells=&lt;0&gt;；，其作用到了I2 C总线上连接的RTC，它的address字段为0x58，是RTC设备的I2 C地址。</p><p>根节点的直接子书点描述的是CPU的视图，因此根子节点的address区域就直接位于CPU的内存区域。但是，经过总线桥后的address往往需要经过转换才能对应CPU的内存映射。external-bus的ranges属性定义了经过external-bus桥后的地址范围如何映射到CPU的内存区域。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">ranges = &lt;0 0  0x10100000   0x10000     // Chipselect 1, Ethernet</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  1 0  0x10160000   0x10000     // Chipselect 2, i2c controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  2 0  0x30000000   0x1000000&gt;; // Chipselect 3, NOR Flash</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ranges是地址转换表，其中的每个项目是一个子地址、父地址以及在子地址空间的大小的映射。映射表中的子地址、父地址分别采用子地址空间的#address-cells和父地址空间的#address-cells大小。对于本例而言，子地址空间的#address-cells为2，父地址空间的#address-cells值为1，因此0 0 0x10100000 0x10000的前2个cell为external-bus桥后external-bus上片选0偏移0，第3个cell表示external-bus上片选0偏移0的地址空间被映射到CPU的本地总线的0x10100000位置，第4个cell表示映射的大小为0x10000。ranges后面两个项目的含义可以类推。</p><h1>18.2.6中断连接</h1><p>设备树中还可以包含中断连接信息，对于中断控制器而言，它提供如下属性：</p><p>interrupt-controller–这个属性为空，中断控制器应该加上此属性表明自己的身份；</p><p>#interrupt-cells–与#address-cells和#size-cells相似，它表明连接此中断控制器的设备的中断属性的cell大小。</p><p>在整个设备树中，与中断相关的属性还包括：</p><p>interrupt-parent–设备节点通过它来指定它所依附的中断控制器的phandle，当节点没有指定interrupt-parent时，则从父级节点继承。对于本例（代码清单18.2）而言，根节点指定了interrupt-parent=&lt;&amp;intc&gt;；，其对应于intc：interrupt-controller@10140000，而根节点的子节点并未指定interrupt-parent，因此它们都继承了intc，即位于0x10140000的中断控制器中。</p><p>interrupts–用到了中断的设备节点，通过它指定中断号、触发方法等，这个属性具体含有多少个cell，由它依附的中断控制器节点的#interrupt-cells属性决定。而每个cell具体又是什么含义，一般由驱动的实现决定，而且也会在设备树的绑定文档中说明。譬如，对于ARM GIC中断控制器而言，#interrupt-cells为3，3个cell的具体含义在Documentation/devicetree/bindings/arm/gic.txt中就有如下文字说明：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">The 1st cell is the interrupt type; 0 for SPI interrupts, 1 for PPI</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interrupts.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The 2nd cell contains the interrupt number for the interrupt type.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SPI interrupts are in the range [0-987].  PPI interrupts are in the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">range [0-15].</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">The 3rd cell is the flags, encoded as follows:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bits[3:0] trigger type and level flags.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              1 = low-to-high edge triggered</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              2 = high-to-low edge triggered</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              4 = active high level-sensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">              8 = active low level-sensitive</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bits[15:8] PPI interrupt cpu mask.  Each bit corresponds to each of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">the 8 possible cpus attached to the GIC.  A bit set to &#x27;1&#x27; indicated</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">the interrupt is wired to that CPU.  Only valid for PPI interrupts.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，值得注意的是，一个设备还可能用到多个中断号。对于ARM GIC而言，若某设备使用了SPI的168号、169号两个中断，而且都是高电平触发，则该设备节点的中断属性可定义为interrupts=&lt;01684&gt;，&lt;01694&gt;；。</p><p>对于平台设备而言，简单的通过如下API就可以指定想取哪一个中断，其中的参数num就是中断的index。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int platform_get_irq(struct platform_device *dev, unsigned int num);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当然在.dts文件中可以对中断进行命名，而后在驱动中通过platform_get_irq_byname（）来获取对应的中断号。譬如代码清单18.14演示了在drivers/dma/fsl-edma.c中通过platform_get_irq_byname（）获取IRQ，以及arch/arm/boot/dts/vf610.dtsi与fsl-edma驱动对应节点的中断描述。</p><p>代码清单18.14　设备树中的中断名称以及驱动获取中断</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2fsl_edma_irq_init(struct platform_device *pdev,struct fsl_edma_engine *fsl_edma)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4     fsl_edma-&gt;txirq = platform_get_irq_byname(pdev, &quot;edma-tx&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5     fsl_edma-&gt;errirq = platform_get_irq_byname(pdev, &quot;edma-err&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8edma0: dma-controller@40018000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9           #dma-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10           compatible = &quot;fsl,vf610-edma&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11           reg = &lt;0x40018000 0x2000&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                   &lt;0x40024000 0x1000&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                   &lt;0x40025000 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14           interrupts = &lt;0 8 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                           &lt;0 9 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16           interrupt-names = &quot;edma-tx&quot;, &quot;edma-err&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17           dma-channels = &lt;32&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18           clock-names = &quot;dmamux0&quot;, &quot;dmamux1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19           clocks = &lt;&amp;clks VF610_CLK_DMAMUX0&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                   &lt;&amp;clks VF610_CLK_DMAMUX1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第4行、第5行的platform_get_irq_byname（）的第2个参数与.dts中的interrupt-names是一致的。</p><h1>18.2.7GPIO、时钟、pinmux连接</h1><p>除了中断以外，在ARM Linux中时钟、GPIO、pinmux都可以通过.dts中的节点和属性进行描述。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1gpio">1.GPIO<a class="hash-link" href="#1gpio" title="标题的直接链接">​</a></h2><p>譬如，对于GPIO控制器而言，其对应的设备节点需声明gpio-controller属性，并设置#gpio-cells的大小。譬如，对于兼容性为fsl，imx28-pinctrl的pinctrl驱动而言，其GPIO控制器的设备节点类似于：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pinctrl@80018000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;fsl,imx28-pinctrl&quot;, &quot;simple-bus&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt;0x80018000 2000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gpio0: gpio@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compatible = &quot;fsl,imx28-gpio&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interrupts = &lt;127&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gpio-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                #gpio-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                interrupt-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                #interrupt-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gpio1: gpio@1 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            compatible = &quot;fsl,imx28-gpio&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            interrupts = &lt;126&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gpio-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                #gpio-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            interrupt-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                #interrupt-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中，#gpio-　cells为2，第1个cell为GPIO号，第2个为GPIO的极性。为0的时候是高电平有效，为1的时候则是低电平有效。</p><p>使用GPIO的设备则通过定义命名xxx-gpios属性来引用GPIO控制器的设备节点，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sdhci@c8000400 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cd-gpios = &lt;&amp;gpio01 0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    wp-gpios = &lt;&amp;gpio02 0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    power-gpios = &lt;&amp;gpio03 0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    bus-width = &lt;4&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而具体的设备驱动则通过类似如下的方法来获取GPIO：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cd_gpio = of_get_named_gpio(np, &quot;cd-gpios&quot;, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">wp_gpio = of_get_named_gpio(np, &quot;wp-gpios&quot;, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">power_gpio = of_get_named_gpio(np, &quot;power-gpios&quot;, 0);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>of_get_named_gpio（）这个API的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int of_get_named_gpio(struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const char *propname, int index);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在.dts和设备驱动不关心GPIO名字的情况下，也可以直接通过of_get_gpio（）获取GPIO，此函数原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline int of_get_gpio(struct device_node *np, int index);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如对于compatible=&quot;gpio-control-nand&quot;的基于GPIO的NAND控制器而言，在.dts中会定义多个gpio属性：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gpio-nand@1,0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compatible = &quot;gpio-control-nand&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg = &lt;1 0x0000 0x2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       #address-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       #size-cells = &lt;1&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">gpios = &lt;&amp;banka 1 0     /* rdy */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;banka 2 0     /* nce */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;banka 3 0     /* ale */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &amp;banka 4 0     /* cle */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                0              /* nwp */&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       partition@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在相应的驱动代码drivers/mtd/nand/gpio.c中是这样获取这些GPIO的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">plat-&gt;gpio_rdy = of_get_gpio(dev-&gt;of_node, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plat-&gt;gpio_nce = of_get_gpio(dev-&gt;of_node, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plat-&gt;gpio_ale = of_get_gpio(dev-&gt;of_node, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plat-&gt;gpio_cle = of_get_gpio(dev-&gt;of_node, 3);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plat-&gt;gpio_nwp = of_get_gpio(dev-&gt;of_node, 4);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2时钟">2.时钟<a class="hash-link" href="#2时钟" title="标题的直接链接">​</a></h2><p>时钟和GPIO也是类似的，时钟控制器的节点被使用时钟的模块引用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">clocks = &lt;&amp;clks 138&gt;, &lt;&amp;clks 140&gt;, &lt;&amp;clks 141&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">clock-names = &quot;uart&quot;, &quot;general&quot;, &quot;noc&quot;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而驱动中则使用上述的clock-names属性作为clk_get（）或devm_clk_get（）的第二个参数来申请时钟，譬如获取第2个时钟：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">devm_clk_get(&amp;pdev-&gt;dev, &quot;general&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>&lt;&amp;clks 138&gt;里的138这个index是与相应时钟驱动中clk的表的顺序对应的，很多开发者也认为这种数字出现在设备树中不太好，因此他们把clk的index作为宏定义到了arch/arm/boot/dts/include/dt-bindings/clock中。譬如include/dt-bindings/clock/imx6qdl-clock.h中存在这样的宏：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define IMX6QDL_CLK_STEP                        16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define IMX6QDL_CLK_PLL1_SW                     17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define IMX6QDL_CLK_ARM                         104</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而arch/arm/boot/dts/imx6q.dtsi则是这样引用它们的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">clocks = &lt;&amp;clks IMX6QDL_CLK_ARM&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;&amp;clks IMX6QDL_CLK_PLL2_PFD2_396M&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;&amp;clks IMX6QDL_CLK_STEP&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;&amp;clks IMX6QDL_CLK_PLL1_SW&gt;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&lt;&amp;clks IMX6QDL_CLK_PLL1_SYS&gt;;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3pinmux">3.pinmux<a class="hash-link" href="#3pinmux" title="标题的直接链接">​</a></h2><p>在设备树中，某个设备节点使用的pinmux的引脚群是通过phandle来指定的。譬如在arch/arm/boot/dts/atlas6.dtsi的pinctrl节点中包含所有引脚群的描述，如代码清单18.15所示。</p><p>代码清单18.15　设备树中pinctrl控制器的引脚群</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1gpio: pinctrl@b0120000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2         #gpio-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         #interrupt-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         compatible = &quot;sirf,atlas6-pinctrl&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         lcd_16pins_a: lcd0@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                lcd {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                       sirf,pins = &quot;lcd_16bitsgrp&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                       sirf,function = &quot;lcd_16bits&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         spi0_pins_a: spi0@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                spi {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                       sirf,pins = &quot;spi0grp&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                       sirf,function = &quot;spi0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         spi1_pins_a: spi1@0 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                spi {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22                       sirf,pins = &quot;spi1grp&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                       sirf,function = &quot;spi1&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而SPI0这个硬件实际上需要用到spi0_pins_a对应的spi0grp这一组引脚，因此在atlas6-evb.dts中通过pinctrl-0引用了它，如代码清单18.16所示。</p><p>代码清单18.16　给设备节点指定引脚群</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 spi@b00d0000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2          status = &quot;okay&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          pinctrl-names = &quot;default&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4          pinctrl-0 = &lt;&amp;spi0_pins_a&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5          …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>到目前为止，我们可以勾勒出一个设备树的全局视图，图18.2显示了设备树中的节点、属性、label以及phandle等信息。</p><p><img loading="lazy" alt="1745764867271" src="/assets/images/1745764867271-c05ed7de92003685a7267837503f2d9c.png" width="1234" height="1014" class="img_ev3q"></p><p>图18.2　设备树的全景视图</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.193Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>移植Linux到全新的SMP SoC上，需在底层提供定时器节拍、中断控制器、SMP启动、GPIO、时钟、pinctrl等功能，这些底层的功能被封装好后，其他设备驱动只能调用内核提供的通用API。这良好地体现了内核的分层设计，即驱动都调用与硬件无关的通用API，而这些API的底层实现则更多的是填充内核规整好的回调函数。</p><p>Linux内核社区针对pinctrl、时钟、GPIO、DMA提供独立的子系统，既给具体的设备驱动提供了统一的API，进一步提高了设备驱动的跨平台性，又为每个SoC和设备实现这些底层API定义好了条条框框，从而可以在最大程度上避免每个硬件实现过多的冗余代码。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.193Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux系统中，对于多核的ARM芯片而言，在Bootrom代码中，每个CPU都会识别自身ID，如果ID是0，则引导Bootloader和Linux内核执行，如果ID不是0，则Bootrom一般在上电时将自身置于WFI或者WFE状态，并等待CPU0给其发CPU核间中断或事件（一般通过SEV指令）以唤醒它。一个典型的多核Linux启动过程如图20.6所示。</p><p>被CPU0唤醒的CPUn可以在运行过程中进行热插拔，譬如运行如下命令即可卸载CPU1，并且将CPU1上的任务全部迁移到其他CPU中：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo 0 &gt; /sys/devices/system/cpu/cpu1/online</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>同理，运行如下命令可以再次启动CPU1：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo 1 &gt; /sys/devices/system/cpu/cpu1/online</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之后CPU1会主动参与系统中各个CPU之间要运行任务的负载均衡工作。</p><p><img loading="lazy" alt="1747234215141" src="/assets/images/1747234215141-2523e04756487f4848dc15e1a615288a.png" width="976" height="847" class="img_ev3q"></p><p>图20.6　一个典型的多核Linux启动过程</p><p>CPU0唤醒其他CPU的动作在内核中被封装为一个smp_operations的结构体，对于ARM而言，它定义于arch/arm/include/asm/smp.h中。该结构体的成员函数如代码清单20.8所示。</p><p>代码清单20.8　smp_operations结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct smp_operations {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#ifdef CONFIG_SMP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         * Setup the set of possible CPUs (via set_cpu_possible)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        void (*smp_init_cpus)(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         * Initialize cpu_possible map, and enable coherency</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        void (*smp_prepare_cpus)(unsigned int max_cpus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * Perform platform specific initialisation of the specified CPU.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        void (*smp_secondary_init)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         * Boot a secondary CPU, and assign it the specified idle task.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         * This also gives us the initial stack to use for this CPU.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        int  (*smp_boot_secondary)(unsigned int cpu, struct task_struct *idle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21#ifdef CONFIG_HOTPLUG_CPU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        int  (*cpu_kill)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        void (*cpu_die)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        int  (*cpu_disable)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们从arch/arm/mach-vexpress/v2m.c中看到VEXPRESS电路板用到的smp_ops（）为vexpress_smp_ops：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DT_MACHINE_START(VEXPRESS_DT, &quot;ARM-Versatile Express&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .dt_compat      = v2m_dt_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .smp            = smp_ops(vexpress_smp_ops),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map_io         = v2m_dt_map_io,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MACHINE_END</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过arch/arm/mach-vexpress/platsmp.c的实现代码可以看出，smp_operations的成员函数smp_init_cpus（），即vexpress_smp_init_cpus（）调用的ct_ca9x4_init_cpu_map（）会探测SoC内CPU核的个数，并通过set_cpu_possible（）设置这些CPU可见。</p><p>而smp_operations的成员函数smp_prepare_cpus（），即vexpress_smp_prepare_cpus（）则会通过v2m_flags_set（virt_to_phys（versatile_secondary_startup））设置其他CPU的启动地址为versatile_secondary_startup，如代码清单20.9所示。</p><p>代码清单20.9　在smp_prepare_cpus（）中设置CPU1...n的启动地址</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void __init vexpress_smp_prepare_cpus(unsigned int max_cpus)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         * Write the address of secondary startup into the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         * system-wide flags register. The boot monitor waits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         * until it receives a soft interrupt, and then the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         * secondary CPU branches to this address.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        v2m_flags_set(virt_to_phys(versatile_secondary_startup));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意这部分的具体实现方法是与SoC相关的，由芯片的设计以及芯片内部的Bootrom决定。对于VEXPRESS来讲，设置方法如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void __init v2m_flags_set(u32 data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writel(~0, v2m_sysreg_base + V2M_SYS_FLAGSCLR);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writel(data, v2m_sysreg_base + V2M_SYS_FLAGSSET);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>即填充v2m_sysreg_base+V2M_SYS_FLAGSCLR标记清除寄存器为0xFFFFFFFF，将CPU1...n初始启动执行的指令地址填入v2m_sysreg_base+V2M_SYS_FLAGSSET寄存器。这两个地址由芯片实现时内部的Bootrom程序设定的。填入CPU1...n的起始地址都通过virt_to_phys（）转化为物理地址，因为此时CPU1...n的MMU尚未开启。</p><p>比较关键的是smp_operations的成员函数smp_boot_secondary（），对于本例而言为versatile_boot_secondary（），它完成CPU的最终唤醒工作，如代码清单20.10所示。</p><p>代码清单20.10　CPU0通过中断唤醒其他CPU</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void write_pen_release(int val)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3pen_release = val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4smp_wmb();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5sync_cache_w(&amp;pen_release);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8int versatile_boot_secondary(unsigned int cpu, struct task_struct *idle)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10unsigned long timeout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 * This is really belt and braces; we hold unintended secondary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 * CPUs in the holding pen until we’re ready for them.  However,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 * since we haven’t sent them a soft interrupt, they shouldn’t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 * be there.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18write_pen_release(cpu_logical_map(cpu));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 * Send the secondary CPU a soft interrupt, thereby causing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 * the boot monitor to read the system wide flags register,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 * and branch to the address found there.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25arch_send_wakeup_ipi_mask(cpumask_of(cpu));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27timeout = jiffies + (1 * HZ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28while (time_before(jiffies, timeout)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        smp_rmb();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        if (pen_release == -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31               break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        udelay(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36return pen_release != -1   -ENOSYS : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第18行调用的write_pen_release（）会将pen_release变量设置为要唤醒的CPU核的CPU号cpu_logical_map（cpu），而后通过arch_send_wakeup_ipi_mask（）给要唤醒的CPU发IPI中断，这个时候，被唤醒的CPU会退出WFI状态并从前面smp_operations中的smp_prepare_cpus（）成员函数，即vexpress_smp_prepare_cpus（）里通过v2m_flags_set（）设置的起始地址versatile_secondary_startup开始执行，如果顺利的话，该CPU会将原先为正数的pen_release写为-1，以便CPU0从等待pen_release成为-1的循环（见第28~34行）中跳出。</p><p>versatile_secondary_startup实现于arch/arm/plat-versatile/headsmp.S中，是一段汇编，如代码清单20.11所示。</p><p>代码清单20.11　被唤醒CPU的执行入口</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1ENTRY(versatile_secondary_startup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        mrc     p15, 0, r0, c0, c0, 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        and     r0, r0, #15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        adr     r4, 1f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        ldmia   r4, {r5, r6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        sub     r4, r4, r5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        add     r6, r6, r4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8pen:    ldr     r7, [r6]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        cmp     r7, r0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        bne     pen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * we’ve been released from the holding pen: secondary_stack</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         * should now contain the SVC stack for this core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        b       secondary_startup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        .align</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">191:      .long   .</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        .long   pen_release</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21ENDPROC(versatile_secondary_startup)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第8~10行的循环是等待pen_release变量成为CPU0设置的cpu_logical_map（cpu），一般直接就成立了。第16行则调用内核通用的secondary_startup（）函数，经过一系列的初始化（如MMU等），最终新的被唤醒的CPU将调用smp_operations的smp_secondary_init（）成员函数，对于本例为versatile_secondary_init（），如代码清单20.12所示。</p><p>代码清单20.12　被唤醒的CPU恢复pen_release（）</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void versatile_secondary_init(unsigned int cpu)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         * let the primary processor know we’re out of the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         * pen, then head off into the C entry point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        write_pen_release(-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         * Synchronise with the boot thread.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        spin_lock(&amp;boot_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        spin_unlock(&amp;boot_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第7行会将pen_release写为-1，于是CPU0还在执行的代码清单20.10里versatile_boot_secondary（）函数中的如下循环就退出了：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">while (time_before(jiffies, timeout)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        smp_rmb();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pen_release == -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        udelay(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样CPU0就知道目标CPU已经被正确地唤醒，此后CPU0和新唤醒的其他CPU各自运行。整个系统在运行过程中会进行实时进程和正常进程的动态负载均衡。</p><p>图20.7总结性地描述了前文提到的vexpress_smp_prepare_cpus（）、versatile_boot_secondary（）、write_pen_release（）、versatile_secondary_startup（）、versatile_secondary_init（）这些函数的执行顺序。</p><p><img loading="lazy" alt="1747234563927" src="/assets/images/1747234563927-5b5bc24d7f64913424af01a246cbc8a6.png" width="1120" height="1026" class="img_ev3q"></p><p>图20.7　CPU0唤醒其他CPU过程</p><p>CPU热插拔的实现也是与芯片相关的，对于VEXPRESS而言，实现了smp_operations的cpu_die（）成员函数，即vexpress_cpu_die（）。它会在进行CPUn的拔除操作时将CPUn投入低功耗的WFI状态，相关代码位于arch/arm/mach-vexpress/hotplug.c中，如代码清单20.13所示。</p><p>代码清单20.13　smp_operations的cpu_die（）成员函数案例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void __ref vexpress_cpu_die(unsigned int cpu)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        int spurious = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         * we’re ready for shutdown now, so do it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        cpu_enter_lowpower();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        platform_do_lowpower(cpu, &amp;spurious);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         * bring this CPU back into the world of cache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * coherency, and then restore interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        cpu_leave_lowpower();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        if (spurious)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                pr_warn(&quot;CPU%u: %u spurious wakeup calls\n&quot;, cpu, spurious);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20static inline void platform_do_lowpower(unsigned int cpu, int *spurious)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23         * there is no power-control hardware on this platform, so all</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24         * we can do is put the core into WFI; this is safe as the calling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         * code will have already disabled interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28                wfi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30                if (pen_release == cpu_logical_map(cpu)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31                        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32                         * OK, proper wakeup, we&#x27;re done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33                         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38                 * Getting here, means that we have come out of WFI without</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39                 * having been woken up - this shouldn’t happen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40                 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41                 * Just note it happening - when we’re woken, we can report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                 * its occurrence.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44                (*spurious)++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>CPUn睡眠于wfi（），之后再次在线的时候，又会因为CPU0给它发出的IPI而从wfi（）函数返回继续执行，醒来时CPUn也判断“pen_release==cpu_logical_map（cpu）”是否成立，以确定该次醒来确实是由CPU0唤醒的一次正常醒来。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.181Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在用户程序中，select（）和poll（）也是与设备阻塞与非阻塞访问息息相关的论题。使用非阻塞I/O的应用程序通常会使用select（）和poll（）系统调用查询是否可对设备进行无阻塞的访问。select（）和poll（）系统调用最终会使设备驱动中的poll（）函数被执行，在Linux2.5.45内核中还引入了epoll（），即扩展的poll（）。</p><p>select（）和poll（）系统调用的本质一样，前者在BSD UNIX中引入，后者在System V中引入。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="822应用程序中的轮询编程">8.2.2　应用程序中的轮询编程<a class="hash-link" href="#822应用程序中的轮询编程" title="标题的直接链接">​</a></h2><p>应用程序中最广泛用到的是BSD UNIX中引入的select（）系统调用，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int select(int numfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timeval *timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中readfds、writefds、exceptfds分别是被select（）监视的读、写和异常处理的文件描述符集合，numfds的值是需要检查的号码最高的fd加1。readfds文件集中的任何一个文件变得可读，select（）返回；同理，writefds文件集中的任何一个文件变得可写，select也返回。</p><p>如图8.3所示，第一次对n个文件进行select（）的时候，若任何一个文件满足要求，select（）就直接返回；第2次再进行select（）的时候，没有文件满足读写要求，select（）的进程阻塞且睡眠。由于调用select（）的时候，每个驱动的poll（）接口都会被调用到，实际上执行select（）的进程被挂到了每个驱动的等待队列上，可以被任何一个驱动唤醒。如果FDn变得可读写，select（）返回。</p><p><img loading="lazy" alt="image-20250329105541292" src="/assets/images/image-20250329105541292-5e945dee46af6437ff8227e14a78ac2f.png" width="1297" height="571" class="img_ev3q"></p><p>图8.3　多路复用select（）</p><p>timeout参数是一个指向struct timeval类型的指针，它可以使select（）在等待timeout时间后若仍然没有文件描述符准备好则超时返回。struct timeval数据结构的定义如代码清单8.7所示。</p><p>代码清单8.7　timeval结构体定义</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct timeval  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   int tv_sec;     /* 秒*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   int tv_usec;    /* 微秒 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下列操作用来设置、清除、判断文件描述符集合：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">FD_ZERO(fd_set *set)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>清除一个文件描述符集合；</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">FD_SET(int fd,fd_set *set)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>将一个文件描述符加入文件描述符集合中；</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">FD_CLR(int fd,fd_set *set)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>将一个文件描述符从文件描述符集合中清除；</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">FD_ISSET(int fd,fd_set *set)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>判断文件描述符是否被置位。</p><p>poll（）的功能和实现原理与select（）相似，其函数原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int poll(struct pollfd *fds, nfds_t nfds, int timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当多路复用的文件数量庞大、I/O流量频繁的时候，一般不太适合使用select（）和poll（），此种情况下，select（）和poll（）的性能表现较差，我们宜使用epoll。epoll的最大好处是不会随着fd的数目增长而降低效率，select（）则会随着fd的数量增大性能下降明显。</p><p>与epoll相关的用户空间编程接口包括</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int epoll_create(int size);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>创建一个epoll的句柄，size用来告诉内核要监听多少个fd。需要注意的是，当创建好epoll句柄后，它本身也会占用一个fd值，所以在使用完epoll后，必须调用close（）关闭。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>告诉内核要监听什么类型的事件。</p><p>第1个参数是epoll_create（）的返回值，</p><p>第2个参数表示动作，包含：</p><ul><li>EPOLL_CTL_ADD：注册新的fd到epfd中。</li><li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件。</li><li>EPOLL_CTL_DEL：从epfd中删除一个fd。</li></ul><p>第3个参数是需要监听的fd，</p><p>第4个参数是告诉内核需要监听的事件类型，struct epoll_event结构如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct epoll_event {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  __uint32_t events;  /* Epoll events */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  epoll_data_t data;  /* User data variable */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>events可以是以下几个宏的“或”：</p><ul><li>EPOLLIN：表示对应的文件描述符可以读。</li><li>EPOLLOUT：表示对应的文件描述符可以写。</li><li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示的是有socket带外数据到来）。</li><li>EPOLLERR：表示对应的文件描述符发生错误。</li><li>EPOLLHUP：表示对应的文件描述符被挂断。</li><li>EPOLLET：将epoll设为边缘触发（Edge Triggered）模式，这是相对于水平触发（Level Triggered）来说的。LT（Level Triggered）是缺省的工作方式，在LT情况下，内核告诉用户一个fd是否就绪了，之后用户可以对这个就绪的fd进行I/O操作。但是如果用户不进行任何操作，该事件并不会丢失，而ET（Edge-Triggered）是高速工作方式，在这种模式下，当fd从未就绪变为就绪时，内核通过epoll告诉用户，然后它会假设用户知道fd已经就绪，并且不会再为那个fd发送更多的就绪通知。</li><li>EPOLLONESHOT：意味着一次性监听，当监听完这次事件之后，如果还需要继续监听这个fd的话，需要再次把这个fd加入到epoll队列里。</li></ul><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>等待事件的产生，其中events参数是输出参数，用来从内核得到事件的集合，maxevents告诉内核本次最多收多少事件，maxevents的值不能大于创建epoll_create（）时的size，参数timeout是超时时间（以毫秒为单位，0意味着立即返回，-1意味着永久等待）。该函数的返回值是需要处理的事件数目，如返回0，则表示已超时。</p><p>位于<a href="https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf" target="_blank" rel="noopener noreferrer">https://www.kernel.org/doc/ols/2004/ols2004v1-pages-215-226.pdf</a> 的文档《Comparing and Evaluating epoll，select，and poll Event Mechanisms》对比了select、epoll、poll之间的一些性能。一般来说，当涉及的fd数量较少的时候，使用select是合适的；如果涉及的fd很多，如在大规模并发的服务器中侦听许多socket的时候，则不太适合选用select，而适合选用epoll。</p><h1>8.2.3　设备驱动中的轮询编程</h1><p>设备驱动中poll（）函数的原型是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int(*poll)(struct file * filp, struct poll_table* wait);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第1个参数为file结构体指针，第2个参数为轮询表指针。这个函数应该进行两项工作。</p><p>1）对可能引起设备文件状态变化的等待队列调用poll_wait（）函数，将对应的等待队列头部添加到poll_table中。</p><p>2）返回表示是否能对设备进行无阻塞读、写访问的掩码。</p><p>用于向poll_table注册等待队列的关键poll_wait（）函数的原型如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void poll_wait(struct file *filp, wait_queue_heat_t *queue, poll_table * wait);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>poll_wait（）函数的名称非常容易让人产生误会，以为它和wait_event（）等一样，会阻塞地等待某事件的发生，其实这个函数并不会引起阻塞。poll_wait（）函数所做的工作是把当前进程添加到wait参数指定的等待列表（poll_table）中，实际作用是让唤醒参数queue对应的等待队列可以唤醒因select（）而睡眠的进程。</p><p>驱动程序poll（）函数应该返回设备资源的可获取状态，即POLLIN、POLLOUT、POLLPRI、POLLERR、POLLNVAL等宏的位“或”结果。每个宏的含义都表明设备的一种状态，如POLLIN（定义为0x0001）意味着设备可以无阻塞地读，POLLOUT（定义为0x0004）意味着设备可以无阻塞地写。</p><p>代码清单8.8　poll（）函数典型模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 static unsigned int xxx_poll(struct file *filp, poll_table *wait)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  unsigned int mask = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  struct xxx_dev *dev = filp-&gt;private_data;      /* 获得设备结构体指针*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  poll_wait(filp, &amp;dev-&gt;r_wait, wait);           /* 加入读等待队列 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  poll_wait(filp, &amp;dev-&gt;w_wait, wait);           /* 加入写等待队列*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  if (...)                                       /* 可读*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11      mask |= POLLIN | POLLRDNORM;               /* 标示数据可获得（对用户可读）*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  if (...)                                       /* 可写 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      mask |= POLLOUT | POLLWRNORM;              /* 标示数据可写入*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  return mask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.165Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核中提供了下列3个函数以分别进行纳秒、微秒和毫秒延迟：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void ndelay(unsigned long nsecs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void udelay(unsigned long usecs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void mdelay(unsigned long msecs);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述延迟的实现原理本质上是忙等待，它根据CPU频率进行一定次数的循环。有时候，人们在软件中进行下面的延迟：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void delay(unsigned int time)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    while(time--);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ndelay（）、udelay（）和mdelay（）函数的实现方式原理与此类似。内核在启动时，会运行一个延迟循环校准（Delay Loop Calibration），计算出lpj（Loops Per Jiffy），内核启动时会打印如下类似信息：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Calibrating delay loop... 530.84 BogoMIPS (lpj=1327104)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果我们直接在bootloader传递给内核的bootargs中设置lpj=1327104，则可以省掉这个校准的过程，节省约百毫秒级的开机时间。</p><p>毫秒时延（以及更大的秒时延）已经比较大了，在内核中，最好不要直接使用mdelay（）函数，这将耗费CPU资源，对于毫秒级以上的时延，内核提供了下述函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void msleep(unsigned int millisecs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long msleep_interruptible(unsigned int millisecs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void ssleep(unsigned int seconds);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数将使得调用它的进程睡眠参数指定的时间为millisecs，msleep（）、ssleep（）不能被打断，而msleep_interruptible（）则可以被打断。</p><p>受系统Hz以及进程调度的影响，msleep（）类似函数的精度是有限的。</p><h1>10.6.2　长延迟</h1><p>在内核中进行延迟的一个很直观的方法是比较当前的jiffies和目标jiffies（设置为当前jiffies加上时间间隔的jiffies），直到未来的jiffies达到目标jiffies。代码清单10.15给出了使用忙等待先延迟100个jiffies再延迟2s的实例。</p><p>代码清单10.15　忙等待时延实例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1/* 延迟100个jiffies */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2unsigned long delay = jiffies + 100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3while(time_before(jiffies, delay));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5/* 再延迟2s */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6unsigned long delay = jiffies + 2*Hz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7while(time_before(jiffies, delay));</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与time_before（）对应的还有一个time_after（），它们在内核中定义为（实际上只是将传入的未来时间jiffies和被调用时的jiffies进行一个简单的比较）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define time_after(a,b)        \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    (typecheck(unsigned long, a) &amp;&amp; \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typecheck(unsigned long, b) &amp;&amp; \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ((long)(b) - (long)(a) &lt; 0))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define time_before(a,b)    time_after(b,a)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了防止在time_before（）和time_after（）的比较过程中编译器对jiffies的优化，内核将其定义为volatile变量，这将保证每次都会重新读取这个变量。因此volatile更多的作用还是避免这种读合并。</p><h1>10.6.3　睡着延迟</h1><p>睡着延迟无疑是比忙等待更好的方式，睡着延迟是在等待的时间到来之前进程处于睡眠状态，CPU资源被其他进程使用。schedule_timeout（）可以使当前任务休眠至指定的jiffies之后再重新被调度执行，msleep（）和msleep_interruptible（）在本质上都是依靠包含了schedule_timeout（）的schedule_timeout_uninterruptible（）和schedule_timeout_interruptible（）来实现的，如代码清单10.16所示。</p><p>代码清单10.16　schedule_timeout（）的使用</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void msleep(unsigned int msecs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   unsigned long timeout = msecs_to_jiffies(msecs) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   while (timeout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      timeout = schedule_timeout_uninterruptible(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9unsigned long msleep_interruptible(unsigned int msecs)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   unsigned long timeout = msecs_to_jiffies(msecs) + 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   while (timeout &amp;&amp; !signal_pending(current))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      timeout = schedule_timeout_interruptible(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  return jiffies_to_msecs(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>实际上，schedule_timeout（）的实现原理是向系统添加一个定时器，在定时器处理函数中唤醒与参数对应的进程。</p><p>代码清单10.16中第6行和第14行分别调用schedule_timeout_uninterruptible（）和schedule_timeout_interruptible（），这两个函数的区别在于前者在调用schedule_timeout（）之前置进程状态为TASK_INTERRUPTIBLE，后者置进程状态为TASK_UNINTERRUPTIBLE，如代码清单10.17所示。</p><p>代码清单10.17　schedule_timeout_interruptible（）和schedule_timeout_interruptible（）</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1signed long __sched schedule_timeout_interruptible(signed long timeout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  __set_current_state(TASK_INTERRUPTIBLE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  return schedule_timeout(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7signed long __sched schedule_timeout_uninterruptible(signed long timeout)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  __set_current_state(TASK_UNINTERRUPTIBLE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  return schedule_timeout(timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，下面两个函数可以将当前进程添加到等待队列中，从而在等待队列上睡眠。当超时发生时，进程将被唤醒（后者可以在超时前被打断）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sleep_on_timeout(wait_queue_head_t *q, unsigned long timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">interruptible_sleep_on_timeout(wait_queue_head_t*q, unsigned long timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.153Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>进入Linux根目录（即“/”，Linux文件系统的入口，也是处于最高一级的目录），运行“ls–l”命令，看到Linux包含以下目录。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1bin">1./bin<a class="hash-link" href="#1bin" title="标题的直接链接">​</a></h2><p>包含基本命令，如ls、cp、mkdir等，这个目录中的文件都是可执行的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2sbin">2./sbin<a class="hash-link" href="#2sbin" title="标题的直接链接">​</a></h2><p>包含系统命令，如modprobe、hwclock、ifconfig等，大多是涉及系统管理的命令，这个目录中的文件都是可执行的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3dev">3./dev<a class="hash-link" href="#3dev" title="标题的直接链接">​</a></h2><p>设备文件存储目录，应用程序通过对这些文件的读写和控制以访问实际的设备。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4etc">4./etc<a class="hash-link" href="#4etc" title="标题的直接链接">​</a></h2><p>系统配置文件的所在地，一些服务器的配置文件也在这里，如用户账号及密码配置文件。busybox的启动脚本也存放在该目录。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5lib">5./lib<a class="hash-link" href="#5lib" title="标题的直接链接">​</a></h2><p>系统库文件存放目录等。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6mnt">6./mnt<a class="hash-link" href="#6mnt" title="标题的直接链接">​</a></h2><p>/mnt这个目录一般是用于存放挂载储存设备的挂载目录，比如含有cdrom等目录。可以参看/etc/fstab的定义。有时我们可以让系统开机自动挂载文件系统，并把挂载点放在这里。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="7opt">7./opt<a class="hash-link" href="#7opt" title="标题的直接链接">​</a></h2><p>opt是“可选”的意思，有些软件包会被安装在这里。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="8proc">8./proc<a class="hash-link" href="#8proc" title="标题的直接链接">​</a></h2><p>操作系统运行时，进程及内核信息（比如CPU、硬盘分区、内存信息等）存放在这里。/proc目录为伪文件系统proc的挂载目录，proc并不是真正的文件系统，它存在于内存之中。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="9tmp">9./tmp<a class="hash-link" href="#9tmp" title="标题的直接链接">​</a></h2><p>用户运行程序的时候，有时会产生临时文件，/tmp用来存放临时文件。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="10usr">10./usr<a class="hash-link" href="#10usr" title="标题的直接链接">​</a></h2><p>这个是系统存放程序的目录，比如用户命令、用户库等。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11var">11./var<a class="hash-link" href="#11var" title="标题的直接链接">​</a></h2><p>var表示的是变化的意思，这个目录的内容经常变动，如/var的/var/log目录被用来存放系统日志。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12sys">12./sys<a class="hash-link" href="#12sys" title="标题的直接链接">​</a></h2><p>Linux 2.6以后的内核所支持的sysfs文件系统被映射在此目录上。Linux设备驱动模型中的总线、驱动和设备都可以在sysfs文件系统中找到对应的节点。当内核检测到在系统中出现了新设备后，内核会在sysfs文件系统中为该新设备生成一项新的记录。</p><h1>5.2.2　Linux文件系统与设备驱动</h1><p>图5.1所示为Linux中虚拟文件系统、磁盘/Flash文件系统及一般的设备文件与设备驱动程序之间的关系。</p><p><img loading="lazy" alt="image-20250324223448543" src="/assets/images/image-20250324223448543-6dd506ffea49130c516b506b43432d59.png" width="1054" height="714" class="img_ev3q"></p><p>图5.1　文件系统与设备驱动之间的关系</p><p>应用程序和VFS之间的接口是系统调用，而VFS与文件系统以及设备文件之间的接口是file_operations结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数，关系如图5.2所示。</p><p><img loading="lazy" alt="1742826912565" src="/assets/images/1742826912565-306aca3aff012a9daae8f86620b00aa5.png" width="1255" height="609" class="img_ev3q"></p><p>图5.2　应用程序、VFS与设备驱动</p><p>在设备驱动程序的设计中，一般而言，会关心file和inode这两个结构体。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1file结构体">1.file结构体<a class="hash-link" href="#1file结构体" title="标题的直接链接">​</a></h2><p>file结构体代表一个打开的文件，系统中每个打开的文件在内核空间都有一个关联的struct file。它由内核在打开文件时创建，并传递给在文件上进行操作的任何函数。在文件的所有实例都关闭后，内核释放这个数据结构。在内核和驱动源代码中，struct file的指针通常被命名为file或filp（即file pointer）。代码清单5.3给出了文件结构体的定义。</p><p>代码清单5.3　文件结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct file {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct llist_node   fu_llist;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct rcu_head     fu_rcuhead;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } f_u;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct path     f_path;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct inode        *f_inode;   /* cached value */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const struct file_operations    *f_op;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Protects f_ep_links, f_flags.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Must not be taken from IRQ context.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spinlock_t      f_lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    enum rw_hint        f_write_hint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    atomic_long_t       f_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int        f_flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    fmode_t         f_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct mutex        f_pos_lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loff_t          f_pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct fown_struct  f_owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const struct cred   *f_cred;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct file_ra_state    f_ra;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u64         f_version;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_SECURITY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void            *f_security;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* needed for tty driver, and maybe others */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void            *private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_EPOLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Used by fs/eventpoll.c to link all the hooks to this file */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    f_ep_links;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    f_tfile_llink;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif /* #ifdef CONFIG_EPOLL */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct address_space    *f_mapping;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    errseq_t        f_wb_err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} __randomize_layout</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  __attribute__((aligned(4)));  /* lest something weird decides that 2 is OK */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>文件读/写模式mode、标志f_flags都是设备驱动关心的内容，而私有数据指针private_data在设备驱动中被广泛应用，大多被指向设备驱动自定义以用于描述设备的结构体。</p><p>下面的代码可用于判断以阻塞还是非阻塞方式打开设备文件：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (file-&gt;f_flags &amp; O_NONBLOCK)     /* 非阻塞*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pr_debug(&quot;open: non-blocking\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">else                                /* 阻塞*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pr_debug(&quot;open: blocking\n&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2inode结构体">2.inode结构体<a class="hash-link" href="#2inode结构体" title="标题的直接链接">​</a></h2><p>VFS inode包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是Linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁，inode结构体的定义如代码清单5.4所示</p><p>代码清单5.4　inode结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct inode {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    umode_t         i_mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned short      i_opflags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kuid_t          i_uid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    kgid_t          i_gid;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned int        i_flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_FS_POSIX_ACL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct posix_acl    *i_acl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct posix_acl    *i_default_acl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const struct inode_operations   *i_op;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct super_block  *i_sb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct address_space    *i_mapping;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_SECURITY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void            *i_security;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Stat data, not accessed from path walking */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long       i_ino;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Filesystems may only read i_nlink directly.  They shall use the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     * following functions for modification:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    (set|clear|inc|drop)_nlink</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     *    inode_(inc|dec)_link_count</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const unsigned int i_nlink;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int __i_nlink;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dev_t           i_rdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    loff_t          i_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec64   i_atime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec64   i_mtime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct timespec64   i_ctime;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    spinlock_t      i_lock; /* i_blocks, i_bytes, maybe i_size */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned short          i_bytes;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u8          i_blkbits;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u8          i_write_hint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    blkcnt_t        i_blocks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef __NEED_I_SIZE_ORDERED</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    seqcount_t      i_size_seqcount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* Misc */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long       i_state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct rw_semaphore i_rwsem;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long       dirtied_when;   /* jiffies of first dirtying */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long       dirtied_time_when;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct hlist_node   i_hash;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    i_io_list;  /* backing dev IO list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_CGROUP_WRITEBACK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct bdi_writeback    *i_wb;      /* the associated cgroup wb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* foreign inode detection, see wbc_detach_inode() */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int         i_wb_frn_winner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u16         i_wb_frn_avg_time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    u16         i_wb_frn_history;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    i_lru;      /* inode LRU list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    i_sb_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    i_wb_list;  /* backing dev writeback list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct hlist_head   i_dentry;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct rcu_head     i_rcu;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    atomic64_t      i_version;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    atomic_t        i_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    atomic_t        i_dio_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    atomic_t        i_writecount;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_IMA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    atomic_t        i_readcount; /* struct files open RO */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    const struct file_operations    *i_fop; /* former -&gt;i_op-&gt;default_file_ops */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct file_lock_context    *i_flctx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct address_space    i_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct list_head    i_devices;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct pipe_inode_info  *i_pipe;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct block_device *i_bdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct cdev     *i_cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char            *i_link;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned        i_dir_seq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __u32           i_generation;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_FSNOTIFY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __u32           i_fsnotify_mask; /* all events this inode cares about */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct fsnotify_mark_connector __rcu    *i_fsnotify_marks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#if IS_ENABLED(CONFIG_FS_ENCRYPTION)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct fscrypt_info *i_crypt_info;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    void            *i_private; /* fs or device private pointer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">} __randomize_layout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于表示设备文件的inode结构，i_rdev字段包含设备编号。Linux内核设备编号分为主设备编号和次设备编号，前者为dev_t的高12位，后者为dev_t的低20位。下列操作用于从一个inode中获得主设备号和次设备号：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int iminor(struct inode *inode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int imajor(struct inode *inode);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查看/proc/devices文件可以获知系统中注册的设备，第1列为主设备号，第2列为设备名，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Character devices:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   1 mem</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   2 pty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   3 ttyp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   4 /dev/vc/0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   4 tty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   5 /dev/tty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   5 /dev/console</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   5 /dev/ptmx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   7 vcs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  10 misc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  13 input</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  21 sg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  29 fb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 128 ptm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 136 pts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 171 ieee1394</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 180 usb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 189 usb_device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Block devices:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   1 ramdisk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   2 fd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   8 sd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   9 md</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  22 ide1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> ...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>查看/dev目录可以获知系统中包含的设备文件，日期的前两列给出了对应设备的主设备号和次设备号：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">crw-rw----    1 root     uucp       4,  64 Jan 30  2003 /dev/ttyS0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">brw-rw----    1 root     disk       8,   0 Jan 30  2003 /dev/sda</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>主设备号是与驱动对应的概念，同一类设备一般使用相同的主设备号，不同类的设备一般使用不同的主设备号（但是也不排除在同一主设备号下包含有一定差异的设备）。因为同一驱动可支持多个同类设备，因此用次设备号来描述使用该驱动的设备的序号，序号一般从0开始。</p><p>内核Documents目录下的devices.txt文件描述了Linux设备号的分配情况，它由LANANA（the Linux Assigned Names and Numbers authority，网址为<a href="http://www.lanana.org/" target="_blank" rel="noopener noreferrer">http://www.lanana.org/</a> ）组织维护，Torben Mathiasen（<a href="mailto:device@lanana.org" target="_blank" rel="noopener noreferrer">device@lanana.org</a>）是其中的主要维护者。</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/13"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/15"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>