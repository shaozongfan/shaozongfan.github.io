<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/13"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/13"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/13" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/13" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.313Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核模块加载函数一般以__exit标识声明，典型的模块卸载函数的形式如代码清单4.3所示。</p><p>代码清单4.3　内核模块卸载函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1 static void _ _exit cleanup_function(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3       /* 释放代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 module_exit(cleanup_function);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>模块卸载函数在模块卸载的时候执行，而不返回任何值，且必须以“module_exit（函数名）”的形式来指定。通常来说，模块卸载函数要完成与模块加载函数相反的功能。</p><p>我们用<strong>exit来修饰模块卸载函数，可以告诉内核如果相关的模块被直接编译进内核（即built-in），则cleanup_function（）函数会被省略，直接不链进最后的镜像。既然模块被内置了，就不可能卸载它了，卸载函数也就没有存在的必要了。除了函数以外，只是退出阶段采用的数据也可以用</strong>exitdata来形容。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.309Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>网络适配器硬件电路可以检测出链路上是否有载波，载波反映了网络的连接是否正常。网络设备驱动可以通过netif_carrier_on（）和netif_carrier_off（）函数改变设备的连接状态，如果驱动检测到连接状态发生变化，也应该以netif_carrier_on（）和netif_carrier_off（）函数显式地通知内核。</p><p>除了netif_carrier_on（）和netif_carrier_off（）函数以外，另一个函数netif_carrier_ok（）可用于向调用者返回链路上的载波信号是否存在。</p><p>这几个函数都接收一个net_device设备结构体指针作为参数，原型分别为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void netif_carrier_on(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void netif_carrier_off(struct net_device *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int netif_carrier_ok(struct net_device *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在网络设备驱动程序中可采取一定的手段来检测和报告链路状态，最常见的方法是采用中断，其次可以设置一个定时器来对链路状态进行周期性的检查。当定时器到期之后，在定时器处理函数中读取物理设备的相关寄存器以获得载波状态，从而更新设备的连接状态，如代码清单14.12所示。</p><p>代码清单14.12　网络设备驱动用定时器周期性检查链路状态</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void xxx_timer(unsigned long data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  struct net_device *dev = (struct net_device*)data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  u16link;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  if (!(dev-&gt;flags &amp;IFF_UP))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    goto set_timer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  /* 获得物理上的连接状态 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  if (link = xxx_chk_link(dev)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11    if (!(dev-&gt;flags &amp;IFF_RUNNING)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12      netif_carrier_on(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      dev-&gt;flags |= IFF_RUNNING;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      printk(KERN_DEBUG &quot;%s: link up\n&quot;, dev-&gt;name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    if (dev-&gt;flags &amp;IFF_RUNNING) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18      netif_carrier_off(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      dev-&gt;flags &amp;= ~IFF_RUNNING;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20      printk(KERN_DEBUG &quot;%s: link down\n&quot;, dev-&gt;name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24  set_timer:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  priv-&gt;timer.expires = jiffies + 1* Hz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  priv-&gt;timer.data = (unsigned long)dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  priv-&gt;timer.function = &amp;xxx_timer; /* timer handler */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  add_timer(&amp;priv-&gt;timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第10行调用xxx_chk_link（）函数来读取网络适配器硬件的相关寄存器，以获得链路连接状态，具体实现由硬件决定。当链路连接上时，第12行的netif_carrier_on（）函数显式地通知内核链路正常；反之，第18行的netif_carrier_off（）同样显式地通知内核链路失去连接。</p><p>此外，从上述源代码还可以看出，定时器处理函数会不停地利用第24~28行代码启动新的定时器以实现周期性检测的目的。那么最初启动定时器的地方在哪里呢？很显然，它最适合在设备的打开函数中完成，如代码清单14.13所示</p><p>代码清单14.13　在网络设备驱动的打开函数中初始化定时器</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_open(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  struct xxx_priv *priv = netdev_priv(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  priv-&gt;timer.expires = jiffies + 3* Hz;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  priv-&gt;timer.data = (unsigned long)dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  priv-&gt;timer.function = &amp;xxx_timer; /* 定时器处理函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  add_timer(&amp;priv-&gt;timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.309Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>原子操作可以保证对一个整型数据的修改是排他性的。Linux内核提供了一系列函数来实现内核中的原子操作，这些函数又分为两类，分别针对位和整型变量进行原子操作。位和整型变量的原子操作都依赖于底层CPU的原子操作，因此所有这些函数都与CPU架构密切相关。对于ARM处理器而言，底层使用LDREX和STREX指令，比如atomic_inc（）底层的实现会调用到atomic_add（），其代码如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline void atomic_add(int i, atomic_t *v)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       unsigned long tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       int result;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       prefetchw(&amp;v-&gt;counter);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       __asm__ __volatile__(&quot;@ atomic_add\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;1:    ldrex   %0, [%3]\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;      add     %0, %0, %4\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;      strex   %1, %0, [%3]\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;      teq     %1, #0\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&quot;      bne     1b&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       : &quot;=&amp;r&quot; (result), &quot;=&amp;r&quot; (tmp), &quot;+Qo&quot; (v-&gt;counter)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       : &quot;r&quot; (&amp;v-&gt;counter), &quot;Ir&quot; (i)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       : &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ldrex指令跟strex配对使用，可以让总线监控ldrex到strex之间有无其他的实体存取该地址，如果有并发的访问，执行strex指令时，第一个寄存器的值被设置为1（Non-Exclusive Access）并且存储的行为也不成功；如果没有并发的存取，strex在第一个寄存器里设置0（Exclusive Access）并且存储的行为也是成功的。本例中，如果两个并发实体同时调用ldrex+strex，如图7.6所示，在T3时间点上，CPU0的strex会执行失败，在T4时间点上CPU1的strex会执行成功。所以CPU0和CPU1之间只有CPU1执行成功了，执行strex失败的CPU0的“teq%1，#0”判断语句不会成立，于是失败的CPU0通过“bne 1b”再次进入ldrex。ldrex和strex的这一过程不仅适用于多核之间的并发，也适用于同一个核内部并发的情况。</p><p><img loading="lazy" alt="1743076329589" src="/assets/images/1743076329589-48666048295900afe0877b685ce8fdda.png" width="967" height="609" class="img_ev3q"></p><p>图7.6　ldrex和strex指令</p><h1>7.4.1　整型原子操作</h1><p>1.设置原子变量的值</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void atomic_set(atomic_t *v, int i);    /* 设置原子变量的值为i */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">atomic_t v = ATOMIC_INIT(0);            /* 定义原子变量v并初始化为0 */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.获取原子变量的值</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">atomic_read(atomic_t *v);        /* 返回原子变量的值*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3.原子变量加/减</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void atomic_add(int i, atomic_t *v);      /* 原子变量增加i */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void atomic_sub(int i, atomic_t *v);      /* 原子变量减少i */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4.原子变量自增/自减</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void atomic_inc(atomic_t *v);     /* 原子变量增加1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void atomic_dec(atomic_t *v);     /* 原子变量减少1 */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>5.操作并测试</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_inc_and_test(atomic_t *v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_dec_and_test(atomic_t *v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_sub_and_test(int i, atomic_t *v);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述操作对原子变量执行自增、自减和减操作后（注意没有加），测试其是否为0，为0返回true，否则返回false。</p><p>6.操作并返回</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_add_return(int i, atomic_t *v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_sub_return(int i, atomic_t *v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_inc_return(atomic_t *v);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int atomic_dec_return(atomic_t *v);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述操作对原子变量进行加/减和自增/自减操作，并返回新的值。</p><h1>7.4.2　位原子操作</h1><p>1.设置位</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void set_bit(nr, void *addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述操作设置addr地址的第nr位，所谓设置位即是将位写为1。</p><p>2.清除位</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void clear_bit(nr, void *addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述操作清除addr地址的第nr位，所谓清除位即是将位写为0。</p><p>3.改变位</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void change_bit(nr, void *addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述操作对addr地址的第nr位进行反置。</p><p>4.测试位</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">test_bit(nr, void *addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述操作返回addr地址的第nr位。</p><p>5.测试并操作位</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int test_and_set_bit(nr, void *addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int test_and_clear_bit(nr, void *addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int test_and_change_bit(nr, void *addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述test_and_xxx_bit（nr，void<em>addr）操作等同于执行test_bit（nr，void</em>addr）后再执行xxx_bit（nr，void*addr）。</p><p>代码清单7.2给出了原子变量的使用例子，它使得设备最多只能被一个进程打开。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static atomic_t xxx_available = ATOMIC_INIT(1); /* 定义原子变量*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3static int xxx_open(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  if (!atomic_dec_and_test(&amp;xxx_available))  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      atomic_inc(&amp;xxx_available);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      return  - EBUSY;                /* 已经打开*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  return 0;                           /* 成功 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14static int xxx_release(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  atomic_inc(&amp;xxx_available);         /* 释放设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.305Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->14 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux内核中，各个设备驱动可以简单地调用request_irq（）、enable_irq（）、disable_irq（）、local_irq_disable（）、local_irq_enable（）等通用API来完成中断申请、使能、禁止等功能。在将Linux移植到新的SoC时，芯片供应商需要提供该部分API的底层支持。</p><p>local_irq_disable（）、local_irq_enable（）的实现与具体中断控制器无关，对于ARM v6以上的体系结构而言，是直接调用CPSID/CPSIE指令进行，而对于ARM v6以前的体系结构，则是通过MRS、MSR指令来读取和设置ARM的CPSR寄存器。由此可见，local_irq_disable（）、local_irq_enable（）针对的并不是外部的中断控制器，而是直接让CPU本身不响应中断请求。相关的实现位于arch/arm/include/asm/irqflags.h中，如代码清单20.3所示。</p><p>代码清单20.3　ARM Linux local_irq_disable（）/enable（）底层实现</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#if __LINUX_ARM_ARCH__ &gt;= 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3static inline unsigned long arch_local_irq_save(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        unsigned long flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                &quot;       mrs     %0, cpsr        @ arch_local_irq_save\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                &quot;       cpsid   i&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                : &quot;=r&quot; (flags) : : &quot;memory&quot;, &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        return flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14static inline void arch_local_irq_enable(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                &quot;       cpsie i                 @ arch_local_irq_enable&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20                : &quot;memory&quot;, &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23static inline void arch_local_irq_disable(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26                &quot;       cpsid i                 @ arch_local_irq_disable&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29                : &quot;memory&quot;, &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 * Save the current interrupt enable state &amp; disable IRQs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36static inline unsigned long arch_local_irq_save(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38        unsigned long flags, temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40        asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41                &quot;       mrs     %0, cpsr        @ arch_local_irq_save\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                &quot;       orr     %1, %0, #128\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                &quot;       msr     cpsr_c, %1&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44                : &quot;=r&quot; (flags), &quot;=r&quot; (temp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46                : &quot;memory&quot;, &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47        return flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51 * Enable IRQs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53static inline void arch_local_irq_enable(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55        unsigned long temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56        asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57                &quot;       mrs     %0, cpsr        @ arch_local_irq_enable\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58                &quot;       bic     %0, %0, #128\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59                &quot;       msr     cpsr_c, %0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60                : &quot;=r&quot; (temp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62                : &quot;memory&quot;, &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 * Disable IRQs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68static inline void arch_local_irq_disable(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70        unsigned long temp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71        asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72                &quot;       mrs     %0, cpsr        @ arch_local_irq_disable\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73                &quot;       orr     %0, %0, #128\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74                &quot;       msr     cpsr_c, %0&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75                : &quot;=r&quot; (temp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76                :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77                : &quot;memory&quot;, &quot;cc&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79 #endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与local_irq_disable（）和local_irq_enable（）不同，disable_irq（）、enable_irq（）针对的则是中断控制器，因此它们适用的对象是某个中断。disable_irq（）的字面意思是暂时屏蔽掉某中断（其实在内核的实现层面上做了延后屏蔽），直到enable_irq（）后再执行ISR。实际上，屏蔽中断可以发生在外设、中断控制器、CPU三个位置，如图20.3所示。对于外设端，是从源头上就不产生中断信号给中断控制器，由于它高度依赖于外设于本身，所以Linux不提供标准的API而是由外设的驱动直接读写自身的寄存器。</p><p><img loading="lazy" alt="1747233426546" src="/assets/images/1747233426546-efb776a119a9ebd95377d9432140f43d.png" width="1227" height="607" class="img_ev3q"></p><p>图20.3　屏蔽中断的3个不同位置</p><p>在内核中，通过irq_chip结构体来描述中断控制器。该结构体内部封装了中断mask、unmask、ack等成员函数，其定义于include/linux/irq.h中，如代码清单20.4所示。</p><p>代码清单20.4　irq_chip结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct irq_chip {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        const char      *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        unsigned int    (*irq_startup)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        void            (*irq_shutdown)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        void            (*irq_enable)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        void            (*irq_disable)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        void            (*irq_ack)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        void            (*irq_mask)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        void            (*irq_mask_ack)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        void            (*irq_unmask)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        void            (*irq_eoi)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        int             (*irq_set_affinity)(struct irq_data *data, const struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                       cpumask *dest, bool force);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int             (*irq_retrigger)(struct irq_data *data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int             (*irq_set_type)(struct irq_data *data, unsigned int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                     flow_type);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        int             (*irq_set_wake)(struct irq_data *data, unsigned int on);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>各个芯片公司会将芯片内部的中断控制器实现为irq_chip驱动的形式。受限于中断控制器硬件的能力，这些成员函数并不一定需要全部实现，有时候只需要实现其中的部分函数即可。譬如drivers/pinctrl/sirf/pinctrl-sirf.c驱动中的下面代码部分：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static struct irq_chip sirfsoc_irq_chip = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .name = &quot;sirf-gpio-irq&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .irq_ack = sirfsoc_gpio_irq_ack,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .irq_mask = sirfsoc_gpio_irq_mask,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .irq_unmask = sirfsoc_gpio_irq_unmask,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .irq_set_type = sirfsoc_gpio_irq_type,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们只实现了其中的ack、mask、unmask和set_type成员函数，ack函数用于清中断，mask、unmask用于中断屏蔽和取消中断屏蔽、set_type则用于配置中断的触发方式，如高电平、低电平、上升沿、下降沿等。至于到enable_irq（）的时候，虽然没有实现irq_enable（）成员函数，但是内核会间接调用irq_unmask（）成员函数，这点从kernel/irq/chip.c中可以看出：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void irq_enable(struct irq_desc *desc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        irq_state_clr_disabled(desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (desc-&gt;irq_data.chip-&gt;irq_enable)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                desc-&gt;irq_data.chip-&gt;irq_enable(&amp;desc-&gt;irq_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                desc-&gt;irq_data.chip-&gt;irq_unmask(&amp;desc-&gt;irq_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        irq_state_clr_masked(desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在芯片内部，中断控制器可能不止1个，多个中断控制器之间还很可能是级联的。举个例子，假设芯片内部有一个中断控制器，支持32个中断源，其中有4个来源于GPIO控制器外围的4组GPIO，每组GPIO上又有32个中断（许多芯片的GPIO控制器也同时是一个中断控制器），其关系如图20.4所示。</p><p><img loading="lazy" alt="1747233562390" src="/assets/images/1747233562390-4a5d0d5733a6eddd70e6e5f503d10862.png" width="1216" height="688" class="img_ev3q"></p><p>图20.4　SoC中断控制器的典型分布</p><p>那么，一般来讲，在实际操作中，gpio0_0~gpio0_31这些引脚本身在第1级会使用中断号28，而这些引脚本身的中断号在实现与GPIO控制器对应的irq_chip驱动时，我们又会把它映射到Linux系统的32~63号中断。同理，gpio1_0~gpio1_31这些引脚本身在第1级会使用中断号29，而这些引脚本身的中断号在实现与GPIO控制器对应的irq_chip驱动时，我们又会把它映射到Linux系统的64~95号中断，以此类推。对于中断号的使用者而言，无须看到这种2级映射关系。如果某设备想申请与gpio1_0这个引脚对应的中断，它只需要申请64号中断即可。这个关系图看起来如图20.5所示。</p><p>要特别注意的是，上述图20.4和20.5中所涉及的中断号的数值，无论是base还是具体某个GPIO对应的中断号是多少，都不一定是如图20.4和图20.5所描述的简单线性映射。Linux使用IRQ Domain来描述一个中断控制器所管理的中断源。换句话说，每个中断控制器都有自己的Domain。我们可以将IRQ Domain看作是IRQ控制器的软件抽象。在添加IRQ Domain的时候，内核中存在的映射方法有：irq_domain_add_legacy（）、irq_domain_add_linear（）、irq_domain_add_tree（）等。</p><p><img loading="lazy" alt="1747233631119" src="/assets/images/1747233631119-0e0ace9ba651c9c4871d899c2af70318.png" width="1276" height="1041" class="img_ev3q"></p><p>图20.5　中断级联与映射</p><p>irq_domain_add_legacy（）实际上是一种过时的方法，它一般是由IRQ控制器驱动直接指定中断源硬件意义上的偏移（一般称为hwirq）和Linux逻辑上的中断号的映射关系。类似图20.5的指定映射可以被这种方法弄出来。irq_domain_add_linear（）则在中断源和irq_desc之间建立线性映射，内核针对这个IRQ Domain维护了一个hwirq和Linux逻辑IRQ之间关系的一个表，这个时候我们其实也完全不关心逻辑中断号了；irq_domain_add_tree（）则更加灵活，逻辑中断号和hwirq之间的映射关系是用一棵radix树来描述的，我们需要通过查找的方法来寻找hwirq和Linux逻辑IRQ之间的关系，一般适合某中断控制器支持非常多中断源的情况。</p><p>实际上，在当前的内核中，中断号更多的是一个逻辑概念，具体数值是多少不是很关键。人们更多的是关心在设备树中设置正确的interrupt_parrent和相对该interrupt_parent的偏移。</p><p>以drivers/pinctrl/sirf/pinctrl-sirf.c的irq_chip部分为例，在sirfsoc_gpio_probe（）函数中，每组GPIO的中断都通过gpiochip_set_chained_irqchip（）级联到上一级中断控制器的中断。</p><p>代码清单20.5　二级GPIO中断级联到一级中断控制器</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int sirfsoc_gpio_probe(struct device_node *np)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4for (i = 0; i &lt; SIRFSOC_GPIO_NO_OF_BANKS; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       bank = &amp;sgpio-&gt;sgpio_bank[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       spin_lock_init(&amp;bank-&gt;lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       bank-&gt;parent_irq = platform_get_irq(pdev, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       if (bank-&gt;parent_irq &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               err = bank-&gt;parent_irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10               goto out_banks;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       gpiochip_set_chained_irqchip(&amp;sgpio-&gt;chip.gc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               &amp;sirfsoc_irq_chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15               bank-&gt;parent_irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16               sirfsoc_gpio_handle_irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于SIRFSOC_GPIO_NO_OF_BANKS这么多组GPIO进行循环，上述代码中第15行的bank-&gt;parent_irq是与这一组GPIO对应的“上级”中断号，sirfsoc_gpio_handle_irq（）则是与bank-&gt;parent_irq对应的“上级”中断服务程序。而sirfsoc_gpio_handle_irq（）这个“上级”函数最终还是要调用GPIO这一级别的中断服务程序。</p><p>在sirfsoc_gpio_handle_irq（）函数的入口处调用chained_irq_enter（）暗示自身进入链式IRQ处理，在函数体内判决具体的GPIO中断，并通过generic_handle_irq（）调用最终的外设驱动中的中断服务程序，最后调用chained_irq_exit（）暗示自身退出链式IRQ处理，如代码清单20.6所示。</p><p>代码清单20.6　“上级”中断服务程序派生到下级</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void sirfsoc_gpio_handle_irq(unsigned int irq, struct irq_desc *desc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4chained_irq_enter(chip, desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6while (status) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       ctrl = readl(sgpio-&gt;chip.regs + SIRFSOC_GPIO_CTRL(bank-&gt;id, idx));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        * Here we must check whether the corresponding GPIO’s interrupt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        * has been enabled, otherwise just skip it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       if ((status &amp; 0x1) &amp;&amp; (ctrl &amp; SIRFSOC_GPIO_CTL_INTR_EN_MASK)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14              generic_handle_irq(irq_find_mapping(gc-&gt;irqdomain, idx +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                             bank-&gt;id * SIRFSOC_GPIO_BANK_SIZE));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       idx++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19       status = status &gt;&gt; 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22chained_irq_exit(chip, desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面用一个实例来呈现这个过程，假设GPIO0_0~31对应上级中断号28，而外设A使用了GPIO0_5（即第0组GPIO的第5个），并假定外设A的中断号为37，即32+5，中断服务程序为deva_isr（）。那么，当GPIO0_5中断发生的时候，内核的调用顺序是：sirfsoc_gpio_handle_irq（）-&gt;generic_handle_irq（）-&gt;deva_isr（）。如果硬件的中断系统有更深的层次，这种软件上的中断服务程序级联实际上可以有更深的级别。</p><p>在上述实例中，GPIO0_0~31的interrupt_parrent实际是上级中断控制器，而外设A的interrupt_parrent就是GPIO0，这些都会在设备树中进行呈现。</p><p>很多中断控制器的寄存器定义呈现出简单的规律，如有一个mask寄存器，其中每1位可屏蔽1个中断等，在这种情况下，我们无须实现1个完整的irq_chip驱动，而可以使用内核提供的通用irq_chip驱动架构irq_chip_generic，这样只需要实现极少量的代码，如drivers/irqchip/irq-sirfsoc.c中，用于注册CSR SiRFprimaII内部中断控制器的代码（见代码清单20.7）。</p><p>代码清单20.7　使用generic的irq_chip框架</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static __init void</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2sirfsoc_alloc_gc(void __iomem *base, unsigned int irq_start, unsigned int num)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct irq_chip_generic *gc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        struct irq_chip_type *ct;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        unsigned int clr = IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_NOAUTOEN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        unsigned int set = IRQ_LEVEL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        ret = irq_alloc_domain_generic_chips(sirfsoc_irqdomain,num, 1, &quot;irq_sirfsoc&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11               handle_level_irq, clr, set, IRQ_GC_INIT_MASK_CACHE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        gc = irq_get_domain_generic_chip(sirfsoc_irqdomain, irq_start);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        gc-&gt;reg_base = base;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        ct = gc-&gt;chip_types;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        ct-&gt;chip.irq_mask = irq_gc_mask_clr_bit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        ct-&gt;chip.irq_unmask = irq_gc_mask_set_bit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        ct-&gt;regs.mask = SIRFSOC_INT_RISC_MASK0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>irq_chip驱动的入口声明方法形如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(sirfsoc_intc, &quot;sirf,prima2-intc&quot;, sirfsoc_irq_init);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>sirf，prima2-intc是设备树中中断控制器的compatible字段，sirfsoc_irq_init是匹配这个compatible字段后运行的初始化函数。</p><p>特别值得一提的是，目前多数主流ARM芯片内部的一级中断控制器都使用了ARM公司的GIC，我们几乎不需要实现任何代码，只需要在设备树中添加相关的节点。</p><p>如在arch/arm/boot/dts/exynos5250.dtsi中即含有：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gic:interrupt-controller@10481000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compatible = &quot;arm,cortex-a9-gic&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #interrupt-cells = &lt;3&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interrupt-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reg = &lt;0x10481000 0x1000&gt;, &lt;0x10482000 0x2000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>打开drivers/irqchip/irq-gic.c，发现GIC驱动的入口声明如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(gic_400, &quot;arm,gic-400&quot;, gic_of_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(cortex_a15_gic, &quot;arm,cortex-a15-gic&quot;, gic_of_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(cortex_a9_gic, &quot;arm,cortex-a9-gic&quot;, gic_of_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(cortex_a7_gic, &quot;arm,cortex-a7-gic&quot;, gic_of_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(msm_8660_qgic, &quot;qcom,msm-8660-qgic&quot;, gic_of_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">IRQCHIP_DECLARE(msm_qgic2, &quot;qcom,msm-qgic2&quot;, gic_of_init);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这说明drivers/irqchip/irq-gic.c这个驱动可以兼容arm，gic-400、arm，cortex-a15-gic、arm，cortex-a7-gic等，但是初始化函数都是统一的gic_of_init。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.297Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux提供了完成量（Completion，关于这个名词，至今没有好的翻译，笔者将其译为“完成量”），它用于一个执行单元等待另一个执行单元执行完某事。</p><p>Linux中与完成量相关的操作主要有以下4种。</p><p>1.定义完成量</p><p>下列代码定义名为my_completion的完成量：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct completion my_completion;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.初始化完成量</p><p>下列代码初始化或者重新初始化my_completion这个完成量的值为0（即没有完成的状态）：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">init_completion(&amp;my_completion);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reinit_completion(&amp;my_completion)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3.等待完成量</p><p>下列函数用于等待一个完成量被唤醒：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void wait_for_completion(struct completion *c);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4.唤醒完成量</p><p>下面两个函数用于唤醒完成量：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void complete(struct completion *c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void complete_all(struct completion *c);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前者只唤醒一个等待的执行单元，后者释放所有等待同一完成量的执行单元。</p><p>完成量用于同步的流程一般如下：</p><p><img loading="lazy" alt="1743172384218" src="/assets/images/1743172384218-2a495b388870550eabf64f9c1e6f90f1.png" width="711" height="189" class="img_ev3q"></p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.285Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->21 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在globalmem字符设备驱动中，应包含它要使用的头文件，并定义globalmem设备结构体及相关宏。</p><p>代码清单6.8　globalmem设备结构体和宏</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;linux/fs.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;linux/cdev.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#include &lt;linux/slab.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#include &lt;linux/uaccess.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8#define GLOBALMEM_SIZE   0x1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#define MEM_CLEAR 0x1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10#define GLOBALMEM_MAJOR 230</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12static int globalmem_major = GLOBALMEM_MAJOR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13module_param(globalmem_major, int, S_IRUGO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15struct globalmem_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 struct cdev cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 unsigned char mem[GLOBALMEM_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20struct globalmem_dev *globalmem_devp;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从第15~18行代码可以看出，定义的globalmem_dev设备结构体包含了对应于globalmem字符设备的cdev、使用的内存mem<!-- -->[GLOBALMEM_SIZE]<!-- -->。当然，程序中并不一定要把mem<!-- -->[GLOBALMEM_SIZE]<!-- -->和cdev包含在一个设备结构体中，但这样定义的好处在于，它借用了面向对象程序设计中“封装”的思想，体现了一种良好的编程习惯。</p><h1>6.3.2　加载与卸载设备驱动</h1><p>globalmem设备驱动的模块加载和卸载函数遵循代码清单6.5的类似模板，其实现的工作与代码清单6.5完全一致，如代码清单6.9所示。</p><p>代码清单6.9　globalmem设备驱动模块的加载与卸载函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  int err, devno = MKDEV(globalmem_major, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  dev-&gt;cdev.owner = THIS_MODULE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  err = cdev_add(&amp;dev-&gt;cdev, devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  if (err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12static int __init globalmem_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  dev_t devno = MKDEV(globalmem_major, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  if (globalmem_major)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       globalmem_major = MAJOR(devno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24      return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  if (!globalmem_devp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29       goto fail_malloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  globalmem_setup_cdev(globalmem_devp, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36  unregister_chrdev_region(devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37  return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39module_init(globalmem_init);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第1~10行的globalmem_setup_cdev（）函数完成cdev的初始化和添加，17~22行完成了设备号的申请，第26行调用kzalloc（）申请了一份globalmem_dev结构体的内存并清0。在cdev_init（）函数中，与globalmem的cdev关联的file_operations结构体如代码清单6.10所示。</p><p>代码清单6.10　globalmem设备驱动的文件操作结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static const struct file_operations globalmem_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2   .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3   .llseek = globalmem_llseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4   .read = globalmem_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5   .write = globalmem_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6   .unlocked_ioctl = globalmem_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7   .open = globalmem_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8   .release = globalmem_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6.3.3　读写函数</h1><p>globalmem设备驱动的读写函数主要是让设备结构体的mem[]数组与用户空间交互数据，并随着访问的字节数变更更新文件读写偏移位置。读和写函数的实现分别如代码清单6.11和6.12所示</p><p>代码清单6.11　globalmem设备驱动的读函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2              loff_t * ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned long p = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 unsigned int count = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 struct globalmem_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 if (p &gt;= GLOBALMEM_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (count &gt; GLOBALMEM_SIZE - p)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     count = GLOBALMEM_SIZE - p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 if (copy_to_user(buf, dev-&gt;mem + p, count)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     ret = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     *ppos += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18     ret = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20     printk(KERN_INFO &quot;read %u bytes(s) from %lu\n&quot;, count, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>*ppos是要读的位置相对于文件开头的偏移，如果该偏移大于或等于GLOBALMEM_SIZE，意味着已经到达文件末尾，所以返回0（EOF）。</p><p>代码清单6.12　globalmem设备驱动的写函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t globalmem_write(struct file *filp, const char __user * buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                size_t size, loff_t * ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned long p = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 unsigned int count = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 struct globalmem_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 if (p &gt;= GLOBALMEM_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (count &gt; GLOBALMEM_SIZE - p)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     count = GLOBALMEM_SIZE - p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 if (copy_from_user(dev-&gt;mem + p, buf, count))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     ret = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     *ppos += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18     ret = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20     printk(KERN_INFO &quot;written %u bytes(s) from %lu\n&quot;, count, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6.3.4　seek函数</h1><p>seek（）函数对文件定位的起始地址可以是文件开头（SEEK_SET，0）、当前位置（SEEK_CUR，1）和文件尾（SEEK_END，2），假设globalmem支持从文件开头和当前位置的相对偏移。</p><p>在定位的时候，应该检查用户请求的合法性，若不合法，函数返回-EINVAL，合法时更新文件的当前位置并返回该位置，如代码清单6.13所示。</p><p>代码清单6.13　globalmem设备驱动的seek（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  loff_t ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  switch (orig) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  case 0: /* 从文件开头位置seek */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       if (offset&lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7            ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       if ((unsigned int)offset &gt; GLOBALMEM_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11            ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       filp-&gt;f_pos = (unsigned int)offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       ret = filp-&gt;f_pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  case 1: /* 从文件当前位置开始seek */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19            ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22       if ((filp-&gt;f_pos + offset) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23            ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24            break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26       filp-&gt;f_pos += offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27       ret = filp-&gt;f_pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31       break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33  return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6.3.5　ioctl函数</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1globalmem设备驱动的ioctl函数">1.globalmem设备驱动的ioctl（）函数<a class="hash-link" href="#1globalmem设备驱动的ioctl函数" title="标题的直接链接">​</a></h2><p>globalmem设备驱动的ioctl（）函数接受MEM_CLEAR命令，这个命令会将全局内存的有效数据长度清0，对于设备不支持的命令，ioctl（）函数应该返回-EINVAL，如代码清单6.14所示。</p><p>代码清单6.14　globalmem设备驱动的I/O控制函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static long globalmem_ioctl(struct file *filp, unsigned int cmd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  struct globalmem_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  switch (cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  case MEM_CLEAR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       memset(dev-&gt;mem, 0, GLOBALMEM_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       printk(KERN_INFO &quot;globalmem is set to zero\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述程序中，MEM_CLEAR被宏定义为0x01，实际上这并不是一种值得推荐的方法，简单地对命令定义为0x0、0x1、0x2等类似值会导致不同的设备驱动拥有相同的命令号。如果设备A、B都支持0x0、0x1、0x2这样的命令，就会造成命令码的污染。因此，Linux内核推荐采用一套统一的ioctl（）命令生成方式</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2ioctl命令">2.ioctl（）命令<a class="hash-link" href="#2ioctl命令" title="标题的直接链接">​</a></h2><p>Linux建议以如图6.2所示的方式定义ioctl（）的命令。</p><p><img loading="lazy" alt="1742913948756" src="/assets/images/1742913948756-5de8acea4a796bfdcaf2b2a25eb4e728.png" width="739" height="117" class="img_ev3q"></p><p>图6.2　I/O控制命令的组成</p><p>命令码的设备类型字段为一个“幻数”，可以是0~0xff的值，内核中的ioctl-number.txt给出了一些推荐的和已经被使用的“幻数”，新设备驱动定义“幻数”的时候要避免与其冲突。</p><p>命令码的序列号也是8位宽。</p><p>命令码的方向字段为2位，该字段表示数据传送的方向，可能的值是_IOC_NONE（无数据传输）、_IOC_READ（读）、_IOC_WRITE（写）和_IOC_READ|_IOC_WRITE（双向）。数据传送的方向是从应用程序的角度来看的。</p><p>命令码的数据长度字段表示涉及的用户数据的大小，这个成员的宽度依赖于体系结构，通常是13或者14位。</p><p>内核还定义了_IO（）、_IOR（）、_IOW（）和_IOWR（）这4个宏来辅助生成命令，这4个宏的通用定义如代码清单6.15所示</p><p>代码清单6.15　_IO（）、_IOR（）、_IOW（）和_IOWR（）宏定义</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define _IO(type,nr)         _IOC(_IOC_NONE,(type),(nr),0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3                                 (_IOC_TYPECHECK(size)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),\</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                                 (_IOC_TYPECHECK(size)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                                 (_IOC_TYPECHECK(size)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8/* _IO、_IOR等使用的_IOC宏*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#define _IOC(dir,type,nr,size) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10     (((dir)  &lt;&lt; _IOC_DIRSHIFT) | \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     ((type) &lt;&lt; _IOC_TYPESHIFT) | \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     ((nr)   &lt;&lt; _IOC_NRSHIFT) | \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     ((size) &lt;&lt; _IOC_SIZESHIFT))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由此可见，这几个宏的作用是根据传入的type（设备类型字段）、nr（序列号字段）、size（数据长度字段）和宏名隐含的方向字段移位组合生成命令码。</p><p>由于globalmem的MEM_CLEAR命令不涉及数据传输，所以它可以定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define GLOBALMEM_MAGIC &#x27;g&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MEM_CLEAR _IO(GLOBALMEM_MAGIC,0)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3预定义命令">3.预定义命令<a class="hash-link" href="#3预定义命令" title="标题的直接链接">​</a></h2><p>内核中预定义了一些I/O控制命令，如果某设备驱动中包含了与预定义命令一样的命令码，这些命令会作为预定义命令被内核处理而不是被设备驱动处理，下面列举一些常用的预定义命令。</p><p>FIOCLEX：即File IOctl Close on Exec，对文件设置专用标志，通知内核当exec（）系统调用发生时自动关闭打开的文件。</p><p>FIONCLEX：即File IOctl Not Close on Exec，与FIOCLEX标志相反，清除由FIOCLEX命令设置的标志。</p><p>FIOQSIZE：获得一个文件或者目录的大小，当用于设备文件时，返回一个ENOTTY错误</p><p>FIONBIO：即File IOctl Non-Blocking I/O，这个调用修改在filp-&gt;f_flags中的O_NONBLOCK标志。</p><p>FIOCLEX、FIONCLEX、FIOQSIZE和FIONBIO这些宏定义在内核的include/uapi/asm-generic/ioctls.h文件中。</p><h1>6.3.6　使用文件私有数据</h1><p>6.3.1~6.3.5节给出的代码完整地实现了预期的globalmem雏形，代码清单6.11的第7行，代码清单6.12的第7行，代码清单6.14的第4行，都使用了struct globalmem_dev*dev=filp-&gt;private_data获取globalmem_dev的实例指针。实际上，大多数Linux驱动遵循一个“潜规则”，那就是将文件的私有数据private_data指向设备结构体，再用read（）、write（）、ioctl（）、llseek（）等函数通过private_data访问设备结构体。私有数据的概念在Linux驱动的各个子系统中广泛存在，实际上体现了Linux的面向对象的设计思想。对于globalmem驱动而言，私有数据的设置是在globalmem_open（）中完成的，如代码清单6.16所示。</p><p>代码清单6.16　globalmem设备驱动的open（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int globalmem_open(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   filp-&gt;private_data = globalmem_devp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>为了让读者建立字符设备驱动的全貌视图，代码清单6.17列出了完整的使用文件私有数据的globalmem的设备驱动，本程序位于本书配套虚拟机代码的/kernel/drivers/globalmem/ch6目录下。</p><p>代码清单6.17　使用文件私有数据的globalmem的设备驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  1/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2 * a simple char device driver: globalmem without mutex</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  3 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4 * Copyright (C) 2014 Barry Song  (baohua@kernel.org)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  6 * Licensed under GPLv2 or later.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  7 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  9#include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 10#include &lt;linux/fs.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 11#include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 12#include &lt;linux/cdev.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 13#include &lt;linux/slab.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 14#include &lt;linux/uaccess.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 16#define GLOBALMEM_SIZE   0x1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 17#define MEM_CLEAR 0x1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 18#define GLOBALMEM_MAJOR 230</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 20static int globalmem_major = GLOBALMEM_MAJOR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 21module_param(globalmem_major, int, S_IRUGO);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 23struct globalmem_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 24   struct cdev cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25   unsigned char mem[GLOBALMEM_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 26};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 28struct globalmem_dev *globalmem_devp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 30static int globalmem_open(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 31{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 32   filp-&gt;private_data = globalmem_devp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 33   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 36static int globalmem_release(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 37{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 38   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 39}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 40</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 41static long globalmem_ioctl(struct file *filp, unsigned int cmd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 42               unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 43{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 44 struct globalmem_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 46 switch (cmd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 47 case MEM_CLEAR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 48      memset(dev-&gt;mem, 0, GLOBALMEM_SIZE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 49      printk(KERN_INFO &quot;globalmem is set to zero\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 50      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 52 default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 53      return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 54 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 56 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 57}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 59static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 60                 loff_t * ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 61{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 62 unsigned long p = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 63 unsigned int count = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 64 int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 65 struct globalmem_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 66</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 67 if (p &gt;= GLOBALMEM_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 68      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 69 if (count &gt; GLOBALMEM_SIZE - p)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 70      count = GLOBALMEM_SIZE - p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 71</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 72 if (copy_to_user(buf, dev-&gt;mem + p, count)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 73      ret = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 74 } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 75      *ppos += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 76      ret = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 77</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 78      printk(KERN_INFO &quot;read %u bytes(s) from %lu\n&quot;, count, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 79 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 80</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 81 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 82}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 83</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 84static ssize_t globalmem_write(struct file *filp, const char __user * buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 85                  size_t size, loff_t * ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 86{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 87 unsigned long p = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 88 unsigned int count = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 89 int ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 90 struct globalmem_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 91</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 92 if (p &gt;= GLOBALMEM_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 93      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 94 if (count &gt; GLOBALMEM_SIZE - p)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 95      count = GLOBALMEM_SIZE - p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 96</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 97 if (copy_from_user(dev-&gt;mem + p, buf, count))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 98      ret = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 99 else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100      *ppos += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">101      ret = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">102</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">103      printk(KERN_INFO &quot;written %u bytes(s) from %lu\n&quot;, count, p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">104 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">105</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">106 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">107}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">108</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">109static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">110{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">111 loff_t ret = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">112 switch (orig) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">113 case 0:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">114      if (offset &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">115           ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">116           break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">117      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">118      if ((unsigned int)offset &gt; GLOBALMEM_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">119           ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">120           break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">121      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">122      filp-&gt;f_pos = (unsigned int)offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">123      ret = filp-&gt;f_pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">124      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">125 case 1:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">126      if ((filp-&gt;f_pos + offset) &gt; GLOBALMEM_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">127           ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">128           break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">129      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">130      if ((filp-&gt;f_pos + offset) &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">131           ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">132           break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">133      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">134      filp-&gt;f_pos += offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">135      ret = filp-&gt;f_pos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">136      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">137 default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">138      ret = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">139      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">140 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">141 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">142}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">143</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">144static const struct file_operations globalmem_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">145 .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">146 .llseek = globalmem_llseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">147 .read = globalmem_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">148 .write = globalmem_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">149 .unlocked_ioctl = globalmem_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">150 .open = globalmem_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">151 .release = globalmem_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">152};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">153</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">154static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">155{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">156 int err, devno = MKDEV(globalmem_major, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">157</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">158 cdev_init(&amp;dev-&gt;cdev, &amp;globalmem_fops);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">159 dev-&gt;cdev.owner = THIS_MODULE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">160 err = cdev_add(&amp;dev-&gt;cdev, devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">161 if (err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">162      printk(KERN_NOTICE &quot;Error %d adding globalmem%d&quot;, err, index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">163}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">164</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">165static int __init globalmem_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">166{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">167 int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">168 dev_t devno = MKDEV(globalmem_major, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">169</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">170 if (globalmem_major)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">171      ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">172 else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">173      ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">174      globalmem_major = MAJOR(devno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">175 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">176 if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">177      return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">178</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">179 globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">180 if (!globalmem_devp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">181      ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">182      goto fail_malloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">183 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">184</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">185 globalmem_setup_cdev(globalmem_devp, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">186 return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">187</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">188 fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">189 unregister_chrdev_region(devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">190 return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">191}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">192module_init(globalmem_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">193</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">194static void __exit globalmem_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">195{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">196 cdev_del(&amp;globalmem_devp-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">197 kfree(globalmem_devp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">198 unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">199}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">200module_exit(globalmem_exit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">201</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">202MODULE_AUTHOR(&quot;Barry Song &lt;baohua@kernel.org&gt;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">203MODULE_LICENSE(&quot;GPL v2&quot;); </span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果globalmem不只包括一个设备，而是同时包括两个或两个以上的设备，采用private_data的优势就会集中显现出来。在不对代码清单6.17中的globalmem_read（）、globalmem_write（）、globalmem_ioctl（）等重要函数及globalmem_fops结构体等数据结构进行任何修改的前提下，只是简单地修改globalmem_init（）、globalmem_exit（）和globalmem_open（），就可以轻松地让globalmem驱动中包含N个同样的设备（次设备号分为0~N），如代码清单6.18列出了支持多个实例的globalmem和支持单实例的globalmem驱动的差异部分。</p><p>代码清单6.18　支持N个globalmem设备的globalmem驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define GLOBALMEM_SIZE   0x1000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#define MEM_CLEAR 0x1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#define GLOBALMEM_MAJOR 230</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#define DEVICE_NUM   10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6static int globalmem_open(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  struct globalmem_dev *dev = container_of(inode-&gt;i_cdev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                struct globalmem_dev, cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  filp-&gt;private_data = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14static int __init globalmem_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  dev_t devno = MKDEV(globalmem_major, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  if (globalmem_major)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       ret = register_chrdev_region(devno, DEVICE_NUM, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23       ret = alloc_chrdev_region(&amp;devno, 0, DEVICE_NUM, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       globalmem_major = MAJOR(devno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27       return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30  if (!globalmem_devp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31       ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32       goto fail_malloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  for (i = 0; i &lt; DEVICE_NUM; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36       globalmem_setup_cdev(globalmem_devp + i, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41  unregister_chrdev_region(devno, DEVICE_NUM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42  return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44module_init(globalmem_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46static void __exit globalmem_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48  int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49  for (i = 0; i &lt; DEVICE_NUM; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50       cdev_del(&amp;(globalmem_devp + i)-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51  kfree(globalmem_devp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52  unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54module_exit(globalmem_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单6.18第8行调用的container_of（）的作用是通过结构体成员的指针找到对应结构体的指针，这个技巧在Linux内核编程中十分常用。在container_of（inode-&gt;i_cdev，struct globalmem_dev，cdev）语句中，传给container_of（）的第1个参数是结构体成员的指针，第2个参数为整个结构体的类型，第3个参数为传入的第1个参数即结构体成员的类型，container_of（）返回值为整个结构体的指针。</p><p>从代码清单6.18可以看出，我们仅仅进行了极其少量的更改就使得globalmem驱动支持多个实例，这一点可以看出私有数据的魔力。完整的代码位于kernel/drivers/globalmem/ch6/multi_globalmem.c下。高亮globalmem.c和multi_globalmem.c（以“-”和“+”开头的代码）的区别如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">@@ -29,7 +30,9 @@ struct globalmem_dev *globalmem_devp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> static int globalmem_open(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    filp-&gt;private_data = globalmem_devp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    struct globalmem_dev *dev = container_of(inode-&gt;i_cdev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+                    struct globalmem_dev, cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    filp-&gt;private_data = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -165,37 +168,42 @@ static void globalmem_setup_cdev(struct globalmem_dev *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int index)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> static int __init globalmem_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     dev_t devno = MKDEV(globalmem_major, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (globalmem_major)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-         ret = register_chrdev_region(devno, 1, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+         ret = register_chrdev_region(devno, DEVICE_NUM, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-         ret = alloc_chrdev_region(&amp;devno, 0, 1, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+         ret = alloc_chrdev_region(&amp;devno, 0, DEVICE_NUM, &quot;globalmem&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          globalmem_major = MAJOR(devno);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (!globalmem_devp) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          ret = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          goto fail_malloc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    globalmem_setup_cdev(globalmem_devp, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    for (i = 0; i &lt; DEVICE_NUM; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+         globalmem_setup_cdev(globalmem_devp + i, i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">- fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    unregister_chrdev_region(devno, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+fail_malloc:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    unregister_chrdev_region(devno, DEVICE_NUM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> module_init(globalmem_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> static void __exit globalmem_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    cdev_del(&amp;globalmem_devp-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    for (i = 0; i &lt; DEVICE_NUM; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+         cdev_del(&amp;(globalmem_devp + i)-&gt;cdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     kfree(globalmem_devp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> module_exit(globalmem_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>6.4　globalmem驱动在用户空间中的验证</h1><p>在globalmem的源代码目录通过“make”命令编译globalmem的驱动，得到globalmem.ko文件。运行</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">baohua@baohua-VirtualBox:~/develop/training/kernel/drivers/globalmem/ch6$ sudo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    insmod globalmem.ko</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>命令加载模块，通过“lnsmod”命令，发现globalmem模块已被加载。再通过“cat/proc/devices”命令查看，发现多出了主设备号为230的“globalmem”字符设备驱动：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cat /proc/devices</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Character devices:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  1mem</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4/dev/vc/0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4tty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4ttyS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5/dev/tty</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5/dev/console</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5/dev/ptmx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  7vcs</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 10misc</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 13input</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 14sound</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 21sg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 29fb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">116alsa</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">128ptm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">136pts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">180usb</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">189usb_device</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">202cpu/msr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">203cpu/cpuid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">226drm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">230globalmem</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">249hidraw</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">250usbmon</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">251bsg</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">252ptp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">253pps</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">254rtc</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>接下来，通过命令</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#mknod /dev/globalmem c 230 0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>创建“/dev/globalmem”设备节点，并通过“echo&#x27;hello world&#x27;&gt;/dev/globalmem”命令和“cat/dev/globalmem”命令分别验证设备的写和读，结果证明“hello world”字符串被正确地写入了globalmem字符设备：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo &quot;hello world&quot; &gt; /dev/globalmem</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># cat /dev/globalmem</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hello world</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果启用了sysfs文件系统，将发现多出了/sys/module/globalmem目录，该目录下的树形结构为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> coresize├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> holders├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> initsize├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> initstate├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> notes├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> parameters│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">globalmem_major├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> refcnt├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> sections│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> __param├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> taint└──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uevent</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>refcnt记录了globalmem模块的引用计数，sections下包含的几个文件则给出了globalmem所包含的BSS、数据段和代码段等的地址及其他信息。</p><p>对于代码清单6.18给出的支持N个globalmem设备的驱动，在加载模块后需创建多个设备节点，如运行mknod/dev/globalmem0c 2300使得/dev/globalmem0对应主设备号为globalmem_major、次设备号为0的设备，运行mknod/dev/globalmem1c 2301使得/dev/globalmem1对应主设备号为globalmem_major、次设备号为1的设备。分别读写/dev/globalmem0和/dev/globalmem1，发现都读写到了正确的对应的设备。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.269Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->18 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>DMA是一种无须CPU的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。使用DMA可以使系统CPU从实际的I/O数据传输过程中摆脱出来，从而大大提高系统的吞吐率。DMA通常与硬件体系结构，特别是外设的总线技术密切相关。</p><p>DMA方式的数据传输由DMA控制器（DMAC）控制，在传输期间，CPU可以并发地执行其他任务。当DMA结束后，DMAC通过中断通知CPU数据传输已经结束，然后由CPU执行相应的中断服务程序进行后处理。</p><h1>11.6.1　DMA与Cache一致性</h1><p>Cache和DMA本身似乎是两个毫不相关的事物。Cache被用作CPU针对内存的缓存，利用程序的空间局部性和时间局部性原理，达到较高的命中率，从而避免CPU每次都必须要与相对慢速的内存交互数据来提高数据的访问速率。DMA可以作为内存与外设之间传输数据的方式，在这种传输方式之下，数据并不需要经过CPU中转。</p><p>Cache和DMA本身似乎是两个毫不相关的事物。Cache被用作CPU针对内存的缓存，利用程序的空间局部性和时间局部性原理，达到较高的命中率，从而避免CPU每次都必须要与相对慢速的内存交互数据来提高数据的访问速率。DMA可以作为内存与外设之间传输数据的方式，在这种传输方式之下，数据并不需要经过CPU中转。</p><p><img loading="lazy" alt="1743864132158" src="/assets/images/1743864132158-3fdbe2ee356318b3fa41e7423c4b34f3.png" width="580" height="441" class="img_ev3q"></p><p>图11.12　DMA目的地址与Cache对象没有重叠</p><p><img loading="lazy" alt="1743864150147" src="/assets/images/1743864150147-67bc381e231d0d3427f2831b464b43f4.png" width="574" height="433" class="img_ev3q"></p><p>图11.13　DMA目的地址与Cache对象有重叠</p><p>所谓Cache数据与内存数据的不一致性，是指在采用Cache的系统中，同样一个数据可能既存在于Cache中，也存在于主存中，Cache与主存中的数据一样则具有一致性，数据若不一样则具有不一致性。</p><p>需要特别注意的是，Cache与内存的一致性问题经常被初学者遗忘。在发生Cache与内存不一致性错误后，驱动将无法正常运行。如果没有相关的背景知识，工程师几乎无法定位错误的原因，因为这时所有的程序看起来都是完全正确的。Cache的不一致性问题并不是只发生在DMA的情况下，实际上，它还存在于Cache使能和关闭的时刻。例如，对于带MMU功能的ARM处理器，在开启MMU之前，需要先置Cache无效，对于TLB，也是如此，代码清单11.12给出的这段汇编可用来完成此任务。</p><p>代码清单11.12　置ARM的Cache无效</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1/* 使cache无效*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2&quot;mov    r0, #0\n&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3&quot;mcr    p15, 0, r0, c7, c7, 0\n&quot;     /* 使数据和指令cache无效*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4&quot;mcr    p15, 0, r0, c7, c10, 4\n&quot;    /* 放空写缓冲 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5&quot;mcr    p15, 0, r0, c8, c7, 0\n&quot;     /* 使TLB无效 */</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>11.6.2　Linux下的DMA编程</h1><p>首先DMA本身不属于一种等同于字符设备、块设备和网络设备的外设，它只是一种外设与内存交互数据的方式。因此，本节的标题不是“Linux下的DMA驱动”而是“Linux下的DMA编程”。</p><p>内存中用于与外设交互数据的一块区域称为DMA缓冲区，在设备不支持scatter/gather（分散/聚集，简称SG）操作的情况下，DMA缓冲区在物理上必须是连续的。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1dma区域">1.DMA区域<a class="hash-link" href="#1dma区域" title="标题的直接链接">​</a></h2><p>对于x86系统的ISA设备而言，其DMA操作只能在16MB以下的内存中进行，因此，在使用kmalloc（）、__get_free_pages（）及其类似函数申请DMA缓冲区时应使用GFP_DMA标志，这样能保证获得的内存位于DMA区域中，并具备DMA能力。</p><p>在内核中定义了<strong>get_free_pages（）针对DMA的“快捷方式”</strong>get_dma_pages（），它在申请标志中添加了GFP_DMA，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define _ _get_dma_pages(gfp_mask, order) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __get_free_pages((gfp_mask) | GFP_DMA,(order))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果不想使用log2size（即order）为参数申请DMA内存，则可以使用另一个函数dma_mem_alloc（），其源代码如代码清单11.13所示。</p><p>代码清单11.13　dma_mem_alloc（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static unsigned long dma_mem_alloc(int size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3  int order = get_order(size);        /* 大小-&gt;指数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4  return _ _get_dma_pages(GFP_KERNEL, order);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于大多数现代嵌入式处理器而言，DMA操作可以在整个常规内存区域进行，因此DMA区域就直接覆盖了常规内存。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2虚拟地址物理地址和总线地址">2.虚拟地址、物理地址和总线地址<a class="hash-link" href="#2虚拟地址物理地址和总线地址" title="标题的直接链接">​</a></h2><p>基于DMA的硬件使用的是总线地址而不是物理地址，总线地址是从设备角度上看到的内存地址，物理地址则是从CPU MMU控制器外围角度上看到的内存地址（从CPU核角度看到的是虚拟地址）。虽然在PC上，对于ISA和PCI而言，总线地址即为物理地址，但并不是每个平台都是如此。因为有时候接口总线通过桥接电路连接，桥接电路会将I/O地址映射为不同的物理地址。例如，在PReP（PowerPC Reference Platform）系统中，物理地址0在设备端看起来是0x80000000，而0通常又被映射为虚拟地址0xC0000000，所以同一地址就具备了三重身份：物理地址0、总线地址0x80000000及虚拟地址0xC0000000。还有一些系统提供了页面映射机制，它能将任意的页面映射为连续的外设总线地址。内核提供了如下函数以进行简单的虚拟地址/总线地址转换：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long virt_to_bus(volatile void *address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void *bus_to_virt(unsigned long address);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在使用IOMMU或反弹缓冲区的情况下，上述函数一般不会正常工作。而且，这两个函数并不建议使用。如图11.14所示，IOMMU的工作原理与CPU内的MMU非常类似，不过它针对的是外设总线地址和内存地址之间的转化。由于IOMMU可以使得外设DMA引擎看到“虚拟地址”，因此在使用IOMMU的情况下，在修改映射寄存器后，可以使得SG中分段的缓冲区地址对外设变得连续。</p><p><img loading="lazy" alt="1743864403446" src="/assets/images/1743864403446-0de2b75c635b130505c3ae3e703ec15b.png" width="901" height="427" class="img_ev3q"></p><p>图11.14　MMU与IOMMU</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3dma地址掩码">3.DMA地址掩码<a class="hash-link" href="#3dma地址掩码" title="标题的直接链接">​</a></h2><p>设备并不一定能在所有的内存地址上执行DMA操作，在这种情况下应该通过下列函数执行DMA地址掩码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int dma_set_mask(struct device *dev, u64 mask);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>例如，对于只能在24位地址上执行DMA操作的设备而言，就应该调用dma_set_mask（dev，0xffffff）。</p><p>其实该API本质上就是修改device结构体中的dma_mask成员，如ARM平台的定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int arm_dma_set_mask(struct device *dev, u64 dma_mask)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!dev-&gt;dma_mask || !dma_supported(dev, dma_mask))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                return -EIO;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        *dev-&gt;dma_mask = dma_mask;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在device结构体中，除了有dma_mask以外，还有一个coherent_dma_mask成员。dma_mask是设备DMA可以寻址的范围，而coherent_dma_mask作用于申请一致性的DMA缓冲区。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4一致性dma缓冲区">4.一致性DMA缓冲区<a class="hash-link" href="#4一致性dma缓冲区" title="标题的直接链接">​</a></h2><p>DMA映射包括两个方面的工作：分配一片DMA缓冲区；为这片缓冲区产生设备可访问的地址。同时，DMA映射也必须考虑Cache一致性问题。内核中提供了如下函数以分配一个DMA一致性的内存区域：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void * dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *handle,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gfp_t gfp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数的返回值为申请到的DMA缓冲区的虚拟地址，此外，该函数还通过参数handle返回DMA缓冲区的总线地址。handle的类型为dma_addr_t，代表的是总线地址。</p><p>dma_alloc_coherent（）申请一片DMA缓冲区，以进行地址映射并保证该缓冲区的Cache一致性。与dma_alloc_coherent（）对应的释放函数为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dma_addr_t handle);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以下函数用于分配一个写合并（Writecombining）的DMA缓冲区：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void * dma_alloc_writecombine(struct device *dev, size_t size, dma_addr_t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    *handle, gfp_t gfp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与dma_alloc_writecombine（）对应的释放函数dma_free_writecombine（）实际上就是dma_free_coherent（），它定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define dma_free_writecombine(dev,size,cpu_addr,handle) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         dma_free_coherent(dev,size,cpu_addr,handle)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此外，Linux内核还提供了PCI设备申请DMA缓冲区的函数pci_alloc_consistent（），其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void * pci_alloc_consistent(struct pci_dev *pdev, size_t size, dma_addr_t *dma_addrp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对应的释放函数为pci_free_consistent（），其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void pci_free_consistent(struct pci_dev *pdev, size_t size, void *cpu_addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    dma_addr_t dma_addr);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这里我们要强调的是，dma<em>alloc_xxx（）函数虽然是以dma_alloc</em>开头的，但是其申请的区域不一定在DMA区域里面。以32位ARM处理器为例，当coherent_dma_mask小于0xffffffff时，才会设置GFP_DMA标记，并从DMA区域去申请内存。</p><p>在我们使用ARM等嵌入式Linux系统的时候，一个头疼的问题是GPU、Camera、HDMI等都需要预留大量连续内存，这部分内存平时不用，但是一般的做法又必须先预留着。目前，Marek Szyprowski和Michal Nazarewicz实现了一套全新的CMA，（Contiguous Memory Allocator）。通过这套机制，我们可以做到不预留内存，这些内存平时是可用的，只有当需要的时候才被分配给Camera、HDMI等设备。</p><p>CMA对上呈现的接口是标准的DMA，也是一致性缓冲区API。关于CMA的进一步介绍，可以参考<a href="http://lwn.net/Articles/486301/" target="_blank" rel="noopener noreferrer">http://lwn.net/Articles/486301/</a> 的文档《A deep dive into CMA》。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="5流式dma映射">5.流式DMA映射<a class="hash-link" href="#5流式dma映射" title="标题的直接链接">​</a></h2><p>并不是所有的DMA缓冲区都是驱动申请的，如果是驱动申请的，用一致性DMA缓冲区自然最方便，这直接考虑了Cache一致性问题。但是，在许多情况下，缓冲区来自内核的较上层（如网卡驱动中的网络报文、块设备驱动中要写入设备的数据等），上层很可能用普通的kmalloc（）、__get_free_pages（）等方法申请，这时候就要使用流式DMA映射。流式DMA缓冲区使用的一般步骤如下。</p><p>1）进行流式DMA映射。</p><p>2）执行DMA操作。</p><p>3）进行流式DMA去映射。</p><p>流式DMA映射操作在本质上大多就是进行Cache的使无效或清除操作，以解决Cache一致性问题。</p><p>相对于一致性DMA映射而言，流式DMA映射的接口较为复杂。对于单个已经分配的缓冲区而言，使用dma_map_single（）可实现流式DMA映射，该函数原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dma_addr_t dma_map_single(struct device *dev, void *buffer, size_t size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果映射成功，返回的是总线地址，否则，返回NULL。第4个参数为DMA的方向，可能的值包括DMA_TO_DEVICE、DMA_FROM_DEVICE、DMA_BIDIRECTIONAL和DMA_NONE。</p><p>dma_map_single（）的反函数为dma_unmap_single（），原型是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通常情况下，设备驱动不应该访问unmap的流式DMA缓冲区，如果一定要这么做，可先使用如下函数获得DMA缓冲区的拥有权：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_sync_single_for_cpu(struct device *dev, dma_handle_t bus_addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size_t size, enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在驱动访问完DMA缓冲区后，应该将其所有权返还给设备，这可通过如下函数完成：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_sync_single_for_device(struct device *dev, dma_handle_t bus_addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">size_t size, enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果设备要求较大的DMA缓冲区，在其支持SG模式的情况下，申请多个相对较小的不连续的DMA缓冲区通常是防止申请太大的连续物理空间的方法。在Linux内核中，使用如下函数映射SG：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int dma_map_sg(struct device *dev, struct scatterlist *sg, int nents,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>nents是散列表（scatterlist）入口的数量，该函数的返回值是DMA缓冲区的数量，可能小于nents。对于scatterlist中的每个项目，dma_map_sg（）为设备产生恰当的总线地址，它会合并物理上临近的内存区域。</p><p>scatterlist结构体的定义如代码清单11.14所示，它包含了与scatterlist对应的页结构体指针、缓冲区在页中的偏移（offset）、缓冲区长度（length）以及总线地址（dma_address）。</p><p>代码清单11.14　scatterlist结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct scatterlist {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#ifdef CONFIG_DEBUG_SG</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       unsigned long   sg_magic;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       unsigned long   page_link;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       unsigned int    offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       unsigned int    length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       dma_addr_t      dma_address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#ifdef CONFIG_NEED_SG_DMA_LENGTH</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       unsigned int    dma_length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>执行dma_map_sg（）后，通过sg_dma_address（）可返回scatterlist对应缓冲区的总线地址，sg_dma_len（）可返回scatterlist对应缓冲区的长度，这两个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dma_addr_t sg_dma_address(struct scatterlist *sg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int sg_dma_len(struct scatterlist *sg);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在DMA传输结束后，可通过dma_map_sg（）的反函数dma_unmap_sg（）除去DMA映射：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_unmap_sg(struct device *dev, struct scatterlist *list,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int nents, enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>SG映射属于流式DMA映射，与单一缓冲区情况下的流式DMA映射类似，如果设备驱动一定要访问映射情况下的SG缓冲区，应该先调用如下函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int nents, enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>访问完后，通过下列函数将所有权返回给设备：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int nents, enum dma_data_direction direction);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux系统中可以用一个相对简单的方法预先分配缓冲区，那就是同步“mem=”参数预留内存。例如，对于内存为64MB的系统，通过给其传递mem=62MB命令行参数可以使得顶部的2MB内存被预留出来作为I/O内存使用，这2MB内存可以被静态映射，也可以被执行ioremap（）。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="6dmaengine标准api">6.dmaengine标准API<a class="hash-link" href="#6dmaengine标准api" title="标题的直接链接">​</a></h2><p>Linux内核目前推荐使用dmaengine的驱动架构来编写DMA控制器的驱动，同时外设的驱动使用标准的dmaengine API进行DMA的准备、发起和完成时的回调工作。</p><p>和中断一样，在使用DMA之前，设备驱动程序需首先向dmaengine系统申请DMA通道，申请DMA通道的函数如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct dma_chan *dma_request_slave_channel(struct device *dev, const char *name);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct dma_chan *__dma_request_channel(const dma_cap_mask_t *mask,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                         dma_filter_fn fn, void *fn_param);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用完DMA通道后，应该利用如下函数释放该通道：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void dma_release_channel(struct dma_chan *chan);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之后，一般通过如代码清单11.15的方法初始化并发起一次DMA操作。它通过dmaengine_prep_slave_single（）准备好一些DMA描述符，并填充其完成回调为xxx_dma_fini_callback（），之后通过dmaengine_submit（）把这个描述符插入队列，再通过dma_async_issue_pending（）发起这次DMA动作。DMA完成后，xxx_dma_fini_callback（）函数会被dmaengine驱动自动调用。</p><p>代码清单11.15　利用dmaengine API发起一次DMA操作</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void xxx_dma_fini_callback(void *data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct completion *dma_complete = data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        complete(dma_complete);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8issue_xxx_dma(...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      rx_desc = dmaengine_prep_slave_single(xxx-&gt;rx_chan,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11              xxx-&gt;dst_start, t-&gt;len, DMA_DEV_TO_MEM,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12              DMA_PREP_INTERRUPT | DMA_CTRL_ACK);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      rx_desc-&gt;callback = xxx_dma_fini_callback;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      rx_desc-&gt;callback_param = &amp;xxx-&gt;rx_done;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      dmaengine_submit(rx_desc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17      dma_async_issue_pending(xxx-&gt;rx_chan);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.265Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->16 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在块设备驱动中，有一个类似于字符设备驱动中file_operations结构体的block_device_operations结构体，它是对块设备操作的集合，定义如代码清单13.1所示。</p><p>代码清单13.1　block_device_operations结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct block_device_operations {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2       int (*open) (struct block_device *, fmode_t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3       void (*release) (struct gendisk *, fmode_t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4       int (*rw_page)(struct block_device *, sector_t, struct page *, int rw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       int (*direct_access) (struct block_device *, sector_t,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                                         void **, unsigned long *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       unsigned int (*check_events) (struct gendisk *disk,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                                unsigned int clearing);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       /* -&gt;media_changed() is DEPRECATED, use -&gt;check_events() instead */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       int (*media_changed) (struct gendisk *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       void (*unlock_native_capacity) (struct gendisk *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       int (*revalidate_disk) (struct gendisk *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       int (*getgeo)(struct block_device *, struct hd_geometry *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       /* this callback is with swap_lock and sometimes page table lock held */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       void (*swap_slot_free_notify) (struct block_device *, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       struct module *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面对其主要成员函数进行分析。</p><p>1.打开和释放</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int (*open) (struct block_device *, fmode_t);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void (*release) (struct gendisk *, fmode_t);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与字符设备驱动类似，当设备被打开和关闭时将调用它们。</p><p>2.I/O控制</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数是ioctl（）系统调用的实现，块设备包含大量的标准请求，这些标准请求由Linux通用块设备层处理，因此大部分块设备驱动的ioctl（）函数相当短。当一个64位系统内的32位进程调用ioctl（）的时候，调用的是compat_ioctl（）。</p><p>3.介质改变</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int (*media_changed) (struct gendisk *gd);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>被内核调用以检查驱动器中的介质是否已经改变，如果是，则返回一个非0值，否则返回0。这个函数仅适用于支持可移动介质的驱动器，通常需要在驱动中增加一个表示介质状态是否改变的标志变量，非可移动设备的驱动不需要实现这个方法。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int (*check_events) (struct gendisk *disk,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                              unsigned int clearing);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>media_changed（）这个回调函数目前已经过时了，已被check_events（）替代。Tejun Heo<a href="mailto:tj@kernel.org" target="_blank" rel="noopener noreferrer">tj@kernel.org</a>在内核提交了一个补丁，完成了“implement in-kernel gendisk events handling”的工作，这个补丁对应的commit ID是77ea887e。老的Linux在用户空间里轮询可移动磁盘介质是否存在，而新的内核则在内核空间里轮询。check_events（）函数检查有没有挂起的事件，如果有DISK_EVENT_MEDIA_CHANGE和DISK_EVENT_EJECT_REQUEST事件，就返回。</p><p>4.使介质有效</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int (*revalidate_disk) (struct gendisk *gd);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>revalidate_disk（）函数被调用来响应一个介质改变，它给驱动一个机会来进行必要的工作以使新介质准备好。</p><p>5.获得驱动器信息</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int (*getgeo)(struct block_device *, struct hd_geometry *);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数根据驱动器的几何信息填充一个hd_geometry结构体，hd_geometry结构体包含磁头、扇区、柱面等信息，其定义于include/linux/hdreg.h头文件中。</p><p>6.模块指针</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct module *owner;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>一个指向拥有这个结构体的模块的指针，它通常被初始化为THIS_MODULE。</p><h1>13.2.2　gendisk结构体</h1><p>在Linux内核中，使用gendisk（通用磁盘）结构体来表示一个独立的磁盘设备（或分区），这个结构体的定义如代码清单13.2所示。</p><p>代码清单13.2　gendisk结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct gendisk {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        /* major, first_minor and minors are input parameters only,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         * don&#x27;t use directly.  Use disk_devt() and disk_max_parts().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int major;        /* major number of driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int first_minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        int minors;       /* maximum number of minors, =1for</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                           * disks that can&#x27;t be partitioned. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        char disk_name[DISK_NAME_LEN];    /* name of major driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        char *(*devnode)(struct gendisk *gd, umode_t *mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        unsigned int events;              /* supported events */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        unsigned int async_events;        /* async events, subset of all */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        /* Array of pointers to partitions indexed by partno.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         * Protected with matching bdev lock but stat and other</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         * non-critical accesses use RCU.  Always access through</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         * helpers.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        struct disk_part_tbl __rcu *part_tbl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        struct hd_struct part0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        const struct block_device_operations *fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        struct request_queue *queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        void *private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        int flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        struct device *driverfs_dev;  // FIXME: remove</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        struct kobject *slave_dir;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        struct timer_rand_state *random;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        atomic_t sync_io;          /* RAID */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34        struct disk_events *ev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35#ifdef  CONFIG_BLK_DEV_INTEGRITY</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36        struct blk_integrity *integrity;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38        int node_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>major、first_minor和minors共同表征了磁盘的主、次设备号，同一个磁盘的各个分区共享一个主设备号，而次设备号则不同。fops为block_device_operations，即上节描述的块设备操作集合。queue是内核用来管理这个设备的I/O请求队列的指针。private_data可用于指向磁盘的任何私有数据，用法与字符设备驱动file结构体的private_data类似。hd_struct成员表示一个分区，而disk_part_tbl成员用于容纳分区表，part0和part_tbl两者的关系在于：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">disk-&gt;part_tbl-&gt;part[0] = &amp;disk-&gt;part0;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Linux内核提供了一组函数来操作gendisk，如下所示。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1分配gendisk">1.分配gendisk<a class="hash-link" href="#1分配gendisk" title="标题的直接链接">​</a></h2><p>gendisk结构体是一个动态分配的结构体，它需要特别的内核操作来初始化，驱动不能自己分配这个结构体，而应该使用下列函数来分配gendisk：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct gendisk *alloc_disk(int minors);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>minors参数是这个磁盘使用的次设备号的数量，一般也就是磁盘分区的数量，此后minors不能被修改。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2增加gendisk">2.增加gendisk<a class="hash-link" href="#2增加gendisk" title="标题的直接链接">​</a></h2><p>gendisk结构体被分配之后，系统还不能使用这个磁盘，需要调用如下函数来注册这个磁盘设备。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void add_disk(struct gendisk *disk);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3释放gendisk">3.释放gendisk<a class="hash-link" href="#3释放gendisk" title="标题的直接链接">​</a></h2><p>当不再需要磁盘时，应当使用如下函数释放gendisk。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void del_gendisk(struct gendisk *gp);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="4gendisk引用计数">4.gendisk引用计数<a class="hash-link" href="#4gendisk引用计数" title="标题的直接链接">​</a></h2><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct kobject *get_disk(struct gendisk *disk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void put_disk(struct gendisk *disk);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前者最终会调用“kobject_get（&amp;disk_to_dev（disk）-&gt;kobj）；”，而后者则会调用“kobject_put（&amp;disk_to_dev（disk）-&gt;kobj）；”。</p><h1>13.2.3　bio、request和request_queue</h1><p>通常一个bio对应上层传递给块层的I/O请求。每个bio结构体实例及其包含的bvec_iter、bio_vec结构体实例描述了该I/O请求的开始扇区、数据方向（读还是写）、数据放入的页，其定义如代码清单13.3所示。</p><p>代码清单13.3　bio结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct bvec_iter {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        sector_t                bi_sector;   /* device address in 512byte</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3                                             sectors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        unsigned int            bi_size;     /* residual I/O count */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        unsigned int            bi_idx;      /* current index into bvl_vec */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        unsigned int            bi_bvec_done;      /* number of bytes completed</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                                                    in current bvec */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 * main unit of I/O for the block layer and lower layers (ie drivers and</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 * stacking drivers)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16struct bio {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        struct bio              *bi_next;   /* request queue link */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        struct block_device     *bi_bdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        unsigned long           bi_flags;   /* status, command, etc */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        unsigned long           bi_rw;      /* bottom bits READ/WRITE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                                           * top bits priority</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22                                           */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        struct bvec_iter        bi_iter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        /* Number of segments in this BIO after</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         * physical address coalescing is performed.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        unsigned int            bi_phys_segments;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        struct bio_vec          *bi_io_vec;  /* the actual vec list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35        struct bio_set          *bi_pool;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38         * We can inline a number of vecs at the end of the bio, to avoid</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39         * double allocations for a small number of bio_vecs. This member</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40         * MUST obviously be kept at the very end of the bio.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42        struct bio_vec          bi_inline_vecs[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与bio对应的数据每次存放的内存不一定是连续的，bio_vec结构体用来描述与这个bio请求对应的所有的内存，它可能不总是在一个页面里面，因此需要一个向量，定义如代码清单13.4所示。向量中的每个元素实际是一个<!-- -->[page，offset，len]<!-- -->，我们一般也称它为一个片段。</p><p>代码清单13.4　bio_vec结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct bio_vec {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2       struct page     *bv_page;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3       unsigned int    bv_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4       unsigned int    bv_offset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>I/O调度算法可将连续的bio合并成一个请求。请求是bio经由I/O调度进行调整后的结果，这是请求和bio的区别。因此，一个request可以包含多个bio。当bio被提交给I/O调度器时，I/O调度器可能会将这个bio插入现存的请求中，也可能生成新的请求。</p><p>每个块设备或者块设备的分区都对应有自身的request_queue，从I/O调度器合并和排序出来的请求会被分发（Dispatch）到设备级的request_queue。图13.3描述了request_queue、request、bio、bio_vec之间的关系。</p><p><img loading="lazy" alt="1744553662621" src="/assets/images/1744553662621-3444ff70473d4562e69840a20aad7f1d.png" width="1354" height="652" class="img_ev3q"></p><p>图13.3　request_queue、request、bio和bio_vec</p><p>下面看一下驱动中涉及的处理bio、request和request_queue的主要API。</p><p>（1）初始化请求队列</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">request_queue_t *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数的第一个参数是请求处理函数的指针，第二个参数是控制访问队列权限的自旋锁，这个函数会发生内存分配的行为，它可能会失败，因此一定要检查它的返回值。这个函数一般在块设备驱动的初始化过程中调用。</p><p>（2）清除请求队列</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void blk_cleanup_queue(request_queue_t * q);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数完成将请求队列返回给系统的任务，一般在块设备驱动卸载过程中调用。</p><p>（3）分配请求队列</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">request_queue_t *blk_alloc_queue(int gfp_mask);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于RAMDISK这种完全随机访问的非机械设备，并不需要进行复杂的I/O调度，这个时候，可以直接“踢开”I/O调度器，使用如下函数来绑定请求队列和“制造请求”函数（make_request_fn）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void blk_queue_make_request(request_queue_t * q, make_request_fn * mfn);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>blk_alloc_queue（）和blk_queue_make_request（）结合起来使用的逻辑一般是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">xxx_queue = blk_alloc_queue(GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">blk_queue_make_request(xxx_queue, xxx_make_request);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>（4）提取请求</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct request * blk_peek_request(struct request_queue *q);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数用于返回下一个要处理的请求（由I/O调度器决定），如果没有请求则返回NULL。它不会清除请求，而是仍然将这个请求保留在队列上。原先的老的函数elv_next_request（）已经不再存在。</p><p>（5）启动请求</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void blk_start_request(struct request *req);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从请求队列中移除请求。原先的老的API blkdev_dequeue_request（）会在blk_start_request（）内部被调用。</p><p>我们可以考虑使用blk_fetch_request（）函数，它同时做完了blk_peek_request（）和blk_start_request（）的工作，如代码清单13.5所示。</p><p>代码清单13.5　blk_fetch_request（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct request *blk_fetch_request(struct request_queue *q)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3       struct request *rq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5       rq = blk_peek_request(q);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6       if (rq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7               blk_start_request(rq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8       return rq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">9}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>（6）遍历bio和片段</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define __rq_for_each_bio(_bio, rq)    \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if ((rq-&gt;bio))                 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (_bio = (rq)-&gt;bio; _bio; _bio = _bio-&gt;bi_next)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>__rq_for_each_bio（）遍历一个请求的所有bio。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define __bio_for_each_segment(bvl, bio, iter, start)          \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (iter = (start);                                   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             (iter).bi_size &amp;&amp;                                 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                ((bvl = bio_iter_iovec((bio), (iter))), 1);    \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             bio_advance_iter((bio), &amp;(iter), (bvl).bv_len))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define bio_for_each_segment(bvl, bio, iter)                   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __bio_for_each_segment(bvl, bio, iter, (bio)-&gt;bi_iter)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>bio_for_each_segment（）遍历一个bio的所有bio_vec。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define rq_for_each_segment(bvl, _rq, _iter)               \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __rq_for_each_bio(_iter.bio, _rq)                  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                bio_for_each_segment(bvl, _iter.bio, _iter.iter)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>rq_for_each_segment（）迭代遍历一个请求所有bio中的所有segment。</p><p>（7）报告完成</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void __blk_end_request_all(struct request *rq, int error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void blk_end_request_all(struct request *rq, int error);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述两个函数用于报告请求是否完成，error为0表示成功，小于0表示失败。__blk_end_request_all（）需要在持有队列锁的场景下调用。</p><p>类似的函数还有blk_end_request_cur（）、blk_end_request_err（）、<strong>blk_end_request（）、</strong>blk_end_request_all（）、<strong>blk_end_request_cur（）以及</strong>blk_end_request_err（）。其中xxx_end_request_cur（）只是表明完成了request中当前的那个chunk，也就是完成了当前的bio_cur_bytes（rq-&gt;bio）的传输。</p><p>若我们用blk_queue_make_request（）绕开I/O调度，但是在bio处理完成后应该使用bio_endio（）函数通知处理结束：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void bio_endio(struct bio *bio, int error);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果是I/O操作故障，可以调用快捷函数bio_io_error（），它定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define bio_io_error(bio) bio_endio((bio), -EIO)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>13.2.4　I/O调度器</h1><p>Linux 2.6以后的内核包含4个I/O调度器，它们分别是Noop I/O调度器、Anticipatory I/O调度器、Deadline I/O调度器与CFQ I/O调度器。其中，Anticipatory I/O调度器算法已经在2010年从内核中去掉了。</p><p>Noop I/O调度器是一个简化的调度程序，该算法实现了一个简单FIFO队列，它只进行最基本的合并，比较适合基于Flash的存储器。</p><p>Anticipatory I/O调度器算法推迟I/O请求，以期能对它们进行排序，获得最高的效率。在每次处理完读请求之后，不是立即返回，而是等待几个微秒。在这段时间内，任何来自临近区域的请求都被立即执行。超时以后，继续原来的处理。</p><p>Deadline I/O调度器是针对Anticipatory I/O调度器的缺点进行改善而得来的，它试图把每次请求的延迟降至最低，该算法重排了请求的顺序来提高性能。它使用轮询的调度器，简洁小巧，提供了最小的读取延迟和尚佳的吞吐量，特别适合于读取较多的环境（比如数据库）。</p><p>CFQ I/O调度器为系统内的所有任务分配均匀的I/O带宽，提供一个公平的工作环境，在多媒体应用中，能保证音、视频及时从磁盘中读取数据</p><p>内核4.0-rc1block目录中的noop-iosched.c、deadline-iosched.c和cfq-iosched.c文件分别实现了IOSCHED_NOOP、IOSCHED_DEADLINE和IOSCHED_CFQ调度算法。as-iosched.c这个文件目前已经不再存在。当前情况下，默认的调度器是CFQ。</p><p>可以通过给内核添加启动参数，选择所使用的I/O调度算法，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">kernel elevator=deadline</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>也可以通过类似如下的命令，改变一个设备的调度器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">echo SCHEDULER &gt; /sys/block/DEVICE/queue/scheduler</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.265Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux的“/proc/kallsyms”文件对应着内核符号表，它记录了符号以及符号所在的内存地址。</p><p>模块可以使用如下宏导出符号到内核符号表中：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">EXPORT_SYMBOL(符号名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">EXPORT_SYMBOL_GPL(符号名</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>导出的符号可以被其他模块使用，只需使用前声明一下即可。EXPORT_SYMBOL_GPL（）只适用于包含GPL许可权的模块。代码清单4.5给出了一个导出整数加、减运算函数符号的内核模块的例子。</p><p>代码清单4.5　内核模块中的符号导出</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 #include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 #include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 int add_integar(int a, int b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   return a + b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 EXPORT_SYMBOL_GPL(add_integar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 int sub_integar(int a, int b)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   return a - b;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 EXPORT_SYMBOL_GPL(sub_integar);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从“/proc/kallsyms”文件中找出add_integar、sub_integar的相关信息</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># grep integar /proc/kallsyms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e679402c r __ksymtab_sub_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e679403c r __kstrtab_sub_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e6794038 r __kcrctab_sub_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e6794024 r __ksymtab_add_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e6794048 r __kstrtab_add_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e6794034 r __kcrctab_add_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e6793000 t add_integar    [export_symb]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e6793010 t sub_integar    [export_symb]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.249Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->9 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>USB主机控制器有这些规格：OHCI（Open Host Controller Interface）、UHCI（Universal Host Controller Interface）、EHCI（Enhanced Host Controller Interface）和xHCI（eXtensible Host Controller Interface）。OHCI驱动程序用来为非PC系统上以及带有SiS和ALi芯片组的PC主板上的USB芯片提供支持。UHCI驱动程序多用来为大多数其他PC主板（包括Intel和Via）上的USB芯片提供支持。EHCI由USB 2.0规范所提出，它兼容于OHCI和UHCI。由于UHCI的硬件线路比OHCI简单，所以成本较低，但需要较复杂的驱动程序，CPU负荷稍重。xHCI，即可扩展的主机控制器接口是Intel公司开发的一个USB主机控制器接口，它目前主要是面向USB 3.0的，同时它也支持USB 2.0及以下的设备。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1主机控制器驱动">1.主机控制器驱动<a class="hash-link" href="#1主机控制器驱动" title="标题的直接链接">​</a></h2><p>在Linux内核中，用usb_hcd结构体描述USB主机控制器驱动，它包含USB主机控制器的“家务”信息、硬件资源、状态描述和用于操作主机控制器的hc_driver等，其定义如代码清单16.6所示</p><p>代码清单16.6　usb_hcd结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_hcd {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   struct usb_bus         self;           /* hcd is-a bus */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   struct kref        kref;               /* reference counter */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   const char         *product_desc;      /* product/vendor string */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   int            speed;                  /* Speed for this roothub.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                           * May be different from</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                           * hcd-&gt;driver-&gt;flags &amp; HCD_MASK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                           */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   char           irq_descr[24];          /* driver + bus # */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   struct timer_list rh_timer;            /* drives root-hub polling */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   struct urb     *status_urb;            /* the current status urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14#ifdef CONfiG_PM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   struct work_struct    wakeup_work;     /* for remote wakeup */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   const struct hc_driver    *driver;     /* hw-specific hooks */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20   struct usb_phy        *usb_phy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   struct phy        *phy;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23   unsigned long     flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27   /* The HC driver&#x27;s private data is stored at the end of</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28   * this structure.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29   */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30   unsigned long hcd_priv[0]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31            __attribute__ ((aligned(sizeof(s64))));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_hcd结构体中第18行的hc_driver成员非常重要，它包含具体的用于操作主机控制器的钩子函数，即“hw-specific hooks”，其定义如代码清单16.7所示。</p><p>代码清单16.7　hc_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct hc_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   const char   *description;          /* &quot;ehci-hcd&quot; etc */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   const char   *product_desc;         /* product/vendor string */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   size_t       hcd_priv_size;         /* size of private data */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   /* irq handler */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   irqreturn_t(*irq) (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   int flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   /* called to init HCD and root hub */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   int (*reset) (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   int (*start) (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   /* cleanly make HCD stop writing memory and doing I/O */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   void (*stop) (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   /* shutdown HCD */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   void (*shutdown) (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   /* return current frame number */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22   int (*get_frame_number) (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   /* manage i/o requests, device state */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   int (*urb_enqueue)(struct usb_hcd *hcd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26                      struct urb *urb, gfp_t mem_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27   int (*urb_dequeue)(struct usb_hcd *hcd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28               struct urb *urb, int status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        /* Allocate endpoint resources and add them to a new schedule */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31   int (*add_endpoint)(struct usb_hcd *, struct usb_device *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32               struct usb_host_endpoint *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        /* Drop an endpoint from a new schedule */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34   int (*drop_endpoint)(struct usb_hcd *, struct usb_device *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                        struct usb_host_endpoint *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37   int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38   void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39        /* Returns the hardware-chosen device address */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40   int (*address_device)(struct usb_hcd *, struct usb_device *udev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42   int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43   /* USB 3.0 Link Power Management */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44        /* Returns the USB3 hub-encoded value for the U1/U2 timeout. */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45   int (*enable_usb3_lpm_timeout)(struct usb_hcd *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46           struct usb_device *, enum usb3_link_state state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47   int (*disable_usb3_lpm_timeout)(struct usb_hcd *,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48           struct usb_device *, enum usb3_link_state state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49   int (*find_raw_port_number)(struct usb_hcd *, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50   /* Call for power on/off the port if necessary */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51   int (*port_power)(struct usb_hcd *hcd, int portnum, bool enable);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在Linux内核中，使用如下函数来创建HCD：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      struct device *dev, char *bus_name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如下函数被用来增加和移除HCD：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_add_hcd(struct usb_hcd *hcd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       unsigned int irqnum, unsigned long irqflags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void usb_remove_hcd(struct usb_hcd *hcd);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第25行的urb_enqueue（）函数非常关键，实际上，上层通过usb_submit_urb（）提交1个USB请求后，该函数调用usb_hcd_submit_urb（），并最终调用至usb_hcd的driver成员（hc_driver类型）的urb_enqueue（）函数。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2ehci主机控制器驱动">2.EHCI主机控制器驱动<a class="hash-link" href="#2ehci主机控制器驱动" title="标题的直接链接">​</a></h2><p>EHCI HCD驱动属于HCD驱动的实例，它定义了一个ehci_hcd结构体，通常作为代码清单16.6定义的usb_hcd结构体的私有数据（hcd_priv），这个结构体的定义位于drivers/usb/host/ehci.h中，如代码清单16.8所示。</p><p>代码清单16.8　ehci_hcd结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct ehci_hcd {                      /* one per controller */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   /* timing support */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   enum ehci_hrtimer_event    next_hrtimer_event;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   unsigned     enabled_hrtimer_events;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   ktime_t          hr_timeouts[EHCI_HRTIMER_NUM_EVENTS];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   struct hrtimer       hrtimer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   int          PSS_poll_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   int          ASS_poll_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   int          died_poll_count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   /* general schedule support */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   bool         scanning:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   bool         need_rescan:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   bool         intr_unlinking:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   bool         iaa_in_progress:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17   bool         async_unlinking:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   bool         shutdown:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   struct ehci_qh        *qh_scan_next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   /* async schedule support */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22   struct ehci_qh        *async;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23   struct ehci_qh        *dummy;         /* For AMD quirk use */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   struct list_head  async_unlink;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   struct list_head  async_idle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   unsigned     async_unlink_cycle;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27   unsigned     async_count;             /* async activity count */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29   /* periodic schedule support */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30#define    DEFAULT_I_TDPS       1024   /* some HCs can do less */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31   unsigned      periodic_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32   __hc32            *periodic;          /* hw periodic table */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33   dma_addr_t        periodic_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34   struct list_head  intr_qh_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35   unsigned     i_thresh;                /* uframes HC might cache */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37   /* bandwidth usage */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38#define EHCI_BANDWIDTH_SIZE 64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39#define EHCI_BANDWIDTH_FRAMES   (EHCI_BANDWIDTH_SIZE &gt;&gt; 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40   u8           bandwidth[EHCI_BANDWIDTH_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41                         /* us allocated per uframe */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42   u8           tt_budget[EHCI_BANDWIDTH_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                         /* us budgeted per uframe */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44   struct list_head tt_list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46   /* platform-specific data -- must come last */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47   unsigned long    priv[0] __aligned(sizeof(s64));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用如下内联函数可实现usb_hcd和ehci_hcd的相互转换：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct ehci_hcd *hcd_to_ehci (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct usb_hcd *ehci_to_hcd (const struct ohci_hcd *ohci);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从usb_hcd得到ehci_hcd只是取得“私有”数据，而从ehci_hcd得到usb_hcd则是通过container_of（）从结构体成员获得结构体指针。</p><p>使用如下函数可初始化EHCI主机控制器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int ehci_init(struct usb_hcd *hcd);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如下函数分别用于开启、停止及复位EHCI控制器：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int ehci_run (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void ehci_stop (struct usb_hcd *hcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int ehci_reset (struct ehci_hcd *ehci);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数在drivers/usb/host/ehci-hcd.c文件中被填充给了一个hc_driver结构体的generic的实例ehci_hc_driver。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct hc_driver ehci_hc_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .reset =             ehci_setup,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .start =             ehci_run,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .stop =              ehci_stop,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .shutdown =          ehci_shutdown,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/usb/host/ehci-hcd.c实现了绝大多数ECHI主机驱动的工作，具体的EHCI实例简单地调用</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void ehci_init_driver(struct hc_driver *drv,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">             const struct ehci_driver_overrides *over);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>初始化hc_driver即可，这个函数会被generic的ehci_hc_driver实例复制给每个具体底层驱动的实例，当然底层驱动可以通过第2个参数，即ehci_driver_overrides重写中间层的reset（）、port_power（）这2个函数，另外也可以填充一些额外的私有数据，这一点从代码清单16.9ehci_init_driver（）的实现中可以看出。</p><p>代码清单16.9　ehci_init_driver的实现</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void ehci_init_driver(struct hc_driver *drv,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2               const struct ehci_driver_overrides *over)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        /* Copy the generic table to drv and then apply the overrides */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        *drv = ehci_hc_driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        if (over) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8               drv-&gt;hcd_priv_size += over-&gt;extra_priv_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               if (over-&gt;reset)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                      drv-&gt;reset = over-&gt;reset;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11               if (over-&gt;port_power)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                      drv-&gt;port_power = over-&gt;port_power;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>16.2.2　实例：Chipidea USB主机驱动</h1><p>Chipidea的USB IP在嵌入式系统中应用比较广泛，它的驱动位于drivers/usb/chipidea/目录下</p><p>当Chipidea USB驱动的内核代码drivers/usb/chipidea/core.c中的ci_hdrc_probe（）被执行后（即一个platform_device与ci_hdrc_driver这个platform_driver匹配上了），它会调用drivers/usb/chipidea/host.c中的ci_hdrc_host_init（）函数，该函数完成hc_driver的初始化并赋值一系列与Chipidea平台相关的私有数据，如代码清单16.10所示。</p><p>代码清单16.10　Chipidea USB host驱动初始化</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int ci_hdrc_host_init(struct ci_hdrc *ci)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct ci_role_driver *rdrv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6               return -ENXIO;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        rdrv = devm_kzalloc(ci-&gt;dev, sizeof(struct ci_role_driver), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        if (!rdrv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10               return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        rdrv-&gt;start    = host_start;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        rdrv-&gt;stop     = host_stop;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        rdrv-&gt;irq      = host_irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        rdrv-&gt;name     = &quot;host&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        ci-&gt;roles[CI_ROLE_HOST] = rdrv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        ehci_init_driver(&amp;ci_ehci_hc_driver, &amp;ehci_ci_overrides);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/12"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/14"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>