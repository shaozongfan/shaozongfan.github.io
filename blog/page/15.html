<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/15"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/15"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/15" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/15" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.149Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>信号量（Semaphore）是操作系统中最典型的用于同步和互斥的手段，信号量的值可以是0、1或者n。信号量与操作系统中的经典概念PV操作对应。</p><p>P（S）：</p><p>①将信号量S的值减1，即S=S-1；</p><p>②如果S≥0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。</p><p>V（S）：</p><p>①将信号量S的值加1，即S=S+1；</p><p>②如果S&gt;0，唤醒队列中等待信号量的进程。</p><p>Linux中与信号量相关的操作主要有下面几种。</p><p>1.定义信号量</p><p>下列代码定义名称为sem的信号量：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct semaphore sem;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.初始化信号量</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void sema_init(struct semaphore *sem, int val);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数初始化信号量，并设置信号量sem的值为val。</p><p>3.获得信号量</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void down(struct semaphore * sem);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于获得信号量sem，它会导致睡眠，因此不能在中断上下文中使用。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int down_interruptible(struct semaphore * sem);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数功能与down类似，不同之处为，因为down（）进入睡眠状态的进程不能被信号打断，但因为down_interruptible（）进入睡眠状态的进程能被信号打断，信号也会导致该函数返回，这时候函数的返回值非0。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int down_trylock(struct semaphore * sem);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数尝试获得信号量sem，如果能够立刻获得，它就获得该信号量并返回0，否则，返回非0值。它不会导致调用者睡眠，可以在中断上下文中使用。</p><p>在使用down_interruptible（）获取信号量时，对返回值一般会进行检查，如果非0，通常立即返回-ERESTARTSYS，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">if (down_interruptible(&amp;sem))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return  -ERESTARTSYS;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>4.释放信号量</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void up(struct semaphore * sem);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数释放信号量sem，唤醒等待者。</p><p>作为一种可能的互斥手段，信号量可以保护临界区，它的使用方式和自旋锁类似。与自旋锁相同，只有得到信号量的进程才能执行临界区代码。但是，与自旋锁不同的是，当获取不到信号量时，进程不会原地打转而是进入休眠等待状态。用作互斥时，信号量一般这样被使用：</p><p><img loading="lazy" alt="1743087820346" src="/assets/images/1743087820346-50c8755590dfbdeaa9ad3fbfef2c0019.png" width="1024" height="181" class="img_ev3q"></p><p><img loading="lazy" alt="1743087835064" src="/assets/images/1743087835064-ea6134afa54489c165c9b5fd2fd3d147.png" width="1018" height="169" class="img_ev3q"></p><p>由于新的Linux内核倾向于直接使用mutex作为互斥手段，信号量用作互斥不再被推荐使用。</p><p>信号量也可以用于同步，一个进程A执行down（）等待信号量，另外一个进程B执行up（）释放信号量，这样进程A就同步地等待了进程B。其过程类似：</p><p><img loading="lazy" alt="1743087864651" src="/assets/images/1743087864651-6f01ea0a273d558104ce9412212e5b19.png" width="1047" height="235" class="img_ev3q"></p><p>此外，对于关心具体数值的生产者/消费者问题，使用信号量则较为合适。因为生产者/消费者问题也是一种同步问题。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.137Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->10 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在一个SoC中，晶振、PLL、驱动和门等会形成一个时钟树形结构，在Linux 2.6中，也存有clk_get_rate（）、clk_set_rate（）、clk_get_parent（）、clk_set_parent（）等通用API，但是这些API由每个SoC单独实现，而且各个SoC供应商在实现方面的差异很大，于是内核增加了一个新的通用时钟框架以解决这个碎片化问题。之所以称为通用时钟，是因为这个通用主要体现在：</p><p>1）统一的clk结构体，统一的定义于clk.h中的clk API，这些API会调用统一的clk_ops中的回调函数；这个统一的clk结构体的定义如代码清单20.22所示。</p><p>代码清单20.22　clk结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct clk {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        const char              *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        const struct clk_ops    *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct clk_hw           *hw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        char                    **parent_names;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        struct clk              **parents;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        struct clk              *parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        struct hlist_head       children;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        struct hlist_node       child_node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中第3行的clk_ops定义是关于时钟使能、禁止、计算频率等的操作集，定义如代码清单20.23所示。</p><p>代码清单20.23　clk_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct clk_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2               int             (*prepare)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3               void            (*unprepare)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4               int             (*enable)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5               void            (*disable)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6               int             (*is_enabled)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7               unsigned long   (*recalc_rate)(struct clk_hw *hw,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8                                               unsigned long parent_rate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               long            (*round_rate)(struct clk_hw *hw, unsigned long,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                                               unsigned long *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11               int             (*set_parent)(struct clk_hw *hw, u8 index);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12               u8              (*get_parent)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13               int             (*set_rate)(struct clk_hw *hw, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               void            (*init)(struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2）对具体的SoC如何去实现针对自己SoC的clk驱动，如何提供硬件特定的回调函数的方法也进行了统一。</p><p>在代码清单20.22这个通用的clk结构体中，第4行的clk_hw是联系clk_ops中回调函数和具体硬件细节的纽带，clk_hw中只包含通用时钟结构体的指针以及具体硬件的init数据，如代码清单20.24所示。</p><p>代码清单20.24　clk_hw结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct clk_hw {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2         struct clk *clk;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         const struct clk_init_data *init;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中的clk_init_data包含了具体时钟的名称、可能的父级时钟的名称列表parent_names、可能的父级时钟数量num_parents等，实际上这些名称的匹配对建立时钟间的父子关系功不可没，如代码清单20.25所示。</p><p>代码清单20.25　clk_init_data结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct clk_init_data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        const char              *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        const struct clk_ops    *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        const char              **parent_names;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        u8                      num_parents;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        unsigned long           flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从clk核心层到具体芯片clk驱动的调用顺序为：</p><p>clk_enable（clk）；<!-- -->[插图]<!-- --> clk-&gt;ops-&gt;enable（clk-&gt;hw）；</p><p>通用的clk API（如clk_enable）在调用底层clk结构体的clk_ops成员函数（如clk-&gt;ops-&gt;enable）时，会将clk-&gt;hw传递过去。</p><p>一般在具体的驱动中会定义针对特定clk（如foo）的结构体，该结构体中包含clk_hw成员以及硬件私有数据：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct clk_foo {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct clk_hw hw;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       ... hardware specific data goes here ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>并定义to_clk_foo（）宏，以便通过clk_hw获取clk_foo：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define to_clk_foo(_hw) container_of(_hw, struct clk_foo, hw)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在针对clk_foo的clk_ops的回调函数中，我们便可以通过clk_hw和to_clk_foo最终获得硬件私有数据，并访问硬件读写寄存器以改变时钟的状态：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct clk_ops clk_foo_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .enable         = &amp;clk_foo_enable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .disable        = &amp;clk_foo_disable;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int clk_foo_enable(struct clk_hw *hw)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       struct clk_foo *foo;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       foo = to_clk_foo(hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       /* 访问硬件读写寄存器以改变时钟的状态*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在具体的clk驱动中，需要通过clk_register（）以及它的变体注册硬件上所有的clk，通过clk_register_clkdev（）注册clk的一个lookup（这样可以通过con_id或者dev_id字符串寻找到这个clk），这两个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *clk_register(struct device *dev, struct clk_hw *hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int clk_register_clkdev(struct clk *clk, const char *con_id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         const char *dev_fmt, ...);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，针对不同的clk类型（如固定频率的clk、clk门、clk驱动等），clk子系统又提供了几个快捷函数以完成clk_register（）的过程：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *clk_register_fixed_rate(struct device *dev, const char *name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const char *parent_name, unsigned long flags,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                unsigned long fixed_rate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *clk_register_gate(struct device *dev, const char *name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const char *parent_name, unsigned long flags,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                void __iomem *reg, u8 bit_idx,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                u8 clk_gate_flags, spinlock_t *lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *clk_register_divider(struct device *dev, const char *name,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                const char *parent_name, unsigned long flags,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                void __iomem *reg, u8 shift, u8 width,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                u8 clk_divider_flags, spinlock_t *lock);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以drivers/clk/clk-prima2.c为例，与该驱动对应的芯片SiRFprimaII的外围接了一个26MHz的晶振和一个32.768kHz的RTC晶振，在26MHz晶振的后面又有3个PLL，当然PLL后面又接了更多的clk节点，则它的相关驱动代码如清单20.26所示。</p><p>代码清单20.26　clk驱动案例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static unsigned long pll_clk_recalc_rate(struct clk_hw *hw,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2unsigned long parent_rate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4unsigned long fin = parent_rate;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5struct clk_pll *clk = to_pllclk(hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9static long pll_clk_round_rate(struct clk_hw *hw, unsigned long rate,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10unsigned long *parent_rate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15static int pll_clk_set_rate(struct clk_hw *hw, unsigned long rate,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16unsigned long parent_rate)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21static struct clk_ops std_pll_ops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22.recalc_rate = pll_clk_recalc_rate,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23.round_rate = pll_clk_round_rate,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24.set_rate = pll_clk_set_rate,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27static const char *pll_clk_parents[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28&quot;osc&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31static struct clk_init_data clk_pll1_init = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32.name = &quot;pll1&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33.ops = &amp;std_pll_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34.parent_names = pll_clk_parents,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35.num_parents = ARRAY_SIZE(pll_clk_parents),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38static struct clk_init_data clk_pll2_init = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39.name = &quot;pll2&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40.ops = &amp;std_pll_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41.parent_names = pll_clk_parents,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42.num_parents = ARRAY_SIZE(pll_clk_parents),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45static struct clk_init_data clk_pll3_init = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46.name = &quot;pll3&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47.ops = &amp;std_pll_ops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48.parent_names = pll_clk_parents,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49.num_parents = ARRAY_SIZE(pll_clk_parents),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52static struct clk_pll clk_pll1 = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53.regofs = SIRFSOC_CLKC_PLL1_CFG0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54.hw = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55        .init = &amp;clk_pll1_init,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59static struct clk_pll clk_pll2 = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60.regofs = SIRFSOC_CLKC_PLL2_CFG0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61.hw = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62        .init = &amp;clk_pll2_init,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66static struct clk_pll clk_pll3 = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67.regofs = SIRFSOC_CLKC_PLL3_CFG0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68.hw = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69        .init = &amp;clk_pll3_init,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70},</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72void __init sirfsoc_of_clk_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76/* These are always available (RTC and 26MHz OSC)*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77clk = clk_register_fixed_rate(NULL, &quot;rtc&quot;, NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78       CLK_IS_ROOT, 32768);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79BUG_ON(!clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80clk = clk_register_fixed_rate(NULL, &quot;osc&quot;, NULL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81       CLK_IS_ROOT, 26000000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82BUG_ON(!clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84clk = clk_register(NULL, &amp;clk_pll1.hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85BUG_ON(!clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">86clk = clk_register(NULL, &amp;clk_pll2.hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">87BUG_ON(!clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">88clk = clk_register(NULL, &amp;clk_pll3.hw);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">89BUG_ON(!clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">90…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">91}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，目前内核更加倡导的方法是通过设备树来描述电路板上的时钟树，以及时钟和设备之间的绑定关系。通常我们需要在clk控制器的节点中定义#clock-cells属性，并且在clk驱动中通过of_clk_add_provider（）注册时钟控制器为一个时钟树的提供者（Provider），并建立系统中各个时钟和索引的映射表，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">       Clock                   ID</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       ---------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       rtc                     0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       osc                     1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       pll1                    2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       pll2                    3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       pll3                    4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       mem                     5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       sys                     6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       security                7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       dsp                     8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       gps                     9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       mf                      10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       …</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在每个具体的设备中，对应的.dts节点上的clocks=&lt;&amp;clks index&gt;属性指向其引用的clk控制器节点以及使用的时钟的索引，如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">gps@a8010000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compatible = &quot;sirf,prima2-gps&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reg = &lt;0xa8010000 0x10000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interrupts = &lt;7&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        clocks = &lt;&amp;clks 9&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>要特别强调的是，在具体的设备驱动中，一定要通过通用clk API来操作所有的时钟，而不要直接通过读写clk控制器的寄存器来进行，这些API包括：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *clk_get(struct device *dev, const char *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *devm_clk_get(struct device *dev, const char *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int clk_enable(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int clk_prepare(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void clk_unprepare(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void clk_disable(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline int clk_prepare_enable(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void clk_disable_unprepare(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned long clk_get_rate(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int clk_set_rate(struct clk *clk, unsigned long rate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct clk *clk_get_parent(struct clk *clk);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int clk_set_parent(struct clk *clk, struct clk *parent);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>值得一提的是，名称中含有prepare、unprepare字符串的API是内核后来才加入的，过去只有clk_enable（）和clk_disable（）。只有clk_enable（）和clk_disable（）带来的问题是，有时候，某些硬件使能/禁止时钟可能会引起睡眠以使得使能/禁止不能在原子上下文进行。加上prepare后，把过去的clk_enable（）分解成不可在原子上下文调用的clk_prepare（）（该函数可能睡眠）和可以在原子上下文调用的clk_enable（）。而clk_prepare_enable（）则同时完成准备和使能的工作，当然也只能在可能睡眠的上下文调用该API。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.125Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->40 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>这里所说的USB设备驱动指的是从主机角度来看，怎样访问被插入的USB设备，而不是指USB设备内部本身运行的固件程序。Linux系统实现了几类通用的USB设备驱动（也称客户驱动），划分为如下几个设备类。</p><ul><li>·音频设备类。</li><li>·通信设备类。</li><li>·HID（人机接口）设备类。</li><li>·显示设备类。</li><li>·海量存储设备类。</li><li>·电源设备类。</li><li>·打印设备类。</li><li>·集线器设备类。</li></ul><p>一般的通用Linux设备（如U盘、USB鼠标、USB键盘等）都不需要工程师再编写驱动，而工程师需要编写的是特定厂商、特定芯片的驱动，而且往往也可以参考已经在内核中提供的驱动模板。</p><p>Linux内核为各类USB设备分配了相应的设备号，如ACM USB调制解调器的主设备号为166（默认设备名/dev/ttyACMn）、USB打印机的主设备号为180，次设备号为0~15（默认设备名/dev/lpn）、USB串口的主设备号为188（默认设备名/dev/ttyUSBn）等，详见<a href="http://www.lanana.org/" target="_blank" rel="noopener noreferrer">http://www.lanana.org/</a> 网站的设备列表。</p><p>在debugfs下，/sys/kernel/debug/usb/devices包含了USB的设备信息，在Ubuntu上插入一个U盘后，我们在/sys/kernel/debug/usb/devices中可看到类似信息。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ sudo cat /sys/kernel/debug/usb/devices</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T:  Bus=02 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">B:  Alloc=  2/900 us ( 0%), #Int=  1, #Iso=  0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">D:  Ver= 1.10 Cls=09(hub  ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">P:  Vendor=1d6b ProdID=0001 Rev= 4.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Manufacturer=Linux 4.0.0-rc1 ohci_hcd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Product=OHCI PCI host controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  SerialNumber=0000:00:06.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=81(I) Atr=03(Int.) MxPS=   2 Ivl=255ms…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T:  Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=480  MxCh= 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">D:  Ver= 2.10 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">P:  Vendor=0930 ProdID=6545 Rev= 1.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Manufacturer=Kingston</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Product=DataTraveler 3.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  SerialNumber=60A44C3FAE22EEA0797900F7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=498mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I:* If#= 0 Alt= 0 #EPs= 2 Cls=08(stor.) Sub=06 Prot=50 Driver=usb-storage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过分析上述记录信息，可以得到系统中USB的完整信息。USBView（<a href="http://www.kroah.com/linux-usb/" target="_blank" rel="noopener noreferrer">http://www.kroah.com/linux-usb/</a> ）是一个图形化的GTK工具，可以显示USB信息。</p><p>此外，在sysfs文件系统中，同样包含了USB相关信息的描述，但只限于接口级别。USB设备和USB接口在sysfs中均表示为单独的USB设备，其目录命名规则如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">根集线器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-集线器端口号（</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-集线器端口号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-...）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">:配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.接口</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面给出一个/sys/bus/usb目录下的树形结构实例，其中的多数文件都是锚定到/sys/devices及/sys/drivers中相应文件的链接。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> devices│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-0:1.0 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-1 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-1:1.0 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-0:1.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2/2-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-1 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2/2-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-1:1.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2/2-1/2-1:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb1 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb2 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> drivers│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> hub│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-0:1.0 -&gt; ../../../../devices/pci0000:00/0000:00:0b.0/usb1/1-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-0:1.0 -&gt; ../../../../devices/pci0000:00/0000:00:06.0/usb2/2-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> module -&gt; ../../../../module/usbcore│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> new_id│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> remove_id│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uevent│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unbind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-1 -&gt; ../../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-1 -&gt; ../../../../devices/pci0000:00/0000:00:06.0/usb2/2-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uevent│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unbind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb1 -&gt; ../../../../devices/pci0000:00/0000:00:0b.0/usb1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb2 -&gt; ../../../../devices/pci0000:00/0000:00:06.0/usb2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正如tty_driver、i2c_driver等，在Linux内核中，使用usb_driver结构体描述一个USB设备驱动，usb_driver结构体的定义如代码清单16.11所示。</p><p>代码清单16.11　usb_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        const char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        int (*probe) (struct usb_interface *intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                    const struct usb_device_id *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        void (*disconnect) (struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                     void *buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        int (*suspend) (struct usb_interface *intf, pm_message_t message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int (*resume) (struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        int (*reset_resume)(struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int (*pre_reset)(struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        int (*post_reset)(struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        const struct usb_device_id *id_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        struct usb_dynids dynids;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        struct usbdrv_wrap drvwrap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        unsigned int no_dynamic_id:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        unsigned int supports_autosuspend:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        unsigned int disable_hub_initiated_lpm:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        unsigned int soft_unbind:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在编写新的USB设备驱动时，主要应该完成的工作是probe（）和disconnect（）函数，即探测和断开函数，它们分别在设备被插入和拔出的时候调用，用于初始化和释放软硬件资源。对usb_driver的注册和注销可通过下面两个函数完成：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register(struct usb_driver *new_driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void usb_deregister(struct usb_driver *driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_driver结构体中的id_table成员描述了这个USB驱动所支持的USB设备列表，它指向一个usb_device_id数组，usb_device_id结构体包含有USB设备的制造商ID、产品ID、产品版本、设备类、接口类等信息及其要匹配标志成员match_flags（标明要与哪些成员匹配，包含DEV_LO、DEV_HI、DEV_CLASS、DEV_SUBCLASS、DEV_PROTOCOL、INT_CLASS、INT_SUBCLASS、INT_PROTOCOL）。可以借助下面一组宏来生成usb_device_id结构体的实例：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_DEVICE(vendor, product)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏根据制造商ID和产品ID生成一个usb_device_id结构体的实例，在数组中增加该元素将意味着该驱动可支持与制造商ID、产品ID匹配的设备。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_DEVICE_VER(vendor, product, lo, hi)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏根据制造商ID、产品ID、产品版本的最小值和最大值生成一个usb_device_id结构体的实例，在数组中增加该元素将意味着该驱动可支持与制造商ID、产品ID匹配和lo~hi范围内版本的设备。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_DEVICE_INFO(class, subclass, protocol)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏用于创建一个匹配设备指定类型的usb_device_id结构体实例。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_INTERFACE_INFO(class, subclass, protocol)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏用于创建一个匹配接口指定类型的usb_device_id结构体实例。</p><p>代码清单16.12所示为两个用于描述某USB驱动支持的USB设备的usb_device_id结构体数组实例。</p><p>代码清单16.12　usb_device_id结构体数组实例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 本驱动支持的USB设备列表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3/* 实例1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4static struct usb_device_id id_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   { USB_DEVICE(VENDOR_ID, PRODUCT_ID) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8MODULE_DEVICE_TABLE (usb, id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10/* 实例2 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11static struct usb_device_id id_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   { .idVendor = 0x10D2, .match_flags = USB_DEVICE_ID_MATCH_VENDOR, },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15MODULE_DEVICE_TABLE (usb, id_table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当USB核心检测到某个设备的属性和某个驱动程序的usb_device_id结构体所携带的信息一致时，这个驱动程序的probe（）函数就被执行（如果这个USB驱动是个模块的话，相关的.ko还应被Linux自动加载）。拔掉设备或者卸掉驱动模块后，USB核心就执行disconnect（）函数来响应这个动作。</p><p>上述usb_driver结构体中的函数是USB设备驱动中与USB相关的部分，而USB只是一个总线，USB设备驱动真正的主体工作仍然是USB设备本身所属类型的驱动，如字符设备、tty设备、块设备、输入设备等。因此USB设备驱动包含其作为总线上挂接设备的驱动和本身所属设备类型的驱动两部分。</p><p>与platform_driver、i2c_driver类似，usb_driver起到了“牵线”的作用，即在probe（）里注册相应的字符、tty等设备，在disconnect（）注销相应的字符、tty等设备，而原先对设备的注册和注销一般直接发生在模块加载和卸载函数中。</p><p>尽管USB本身所属设备驱动的结构与其挂不挂在USB总线上没什么关系，但是据此在访问方式上却有很大的变化，例如，对于USB接口的字符设备而言，尽管仍然是write（）、read（）、ioctl（）这些函数，但是在这些函数中，贯穿始终的是称为URB的USB请求块。</p><p>如图16.3所示，在这棵树里，我们把树根比作主机控制器，树叶比作具体的USB设备，树干和树枝就是USB总线。树叶本身与树枝通过usb_driver连接，而树叶本身的驱动（读写、控制）则需要通过其树叶设备本身所属类设备驱动来完成。树根和树叶之间的“通信”依靠在树干和树枝里“流淌”的URB来完成。</p><p><img loading="lazy" alt="1745247374129" src="/assets/images/1745247374129-31e34ded71baa9955f6b54aa9479649f.png" width="1402" height="1039" class="img_ev3q"></p><p>图16.3　USB设备驱动结构</p><p>由此可见，usb_driver本身只是有找到USB设备、管理USB设备连接和断开的作用，也就是说，它是公司入口处的“打卡机”，可以获得员工（USB设备）的上/下班情况。树叶和员工一样，可以是研发工程师也可以是销售工程师，而作为USB设备的树叶可以是字符树叶、网络树叶或块树叶，因此必须实现相应设备类的驱动。</p><h1>16.3.2　USB请求块</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1urb结构体">1.urb结构体<a class="hash-link" href="#1urb结构体" title="标题的直接链接">​</a></h2><p>USB请求块（USB Request Block，URB）是USB设备驱动中用来描述与USB设备通信所用的基本载体和核心数据结构，非常类似于网络设备驱动中的sk_buff结构体。</p><p>代码清单16.13　URB结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct urb {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /* public: documented fields in the urb that can be used by drivers */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct list_head urb_list;      /* list head for use by the urb&#x27;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                                      * current owner */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        struct usb_host_endpoint *ep;   /* (internal) pointer to endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        unsigned int pipe;              /* (in) pipe information */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        unsigned int stream_id;         /* (in) stream ID */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        int status;                     /* (return) non-ISO status */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        unsigned int transfer_flags;    /* (in) URB_SHORT_NOT_OK | ...*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        void *transfer_buffer;          /* (in) associated data buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        dma_addr_t transfer_dma;        /* (in) dma addr for transfer_buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        struct scatterlist *sg;         /* (in) scatter gather buffer list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int num_mapped_sgs;             /* (internal) mapped sg entries */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int num_sgs;                    /* (in) number of entries in the sg list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        u32 transfer_buffer_length;     /* (in) data buffer length */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        u32 actual_length;              /* (return) actual transfer length */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        unsigned char *setup_packet;    /* (in) setup packet (control only) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        dma_addr_t setup_dma;           /* (in) dma addr for setup_packet */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        int start_frame;                /* (modify) start frame (ISO) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        int number_of_packets;          /* (in) number of ISO packets */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        int interval;                   /* (modify) transfer interval</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                                       * (INT/ISO) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        int error_count;                /* (return) number of ISO errors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        void *context;                  /* (in) context for completion */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        usb_complete_t complete;        /* (in) completion routine */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        struct usb_iso_packet_descriptor iso_frame_desc[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29                                        /* (in) ISO ONLY */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2urb处理流程">2.URB处理流程<a class="hash-link" href="#2urb处理流程" title="标题的直接链接">​</a></h2><p>USB设备中的每个端点都处理一个URB队列，在队列被清空之前，一个URB的典型生命周期如下。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1被一个usb设备驱动创建">1）被一个USB设备驱动创建。<a class="hash-link" href="#1被一个usb设备驱动创建" title="标题的直接链接">​</a></h3><p>创建URB结构体的函数为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>iso_packets是这个URB应当包含的等时数据包的数目，若为0表示不创建等时数据包。mem_flags参数是分配内存的标志，和kmalloc（）函数的分配标志参数含义相同。如果分配成功，该函数返回一个URB结构体指针，否则返回0。</p><p>URB结构体在驱动中不宜静态创建，因为这可能破坏USB核心给URB使用的引用计数方法。</p><p>usb_alloc_urb（）的“反函数”为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_free_urb(struct urb *urb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于释放由usb_alloc_urb（）分配的URB结构体。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_free_urb(struct urb *urb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于释放由usb_alloc_urb（）分配的URB结构体。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2初始化被安排给一个特定usb设备的特定端点">2）初始化，被安排给一个特定USB设备的特定端点。<a class="hash-link" href="#2初始化被安排给一个特定usb设备的特定端点" title="标题的直接链接">​</a></h3><p>对于中断URB，使用usb_fill_int_urb（）函数来初始化URB，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_fill_int_urb(struct urb *urb, struct usb_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unsigned int pipe, void *transfer_buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> int buffer_length, usb_complete_t complete,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void *context, int interval);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>URB参数指向要被初始化的URB的指针；dev指向这个URB要被发送到的USB设备；pipe是这个URB要被发送到的USB设备的特定端点；transfer_buffer是指向发送数据或接收数据的缓冲区的指针，和URB一样，它也不能是静态缓冲区，必须使用kmalloc（）来分配；buffer_length是transfer_buffer指针所指向缓冲区的大小；complete指针指向当这个URB完成时被调用的完成处理函数；context是完成处理函数的“上下文”；interval是这个URB应当被调度的间隔。</p><p>上述函数参数中的pipe使用usb_sndintpipe（）或usb_rcvintpipe（）创建。</p><p>对于批量URB，使用usb_fill_bulk_urb（）函数来初始化，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_fill_bulk_urb(struct urb *urb, struct usb_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unsigned int pipe, void *transfer_buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> int buffer_length, usb_complete_t complete,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void *context);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了没有对应于调度间隔的interval参数以外，该函数的参数和usb_fill_int_urb（）函数的参数含义相同。</p><p>上述函数参数中的pipe使用usb_sndbulkpipe（）或者usb_rcvbulkpipe（）函数来创建。</p><p>对于控制URB，使用usb_fill_control_urb（）函数来初始化，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_fill_control_urb(struct urb *urb, struct usb_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unsigned int pipe, unsigned char *setup_packet,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void *transfer_buffer, int buffer_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb_complete_t complete, void *context);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了增加了新的setup_packet参数以外，该函数的参数和usb_fill_bulk_urb（）函数的参数含义相同。setup_packet参数指向即将被发送到端点的设置数据包。</p><p>上述函数参数中的pipe使用usb_sndctrlpipe（）或usb_rcvictrlpipe（）函数来创建。</p><p>等时URB没有像中断、控制和批量URB的初始化函数usb_fill_iso_urb（），我们只能手动对它初始化，而后才能提交给USB核心。代码清单16.14给出了初始化等时URB的例子，它来自drivers/media/usb/uvc/uvc_video.c文件。</p><p>代码清单16.14　初始化等时URB</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1        for (i = 0; i &lt; UVC_URBS; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2               urb = usb_alloc_urb(npackets, gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3               if (urb == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4                      uvc_uninit_video(stream, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                      return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6               }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8               urb-&gt;dev = stream-&gt;dev-&gt;udev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               urb-&gt;context = stream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10               urb-&gt;pipe = usb_rcvisocpipe(stream-&gt;dev-&gt;udev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                                 ep-&gt;desc.bEndpointAddress);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12#ifndef CONfiG_DMA_NONCOHERENT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13               urb-&gt;transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               urb-&gt;transfer_dma = stream-&gt;urb_dma[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16               urb-&gt;transfer_flags = URB_ISO_ASAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18               urb-&gt;interval = ep-&gt;desc.bInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19               urb-&gt;transfer_buffer = stream-&gt;urb_buffer[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20               urb-&gt;complete = uvc_video_complete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21               urb-&gt;number_of_packets = npackets;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22               urb-&gt;transfer_buffer_length = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24               for (j = 0; j &lt; npackets; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25                      urb-&gt;iso_frame_desc[j].offset = j * psize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26                      urb-&gt;iso_frame_desc[j].length = psize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27               }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29               stream-&gt;urb[i] = urb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3被usb设备驱动提交给usb核心">3）被USB设备驱动提交给USB核心。<a class="hash-link" href="#3被usb设备驱动提交给usb核心" title="标题的直接链接">​</a></h3><p>在完成第1）、2）步的创建和初始化URB后，URB便可以提交给USB核心了，可通过usb_submit_urb（）函数来完成，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_submit_urb(struct urb *urb, gfp_t mem_flags);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>URB参数是指向URB的指针，mem_flags参数与传递给kmalloc（）函数参数的意义相同，它用于告知USB核心如何在此时分配内存缓冲区。</p><p>在提交URB到USB核心后，直到完成函数被调用之前，不要访问URB中的任何成员。</p><p>usb_submit_urb（）在原子上下文和进程上下文中都可以被调用，mem_flags变量需根据调用环境进行相应的设置，如下所示。</p><ul><li>·GFP_ATOMIC：在中断处理函数、底半部、tasklet、定时器处理函数以及URB完成函数中，在调用者持有自旋锁或者读写锁时以及当驱动将current-&gt;state修改为非TASK_RUNNING时，应使用此标志。</li><li>·GFP_NOIO：在存储设备的块I/O和错误处理路径中，应使用此标志；</li><li>·GFP_KERNEL：如果没有任何理由使用GFP_ATOMIC和GFP_NOIO，就使用GFP_KERNEL。</li></ul><p>如果usb_submit_urb（）调用成功，即URB的控制权被移交给USB核心，该函数返回0；否则，返回错误号。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4提交由usb核心指定的usb主机控制器驱动">4）提交由USB核心指定的USB主机控制器驱动。<a class="hash-link" href="#4提交由usb核心指定的usb主机控制器驱动" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5被usb主机控制器处理进行一次到usb设备的传送">5）被USB主机控制器处理，进行一次到USB设备的传送。<a class="hash-link" href="#5被usb主机控制器处理进行一次到usb设备的传送" title="标题的直接链接">​</a></h3><p>第4）~5）步由USB核心和主机控制器完成，不受USB设备驱动的控制。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6当urb完成usb主机控制器驱动通知usb设备驱动">6）当URB完成，USB主机控制器驱动通知USB设备驱动。<a class="hash-link" href="#6当urb完成usb主机控制器驱动通知usb设备驱动" title="标题的直接链接">​</a></h3><p>在如下3种情况下，URB将结束，URB完成回调函数将被调用（完成回调是通过usb_fill_xxx_urb的参数传入的）。在完成回调中，我们通常要进行urb-&gt;status的判断。</p><ul><li>·URB被成功发送给设备，并且设备返回正确的确认。如果urb-&gt;status为0，意味着对于一个输出URB，数据被成功发送；对于一个输入URB，请求的数据被成功收到。</li><li>·如果发送数据到设备或从设备接收数据时发生了错误，urb-&gt;status将记录错误值。</li><li>·URB被从USB核心“去除连接”，这发生在驱动通过usb_unlink_urb（）或usb_kill_urb（）函数取消或URB虽已提交而USB设备被拔出的情况下</li></ul><p>usb_unlink_urb（）和usb_kill_urb（）这两个函数用于取消已提交的URB，其参数为要被取消的URB指针。usb_unlink_urb（）是异步的，搞定后对应的完成回调会被调用；而usb_kill_urb（）会彻底终止URB的生命周期并等待这一行为，它通常在设备的disconnect（）函数中被调用。</p><p>当URB生命结束时（处理完成或被解除链接），在URB的完成回调中通过URB结构体的status成员可以获知其原因，如0表示传输成功，-ENOENT表示被usb_kill_urb（）杀死，-ECONNRESET表示被usb_unlink_urb（）杀死，-EPROTO表示传输中发生了bitstuff错误或者硬件未能及时收到响应数据包，-ENODEV表示USB设备已被移除，-EXDEV表示等时传输仅完成了一部分等。</p><p>对以上URB的处理步骤进行一个总结，图16.4给出了一个URB的完整处理流程，虚线框的usb_unlink_urb（）和usb_kill_urb（）并不一定会发生，它们只是在URB正在被USB核心和主机控制器处理时又被驱动程序取消的情况下才发生。</p><p><img loading="lazy" alt="1745247828456" src="/assets/images/1745247828456-9341f4f96bfe430b601dc646a057ffe5.png" width="994" height="664" class="img_ev3q"></p><p>图16.4　URB处理流程</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3简单的批量与控制urb">3.简单的批量与控制URB<a class="hash-link" href="#3简单的批量与控制urb" title="标题的直接链接">​</a></h2><p>有时USB驱动程序只是从USB设备上接收或向USB设备发送一些简单的数据，这时候，没有必要将URB创建、初始化、提交、完成处理的整个流程走一遍，而可以使用两个更简单的函数，如下所示。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1usb_bulk_msg">（1）usb_bulk_msg（）<a class="hash-link" href="#1usb_bulk_msg" title="标题的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 void *data, int len, int *actual_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 int timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_dev参数为批量消息要发送的USB设备的指针，pipe为批量消息要发送到的USB设备的端点，data参数为指向要发送或接收的数据缓冲区的指针，len参数为data参数所指向的缓冲区的长度，actual_length用于返回实际发送或接收的字节数，timeout是发送超时，以jiffies为单位，0意味着永远等待。</p><p>如果函数调用成功，返回0；否则，返回1个负的错误值</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2usb_control_msg函数">（2）usb_control_msg（）函数<a class="hash-link" href="#2usb_control_msg函数" title="标题的直接链接">​</a></h2><p>usb_control_msg（）函数与usb_bulk_msg（）函数类似，不过它提供给驱动发送和结束USB控制信息而不是批量信息的能力，该函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    __u8 requesttype, __u16 value, __u16 index, void *data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    __u16 size, int timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>dev指向控制消息发往的USB设备，pipe是控制消息要发往的USB设备的端点，request是这个控制消息的USB请求值，requesttype是这个控制消息的USB请求类型，value是这个控制消息的USB消息值，index是这个控制消息的USB消息索引值，data指向要发送或接收的数据缓冲区，size是data参数所指向的缓冲区的大小，timeout是发送超时，以毫秒为单位，0意味着永远等待。</p><p>参数request、requesttype、value和index与USB规范中定义的USB控制消息直接对应。</p><p>如果函数调用成功，该函数返回发送到设备或从设备接收到的字节数；否则，返回一个负的错误值。</p><p>对usb_bulk_msg（）和usb_control_msg（）函数的使用要特别慎重，由于它们是同步的，因此不能在中断上下文和持有自旋锁的情况下使用。而且，该函数也不能被任何其他函数取消，因此，务必要使得驱动程序的disconnect（）函数掌握足够的信息，以判断和等待该调用的结束。</p><h1>16.3.3　探测和断开函数</h1><p>在USB设备驱动usb_driver结构体的probe（）函数中，应该完成如下工作。</p><ul><li>·探测设备的端点地址、缓冲区大小，初始化任何可能用于控制USB设备的数据结构。</li><li>·把已初始化的数据结构的指针保存到接口设备中。</li></ul><p>usb_set_intfdata（）函数可以设置usb_interface的私有数据，这个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_set_intfdata (struct usb_interface *intf, void *data);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数的“反函数”用于得到usb_interface的私有数据，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void *usb_get_intfdata (struct usb_interface *intf);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>·注册USB设备。</li></ul><p>如果是简单的字符设备，则可调用usb_register_dev（），这个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register_dev(struct usb_interface *intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     struct usb_class_driver *class_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数中的第二个参数为usb_class_driver结构体，这个结构体的定义如代码清单16.15所示</p><p>代码清单16.15　usb_class_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_class_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        char *(*devnode)(struct device *dev, umode_t *mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        const struct file_operations *fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int minor_base;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于字符设备而言，usb_class_driver结构体的fops成员中的write（）、read（）、ioctl（）等函数的地位完全等同于本书第6章中的file_operations成员函数。</p><p>如果是其他类型的设备，如tty设备，则调用对应设备的注册函数。</p><p>在USB设备驱动usb_driver结构体的probe（）函数中，应该完成如下工作。</p><ul><li>·释放所有为设备分配的资源。</li><li>·设置接口设备的数据指针为NULL。</li><li>·注销USB设备。</li></ul><p>对于字符设备，可以直接调用usb_register_dev（）函数的“反函数”，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_deregister_dev(struct usb_interface *intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        struct usb_class_driver *class_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于其他类型的设备，如tty设备，则调用对应设备的注销函数。</p><h1>16.3.4　USB骨架程序</h1><p>Linux内核源代码中的driver/usb/usb-skeleton.c文件为我们提供了一个最基础的USB驱动程序，即USB骨架程序，它可被看作一个最简单的USB设备驱动实例。尽管具体的USB设备驱动千差万别，但其骨架则万变不离其宗</p><p>首先看看USB骨架程序的usb_driver结构体定义，如代码清单16.16所示。</p><p>代码清单16.16　USB骨架程序的usb_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_driver skel_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .name =         &quot;skeleton&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        .probe =        skel_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        .disconnect =   skel_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        .suspend =      skel_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .resume =       skel_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .pre_reset =    skel_pre_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .post_reset =   skel_post_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        .id_table =     skel_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .supports_autosuspend = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上述代码第9行可以看出，它所支持的USB设备的列表数组为skel_table[]，其定义如代码清单16.17所示。</p><p>代码清单16.17　USB骨架程序的id_table</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_device_id skel_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2    { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    { }                  /* Terminating entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5MODULE_DEVICE_TABLE(usb, skel_table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对上述usb_driver的注册和注销发生在USB骨架程序的模块加载与卸载函数内，其分别调用了usb_register（）和usb_deregister（），不过这个注册和注销的代码却不用写出来，直接用一个快捷宏module_usb_driver即可，如代码清单16.18所示。</p><p>代码清单16.18　USB骨架程序的模块加载</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_driver skel_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .name =        &quot;skeleton&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        .probe =       skel_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        .disconnect =   skel_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        .suspend =     skel_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .resume =      skel_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .pre_reset =    skel_pre_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .post_reset =   skel_post_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        .id_table =     skel_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .supports_autosuspend = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13module_usb_driver(skel_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在usb_driver的probe（）成员函数中，会根据usb_interface的成员寻找第一个批量输入和输出端点，将端点地址、缓冲区等信息存入为USB骨架程序定义的usb_skel结构体中，并将usb_skel实例的指针传入usb_set_intfdata（）中以作为USB接口的私有数据，最后，它会注册USB设备，如代码清单16.19所示。</p><p>代码清单16.19　USB骨架程序的probe（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int skel_probe(struct usb_interface *interface,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2            const struct usb_device_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   struct usb_host_interface *iface_desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   struct usb_endpoint_descriptor *endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   size_t buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   int retval = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   /* allocate memory for our device state and initialize it */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   kref_init(&amp;dev-&gt;kref);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   sema_init(&amp;dev-&gt;limit_sem, WRITES_IN_FLIGHT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   mutex_init(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17   spin_lock_init(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   init_usb_anchor(&amp;dev-&gt;submitted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   init_waitqueue_head(&amp;dev-&gt;bulk_in_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22   dev-&gt;interface = interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   /* set up the endpoint information */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   /* use only the first bulk-in and bulk-out endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   iface_desc = interface-&gt;cur_altsetting;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27   for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       endpoint = &amp;iface_desc-&gt;endpoint[i].desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       if (!dev-&gt;bulk_in_endpointAddr &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31          usb_endpoint_is_bulk_in(endpoint)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32           /* we found a bulk in endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33           buffer_size = usb_endpoint_maxp(endpoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34           dev-&gt;bulk_in_size = buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35           dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36           dev-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37           ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38           dev-&gt;bulk_in_urb = usb_alloc_urb(0, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39           ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42       if (!dev-&gt;bulk_out_endpointAddr &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43          usb_endpoint_is_bulk_out(endpoint)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44           /* we found a bulk out endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45           dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50   /* save our data pointer in this interface device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51   usb_set_intfdata(interface, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53   /* we can register the device now, as it is ready */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54   retval = usb_register_dev(interface, &amp;skel_class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_skel结构体可以被看作是一个私有数据结构体，其定义如代码清单16.20所示，应该根据具体的设备量身定制。</p><p>代码清单16.20　USB骨架程序的自定义数据结构usb_skel</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_skel {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        struct usb_device      *udev;         /* the usb device for this device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_interface   *interface;    /* the interface for this device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct semaphore limit_sem;    /* limiting the number of writes in progress */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        struct usb_anchor submitted;   /* in case we need to retract our submissions */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        struct urb  *bulk_in_urb;             /* the urb to read data with */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        unsigned char  *bulk_in_buffer;       /* the buffer to receive data */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        size_t bulk_in_size;                  /* the size of the receive buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        size_t  bulk_in_filled;               /* number of bytes in the buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        size_t   bulk_in_copied;              /* already copied to user space */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        __u8 bulk_in_endpointAddr;         /* the address of the bulk in endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        __u8  bulk_out_endpointAddr;        /* the address of the bulk out endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int                  errors;          /* the last request tanked */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        bool                 ongoing_read;    /* a read is going on */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        spinlock_t            err_lock;       /* lock for errors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        struct kref           kref;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        struct mutex          io_mutex;       /* synchronize I/O with disconnect */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        wait_queue_head_t      bulk_in_wait;     /* to wait for an ongoing read */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>USB骨架程序的断开函数会完成与probe（）函数相反的工作，即设置接口数据为NULL，注销USB设备，如代码清单16.21所示。</p><p>代码清单16.21　USB骨架程序的断开函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void skel_disconnect(struct usb_interface *interface)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        int minor = interface-&gt;minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        dev = usb_get_intfdata(interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        usb_set_intfdata(interface, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        /* give back our minor */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        usb_deregister_dev(interface, &amp;skel_class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        /* prevent more I/O from starting */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        mutex_lock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        dev-&gt;interface = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        mutex_unlock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        usb_kill_anchored_urbs(&amp;dev-&gt;submitted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        /* decrement our usage count */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        kref_put(&amp;dev-&gt;kref, skel_delete);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        dev_info(&amp;interface-&gt;dev, &quot;USB Skeleton #%d now disconnected&quot;, minor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单16.19第54行usb_register_dev（interface，&amp;skel_class）中的第二个参数包含了字符设备的file_operations结构体指针，而这个结构体中的成员实现也是USB字符设备的另一个组成成分。代码清单16.22给出了USB骨架程序的字符设备文件操作file_operations结构体的定义。</p><p>代码清单16.22　USB骨架程序的字符设备文件操作结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct file_operations skel_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .owner =       THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        .read =        skel_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        .write =       skel_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        .open =        skel_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .release =     skel_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .flush =        skel_flush,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .llseek =      noop_llseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于只是一个象征性的骨架程序，open（）成员函数的实现非常简单，它根据usb_driver和次设备号通过usb_find_interface（）获得USB接口，之后通过usb_get_intfdata（）获得接口的私有数据并赋予file-&gt;private_data，如代码清单16.23所示。</p><p>代码清单16.23　USB骨架程序的字符设备open（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int skel_open(struct inode *inode, struct file *file)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct usb_interface *interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int subminor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int retval = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        subminor = iminor(inode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        interface = usb_find_interface(&amp;skel_driver, subminor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        dev = usb_get_intfdata(interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        retval = usb_autopm_get_interface(interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        if (retval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17               goto exit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        /* increment our usage count for the device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        kref_get(&amp;dev-&gt;kref);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        /* save our object in the file&#x27;s private structure */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        file-&gt;private_data = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25exit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        return retval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于在open（）函数中并没有申请任何软件和硬件资源，所以与open（）函数对应的release（）函数不用进行资源的释放，而只需进行减少在open（）中增加的引用计数等工作。</p><p>接下来要分析的是读写函数，前面已经提到，在访问USB设备的时候，贯穿其中的“中枢神经”是URB结构体。</p><p>在skel_write（）函数中进行的关于URB的操作与16.3.2小节的描述完全对应，即进行了URB的分配（调用usb_alloc_urb（））、初始化（调用usb_fill_bulk_urb（））和提交（调用usb_submit_urb（））的操作，如代码清单16.24所示。</p><p>代码清单16.24　USB骨架程序的字符设备写函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t skel_write(struct file *file, const char *user_buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2               size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    int retval = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    struct urb *urb = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    char *buf = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    size_t writesize = min(count, (size_t)MAX_TRANSFER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    dev = file-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    spin_lock_irq(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13    retval = dev-&gt;errors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    spin_unlock_irq(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    /* create a urb, and a buffer for it, and copy the data to the urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    urb = usb_alloc_urb(0, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22    buf = usb_alloc_coherent(dev-&gt;udev, writesize, GFP_KERNEL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                    &amp;urb-&gt;transfer_dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26    if (copy_from_user(buf, user_buffer, writesize)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         retval = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28         goto error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    /* this lock makes sure we don&#x27;t submit URBs to gone devices */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32    mutex_lock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35    /* initialize the urb properly */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36    usb_fill_bulk_urb(urb, dev-&gt;udev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37               usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38               buf, writesize, skel_write_bulk_callback, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40    usb_anchor_urb(urb, &amp;dev-&gt;submitted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42    /* send the data out the bulk port */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43    retval = usb_submit_urb(urb, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44    mutex_unlock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    usb_free_urb(urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48    return writesize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在写函数中发起的URB结束后，第38行填入的完成函数skel_write_bulk_callback（）将被调用，它会进行urb-&gt;status的判断，如代码清单16.25所示。</p><p>代码清单16.25　USB骨架程序的字符设备写操作完成函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void skel_write_bulk_callback(struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        dev = urb-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        /* sync/async unlink faults aren&#x27;t errors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        if (urb-&gt;status) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               if (!(urb-&gt;status == -ENOENT ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                   urb-&gt;status == -ECONNRESET ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                   urb-&gt;status == -ESHUTDOWN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                      dev_err(&amp;dev-&gt;interface-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                            &quot;%s - nonzero write bulk status received: %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                            __func__, urb-&gt;status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16               spin_lock(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17               dev-&gt;errors = urb-&gt;status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18               spin_unlock(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        /* free up our allocated buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        usb_free_coherent(urb-&gt;dev, urb-&gt;transfer_buffer_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                      urb-&gt;transfer_buffer, urb-&gt;transfer_dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        up(&amp;dev-&gt;limit_sem);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>16.3.5　实例：USB键盘驱动</h1><p>在Linux系统中，键盘被认定为标准输入设备，对于一个USB键盘而言，其驱动主要由两部分组成：usb_driver的成员函数以及输入设备驱动的input_event获取和报告。</p><p>在USB键盘设备驱动的模块加载和卸载函数中，将分别注册和注销对应于USB键盘的usb_driver结构体usb_kbd_driver，代码清单16.26所示为模块加载与卸载函数以及usb_driver结构体的定义。</p><p>代码清单16.26　USB键盘设备驱动的模块加载与卸载函数以及usb_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_device_id usb_kbd_id_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        { USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3               USB_INTERFACE_PROTOCOL_KEYBOARD) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        { }                                      /* Terminating entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7MODULE_DEVICE_TABLE (usb, usb_kbd_id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9static struct usb_driver usb_kbd_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .name =        &quot;usbkbd&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        .probe =       usb_kbd_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        .disconnect =   usb_kbd_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        .id_table =    usb_kbd_id_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16module_usb_driver(usb_kbd_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在usb_driver的probe（）函数中，将进行输入设备的初始化和注册，USB键盘要使用的中断URB和控制URB的初始化，并设置接口的私有数据，如代码清单16.27所示。</p><p>代码清单16.27　USB键盘设备驱动的probe（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int usb_kbd_probe(struct usb_interface *iface,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2             const struct usb_device_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    struct usb_device *dev = interface_to_usbdev(iface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    struct usb_host_interface *interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    struct usb_endpoint_descriptor *endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    struct usb_kbd *kbd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    struct input_dev *input_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    interface = iface-&gt;cur_altsetting;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    endpoint = &amp;interface-&gt;endpoint[0].desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    kbd = kzalloc(sizeof(struct usb_kbd), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    input_dev = input_allocate_device();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    if (usb_kbd_alloc_mem(dev, kbd))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        goto fail2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    kbd-&gt;usbdev = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24    kbd-&gt;dev = input_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26    usb_make_path(dev, kbd-&gt;phys, sizeof(kbd-&gt;phys));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27    strlcat(kbd-&gt;phys, &quot;/input0&quot;, sizeof(kbd-&gt;phys));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    input_dev-&gt;name = kbd-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30    input_dev-&gt;phys = kbd-&gt;phys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    usb_to_input_id(dev, &amp;input_dev-&gt;id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32    input_dev-&gt;dev.parent = &amp;iface-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34    input_set_drvdata(input_dev, kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36    input_dev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        BIT_MASK(EV_REP);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    input_dev-&gt;event = usb_kbd_event;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40    input_dev-&gt;open = usb_kbd_open;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41    input_dev-&gt;close = usb_kbd_close;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43    usb_fill_int_urb(kbd-&gt;irq, dev, pipe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44              kbd-&gt;new, (maxp &gt; 8   8 : maxp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45              usb_kbd_irq, kbd, endpoint-&gt;bInterval);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    kbd-&gt;irq-&gt;transfer_dma = kbd-&gt;new_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47    kbd-&gt;irq-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    usb_fill_control_urb(kbd-&gt;led, dev, usb_sndctrlpipe(dev, 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50                 (void *) kbd-&gt;cr, kbd-&gt;leds, 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51                 usb_kbd_led, kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52    kbd-&gt;led-&gt;transfer_dma = kbd-&gt;leds_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53    kbd-&gt;led-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55    error = input_register_device(kbd-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56    if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57        goto fail2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59    usb_set_intfdata(iface, kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60    device_set_wakeup_enable(&amp;dev-&gt;dev, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在usb_driver的断开函数中，将设置接口私有数据为NULL、终止已提交的URB并注销输入设备，如代码清单16.28所示。</p><p>代码清单16.28　USB键盘设备驱动的断开函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void usb_kbd_disconnect(struct usb_interface *intf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   struct usb_kbd *kbd = usb_get_intfdata (intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   usb_set_intfdata(intf, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   if (kbd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       usb_kill_urb(kbd-&gt;irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       input_unregister_device(kbd-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       usb_kill_urb(kbd-&gt;led);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        usb_kbd_free_mem(interface_to_usbdev(intf), kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       kfree(kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>键盘主要依赖于中断传输模式，在键盘中断URB的完成函数usb_kbd_irq（）中（通过代码清单16.27的第45行可以看出），将会通过input_report_key（）报告按键事件，通过input_sync（）报告同步事件，如代码清单16.29所示。</p><p>代码清单16.29　USB键盘设备驱动的中断URB完成函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void usb_kbd_irq(struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   for (i = 0; i &lt; 8; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       input_report_key(kbd-&gt;dev, usb_kbd_keycode[i + 224], (kbd-&gt;new[0] &gt;&gt; i) &amp; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   for (i = 2; i &lt; 8; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       if (kbd-&gt;old[i]&gt;3 &amp;&amp; memscan(kbd-&gt;new + 2, kbd-&gt;old[i], 6)==kbd-&gt;new + 8) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10           if (usb_kbd_keycode[kbd-&gt;old[i]])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11               input_report_key(kbd-&gt;dev, usb_kbd_keycode[kbd-&gt;old[i]], 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12           else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13               hid_info(urb-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                    &quot;Unknown key (scancode %#x) released.\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                    kbd-&gt;old[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       if (kbd-&gt;new[i] &gt; 3&amp;&amp;memscan(kbd-&gt;old + 2, kbd-&gt;new[i], 6)==kbd-&gt;old + 8) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19           if (usb_kbd_keycode[kbd-&gt;new[i]])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20               input_report_key(kbd-&gt;dev, usb_kbd_keycode[kbd-&gt;new[i]], 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21           else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22               hid_info(urb-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                    &quot;Unknown key (scancode %#x) pressed.\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                    kbd-&gt;new[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28   input_sync(kbd-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从USB键盘驱动的例子中，我们进一步看到了usb_driver本身只是起一个挂接总线的作用，而具体设备类型的驱动仍然是工作的主体，例如键盘就是input、USB串口就是tty，只是在这些设备底层进行硬件访问的时候，调用的都是与URB相关的接口，这套USB核心层API—URB的存在使我们无须关心底层USB主机控制器的具体细节，因此，USB设备驱动也变得与平台无关，同样的驱动可应用于不同的SoC。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.121Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>首先，参考代码清单9.3，应该将异步结构体指针添加到globalfifo_dev设备结构体内，如代码清单9.7所示。</p><p>代码清单9.7　增加异步通知后的globalfifo设备结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct globalfifo_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   struct cdev cdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   unsigned int current_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   unsigned char mem[GLOBALFIFO_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   struct mutex mutex;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   wait_queue_head_t r_wait;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   wait_queue_head_t w_wait;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   struct fasync_struct *async_queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>参考代码清单9.4的fasync（）函数模板，globalfifo的这个函数如代码清单9.8所示。</p><p>代码清单9.8　支持异步通知的globalfifo设备驱动fasync（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int globalfifo_fasync(int fd, struct file *filp, int mode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   struct globalfifo_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   return fasync_helper(fd, filp, mode, &amp;dev-&gt;async_queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在globalfifo设备被正确写入之后，它变得可读，这个时候驱动应释放SIGIO信号，以便应用程序捕获，代码清单9.9给出了支持异步通知的globalfifo设备驱动的写函数。</p><p>代码清单9.9　支持异步通知的globalfifo设备驱动写函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t globalfifo_write(struct file *filp, const char __user *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                  size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  struct globalfifo_dev *dev = filp-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  DECLARE_WAITQUEUE(wait, current);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  mutex_lock(&amp;dev-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  add_wait_queue(&amp;dev-&gt;w_wait, &amp;wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  while (dev-&gt;current_len == GLOBALFIFO_SIZE) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       if (filp-&gt;f_flags &amp; O_NONBLOCK) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13            ret = -EAGAIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14            goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       __set_current_state(TASK_INTERRUPTIBLE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       mutex_unlock(&amp;dev-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       schedule();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       if (signal_pending(current)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22            ret = -ERESTARTSYS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23            goto out2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26       mutex_lock(&amp;dev-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29  if (count &gt; GLOBALFIFO_SIZE - dev-&gt;current_len)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       count = GLOBALFIFO_SIZE - dev-&gt;current_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32  if (copy_from_user(dev-&gt;mem + dev-&gt;current_len, buf, count)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33       ret = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34       goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36       dev-&gt;current_len += count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37       printk(KERN_INFO &quot;written %d bytes(s),current_len:%d\n&quot;, count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38              dev-&gt;current_len);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40       wake_up_interruptible(&amp;dev-&gt;r_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42       if (dev-&gt;async_queue) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43            kill_fasync(&amp;dev-&gt;async_queue, SIGIO, POLL_IN);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44            printk(KERN_DEBUG &quot;%s kill SIGIO\n&quot;, __func__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47       ret = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51  mutex_unlock(&amp;dev-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52 out2:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53  remove_wait_queue(&amp;dev-&gt;w_wait, &amp;wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54  set_current_state(TASK_RUNNING);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55  return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>参考代码清单9.6，增加异步通知后的globalfifo设备驱动的release（）函数中需调用globalfifo_fasync（）函数将文件从异步通知列表中删除，代码清单9.10给出了支持异步通知的globalfifo_release（）函数。</p><p>代码清单9.10　增加异步通知后的globalfifo设备驱动release（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int globalfifo_release(struct inode *inode, struct file *filp)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  globalfifo_fasync(-1, filp, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>9.3.2　在用户空间中验证globalfifo的异步通知</h1><p>现在，我们可以采用与代码清单9.2类似的方法，编写一个在用户空间验证globalfifo异步通知的程序，这个程序在接收到由globalfifo发出的信号后将输出信号值，如代码清单9.11所示。</p><p>代码清单9.11　监控globalfifo异步通知信号的应用程序</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void signalio_handler(int signum)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   printf(&quot;receive a signal from globalfifo,signalnum:%d\n&quot;, signum);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6void main(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  int fd, oflags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  fd = open(&quot;/dev/globalfifo&quot;, O_RDWR, S_IRUSR | S_IWUSR);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  if (fd != -1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       signal(SIGIO, signalio_handler);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       fcntl(fd, F_SETOWN, getpid());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       oflags = fcntl(fd, F_GETFL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       fcntl(fd, F_SETFL, oflags | FASYNC);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       while (1) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16            sleep(100);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19       printf(&quot;device open failure\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>本书代码/kernel/drivers/globalfifo/ch9包含了支持异步通知的globalfifo驱动以及代码清单9.11对应的globalfifo_test.c测试程序，在该目录运行make将得到globalfifo.ko和globalfifo_test。</p><p>按照与第8章相同的方法加载新的globalfifo设备驱动并创建设备文件节点，运行上述程序，每当通过echo向/dev/globalfifo写入新的数据时，signalio_handler（）将会被调用：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">baohua@baohua-VirtualBox:~/develop/training/kernel/drivers/globalfifo/ch9$ sudo su</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># ./globalfifo_test&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">[1] 25251</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># echo 1 &gt; /dev/globalfifo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">receive a signal from globalfifo,signalnum:29    -&gt; globalfifo_test程序打印</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># echo hello &gt; /dev/globalfifo</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">receive a signal from globalfifo,signalnum:29   -&gt; globalfifo_test程序打印</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.089Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->3 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核模块加载函数一般以__init标识声明，典型的模块加载函数的形式如代码清单4.2所示。</p><p>代码清单4.2　内核模块加载函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1 static int _ _init initialization_function(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3     /* 初始化代码</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5 module_init(initialization_function);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>模块加载函数以“module_init（函数名）”的形式被指定。它返回整型值，若初始化成功，应返回0。而在初始化失败时，应该返回错误编码。在Linux内核里，错误编码是一个接近于0的负值，在&lt;linux/errno.h&gt;中定义，包含-ENODEV、-ENOMEM之类的符号值。总是返回相应的错误编码是种非常好的习惯，因为只有这样，用户程序才可以利用perror等方法把它们转换成有意义的错误信息字符串。</p><p>在Linux内核中，可以使用request_module（const char*fmt，…）函数加载内核模块，驱动开发人员可以通过调用下列代码：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">request_module(module_name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>灵活地加载其他内核模块。</p><p>在Linux中，所有标识为__init的函数如果直接编译进入内核，成为内核镜像的一部分，在连接的时候都会放在.init.text这个区段内。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define _ _init        _ _attribute_ _ ((_ _section_ _ (&quot;.init.text&quot;)))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>所有的<strong>init函数在区段.initcall.init中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些</strong>init函数，并在初始化完成后，释放init区段（包括.init.text、.initcall.init等）的内存。</p><p>除了函数以外，数据也可以被定义为<strong>initdata，对于只是初始化阶段需要的数据，内核在初始化完后，也可以释放它们占用的内存。例如，下面的代码将hello_data定义为</strong>initdata：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static int hello_data __initdata = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int __init hello_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     printk(KERN_INFO &quot;Hello, world %d\n&quot;, hello_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_init(hello_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static void __exit hello_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    printk(KERN_INFO &quot;Goodbye, world\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">module_exit(hello_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.089Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->2 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>从本章开始，后续的数章都将基于虚拟的globalmem设备进行字符设备驱动的讲解。globalmem意味着“全局内存”，在globalmem字符设备驱动中会分配一片大小为GLOBALMEM_SIZE（4KB）的内存空间，并在驱动中提供针对该片内存的读写、控制和定位函数，以供用户空间的进程能通过Linux系统调用获取或设置这片内存的内容。</p><p>实际上，这个虚拟的globalmem设备几乎没有任何实用价值，仅仅是一种为了讲解问题的方便而凭空制造的设备。</p><p>本章将给出globalmem设备驱动的雏形，而后续章节会在这个雏形的基础上添加并发与同步控制等复杂功能。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.089Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>本章主要讲述了Linux中的异步I/O，异步I/O可以使得应用程序在等待I/O操作的同时进行其他操作。</p><p>使用信号可以实现设备驱动与用户程序之间的异步通知，总体而言，设备驱动和用户空间要分别完成3项对应的工作，用户空间设置文件的拥有者、FASYNC标志及捕获信号，内核空间响应对文件的拥有者、FASYNC标志的设置并在资源可获得时释放信号。</p><p>Linux 2.6以后的内核包含对AIO的支持，它为用户空间提供了统一的异步I/O接口。另外，glibc也提供了一个不依赖于内核的用户空间的AIO支持。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.077Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在drivers/gpio下实现了通用的基于gpiolib的GPIO驱动，其中定义了一个通用的用于描述底层GPIO控制器的gpio_chip结构体，并要求具体的SoC实现gpio_chip结构体的成员函数，最后通过gpiochip_add（）注册gpio_chip。GPIO驱动可以存在于drivers/gpio目录中，但是在GPIO兼有多种功能且需要复杂配置的情况下，GPIO的驱动部分往往直接移到drivers/pinctrl目录下并连同pinmux一起实现，而不存在于drivers/gpio目录中。</p><p>gpio_chip结构体封装了底层硬件的GPIO enable（）/disable（）等操作，它的定义如代码清单20.15所示。</p><p>代码清单20.15　gpio_chip结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct gpio_chip {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        const char           *label;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct device        *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct module        *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int                  (*request)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                                             unsigned offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        void                 (*free)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                                             unsigned offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        int                  (*direction_input)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                                             unsigned offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int                  (*get)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                                             unsigned offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int                  (*direction_output)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16                                             unsigned offset, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        int                  (*set_debounce)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                                        unsigned offset, unsigned debounce);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        void                 (*set)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21                                             unsigned offset, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        int                  (*to_irq)(struct gpio_chip *chip,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                                             unsigned offset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        void                 (*dbg_show)(struct seq_file *s,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27                                             struct gpio_chip *chip);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        int                  base;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        u16                  ngpio;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        const char           *const *names;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31        unsigned             can_sleep:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        unsigned             exported:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34#if defined(CONFIG_OF_GPIO)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36         * If CONFIG_OF is enabled, then all GPIO controllers described in the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37         * device tree automatically may have an OF translation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39        struct device_node *of_node;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40        int of_gpio_n_cells;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41        int (*of_xlate)(struct gpio_chip *gc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                        const struct of_phandle_args *gpiospec, u32 *flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过这层封装，每个具体的要用到GPIO的设备驱动都使用通用的GPIO API来操作GPIO，这些API主要用于GPIO的申请、释放和设置：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_request(unsigned gpio, const char *label);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void gpio_free(unsigned gpio);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_direction_input(unsigned gpio);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_direction_output(unsigned gpio, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_set_debounce(unsigned gpio, unsigned debounce);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_get_value_cansleep(unsigned gpio);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void gpio_set_value_cansleep(unsigned gpio, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int gpio_request_array(const struct gpio *array, size_t num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void gpio_free_array(const struct gpio *array, size_t num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int devm_gpio_request(struct device *dev, unsigned gpio, const char *label);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int devm_gpio_request_one(struct device *dev, unsigned gpio,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                         unsigned long flags, const char *label);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void devm_gpio_free(struct device *dev, unsigned int gpio);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意： 内核中针对内存、IRQ、时钟、GPIO、pinctrl、Regulator都有以devm_开头的API，使用这部分API的时候，内核会有类似于Java的资源自动回收机制，因此在代码中进行出错处理时，无须释放相关的资源。</p><p>对于GPIO而言，特别值得一提的是，内核会创建/sys节点/sys/class/gpio/gpioN/，通过它我们可以echo值从而改变GPIO的方向、设置并获取GPIO的值。</p><p>在拥有设备树支持的情况下，我们可以通过设备树来描述某GPIO控制器提供的GPIO引脚被具体设备使用的情况。在GPIO控制器对应的节点中，需定义#gpio-cells和gpio-controller属性，具体的设备节点则通过xxx-gpios属性来引用GPIO控制器节点及GPIO引脚。</p><p>如VEXPRESS电路板DT文件arch/arm/boot/dts/vexpress-v2m.dtsi中有如下GPIO控制器节点：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">v2m_sysreg: sysreg@00000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compatible = &quot;arm,vexpress-sysreg&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reg = &lt;0x00000 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        gpio-controller;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #gpio-cells = &lt;2&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>VEXPRESS电路板上的MMC控制器会使用该节点GPIO控制器提供的GPIO引脚，则具体的mmci@05000设备节点会通过-gpios属性引用GPIO：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mmci@05000 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        compatible = &quot;arm,pl180&quot;, &quot;arm,primecell&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        reg = &lt;0x05000 0x1000&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        interrupts = &lt;9 10&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cd-gpios = &lt;&amp;v2m_sysreg 0 0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        wp-gpios = &lt;&amp;v2m_sysreg 1 0&gt;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中的cd-gpios用于SD/MMC卡的探测，而wp-gpios用于写保护，MMC主机控制器驱动会通过如下方法获取这两个GPIO，详见于drivers/mmc/host/mmci.c：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void mmci_dt_populate_generic_pdata(struct device_node *np,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        struct mmci_platform_data *pdata)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pdata-&gt;gpio_wp = of_get_named_gpio(np, &quot;wp-gpios&quot;, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pdata-&gt;gpio_cd = of_get_named_gpio(np, &quot;cd-gpios&quot;, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.065Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->1 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux内核模块中，我们可以用MODULE_AUTHOR、MODULE_DESCRIPTION、MODULE_VERSION、MODULE_DEVICE_TABLE、MODULE_ALIAS分别声明模块的作者、描述、版本、设备表和别名，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_AUTHOR(author);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_DESCRIPTION(description);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_VERSION(version_string);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_DEVICE_TABLE(table_info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MODULE_ALIAS(alternate_name);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于USB、PCI等设备驱动，通常会创建一个MODULE_DEVICE_TABLE，以表明该驱动模块所支持的设备，如代码清单4.6所示。</p><p>代码清单4.6　驱动所支持的设备列表</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1 /* table of devices that work with this driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2 static struct usb_device_id skel_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 { USB_DEVICE(USB_SKEL_VENDOR_ID,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4       USB_SKEL_PRODUCT_ID) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5     { } /* terminating enttry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6 };</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8 MODULE_DEVICE_TABLE (usb, skel_table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.053Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->8 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>I2 C设备驱动要使用i2c_driver和i2c_client数据结构并填充i2c_driver中的成员函数。i2c_client一般被包含在设备的私有信息结构体yyy_data中，而i2c_driver则适合被定义为全局变量并初始化，代码清单15.12所示为已被初始化的i2c_driver。</p><p>代码清单15.12　被初始化的i2c_driver</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static struct i2c_driver yyy_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2   .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3     .name = &quot;yyy&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4   } ,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5   .probe            = yyy_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6   .remove           = yyy_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7   .id_table         = yyy_id,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>15.4.1　Linux I2 C设备驱动的模块加载与卸载</h1><p>I2 C设备驱动的模块加载函数通过I2 C核心的i2c_add_driver（）API函数添加i2c_driver的工作，而模块卸载函数需要做相反的工作：通过I2 C核心的i2c_del_driver（）函数删除i2c_driver。代码清单15.13所示为I2 C设备驱动的模块加载与卸载函数模板。</p><p>代码清单15.13　I2 C外设驱动的模块加载与卸载函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int __init yyy_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          return i2c_add_driver(&amp;yyy_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5module_initcall(yyy_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7static void __exit yyy_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9          i2c_del_driver(&amp;yyy_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11module_exit(yyy_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>15.4.2　Linux I2 C设备驱动的数据传输</h1><p>在I2 C设备上读写数据的时序且数据通常通过i2c_msg数组进行组织，最后通过i2c_transfer（）函数完成，代码清单15.14所示为一个读取指定偏移offs的寄存器。</p><p>代码清单15.14　I2 C设备驱动的数据传输范例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct i2c_msg msg[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   /* 第一条消息是写消息*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   msg[0].addr = client-&gt;addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   msg[0].flags = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   msg[0].len = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   msg[0].buf = &amp;offs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   /* 第二条消息是读消息*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   msg[1].addr = client-&gt;addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   msg[1].flags = I2C_M_RD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   msg[1].len = sizeof(buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   msg[1].buf = &amp;buf[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   i2c_transfer(client-&gt;adapter, msg, 2);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>15.4.3　Linux的i2c-dev.c文件分析</h1><p>i2c-dev.c文件完全可以被看作是一个I2 C设备驱动，不过，它实现的i2c_client是虚拟、临时的，主要是为了便于从用户空间操作I2 C外设。i2c-dev.c针对每个I2 C适配器生成一个主设备号为89的设备文件，实现了i2c_driver的成员函数以及文件操作接口，因此i2c-dev.c的主体是“i2c_driver成员函数+字符设备驱动”。</p><p>i2c-dev.c提供的i2cdev_read（）、i2cdev_write（）函数对应于用户空间要使用的read（）和write（）文件操作接口，这两个函数分别调用I2 C核心的i2c_master_recv（）和i2c_master_send（）函数来构造一条I2 C消息并引发适配器Algorithm通信函数的调用，以完成消息的传输，它们对应于如图15.4所示的时序。</p><p><img loading="lazy" alt="1745070766336" src="/assets/images/1745070766336-6730dd5c2f73fe874f16c530fb7eec2f.png" width="1038" height="84" class="img_ev3q"></p><p>图15.4　i2cdev_read（）和i2cdev_write（）函数对应的时序</p><p>但是，很遗憾，大多数稍微复杂一点的I2 C设备的读写流程并不对应于一条消息，往往需要两条甚至多条消息来进行一次读写周期（即如图15.5所示的重复开始位的RepStart模式），在这种情况下，在应用层仍然调用read（）、write（）文件API来读写I2 C设备，将不能正确地读写。</p><p><img loading="lazy" alt="1745070806688" src="/assets/images/1745070806688-5c918b573d31d9ba5dabe21df418da1d.png" width="1089" height="85" class="img_ev3q"></p><p>图15.5　RepStart模式</p><p>鉴于上述原因，i2c-dev.c中的i2cdev_read（）和i2cdev_write（）函数不具备太强的通用性，没有太大的实用价值，只能适用于非RepStart模式的情况。对于由两条以上消息组成的读写，在用户空间需要组织i2c_msg消息数组并调用I2C_RDWR IOCTL命令。代码清单15.15所示为i2cdev_ioctl（）函数的框架。</p><p>代码清单15.15　i2c-dev_c中的i2cdev_ioctl（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int i2cdev_ioctl(struct inode *inode, struct file *file,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        unsigned int cmd, unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   struct i2c_client *client = (struct i2c_client *)file-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   switch ( cmd ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   case I2C_SLAVE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   case I2C_SLAVE_FORCE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        ...                           /* 设置从设备地址*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   case I2C_TENBIT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   case I2C_PEC:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   case I2C_FUNCS:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   case I2C_RDWR:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17       return i2cdev_ioctl_rdrw(client, arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   case I2C_SMBUS:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20   case I2C_RETRIES:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22   case I2C_TIMEOUT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   default:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      return i2c_control(client,cmd,arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>常用的IOCTL包括I2C_SLAVE（设置从设备地址）、I2C_RETRIES（没有收到设备ACK情况下的重试次数，默认为1）、I2C_TIMEOU（超时）以及I2C_RDWR。</p><p>代码清单15.16和代码清单15.17所示为直接通过read（）、write（）接口和O_RDWR IOCTL读写I2 C设备的例子。</p><p>代码清单15.16　直接通过read（）/write（）读写I2 C设备</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;linux/types.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;fcntl.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;unistd.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#include &lt;sys/types.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#include &lt;sys/ioctl.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8#include &lt;linux/i2c.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#include &lt;linux/i2c-dev.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11int main(int argc, char **argv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   unsigned int fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   unsigned short mem_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   unsigned short size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   unsigned short idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17   #define BUFF_SIZE    32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   char buf[BUFF_SIZE];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   char cswap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20   union</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22    unsigned short addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    char bytes[2];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24}  tmp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   if (argc &lt; 3) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27    printf(&quot;Use:\n%s /dev/i2c-x mem_addr size\n&quot;, argv[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30   sscanf(argv[2], &quot;%d&quot;, &amp;mem_addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31   sscanf(argv[3], &quot;%d&quot;, &amp;size);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33   if (size &gt; BUFF_SIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34    size = BUFF_SIZE;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36   fd = open(argv[1], O_RDWR);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38   if (!fd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    printf(&quot;Error on opening the device file\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43   ioctl(fd, I2C_SLAVE, 0x50); /* 设置EEPROM地址*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44   ioctl(fd, I2C_TIMEOUT, 1);  /* 设置超时*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45   ioctl(fd, I2C_RETRIES, 1);  /* 设置重试次数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47   for (idx = 0; idx &lt; size; ++idx, ++mem_addr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48    tmp.addr = mem_addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    cswap = tmp.bytes[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50    tmp.bytes[0] = tmp.bytes[1];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51    tmp.bytes[1] = cswap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52    write(fd, &amp;tmp.addr, 2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53    read(fd, &amp;buf[idx], 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55   buf[size] = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56   close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57   printf(&quot;Read %d char: %s\n&quot;, size, buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单15.17　通过O_RDWR IOCTL读写I2 C设备</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#include &lt;linux/types.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3#include &lt;fcntl.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#include &lt;unistd.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#include &lt;stdlib.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6#include &lt;sys/types.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#include &lt;sys/ioctl.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8#include &lt;errno.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#include &lt;assert.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10#include &lt;string.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#include &lt;linux/i2c.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12#include &lt;linux/i2c-dev.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14int main(int argc, char **argv)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16struct i2c_rdwr_ioctl_data work_queue;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17unsigned int idx;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18unsigned int fd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19unsigned int slave_address, reg_address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20unsigned char val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24if (argc &lt; 4) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      printf(&quot;Usage:\n%s /dev/i2c-x start_addr reg_addr\n&quot;, argv[0]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29fd = open(argv[1], O_RDWR);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31if (!fd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32      printf(&quot;Error on opening the device file\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33      return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35sscanf(argv[2], &quot;%x&quot;, &amp;slave_address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36sscanf(argv[3], &quot;%x&quot;, &amp;reg_address);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38work_queue.nmsgs = 2;         /* 消息数量*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39work_queue.msgs = (struct i2c_msg*)malloc(work_queue.nmsgs *sizeof(struct</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40           i2c_msg));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41if (!work_queue.msgs) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42       printf(&quot;Memory alloc error\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43       close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44       return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47ioctl(fd, I2C_TIMEOUT, 2);    /* 设置超时*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48ioctl(fd, I2C_RETRIES, 1);    /* 设置重试次数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50for (i = reg_address; i &lt; reg_address + 16; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51       val = i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52      (work_queue.msgs[0]).len = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53      (work_queue.msgs[0]).addr = slave_address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54      (work_queue.msgs[0]).buf = &amp;val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56      (work_queue.msgs[1]).len = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57      (work_queue.msgs[1]).flags = I2C_M_RD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58      (work_queue.msgs[1]).addr = slave_address;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59      (work_queue.msgs[1]).buf = &amp;val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61      ret = ioctl(fd, I2C_RDWR, (unsigned long) &amp;work_queue);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62      if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63      printf(&quot;Error during I2C_RDWR ioctl with error code: %d\n&quot;, ret);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65      printf(&quot;reg:%02x val:%02x\n&quot;, i, val);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67close(fd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68return ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用该工具可指定读取某I2 C控制器上某I2 C从设备的某寄存器，如读I2 C控制器0上的地址为0x18的从设备，从寄存器0x20开始读：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># i2c-test /dev/i2c-0 0x18 0x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:20 val:07</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:21 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:22 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:23 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:24 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:25 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:26 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:27 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:28 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:29 val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:2a val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:2b val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:2c val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:2d val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:2e val:00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">reg:2f val:00</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/14"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/16"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>