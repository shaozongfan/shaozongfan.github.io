<!doctype html>
<html lang="zh-Hans" dir="ltr" class="blog-wrapper blog-list-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">蒲城小农的博客 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/blog/page/8"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" property="og:title" content="蒲城小农的博客 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="美好的时光在文字中停滞不前"><meta data-rh="true" property="og:description" content="美好的时光在文字中停滞不前"><meta data-rh="true" name="docusaurus_tag" content="blog_posts_list"><meta data-rh="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/blog/page/8"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/8" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/blog/page/8" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_pO2u margin-bottom--md">历史发布</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能分析神器ftrace：从原理到实战">技术博客/调试/Linux性能分析神器ftrace：从原理到实战</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">技术博客/调试/Linux内核追踪神器：perf实现原理剖析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/linux信号机制">技术博客/调试/linux信号机制</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/信号机制学习记录">技术博客/调试/信号机制学习记录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/调试/Linux性能工具(三)ftrace框架">一，ringBuffer</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/网络/网络问题">技术博客/网络/网络问题</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/rzg部署kdump">技术博客/嵌入式/rzg部署kdump</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">技术博客/嵌入式/linux设备驱动开发详解/14.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">技术博客/嵌入式/linux设备驱动开发详解/15.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">技术博客/嵌入式/linux设备驱动开发详解/21.8　strace</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">技术博客/嵌入式/linux设备驱动开发详解/18.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">技术博客/嵌入式/linux设备驱动开发详解/10.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">技术博客/嵌入式/linux设备驱动开发详解/8.4　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">技术博客/嵌入式/linux设备驱动开发详解/16.6　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">技术博客/嵌入式/linux设备驱动开发详解/11.7　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">技术博客/嵌入式/linux设备驱动开发详解/19.11　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">技术博客/嵌入式/linux设备驱动开发详解/7.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">技术博客/嵌入式/linux设备驱动开发详解/21.13　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">技术博客/嵌入式/linux设备驱动开发详解/13.9　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">技术博客/嵌入式/linux设备驱动开发详解/20.10　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">技术博客/嵌入式/linux设备驱动开发详解/9.5　总结</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/技术博客/AI相关/AI核心技能">技术博客/AI相关/AI核心技能</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/人生哲学/人生的底层逻辑">人生哲学/人生的底层逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/2025国家生育政策8大补贴汇总">个人生活/2025国家生育政策8大补贴汇总</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/怀孕注意">个人生活/怀孕注意</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/顺产">个人生活/顺产</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/自建房">一、宽11米深9.8米</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人生活/孕早期">个人生活/孕早期</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus2.4">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/个人博客/docusaurus3.7">依赖工具安装</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/intro">intro</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.661Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->11 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在电路板调试过程中主要使用万用表的两个功能。</p><ul><li>·测量电平。</li><li>·使用二极管挡测量电路板上网络的连通性，当示波器被设置在二极管挡，测量连通的网络会发出“嘀嘀”的鸣叫，否则，没有连通。</li></ul><h1>2.8.2　示波器</h1><p>示波器是利用电子示波管的特性，将人眼无法直接观测的交变电信号转换成图像，显示在荧光屏上以便测量的电子仪器。它是观察数字电路实验现象、分析实验中的问题、测量实验结果必不可少的重要仪器</p><p>使用示波器时应主要注意调节垂直偏转因数选择（VOLTS/DIV）和微调、时基选择（TIME/DIV）和微调以及触发方式。</p><p>如果VOLTS/DIV设置不合理，则可能造成电压幅度超出整个屏幕或在屏幕上变动太过微小以致无法观测的现象。图2.31所示为同一个波形在VOLTS/DIV设置由大到小变化过程中的示意图。</p><p><img loading="lazy" alt="1742736503319" src="/assets/images/1742736503319-b78f8e2f8ceecb9cf89d4d0eb3814900.png" width="1393" height="1038" class="img_ev3q"></p><p>图2.31　示波器的VOLTS/DIV设置与波形</p><p>如果TIME/DIV设置不合适，则可能造成波形混迭。混迭意味着屏幕上显示的波形频率低于信号实际频率。这时候，可以通过缓慢改变扫速TIME/DIV到较快的时基挡提高波形频率，如果波形频率参数急剧改变或者晃动的波形在某个较快的时基挡稳定下来，说明之前发生了波形混迭。根据奈奎斯特定理，采样速率至少高于信号高频分量的两倍才不会发生混迭，如一个500MHz的信号，至少需要1GS/s的采样速率。图2.32所示为同一个波形在TIME/DIV设置由小到大变化过程中的示意图。</p><p><img loading="lazy" alt="image-20250323212848886" src="/assets/images/image-20250323212848886-d635a6d5846a8acac0fddcd3fcb63f31.png" width="940" height="1360" class="img_ev3q"></p><p>图2.32　示波器的TIME/DIV设置与波形</p><p>奈奎斯特定理即为采样定理，指当采样频率fsmax 大于信号中最高频率fmax 的两倍时，即fsmax ≥2fmax 时，采样之后的数字信号可完整地保留原始信息。这条定理在信号处理领域中的地位相当高，大致相当于物理学领域中的牛顿定律。</p><p>在示波器的使用过程中，要设置触发方式和触发模式。触发的目的是为了在每次显示的时候都从波形的同一位置开始，波形可以稳定显示。一般示波器都支持边沿触发，在某些情况下，我们也要使用视频触发、毛刺触发、脉宽触发、斜率触发、码型触发等。设定正确的触发，可以大大提高测试过程的灵活性，并简化工作。</p><p>示波器一般支持3种触发模式：自动模式、常规模式和单次模式。</p><ul><li>·自动模式（示波器面板上的AUTO按钮）。在这种模式下，当触发没有发生时，示波器的扫描系统会根据设定的扫描速率自动进行扫描；而当有触发发生时，扫描系统会尽量按信号的频率进行扫描。因此，AUTO模式下，不论触发条件是否满足，示波器都会产生扫描，都可以在屏幕上看到有变化的扫描线，这是这种模式的特点。一般来说，在对信号的特点不是很了解的时候，可先选择自动模式。</li><li>·常规模式（示波器面板上的NORM或NORMAL按钮）。在这种模式下，示波器只有当触发条件满足了才进行扫描，如果没有触发，就不进行扫描。因此在这种模式下，如果没有触发，对于模拟示波器而言，用户不会看到扫描线，对于数字示波器而言，不会看到波形更新</li><li>·单次模式（示波器面板上的SIGL或SINGLE按钮）。这种模式与NORMAL模式有一点类似，就是只有当触发条件满足时才产生扫描，否则不扫描。而不同在于，这种扫描一旦产生并完成后，示波器的扫描系统即进入一种休止状态，即使后面再有满足触发条件的信号出现也不再进行扫描，也就是触发一次只扫描一次。实际工作中，可能要根据情况在自动、常规和单次模式之间进行切换。</li></ul><h1>2.8.3　逻辑分析仪</h1><p>逻辑分析仪是利用时钟从测试设备上采集数字信号并进行显示的仪器，其最主要的作用是用于时序的判定。与示波器不同，逻辑分析仪并不具备许多电压等级，通常只显示两个电压（逻辑1和0）。在设定了参考电压之后，逻辑分析仪通过比较器来判定待测试信号，高于参考电压者为1，低于参考电压者为0。</p><p>例如，如果以n MHz采样率测量一个信号，逻辑分析仪会以1000/n ns为周期采样信号，当参考电压设定为1.5V时，超过1.5V则判定为1，低于1.5V则为0，将逻辑1和0连接成连续的波形，工程师依据此连续波形可寻找时序问题。</p><p>高端逻辑分析仪会安装Windows操作系统并提供非常友善的逻辑分析应用软件，在其中可方便地编辑探针、信号并查看波形。这种逻辑分析仪一般称为传统逻辑分析仪，其功能强大，数据采集、分析和波形显示融于一身，但是价格十分昂贵。有的逻辑分析仪则没有图形界面，但是可以通过USB等接口与PC连接，分析软件则工作在PC上。这种逻辑分析仪一般称为虚拟逻辑分析仪，它是PC技术和测量技术结合的产物，触发和记录功能由虚拟逻辑分析仪硬件完成，波形显示、输入设置等功能由PC完成，因此比较廉价。图2.33给出了两种逻辑分析仪。</p><p><img loading="lazy" alt="1742736620408" src="/assets/images/1742736620408-85f85385b9d2948a0578d8f23173f6d7.png" width="1218" height="390" class="img_ev3q"></p><p>图2.33　逻辑分析仪</p><p>逻辑分析仪的波形可以显示地址、数据、控制信号及任意外部探头信号的变化轨迹，在使用之前应先编辑每个探头的信号名。之后，根据波形还原出总线的工作时序，图2.34给出了一个I2 C的例子。目前，很多逻辑分析仪都自带了协议分析能力，可以自动分析出总线上传输的命令、地址和数据等信息。</p><p><img loading="lazy" alt="image-20250323213056156" src="/assets/images/image-20250323213056156-4ebc80220a75c5b41f0787118f12639d.png" width="1378" height="501" class="img_ev3q"></p><p>图2.34　从逻辑分析仪波形还原I2 C总线</p><p>逻辑分析仪具有超强的逻辑跟踪分析功能，它可以捕获并记录嵌入式处理器的总线周期，也可以捕获如实时跟踪用的ETM接口的程序执行信息，并对这些记录进行分析、译码且还原出应用程序的执行过程。因此，可使用逻辑分析仪通过触发接口与ICD（在线调试器）协调工作以补充ICD在跟踪功能方面的不足。逻辑分析仪与ICD协作可为工程师提供断点、触发和跟踪调试手段，如图2.35所示。</p><p> ICD是一个容易与ICE（在线仿真器）混淆的概念，ICE本身需要完全仿真CPU的行为，可以从物理上完全替代CPU，而ICD则只是与芯片内部的嵌入式ICE单元通过JTAG等接口互通。因此，对ICD的硬件性能要求远低于ICE。目前市面上出现的很多号称为ICE的产品实际上是ICD等，但是人们一般也称它们为ICE。</p><p><img loading="lazy" alt="1742736685202" src="/assets/images/1742736685202-da2fddb3288548982c0c837b1bddeddc.png" width="639" height="568" class="img_ev3q"></p><p>图2.35　逻辑分析仪与ICD协作</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.657Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->17 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux设备驱动中，使用中断的设备需要申请和释放对应的中断，并分别使用内核提供的request_irq（）和free_irq（）函数。</p><p>1.申请irq</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            const char *name, void *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>irq是要申请的硬件中断号。</p><p>handler是向系统登记的中断处理函数（顶半部），是一个回调函数，中断发生时，系统调用这个函数，dev参数将被传递给它。</p><p>irqflags是中断处理的属性，可以指定中断的触发方式以及处理方式。在触发方式方面，可以是IRQF_TRIGGER_RISING、IRQF_TRIGGER_FALLING、IRQF_TRIGGER_HIGH、IRQF_TRIGGER_LOW等。在处理方式方面，若设置了IRQF_SHARED，则表示多个设备共享中断，dev是要传递给中断服务程序的私有数据，一般设置为这个设备的设备结构体或者NULL。</p><p>request_irq（）返回0表示成功，返回-EINVAL表示中断号无效或处理函数指针为NULL，返回-EBUSY表示中断已经被占用且不能共享。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 unsigned long irqflags, const char *devname, void *dev_id);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此函数与request<em>irq（）的区别是devm</em>开头的API申请的是内核“managed”的资源，一般不需要在出错处理和remove（）接口里再显式的释放。有点类似Java的垃圾回收机制。比如，对于at86rf230驱动，如下的补丁中改用devm_request_irq（）后就删除了free_irq（），该补丁对应的内核commit ID是652355c5。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">--- a/drivers/net/ieee802154/at86rf230.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+++ b/drivers/net/ieee802154/at86rf230.c</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -1190,24+1190,22@@ static int at86rf230_probe(struct spi_device *spi)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (rc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          goto err_hw_init;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    rc = request_irq(spi-&gt;irq, irq_handler, IRQF_SHARED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-               dev_name(&amp;spi-&gt;dev), lp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+    rc = devm_request_irq(&amp;spi-&gt;dev, spi-&gt;irq, irq_handler, IRQF_SHARED,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+                    dev_name(&amp;spi-&gt;dev), lp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (rc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         goto err_hw_init;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* Read irq status register to reset irq line */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     rc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &amp;status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (rc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-        goto err_irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+        goto err_hw_init;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     rc = ieee802154_register_device(lp-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (rc)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-        goto err_irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">+        goto err_hw_init;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     return rc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-err_irq:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    free_irq(spi-&gt;irq, lp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> err_hw_init:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     flush_work(&amp;lp-&gt;irqwork);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     spi_set_drvdata(spi, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">@@ -1232,7+1230,6@@ static int at86rf230_remove(struct spi_device *spi)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     at86rf230_write_subreg(lp, SR_IRQ_MASK, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ieee802154_unregister_device(lp-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-    free_irq(spi-&gt;irq, lp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     flush_work(&amp;lp-&gt;irqwork);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     if (gpio_is_valid(pdata-&gt;slp_tr))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>顶半部handler的类型irq_handler_t定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">typedef irqreturn_t (*irq_handler_t)(int, void *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">typedef int irqreturn_t;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>2.释放irq</p><p>与request_irq（）相对应的函数为free_irq（），free_irq（）的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void free_irq(unsigned int irq,void *dev_id);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>free_irq（）中参数的定义与request_irq（）相同。</p><h1>10.3.2　使能和屏蔽中断</h1><p>下列3个函数用于屏蔽一个中断源：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void disable_irq(int irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void disable_irq_nosync(int irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void enable_irq(int irq);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>disable_irq_nosync（）与disable_irq（）的区别在于前者立即返回，而后者等待目前的中断处理完成。由于disable_irq（）会等待指定的中断被处理完，因此如果在n号中断的顶半部调用disable_irq（n），会引起系统的死锁，这种情况下，只能调用disable_irq_nosync（n）。</p><p>下列两个函数（或宏，具体实现依赖于CPU的体系结构）将屏蔽本CPU内的所有中断：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define local_irq_save(flags) ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void local_irq_disable(void);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>前者会将目前的中断状态保留在flags中（注意flags为unsigned long类型，被直接传递，而不是通过指针），后者直接禁止中断而不保存状态。</p><p>与上述两个禁止中断对应的恢复中断的函数（或宏）是：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define local_irq_restore(flags) ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void local_irq_enable(void);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>以上各以local_开头的方法的作用范围是本CPU内。</p><h1>10.3.3　底半部机制</h1><p>Linux实现底半部的机制主要有tasklet、工作队列、软中断和线程化irq。</p><p>1.tasklet</p><p>tasklet的使用较简单，它的执行上下文是软中断，执行时机通常是顶半部返回的时候。我们只需要定义tasklet及其处理函数，并将两者关联则可，例如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void my_tasklet_func(unsigned long); /*定义一个处理函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DECLARE_TASKLET(my_tasklet, my_tasklet_func, data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  /*定义一个tasklet结构my_tasklet，与my_tasklet_func(data)函数相关联*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码DECLARE_TASKLET（my_tasklet，my_tasklet_func，data）实现了定义名称为my_tasklet的tasklet，并将其与my_tasklet_func（）这个函数绑定，而传入这个函数的参数为data。</p><p>在需要调度tasklet的时候引用一个tasklet_schedule（）函数就能使系统在适当的时候进行调度运行：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">tasklet_schedule(&amp;my_tasklet);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用tasklet作为底半部处理中断的设备驱动程序模板如代码清单10.2所示（仅包含与中断相关的部分）。</p><p>代码清单10.2　tasklet使用模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 定义tasklet和底半部函数并将它们关联 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2void xxx_do_tasklet(unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5/* 中断处理底半部*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6void xxx_do_tasklet(unsigned long)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11/* 中断处理顶半部*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12irqreturn_t xxx_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 tasklet_schedule(&amp;xxx_tasklet);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19/* 设备驱动模块加载函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20int __init xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 /* 申请中断 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 result = request_irq(xxx_irq, xxx_interrupt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     0, &quot;xxx&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 return IRQ_HANDLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30/* 设备驱动模块卸载函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31void __exit xxx_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 /* 释放中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 free_irq(xxx_irq, xxx_interrupt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述程序在模块加载函数中申请中断（第24~25行），并在模块卸载函数中释放它（第35行）。对应于xxx_irq的中断处理程序被设置为xxx_interrupt（）函数，在这个函数中，第15行的tasklet_schedule（&amp;xxx_tasklet）调度被定义的tasklet函数xxx_do_tasklet（）在适当的时候执行。</p><p>2.工作队列</p><p>工作队列的使用方法和tasklet非常相似，但是工作队列的执行上下文是内核线程，因此可以调度和睡眠。下面的代码用于定义一个工作队列和一个底半部执行函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct work_struct my_wq;                    /* 定义一个工作队列 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void my_wq_func(struct work_struct *work);   /* 定义一个处理函数*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过INIT_WORK（）可以初始化这个工作队列并将工作队列与处理函数绑定：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">INIT_WORK(&amp;my_wq, my_wq_func);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  /* 初始化工作队列并将其与处理函数绑定*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与tasklet_schedule（）对应的用于调度工作队列执行的函数为schedule_work（），如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">schedule_work(&amp;my_wq);     /* 调度工作队列执行*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与代码清单10.2对应的使用工作队列处理中断底半部的设备驱动程序模板如代码清单10.3所示（仅包含与中断相关的部分）。</p><p>代码清单10.3　工作队列使用模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 定义工作队列和关联函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2struct work_struct xxx_wq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3void xxx_do_work(struct work_struct *work);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5/* 中断处理底半部*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6void xxx_do_work(struct work_struct *work)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11/*中断处理顶半部*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12irqreturn_t xxx_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 schedule_work(&amp;xxx_wq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 return IRQ_HANDLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20/* 设备驱动模块加载函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21int xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 /* 申请中断*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 result = request_irq(xxx_irq, xxx_interrupt,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26      0, &quot;xxx&quot;, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 /* 初始化工作队列*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 INIT_WORK(&amp;xxx_wq, xxx_do_work);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33/* 设备驱动模块卸载函数 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34void xxx_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37 /* 释放中断 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 free_irq(xxx_irq, xxx_interrupt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>与代码清单10.2不同的是，上述程序在设计驱动模块加载函数中增加了初始化工作队列的代码（第29行）。</p><p>工作队列早期的实现是在每个CPU核上创建一个worker内核线程，所有在这个核上调度的工作都在该worker线程中执行，其并发性显然差强人意。在Linux 2.6.36以后，转而实现了“Concurrency-managed workqueues”，简称cmwq，cmwq会自动维护工作队列的线程池以提高并发性，同时保持了API的向后兼容。</p><p>3.软中断</p><p>软中断（Softirq）也是一种传统的底半部处理机制，它的执行时机通常是顶半部返回的时候，tasklet是基于软中断实现的，因此也运行于软中断上下文。</p><p>在Linux内核中，用softirq_action结构体表征一个软中断，这个结构体包含软中断处理函数指针和传递给该函数的参数。使用open_softirq（）函数可以注册软中断对应的处理函数，而raise_softirq（）函数可以触发一个软中断。</p><p>软中断和tasklet运行于软中断上下文，仍然属于原子上下文的一种，而工作队列则运行于进程上下文。因此，在软中断和tasklet处理函数中不允许睡眠，而在工作队列处理函数中允许睡眠。</p><p>local_bh_disable（）和local_bh_enable（）是内核中用于禁止和使能软中断及tasklet底半部机制的函数。</p><p>内核中采用softirq的地方包括HI_SOFTIRQ、TIMER_SOFTIRQ、NET_TX_SOFTIRQ、NET_RX_SOFTIRQ、SCSI_SOFTIRQ、TASKLET_SOFTIRQ等，一般来说，驱动的编写者不会也不宜直接使用softirq。</p><p>第9章异步通知所基于的信号也类似于中断，现在，总结一下硬中断、软中断和信号的区别：硬中断是外部设备对CPU的中断，软中断是中断底半部的一种处理机制，而信号则是由内核（或其他进程）对某个进程的中断。在涉及系统调用的场合，人们也常说通过软中断（例如ARM为swi）陷入内核，此时软中断的概念是指由软件指令引发的中断，和我们这个地方说的softirq是两个完全不同的概念，一个是software，一个是soft。</p><p>需要特别说明的是，软中断以及基于软中断的tasklet如果在某段时间内大量出现的话，内核会把后续软中断放入ksoftirqd内核线程中执行。总的来说，中断优先级高于软中断，软中断又高于任何一个线程。软中断适度线程化，可以缓解高负载情况下系统的响应。</p><p>4.threaded_irq</p><p>在内核中，除了可以通过request_irq（）、devm_request_irq（）申请中断以外，还可以通过request_threaded_irq（）和devm_request_threaded_irq（）申请。这两个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int request_threaded_irq(unsigned int irq, irq_handler_t handler,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     irq_handler_t thread_fn,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     unsigned long flags, const char *name, void *dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int devm_request_threaded_irq(struct device *dev, unsigned int irq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          irq_handler_t handler, irq_handler_t thread_fn,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          unsigned long irqflags, const char *devname,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                          void *dev_id);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由此可见，它们比request_irq（）、devm_request_irq（）多了一个参数thread_fn。用这两个API申请中断的时候，内核会为相应的中断号分配一个对应的内核线程。注意这个线程只针对这个中断号，如果其他中断也通过request_threaded_irq（）申请，自然会得到新的内核线程。</p><p>参数handler对应的函数执行于中断上下文，thread_fn参数对应的函数则执行于内核线程。如果handler结束的时候，返回值是IRQ_WAKE_THREAD，内核会调度对应线程执行thread_fn对应的函数。</p><p>request_threaded_irq（）和devm_request_threaded_irq（）支持在irqflags中设置IRQF_ONESHOT标记，这样内核会自动帮助我们在中断上下文中屏蔽对应的中断号，而在内核调度thread_fn执行后，重新使能该中断号。对于我们无法在上半部清除中断的情况，IRQF_ONESHOT特别有用，避免了中断服务程序一退出，中断就洪泛的情况。</p><p>handler参数可以设置为NULL，这种情况下，内核会用默认的irq_default_primary_handler（）代替handler，并会使用IRQF_ONESHOT标记。irq_default_primary_handler（）定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Default primary interrupt handler for threaded interrupts. Is</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * assigned as primary handler when request_threaded_irq is called</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * with handler == NULL. Useful for oneshot interrupts.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return IRQ_WAKE_THREAD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>10.3.4　实例：GPIO按键的中断</h1><p>drivers/input/keyboard/gpio_keys.c是一个放之四海皆准的GPIO按键驱动，为了让该驱动在特定的电路板上工作，通常只需要修改arch/arm/mach-xxx下的板文件或者修改device tree对应的dts。该驱动会为每个GPIO申请中断，在gpio_keys_setup_key（）函数中进行。注意最后一个参数bdata，会被传入中断服务程序。</p><p>代码清单10.4　GPIO按键驱动中断申请</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int gpio_keys_setup_key(struct platform_device *pdev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2                  struct input_dev *input,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3                  struct gpio_button_data *bdata,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4                  const struct gpio_keys_button *button)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  error = request_any_context_irq(bdata-&gt;irq, isr, irqflags, desc, bdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  if (error &lt; 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      dev_err(dev, &quot;Unable to claim irq %d; error %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11          bdata-&gt;irq, error);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12      goto fail;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第8行的request_any_context_irq（）会根据GPIO控制器本身的“上级”中断是否为threaded_irq来决定采用request_irq（）还是request_threaded_irq（）。一组GPIO（如32个GPIO）虽然每个都提供一个中断，并且都有中断号，但是在硬件上一组GPIO通常是嵌套在上一级的中断控制器上的一个中断。</p><p>request_any_context_irq（）也有一个变体是devm_request_any_context_irq（）。</p><p>在GPIO按键驱动的remove_key（）函数中，会释放GPIO对应的中断，如代码清单10.5所示。</p><p>代码清单10.5　GPIO按键驱动中断释放</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1static void gpio_remove_key(struct gpio_button_data *bdata)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3    free_irq(bdata-&gt;irq, bdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4    if (bdata-&gt;timer_debounce)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5         del_timer_sync(&amp;bdata-&gt;timer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6    cancel_work_sync(&amp;bdata-&gt;work);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7    if (gpio_is_valid(bdata-&gt;button-&gt;gpio))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8         gpio_free(bdata-&gt;button-&gt;gpio);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第3行直接从dev_id取出了bdata，这就是对应的那个GPIO键的数据结构，之后根据情况启动timer以进行debounce或者直接调度工作队列去汇报按键事件。在GPIO按键驱动初始化的时候，通过INIT_WORK（&amp;bdata-&gt;work，gpio_keys_gpio_work_func）初始化了bdata-&gt;work，对应的处理函数是gpio_keys_gpio_work_func（），如代码清单10.7所示</p><p>代码清单10.7　GPIO按键驱动的工作队列底半部</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void gpio_keys_gpio_work_func(struct work_struct *work)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct gpio_button_data *bdata =</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4                container_of(work, struct gpio_button_data, work);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        gpio_keys_gpio_report_event(bdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        if (bdata-&gt;button-&gt;wakeup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                pm_relax(bdata-&gt;input-&gt;dev.parent);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>观察其中的第3~4行，它通过container_of（）再次从work_struct反向解析出了bdata。原因是work_struct本身在定义时，就嵌入在gpio_button_data结构体内。读者朋友们应该掌握Linux的这种可以到处获取一个结构体指针的技巧，它实际上类似于面向对象里面的“this”指针。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct gpio_button_data {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        const struct gpio_keys_button *button;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct input_dev *input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct timer_list timer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        struct work_struct work;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int timer_debounce;    /* in msecs */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned int irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        spinlock_t lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bool disabled;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        bool key_pressed;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.657Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>网络设备的初始化主要需要完成如下几个方面的工作。</p><ul><li>·进行硬件上的准备工作，检查网络设备是否存在，如果存在，则检测设备所使用的硬件资源。</li><li>·进行软件接口上的准备工作，分配net_device结构体并对其数据和函数指针成员赋值。</li><li>·获得设备的私有信息指针并初始化各成员的值。如果私有信息中包括自旋锁或信号量等并发或同步机制，则需对其进行初始化。</li></ul><p>对net_device结构体成员及私有数据的赋值都可能需要与硬件初始化工作协同进行，即硬件检测出了相应的资源，需要根据检测结果填充net_device结构体成员和私有数据。</p><p>网络设备驱动的初始化函数模板如代码清单14.5所示，具体的设备驱动初始化函数并不一定完全和本模板一样，但其本质过程是一致的。</p><p>代码清单14.5　网络设备驱动的初始化函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void xxx_init(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  /* 设备的私有信息结构体*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  struct xxx_priv *priv;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  /* 检查设备是否存在和设备所使用的硬件资源*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  xxx_hw_init();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  /* 初始化以太网设备的公用成员*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  ether_setup(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  /* 设置设备的成员函数指针*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  ndev-&gt;netdev_ops        = &amp;xxx_netdev_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  ndev-&gt;ethtool_ops       = &amp;xxx_ethtool_ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  dev-&gt;watchdog_timeout = timeout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  /* 取得私有信息，并初始化它*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  priv = netdev_priv(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19  ...  /* 初始化设备私有数据区*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第7行的xxx_hw_init（）函数完成的与硬件相关的初始化操作如下。</p><ul><li>探测xxx网络设备是否存在。探测的方法类似于数学上的“反证法”，即先假设存在设备xxx，访问该设备，如果设备的表现与预期一致，就确定设备存在；否则，假设错误，设备xxx不存在。</li><li>探测设备的具体硬件配置。一些设备驱动编写得非常通用，对于同类的设备使用统一的驱动，我们需要在初始化时探测设备的具体型号。另外，即便是同一设备，在硬件上的配置也可能不一样，我们也可以探测设备所使用的硬件资源。</li><li>申请设备所需要的硬件资源，如用request_region（）函数进行I/O端口的申请等，但是这个过程可以放在设备的打开函数xxx_open（）中完成。</li></ul></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.657Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->7 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>网络设备的驱动程序还提供一些供系统对设备的参数进行设置或读取设备相关信息的方法。</p><p>当用户调用ioctl（）函数，并指定SIOCSIFHWADDR命令时，意味着要设置这个设备的MAC地址。设置网络设备的MAC地址可用如代码清单14.14所示的模板。</p><p>代码清单14.14　设置网络设备的MAC地址</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int set_mac_address(struct net_device *dev, void *addr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    if (netif_running(dev))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        return -EBUSY;  /* 设备忙*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    /* 设置以太网的MAC地址*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    xxx_set_mac(dev, addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述程序首先用netif_running（）宏判断设备是否正在运行，如果是，则意味着设备忙，此时不允许设置MAC地址；否则，调用xxx_set_mac（）函数在网络适配器硬件内写入新的MAC地址。这要求设备在硬件上支持MAC地址的修改，而实际上，许多设备并不提供修改MAC地址的接口。</p><p>netif_running（）宏的定义为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static inline bool netif_running(const struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return test_bit(__LINK_STATE_START, &amp;dev-&gt;state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当用户调用ioctl（）函数时，若命令为SIOCSIFMAP（如在控制台中运行网络配置命令ifconfig就会引发这一调用），系统会调用驱动程序的set_config（）函数。</p><p>系统会向set_config（）函数传递一个ifmap结构体，该结构体主要包含用户欲设置的设备要使用的I/O地址、中断等信息。注意，并不是ifmap结构体中给出的所有修改都是可以接受的。实际上，大多数设备并不适合包含set_config（）函数。set_config（）函数的例子如代码清单14.15所示。</p><p>代码清单14.15　网络设备驱动的set_config函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int xxx_config(struct net_device *dev, struct ifmap *map)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  if (netif_running(dev))   /* 不能设置一个正在运行状态的设备*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    return  - EBUSY;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  /* 假设不允许改变I/O 地址*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  if (map-&gt;base_addr != dev-&gt;base_addr) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    printk(KERN_WARNING &quot;xxx: Can&#x27;t change I/O address\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    return  - EOPNOTSUPP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  /* 假设允许改变IRQ */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  if (map-&gt;irq != dev-&gt;irq)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    dev-&gt;irq = map-&gt;irq;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中的set_config（）函数接受IRQ的修改，拒绝设备I/O地址的修改。具体的设备是否接受这些信息的修改，要视硬件的设计而定。</p><p>如果用户调用ioctl（）时，命令类型在SIOCDEVPRIVATE和SIOCDEVPRIVATE+15之间，系统会调用驱动程序的do_ioctl（）函数，以进行设备专用数据的设置。这个设置在大多数情况下也并不需要。</p><p>驱动程序还应提供get_stats（）函数以向用户反馈设备状态和统计信息，该函数返回的是一个net_device_stats结构体，如代码清单14.16所示。</p><p>代码清单14.16　网络设备驱动的get_stats（）函数模板</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct net_device_stats *xxx_stats(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3  …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4  return  &amp;dev-&gt;stats;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>有的网卡硬件比较强大，可以从硬件的寄存器中读出一些统计信息，如rx_missed_errors、tx_aborted_errors、rx_dropped、rx_length_errors等。这个时候，我们应该从硬件寄存器读取统计信息，填充到net_device的stats字段中，并返回。具体例子可见drivers/net/ethernet/adaptec/starfire.c中的get_stats（）函数。</p><p>net_device_stats结构体定义在内核的include/linux/netdevice.h文件中，它包含了比较完整的统计信息，如代码清单14.17所示。</p><p>代码清单14.17　net_device_stats结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct net_device_stats</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  unsigned long rx_packets;      /* 收到的数据包数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  unsigned long tx_packets;      /* 发送的数据包数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  unsigned long rx_bytes;        /* 收到的字节数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  unsigned long tx_bytes;        /* 发送的字节数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  unsigned long rx_errors;       /* 收到的错误数据包数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  unsigned long tx_errors;       /* 发生发送错误的数据包数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码清单只是列出了net_device_stats包含的主项目统计信息，实际上，这些项目还可以进一步细分，net_device_stats中的其他信息给出了更详细的子项目统计，详见Linux源代码。</p><p>net_device_stats结构体已经内嵌在与网络设备对应的net_device结构体中，而其中统计信息的修改则应该在设备驱动的与发送和接收相关的具体函数中完成，这些函数包括中断处理程序、数据包发送函数、数据包发送超时函数和数据包接收相关函数等。我们应该在这些函数中添加相应的代码，如代码清单14.18所示。</p><p>代码清单14.18　net_device_stats结构体中统计信息的维护</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 发送超时函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2void xxx_tx_timeout(struct net_device *dev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  dev-&gt;stats.tx_errors++;        /* 发送错误包数加1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9/* 中断处理函数*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10static void xxx_interrupt(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  struct net_device *dev = dev_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  switch (status &amp;ISQ_EVENT_MASK) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  case ISQ_TRANSMITTER_EVENT:       /</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      dev-&gt;stats.tx_packets++;      /* 数据包发送成功，tx_packets信息加1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17      netif_wake_queue(dev);        /* 通知上层协议*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18      if ((status &amp;(TX_OK | TX_LOST_CRS | TX_SQE_ERROR |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      TX_LATE_COL | TX_16_COL)) != TX_OK) { /* 读取硬件上的出错标志*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        /* 根据错误的不同情况，对net_device_stats的不同成员加1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        if ((status &amp;TX_OK) == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22          dev-&gt;stats.tx_errors++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        if (status &amp;TX_LOST_CRS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24          dev-&gt;stats.tx_carrier_errors++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        if (status &amp;TX_SQE_ERROR)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26          dev-&gt;stats.tx_heartbeat_errors++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        if (status &amp;TX_LATE_COL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28          dev-&gt;stats.tx_window_errors++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        if (status &amp;TX_16_COL)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30          dev-&gt;stats.tx_aborted_errors++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33  case ISQ_RX_MISS_EVENT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34      dev-&gt;stats.rx_missed_errors += (status &gt;&gt; 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36  case ISQ_TX_COL_EVENT:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37      dev-&gt;stats.collisions += (status &gt;&gt; 6);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38      break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.641Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>任何一个计算机系统的运转都是系统中软硬件共同努力的结果，没有硬件的软件是空中楼阁，而没有软件的硬件则只是一堆废铁。硬件是底层基础，是所有软件得以运行的平台，代码最终会落实为硬件上的组合逻辑与时序逻辑；软件则实现了具体应用，它按照各种不同的业务需求而设计，并完成用户的最终诉求。硬件较固定，软件则很灵活，可以适应各种复杂多变的应用。因此，计算机系统的软硬件相互成就了对方。</p><p>但是，软硬件之间同样存在着悖论，那就是软件和硬件不应该互相渗透入对方的领地。为尽可能快速地完成设计，应用软件工程师不想也不必关心硬件，而硬件工程师也难有足够的闲暇和能力来顾及软件。譬如，应用软件工程师在调用套接字发送和接收数据包的时候，不必关心网卡上的中断、寄存器、存储空间、I/O端口、片选以及其他任何硬件词汇；在使用printf（）函数输出信息的时候，他不用知道底层究竟是怎样把相应的信息输出到屏幕或者串口。</p><p>也就是说，应用软件工程师需要看到一个没有硬件的纯粹的软件世界，硬件必须透明地呈现给他。谁来实现硬件对应用软件工程师的隐形？这个光荣而艰巨的任务就落在了驱动工程师的头上。</p><p>对设备驱动最通俗的解释就是“驱使硬件设备行动”。驱动与底层硬件直接打交道，按照硬件设备的具体工作方式，读写设备的寄存器，完成设备的轮询、中断处理、DMA通信，进行物理内存向虚拟内存的映射等，最终让通信设备能收发数据，让显示设备能显示文字和画面，让存储设备能记录文件和数据。</p><p>由此可见，设备驱动充当了硬件和应用软件之间的纽带，应用软件时只需要调用系统软件的应用编程接口（API）就可让硬件去完成要求的工作。在系统没有操作系统的情况下，工程师可以根据硬件设备的特点自行定义接口，如对串口定义SerialSend（）、SerialRecv（），对LED定义LightOn（）、LightOff（），对Flash定义FlashWr（）、FlashRd（）等。而在有操作系统的情况下，驱动的架构则由相应的操作系统定义，驱动工程师必须按照相应的架构设计驱动，这样，驱动才能良好地整合入操作系统的内核中。</p><p>动程序负责硬件和应用软件之间的沟通，而驱动工程师则负责硬件工程师和应用软件工程师之间的沟通。目前，随着通信、电子行业的迅速发展，全世界每天都会生产大量新芯片，设计大量新电路板，也因此，会有大量设备驱动需要开发。这些驱动或运行在简单的单任务环境中，或运行在VxWorks、Linux、Windows等多任务操作系统环境中，它们发挥着不可替代的作用。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.641Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->4 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>I2 C核心（drivers/i2c/i2c-core.c）中提供了一组不依赖于硬件平台的接口函数，这个文件一般不需要被工程师修改，但是理解其中的主要函数非常关键，因为I2 C总线驱动和设备驱动之间以I2 C核心作为纽带。I2 C核心中的主要函数如下。</p><p>（1）增加/删除i2c_adapter</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int i2c_add_adapter(struct i2c_adapter *adap);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void i2c_del_adapter(struct i2c_adapter *adap);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>（2）增加/删除i2c_driver</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int i2c_register_driver(struct module *owner, struct i2c_driver *driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void i2c_del_driver(struct i2c_driver *driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define i2c_add_driver(driver) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        i2c_register_driver(THIS_MODULE, driver)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>（3）I2 C传输、发送和接收</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int i2c_master_send(struct i2c_client *client,const char *buf ,int count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int i2c_master_recv(struct i2c_client *client, char *buf ,int count);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>i2c_transfer（）函数用于进行I2 C适配器和I2 C设备之间的一组消息交互，其中第2个参数是一个指向i2c_msg数组的指针，所以i2c_transfer（）一次可以传输多个i2c_msg（考虑到很多外设的读写波形比较复杂，比如读寄存器可能要先写，所以需要两个以上的消息）。而对于时序比较简单的外设，i2c_master_send（）函数和i2c_master_recv（）函数内部会调用i2c_transfer（）函数分别完成一条写消息和一条读消息，如代码清单15.6、15.7所示。</p><p>代码清单15.6　I2 C核心的i2c_master_send（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int i2c_master_send(const struct i2c_client *client, const char *buf, int count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         struct i2c_adapter *adap = client-&gt;adapter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         struct i2c_msg msg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         msg.addr = client-&gt;addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         msg.len = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         msg.buf = (char *)buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         ret = i2c_transfer(adap, &amp;msg, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15          * If everything went ok (i.e. 1 msg transmitted), return #bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16          * transmitted, else error code.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17          */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         return (ret == 1)   count : ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单15.7　I2 C核心的i2c_master_recv（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int i2c_master_recv(const struct i2c_client *client, char *buf, int count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3         struct i2c_adapter *adap = client-&gt;adapter;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         struct i2c_msg msg;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         msg.addr = client-&gt;addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         msg.flags = client-&gt;flags &amp; I2C_M_TEN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         msg.flags |= I2C_M_RD;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         msg.len = count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         msg.buf = buf;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         ret = i2c_transfer(adap, &amp;msg, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16          * If everything went ok (i.e. 1 msg received), return #bytes received,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17          * else error code.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18          */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         return (ret == 1)   count : ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>i2c_transfer（）函数本身不具备驱动适配器物理硬件以完成消息交互的能力，它只是寻找到与i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer（）函数真正驱动硬件流程，如代码清单15.8所示。</p><p>代码清单15.8　I2 C核心的i2c_transfer（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   if (adap-&gt;algo-&gt;master_xfer) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       ret = adap-&gt;algo-&gt;master_xfer(adap,msgs,num);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       dev_dbg(&amp;adap-&gt;dev, &quot;I2C level transfers not supported\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       return -ENOSYS;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.633Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->8 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>Linux内核的整体架构本就非常庞大，其包含的组件也非常多。而我们怎样把需要的部分都包含在内核中呢？</p><p>一种方法是把所有需要的功能都编译到Linux内核中。这会导致两个问题，一是生成的内核会很大，二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核。</p><p>有没有另一种机制可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时候，其对应的代码被动态地加载到内核中呢？</p><p>Linux提供了这样的机制，这种机制被称为模块（Module）。模块具有这样的特点。·</p><p>模块本身不被编译入内核映像，从而控制了内核的大小。·</p><p>模块一旦被加载，它就和内核中的其他部分完全一样。</p><p>为了使读者初步建立对模块的感性认识，我们先来看一个最简单的内核模块“Hello World”，如代码清单4.1所示。</p><p>代码清单4.1　一个最简单的Linux内核模块</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 * a simple kernel module: hello</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 * Copyright (C) 2014 Barry Song  (baohua@kernel.org)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 * Licensed under GPLv2 or later.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#include &lt;linux/init.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10#include &lt;linux/module.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12static int __init hello_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14  printk(KERN_INFO &quot;Hello World enter\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17module_init(hello_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19static void __exit hello_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  printk(KERN_INFO &quot;Hello World exit\n &quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23module_exit(hello_exit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25MODULE_AUTHOR(&quot;Barry Song &lt;21cnbao@gmail.com&gt;&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26MODULE_LICENSE(&quot;GPL v2&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27MODULE_DESCRIPTION(&quot;A simple Hello World Module&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28MODULE_ALIAS(&quot;a simplest module&quot;);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个最简单的内核模块只包含内核模块加载函数、卸载函数和对GPL v2许可权限的声明以及一些描述信息，位于本书配套Ubuntu的/home/baohua/develop/training/kernel/drivers/hello目录。编译它会产生hello.ko目标文件，通过“insmod./hello.ko”命令可以加载它，通过“rmmod hello”命令可以卸载它，加载时输出“Hello World enter”，卸载时输出“Hello World exit”。</p><p>内核模块中用于输出的函数是内核空间的printk（）而不是用户空间的printf（），printk（）的用法和printf（）基本相似，但前者可定义输出级别。printk（）可作为一种最基本的内核调试手段，在Linux驱动的调试章节中将会详细讲解。</p><p>在Linux中，使用lsmod命令可以获得系统中已加载的所有模块以及模块间的依赖关系，例如</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Module                  Size  Used by</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hello                   9 472  0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nls_iso8859_1          12 032  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nls_cp437              13 696  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vfat                   18 816  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fat                    57 376  1 vfat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>lsmod命令实际上是读取并分析“/proc/modules”文件，与上述lsmod命令结果对应的“/proc/modules”文件如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">vboxvideo 16384 0 - Live 0x00000000 (OE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vboxsf 45056 0 - Live 0x00000000 (OE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xt_addrtype 16384 2 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xt_conntrack 16384 1 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ipt_MASQUERADE 16384 1 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nf_nat_masquerade_ipv4 16384 1 ipt_MASQUERADE, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iptable_nat 16384 1 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nf_conntrack_ipv4 16384 2 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nf_defrag_ipv4 16384 1 nf_conntrack_ipv4, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nf_nat_ipv4 16384 1 iptable_nat, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">iptable_filter 16384 1 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ip_tables 20480 2 iptable_nat,iptable_filter, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">x_tables 24576 5 xt_addrtype,xt_conntrack,ipt_MASQUERADE,iptable_filter,ip_tables, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nf_nat 24576 2 nf_nat_masquerade_ipv4,nf_nat_ipv4, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nf_conntrack 90112 5 xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_ipv4,nf_nat_ipv4,nf_nat, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bridge 102400 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">stp 16384 1 bridge, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">llc 16384 2 bridge,stp, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dm_thin_pool 61440 1 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dm_persistent_data 61440 1 dm_thin_pool, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dm_bio_prison 16384 1 dm_thin_pool, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dm_bufio 28672 1 dm_persistent_data, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">libcrc32c 16384 1 dm_persistent_data, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bnep 20480 2 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">rfcomm 61440 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">bluetooth 450560 10 bnep,rfcomm, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">crc32_pclmul 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">aesni_intel 20480 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">aes_i586 20480 1 aesni_intel, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">xts 16384 1 aesni_intel, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lrw 16384 1 aesni_intel, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">gf128mul 16384 2 xts,lrw, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_intel8x0 40960 2 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ablk_helper 16384 1 aesni_intel, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cryptd 20480 1 ablk_helper, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_ac97_codec 110592 1 snd_intel8x0, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nfsd 294912 13 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ac97_bus 16384 1 snd_ac97_codec, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_pcm 90112 2 snd_intel8x0,snd_ac97_codec, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_seq_midi 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">auth_rpcgss 57344 1 nfsd, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nfs_acl 16384 1 nfsd, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_seq_midi_event 16384 1 snd_seq_midi, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">joydev 20480 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">dm_multipath 24576 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">serio_raw 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">scsi_dh 16384 1 dm_multipath, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_rawmidi 28672 1 snd_seq_midi, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vmwgfx 155648 2 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">nfs 225280 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ttm 86016 1 vmwgfx, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_seq 57344 2 snd_seq_midi,snd_seq_midi_event, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">i2c_piix4 20480 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">drm_kms_helper 114688 1 vmwgfx, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_seq_device 16384 3 snd_seq_midi,snd_rawmidi,snd_seq, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lockd 81920 2 nfsd,nfs, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd_timer 32768 2 snd_pcm,snd_seq, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">grace 16384 2 nfsd,lockd, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">video 20480 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8250_fintek 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">snd 69632 11 snd_intel8x0,snd_ac97_codec,snd_pcm,snd_rawmidi,snd_seq,snd_seq_device,snd_timer, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">binfmt_misc 20480 1 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">drm 294912 6 vboxvideo,vmwgfx,ttm,drm_kms_helper, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mac_hid 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">parport_pc 32768 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vboxguest 221184 1 vboxsf, Live 0x00000000 (OE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">soundcore 16384 1 snd, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sunrpc 282624 19 nfsd,auth_rpcgss,nfs_acl,nfs,lockd, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">fscache 57344 1 nfs, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ppdev 20480 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">lp 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">parport 40960 3 parport_pc,ppdev,lp, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hid_generic 16384 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">usbhid 49152 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">hid 98304 2 hid_generic,usbhid, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ahci 28672 2 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">psmouse 110592 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">libahci 32768 1 ahci, Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vmw_pvscsi 24576 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vmxnet3 53248 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">e1000 131072 0 - Live 0x00000000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>内核中已加载模块的信息也存在于/sys/module目录下，加载hello.ko后，内核中将包含/sys/module/hello目录，该目录下又有一个refcnt文件和一个sections目录，在/sys/module/hello目录下运行“tree–a”可得到如下目录树：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">root@barry-VirtualBox:/sys/module/hello# tree -a</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> coresize├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> holders├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> initsize├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> initstate├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> notes│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .note.gnu.build-id├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> refcnt├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> sections│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .exit.text│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .gnu.linkonce.this_module│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .init.text│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .note.gnu.build-id│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .rodata.str1.1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .strtab│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> .symtab├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> srcversion├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> taint└──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uevent</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3 directories, 15 files</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>modprobe命令比insmod命令要强大，它在加载某模块时，会同时加载该模块所依赖的其他模块。使用modprobe命令加载的模块若以“modprobe-r filename”的方式卸载，将同时卸载其依赖的模块。模块之间的依赖关系存放在根文件系统的/lib/modules/kernel-version/modules.dep文件中，实际上是在整体编译内核的时候由depmod工具生成的，它的格式非常简单：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">kernel/lib/cpu-notifier-error-inject.ko: kernel/lib/notifier-error-inject.ko</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kernel/lib/pm-notifier-error-inject.ko: kernel/lib/notifier-error-inject.ko</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kernel/lib/lru_cache.ko:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kernel/lib/cordic.ko:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kernel/lib/rbtree_test.ko:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">kernel/lib/interval_tree_test.ko:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">updates/dkms/vboxvideo.ko: kernel/drivers/gpu/drm/drm.ko</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用modinfo&lt;模块名&gt;命令可以获得模块的信息，包括模块作者、模块的说明、模块所支持的参数以及vermagic：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># modinfo hello.ko</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">filename:       /home/baohua/develop/training/kernel/drivers/hello/hello.ko</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">alias:          a simplest module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">description:    A simple Hello World Module</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">license:        GPL v2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">author:         Barry Song &lt;21cnbao@gmail.com&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">depends:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">vermagic:       4.0.0-rc1 SMP mod_unload 686</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.629Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->8 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>在Linux中，内核打印语句printk（）会将内核信息输出到内核信息缓冲区中，内核缓冲区是在kernel/printk.c中通过如下语句静态定义的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>内核信息缓冲区是一个环形缓冲区（Ring Buffer），因此，如果塞入的消息过多，则就会将之前的消息冲刷掉。</p><p>printk（）定义了8个消息级别，分为级别0~7，级别越低（数值越大），消息越不重要，第0级是紧急事件级，第7级是调试级，代码清单21.2所示为printk（）的级别定义。</p><p>代码清单21.2　printk（）的级别定义</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 #define KERN_EMERG &quot;&lt;0&gt;&quot;      /* 紧急事件，一般是系统崩溃之前提示的消息 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 #define KERN_ALERT &quot;&lt;1&gt;&quot;      /* 必须立即采取行动*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 #define KERN_CRIT &quot;&lt;2&gt;&quot;       /* 临界状态，通常涉及严重的硬件或软件操作失败*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 #define KERN_ERR  &quot;&lt;3&gt;&quot;       /* 用于报告错误状态，设备驱动程序会经常使用KERN_ERR来报告来自硬件的问题*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 #define KERN_WARNING  &quot;&lt;4&gt;&quot;   /* 对可能出现问题的情况进行警告，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7                                  这类情况通常不会对系统造成严重的问题*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 #define KERN_NOTICE   &quot;&lt;5&gt;&quot;   /* 有必要进行提示的正常情形，</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                                  许多与安全相关的状况用这个级别进行汇报*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10#define KERN_INFO     &quot;&lt;6&gt;&quot;    /* 内核提示性信息，很多驱动程序</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                                  在启动的时候，用这个级别打印出它们找到的硬件信息*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12#define KERN_DEBUG    &quot;&lt;7&gt;&quot;    /* 用于调试信息*/</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过/proc/sys/kernel/printk文件可以调节printk（）的输出等级，该文件有4个数字值，如下所示。</p><ul><li>·控制台（一般是串口）日志级别：当前的打印级别，优先级高于该值的消息将被打印至控制台。</li><li>·默认的消息日志级别：将用该优先级来打印没有优先级前缀的消息，也就是在直接写printk（“xxx”）而不带打印级别的情况下，会使用该打印级别。</li><li>·最低的控制台日志级别：控制台日志级别可被设置的最小值（一般都是1）。</li><li>·默认的控制台日志级别：控制台日志级别的默认值。</li></ul><p>如在Ubuntu PC上，/proc/sys/kernel/printk的值一般如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ cat /proc/sys/kernel/printk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4   4    1   7</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而我们通过如下命令可以使得Linux内核的任何printk（）都从控制台输出：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo 8 &gt; /proc/sys/kernel/printk</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在默认情况下，DEBUG级别的消息不会从控制台输出，我们可以通过在bootargs中设置ignore_loglevel来忽略打印级别，以保证所有消息都被打印到控制台。在系统启动后，用户还可以通过写/sys/module/printk/parameters/ignore_loglevel文件动态来设置是否忽略打印级别。</p><p>要注意的是，/proc/sys/kernel/printk并不控制内核消息进入<strong>log_buf的门槛，因此无论消息级别是多少，都会进入</strong>log_buf中，但是最终只有高于当前打印级别的内核消息才会从控制台打印。</p><p>用户可以通过dmesg命令查看内核打印缓冲区，而如果使用dmesg-c命令，则不仅会显示__log_buf，还会清除该缓冲区的内容。也可以使用cat/proc/kmsg命令来显示内核信息。/proc/kmsg是一个“永无休止的文件”，因此，cat/proc/kmsg的进程只能通过“Ctrl+C”或kill终止。</p><p>在设备驱动中，经常需要输出调试或系统信息，尽管可以直接采用printk（“&lt;7&gt;debug info…\n”）方式的printk（）语句输出，但是通常可以使用封装了printk（）的更高级的宏，如pr_debug（）、dev_debug（）等。代码清单21.3所示为pr_debug（）和pr_info（）的定义。</p><p>代码清单21.3　可替代printk（）的宏pr_debug（）和pr_info（）的定义</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#ifdef DEBUG</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#define pr_debug(fmt,arg...) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3  printk(KERN_DEBUG fmt,##arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5static inline int _ _attribute_ _ ((format (printf, 1, 2))) pr_debug(const char * fmt, ...)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#define pr_info(fmt,arg...) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   printk(KERN_INFO fmt,##arg)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>使用pr_xxx（）族API的好处是，可以在文件最开头通过pr_fmt（）定义一个打印格式，比如在kernel/watchdog.c的最开头通过如下定义可以保证之后watchdog.c调用的所有pr_xxx（）打印的消息都自动带有“NMI watchdog：”的前缀。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define pr_fmt(fmt) &quot;NMI watchdog: &quot; fmt</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/mm.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/cpu.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#include &lt;linux/nmi.h&gt;…</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单21.4所示为dev_dbg（）、dev_err（）、dev_info（）等的定义，使用dev_xxx（）族API打印的时候，设备名称会被自动加到打印消息的前头。</p><p>代码清单21.4　包含设备信息的可替代printk（）的宏</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define dev_printk(level, dev, format, arg...)  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  printk(level &quot;%s %s: &quot; format , dev_driver_string(dev) , (dev)-&gt;bus_id , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#ifdef DEBUG</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#define dev_dbg(dev, format, arg...)            \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       dev_printk(KERN_DEBUG , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8#define dev_dbg(dev, format, arg...) do { (void)(dev); } while (0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#define dev_err(dev, format, arg...)            \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       dev_printk(KERN_ERR , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13#define dev_info(dev, format, arg...)           \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       dev_printk(KERN_INFO , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15#define dev_warn(dev, format, arg...)           \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       dev_printk(KERN_WARNING , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17#define dev_notice(dev, format, arg...)         \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       dev_printk(KERN_NOTICE , dev , format , ## arg)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单21.4所示为dev_dbg（）、dev_err（）、dev_info（）等的定义，使用dev_xxx（）族API打印的时候，设备名称会被自动加到打印消息的前头。</p><p>代码清单21.4　包含设备信息的可替代printk（）的宏</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1#define dev_printk(level, dev, format, arg...)  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2  printk(level &quot;%s %s: &quot; format , dev_driver_string(dev) , (dev)-&gt;bus_id , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4#ifdef DEBUG</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5#define dev_dbg(dev, format, arg...)            \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       dev_printk(KERN_DEBUG , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8#define dev_dbg(dev, format, arg...) do { (void)(dev); } while (0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11#define dev_err(dev, format, arg...)            \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       dev_printk(KERN_ERR , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13#define dev_info(dev, format, arg...)           \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       dev_printk(KERN_INFO , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15#define dev_warn(dev, format, arg...)           \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       dev_printk(KERN_WARNING , dev , format , ## arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17#define dev_notice(dev, format, arg...)         \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       dev_printk(KERN_NOTICE , dev , format , ## arg)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在打印信息时，如果想输出printk（）调用所在的函数名，可以使用<strong>func</strong>；如果想输出其所在代码的行号，可以使用<strong>LINE</strong>；想输出源代码文件名，可以使用<strong>FILE</strong>。例如drivers/block/sx8.c中的：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CARM_NDEBUG</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define assert(expr)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define assert(expr) \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       if(unlikely(!(expr))) {                                 \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       printk(KERN_ERR &quot;Assertion failed! %s,%s,%s,line=%d\n&quot;, \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       #expr, __FILE__, __func__, __LINE__);          \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.617Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->15 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>CPUFreq子系统位于drivers/cpufreq目录下，负责进行运行过程中CPU频率和电压的动态调整，即DVFS（Dynamic Voltage Frequency Scaling，动态电压频率调整）。运行时进行CPU电压和频率调整的原因是：CMOS电路中的功耗与电压的平方成正比、与频率成正比（P∝fV2 ），因此降低电压和频率可降低功耗。</p><p>CPUFreq的核心层位于drivers/cpufreq/cpufreq.c下，它为各个SoC的CPUFreq驱动的实现提供了一套统一的接口，并实现了一套notifier机制，可以在CPUFreq的策略和频率改变的时候向其他模块发出通知。另外，在CPU运行频率发生变化的时候，内核的loops_per_jiffy常数也会发生相应变化。</p><h1>19.2.1　SoC的CPUFreq驱动实现</h1><p>每个SoC的具体CPUFreq驱动实例只需要实现电压、频率表，以及从硬件层面完成这些变化。</p><p>CPUFreq核心层提供了如下API以供SoC注册自身的CPUFreq驱动：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">intcpufreq_register_driver(struct cpufreq_driver *driver_data);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其参数为一个cpufreq_driver结构体指针，实际上，cpufreq_driver封装了一个具体的SoC的CPUFreq驱动的主体，该结构体形如代码清单19.1所示。</p><p>代码清单19.1　cpufreq_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct cpufreq_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2struct module         *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3char                 name[CPUFREQ_NAME_LEN];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 u8                   flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6       /* needed by all drivers */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7int    (*init)         (struct cpufreq_policy *policy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8int    (*verify)       (struct cpufreq_policy *policy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10       /* define one out of two */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11int     (*setpolicy)    (struct cpufreq_policy *policy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12int     (*target)       (struct cpufreq_policy *policy),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13unsigned inttarget_freq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14unsigned int relation);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      /* should be defined, if possible */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17unsigned int    (*get)  (unsigned intcpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      /* optional */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20unsigned int (*getavg)  (struct cpufreq_policy *policy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21unsigned intcpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22int     (*bios_limit)   (intcpu, unsigned int *limit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24int     (*exit)         (struct cpufreq_policy *policy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25int     (*suspend)      (struct cpufreq_policy *policy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26int     (*resume)       (struct cpufreq_policy *policy);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27structfreq_attr        **attr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其中的owner成员一般被设置为THIS_MODULE；name成员是CPUFreq驱动的名字，如drivers/cpufreq/s5pv210-cpufreq.c设置name为s5pv210，drivers/cpufreq/omap-cpufreq.c设置name为omap；flags是一些暗示性的标志，譬如，若设置了CPUFREQ_CONST_LOOPS，则是告诉内核loops_per_jiffy不会因为CPU频率的变化而变化。</p><p>init（）成员是一个per-CPU初始化函数指针，每当一个新的CPU被注册进系统的时候，该函数就被调用，该函数接受一个cpufreq_policy的指针参数，在init（）成员函数中，可进行如下设置：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;cpuinfo.min_freq</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;cpuinfo.max_freq</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码描述的是该CPU支持的最小频率和最大频率（单位是kHz）。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;cpuinfo.transition_latency</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码描述的是CPU进行频率切换所需要的延迟（单位是ns）</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;cur</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码描述的是CPU的当前频率。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;policy</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;governor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;min</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">policy-&gt;max</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码定义该CPU的缺省策略，以及在缺省策略情况下，该策略支持的最小、最大CPU频率。</p><p>verify（）成员函数用于对用户的CPUFreq策略设置进行有效性验证和数据修正。每当用户设定一个新策略时，该函数根据老的策略和新的策略，检验新策略设置的有效性并对无效设置进行必要的修正。在该成员函数的具体实现中，常用到如下辅助函数：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cpufreq_verify_within_limits(struct cpufreq_policy *policy, unsigned intmin_freq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        unsigned intmax_freq);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>setpolicy（）成员函数接受一个policy参数（包含policy-&gt;policy、policy-&gt;min和policy-&gt;max等成员），实现了这个成员函数的CPU一般具备在一个范围（limit，从policy-&gt;min到policy-&gt;max）里自动调整频率的能力。目前只有少数驱动（如intel_pstate.c和longrun.c）包含这样的成员函数，而绝大多数CPU都不会实现此函数，一般只实现target（）成员函数，target（）的参数直接就是一个指定的频率。</p><p>target（）成员函数用于将频率调整到一个指定的值，接受3个参数：policy、target_freq和relation。target_freq是目标频率，实际驱动总是要设定真实的CPU频率到最接近于target_freq，并且设定的频率必须位于policy-&gt;min到policy-&gt;max之间。在设定频率接近target_freq的情况下，relation若为CPUFREQ_REL_L，则暗示设置的频率应该大于或等于target_freq；relation若为CPUFREQ_REL_H，则暗示设置的频率应该小于或等于target_freq。</p><p>表19.1描述了setpolicy（）和target（）所针对的CPU以及调用方式上的区别。</p><p><img loading="lazy" alt="1746005269313" src="/assets/images/1746005269313-62ea6b6234818fa7700e6183da80bc64.png" width="1420" height="199" class="img_ev3q"></p><p>根据芯片内部PLL和分频器的关系，ARM SoC一般不具备独立调整频率的能力，往往SoC的CPUFreq驱动会提供一个频率表，频率在该表的范围内进行变更，因此一般实现target（）成员函数。</p><p>CPUFreq核心层提供了一组与频率表相关的辅助API。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">intcpufreq_frequency_table_cpuinfo(struct cpufreq_policy *policy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct cpufreq_frequency_table *table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它是cpufreq_driver的init（）成员函数的助手，用于将policy-&gt;min和policy-&gt;max设置为与cpuinfo.min_freq和cpuinfo.max_freq相同的值。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">intcpufreq_frequency_table_verify(struct cpufreq_policy *policy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct cpufreq_frequency_table *table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它是cpufreq_driver的verify（）成员函数的助手，确保至少有1个有效的CPU频率位于policy-&gt;min到policy-&gt;max的范围内。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">intcpufreq_frequency_table_target(struct cpufreq_policy *policy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">struct cpufreq_frequency_table *table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned inttarget_freq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int relation,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int *index);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>它是cpufreq_driver的target（）成员函数的助手，返回需要设定的频率在频率表中的索引。</p><p>省略掉具体的细节，1个SoC的CPUFreq驱动实例drivers/cpufreq/s3c64xx-cpufreq.c的核心结构如代码清单19.2所示。</p><p>代码清单19.2　S3C64xx的CPUFreq驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">  1static unsigned long regulator_latency;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  3struct s3c64xx_dvfs {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4unsigned intvddarm_min;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5unsigned intvddarm_max;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  6};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  8static struct s3c64xx_dvfs s3c64xx_dvfs_table[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  9[0] = { 1000000, 1150000 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 10…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 11[4] = { 1300000, 1350000 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 12};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 14static struct cpufreq_frequency_table s3c64xx_freq_table[] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 15{ 0,  66000 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 16{ 0, 100000 },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 17…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 18{ 0, CPUFREQ_TABLE_END },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 19};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 21static int s3c64xx_cpufreq_verify_speed(struct cpufreq_policy *policy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 22{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 23if (policy-&gt;cpu != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 24    return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 26return cpufreq_frequency_table_verify(policy, s3c64xx_freq_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 27}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 29static unsigned int s3c64xx_cpufreq_get_speed(unsigned intcpu)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 30{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 31if (cpu != 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 32    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 34return clk_get_rate(armclk) / 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 35}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 37static int s3c64xx_cpufreq_set_target(struct cpufreq_policy *policy,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 38             unsigned inttarget_freq,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 39             unsigned int relation)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 40{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 41…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 42ret = cpufreq_frequency_table_target(policy, s3c64xx_freq_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 43                 target_freq, relation, &amp;i);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 44…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 45freqs.cpu = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 46freqs.old = clk_get_rate(armclk) / 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 47freqs.new = s3c64xx_freq_table[i].frequency;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 48freqs.flags = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 49dvfs = &amp;s3c64xx_dvfs_table[s3c64xx_freq_table[i].index];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 50</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 51if (freqs.old == freqs.new)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 52    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 54cpufreq_notify_transition(&amp;freqs, CPUFREQ_PRECHANGE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 56if (vddarm&amp;&amp;freqs.new&gt;freqs.old) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 57    ret = regulator_set_voltage(vddarm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 58                 dvfs-&gt;vddarm_min,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 59                 dvfs-&gt;vddarm_max);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 60    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 61}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 62</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 63ret = clk_set_rate(armclk, freqs.new * 1000);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 64…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 65cpufreq_notify_transition(&amp;freqs, CPUFREQ_POSTCHANGE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 66</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 67if (vddarm&amp;&amp;freqs.new&lt;freqs.old) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 68    ret = regulator_set_voltage(vddarm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 69                 dvfs-&gt;vddarm_min,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 70                 dvfs-&gt;vddarm_max);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 71    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 72}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 73</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 74return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 75}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 76</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 77static int s3c64xx_cpufreq_driver_init(struct cpufreq_policy *policy)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 78{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 79…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 80armclk = clk_get(NULL, &quot;armclk&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 81…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 82vddarm = regulator_get(NULL, &quot;vddarm&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 83…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 84s3c64xx_cpufreq_config_regulator();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 85</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 86freq = s3c64xx_freq_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 87while (freq-&gt;frequency != CPUFREQ_TABLE_END) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 88    unsigned long r;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 89    …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 90}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 91</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 92policy-&gt;cur = clk_get_rate(armclk) / 1000;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 93policy-&gt;cpuinfo.transition_latency = (500 * 1000) + regulator_latency;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 94ret = cpufreq_frequency_table_cpuinfo(policy, s3c64xx_freq_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 95…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 96return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 97}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 98</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 99staticstruct cpufreq_driver s3c64xx_cpufreq_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">100.owner       = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">101.flags         = 0,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">102.verify      = s3c64xx_cpufreq_verify_speed,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">103.target      = s3c64xx_cpufreq_set_target,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">104.get     = s3c64xx_cpufreq_get_speed,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">105.init        = s3c64xx_cpufreq_driver_init,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">106.name        = &quot;s3c&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">107};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">108</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">109static int __init s3c64xx_cpufreq_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">110{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">111return cpufreq_register_driver(&amp;s3c64xx_cpufreq_driver);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">112}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">113module_init(s3c64xx_cpufreq_init);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第37行s3c64xx_cpufreq_set_target（）就是完成目标频率设置的函数，它调用了cpufreq_frequency_table_target（）从s3c64xx支持的频率表s3c64xx_freq_table里找到合适的频率。在具体的频率和电压设置环节，用的都是Linux的标准API regulator_set_voltage（）和clk_set_rate（）之类的函数。</p><p>第111行在模块初始化的时候通过cpufreq_register_driver（）注册了cpufreq_driver的实例，第94行，在CPUFreq的初始化阶段调用cpufreq_frequency_table_cpuinfo（）注册了频率表。关于频率表，比较新的内核喜欢使用后面章节将介绍的OPP。</p><h1>19.2.2　CPUFreq的策略</h1><p>SoCCPUFreq驱动只是设定了CPU的频率参数，以及提供了设置频率的途径，但是它并不会管CPU自身究竟应该运行在哪种频率上。究竟频率依据的是哪种标准，进行何种变化，而这些完全由CPUFreq的策略（policy）决定，这些策略如表19.2所示。</p><p>表19.2　CPUFrep的策略及其实现方法</p><p><img loading="lazy" alt="1746022386526" src="/assets/images/1746022386526-1ecb37d8efc34a190ea5582390a18dbd.png" width="1464" height="351" class="img_ev3q"></p><p>在Android系统中，则增加了1个交互策略，该策略适合于对延迟敏感的UI交互任务，当有UI交互任务的时候，该策略会更加激进并及时地调整CPU频率。</p><p>总而言之，系统的状态以及CPUFreq的策略共同决定了CPU频率跳变的目标，CPUFreq核心层并将目标频率传递给底层具体SoC的CPUFreq驱动，该驱动修改硬件，完成频率的变换，如图19.2所示。</p><p><img loading="lazy" alt="1746022458907" src="/assets/images/1746022458907-b5a4d4aa003d59cbbb7b4947729fb648.png" width="958" height="562" class="img_ev3q"></p><p>图19.2　CPUFreq、系统负载、策略与调频</p><p>用户空间一般可通过/sys/devices/system/cpu/cpux/cpufreq节点来设置CPUFreq。譬如，我们要设置CPUFreq到700MHz，采用userspace策略，则运行如下命令：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo userspace &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># echo 700000 &gt; /sys/devices/system/cpu/cpu0/cpufreq/scaling_setspeed</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>19.2.3　CPUFreq的性能测试和调优</h1><p>Linux 3.1以后的内核已经将cpupower-utils工具集放入内核的tools/power/cpupower目录中，该工具集当中的cpufreq-bench工具可以帮助工程师分析采用CPUFreq后对系统性能的影响。</p><p>cpufreq-bench工具的工作原理是模拟系统运行时候的“空闲→忙→空闲→忙”场景，从而触发系统的动态频率变化，然后在使用ondemand、conservative、interactive等策略的情况下，计算在做与performance高频模式下同样的运算完成任务的时间比例。</p><p>交叉编译该工具后，可放入目标电路板文件系统的/usr/sbin/等目录下，运行该工具：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># cpufreq-bench -l 50000 -s 100000 -x 50000 -y 100000 -g ondemand -r 5 -n 5 -v</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>会输出一系列的结果，我们提取其中的Round n这样的行，它表明了-g ondemand选项中设定的ondemand策略相对于performance策略的性能比例，假设值为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Round 1 - 39.74%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 2 - 36.35%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 3 - 47.91%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 4 - 54.22%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 5 - 58.64%</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这显然不太理想，我们在同样的平台下采用Android的交互策略，得到新的测试结果：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Round 1 - 72.95%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 2 - 87.20%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 3 - 91.21%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 4 - 94.10%</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Round 5 - 94.93%</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>一般的目标是在采用CPUFreq动态调整频率和电压后，性能应该为performance这个高性能策略下的90%左右，这样才比较理想。</p><h1>19.2.4　CPUFreq通知</h1><p>CPUFreq子系统会发出通知的情况有两种：CPUFreq的策略变化或者CPU运行频率变化。</p><p>在策略变化的过程中，会发送3次通知：</p><ul><li><p>·CPUFREQ_ADJUST：所有注册的notifier可以根据硬件或者温度的情况去修改范围（即policy-&gt;min和policy-&gt;max）；</p></li><li><p>·CPUFREQ_INCOMPATIBLE：除非前面的策略设定可能会导致硬件出错，否则被注册的notifier不能改变范围等设定；</p></li><li><p>·CPUFREQ_NOTIFY：所有注册的notifier都会被告知新的策略已经被设置。</p></li></ul><p>在频率变化的过程中，会发送2次通知：</p><ul><li>·CPUFREQ_PRECHANGE：准备进行频率变更；</li><li>·CPUFREQ_POSTCHANGE：已经完成频率变更。</li></ul><p>notifier中的第3个参数是一个cpufreq_freqs的结构体，包含cpu（CPU号）、old（过去的频率）和new（现在的频率）这3个成员。发送CPUFREQ_PRECHANGE和CPUFREQ_POSTCHANGE的代码如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CPUFREQ_PRECHANGE, freqs);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">srcu_notifier_call_chain(&amp;cpufreq_transition_notifier_list,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CPUFREQ_POSTCHANGE, freqs);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果某模块关心CPUFREQ_PRECHANGE或CPUFREQ_POSTCHANGE事件，可简单地使用Linux notifier机制监控。譬如，drivers/video/sa1100fb.c在CPU频率变化过程中需对自身硬件进行相关设置，因此它注册了notifier并在CPUFREQ_PRECHANGE和CPUFREQ_POSTCHANGE情况下分别进行不同的处理，如代码清单19.3所示。</p><p>代码清单19.3　CPUFreq notifier案例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1fbi-&gt;freq_transition.notifier_call = sa1100fb_freq_transition;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2cpufreq_register_notifier(&amp;fbi-&gt;freq_transition, CPUFREQ_TRANSITION_NOTIFIER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4sa1100fb_freq_transition(structnotifier_block *nb, unsigned long val,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5void *data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 struct sa1100fb_info *fbi = TO_INF(nb, freq_transition);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 struct cpufreq_freqs *f = data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9     u_intpcd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     switch (val) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         case CPUFREQ_PRECHANGE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13             set_ctrlr_state(fbi, C_DISABLE_CLKCHANGE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14             break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         case CPUFREQ_POSTCHANGE:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16             pcd = get_pcd(fbi-&gt;fb.var.pixclock, f-&gt;new);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17             fbi-&gt;reg_lccr3 = (fbi-&gt;reg_lccr3&amp; ~0xff) | LCCR3_PixClkDiv(pcd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18             set_ctrlr_state(fbi, C_ENABLE_CLKCHANGE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19             break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>此外，如果在系统挂起/恢复的过程中CPU频率会发生变化，则CPUFreq子系统也会发出CPUFREQ_SUSPENDCHANGE和CPUFREQ_RESUMECHANGE这两个通知。</p><p>值得一提的是，除了CPU以外，一些非CPU设备也支持多个操作频率和电压，存在多个OPP。Linux 3.2之后的内核也支持针对这种非CPU设备的DVFS，该套子系统为Devfreq。与CPUFreq存在一个drivers/cpufreq目录相似，在内核中也存在一个drivers/devfreq的目录。</p></div></article><article class="margin-bottom--xl" itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h2 class="blogPostTitle_Ikge" itemprop="headline"><a itemprop="url" href="/blog/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></h2><div class="blogPostData_SAv4 margin-vert--md"><time datetime="2025-09-15T14:44:14.605Z" itemprop="datePublished">2025年9月15日</time> · <!-- -->5 分钟阅读</div></header><div class="markdown" itemprop="articleBody"><p>并不是任何一个计算机系统都一定要有操作系统，在许多情况下，操作系统都不必存在。对于功能比较单一、控制并不复杂的系统，譬如ASIC内部、公交车的刷卡机、电冰箱、微波炉、简单的手机和小灵通等，并不需要多任务调度、文件系统、内存管理等复杂功能，用单任务架构完全可以良好地支持它们的工作。一个无限循环中夹杂着对设备中断的检测或者对设备的轮询是这种系统中软件的典型架构，如代码清单1.1所示。</p><p>代码清单1.1　单任务软件典型架构</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1 int main(int argc, char* argv[])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   while (1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5     if (serialInt == 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6     /* 有串口中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7     {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       ProcessSerialInt();   /* 处理串口中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       serialInt = 0;        /* 中断标志变量清</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     if (keyInt == 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     /* 有按键中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14       ProcessKeyInt();     /* 处理按键中断</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15       keyInt = 0;          /* 中断标志变量清</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     status = CheckXXX();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18     switch (status)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19     {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在这样的系统中，虽然不存在操作系统，但是设备驱动则无论如何都必须存在。一般情况下，每一种设备驱动都会定义为一个软件模块，包含.h文件和.c文件，前者定义该设备驱动的数据结构并声明外部函数，后者进行驱动的具体实现。譬如，可以像代码清单1.2那样定义一个串口的驱动。</p><p>代码清单1.2　无操作系统情况下串口的驱动</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1  /**********************</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2   *serial.h文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   **********************/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4  extern void SerialInit(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5  extern void SerialSend(const char buf*,int count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6  extern void SerialRecv(char buf*,int count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8  /**********************</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   *serial.c文件</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10   **********************/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11  /* 初始化串口</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12  void SerialInit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16  /* 串口发送</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17  void SerialSend(const char buf*,int count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21  /* 串口接收</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22  void SerialRecv(char buf*,int count)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26  /* 串口中断处理函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27  void SerialIsr(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30   serialInt = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>其他模块想要使用这个设备的时候，只需要包含设备驱动的头文件serial.h，然后调用其中的外部接口函数。如要从串口上发送“Hello World”字符串，使用语句SerialSend（“Hello World”，11）即可。</p><p>由此可见，在没有操作系统的情况下，设备驱动的接口被直接提交给应用软件工程师，应用软件没有跨越任何层次就直接访问设备驱动的接口。驱动包含的接口函数也与硬件的功能直接吻合，没有任何附加功能。图1.1所示为无操作系统情况下硬件、设备驱动与应用软件的关系。</p><p><img loading="lazy" alt="1742482124707" src="/assets/images/1742482124707-fc651df6de8de92110e9c1135634442a.png" width="579" height="592" class="img_ev3q"></p><p>图1.1　无操作系统时硬件、设备驱动和应用软件的关系</p><p>有的工程师把单任务系统设计成了如图1.2所示的结构，即设备驱动和具体的应用软件模块之间平等，驱动中包含了业务层面上的处理，这显然是不合理的，不符合软件设计中高内聚、低耦合的要求。</p><p>另一种不合理的设计是直接在应用中操作硬件的寄存器，而不单独设计驱动模块，如图1.3所示。这种设计意味着系统中不存在或未能充分利用可重用的驱动代码。</p><p><img loading="lazy" alt="image-20250320224927891" src="/assets/images/image-20250320224927891-785db830d843a645757a4a02c6660ae0.png" width="720" height="421" class="img_ev3q"></p><p>图1.2　驱动与应用高耦合的不合理设计</p><p><img loading="lazy" alt="1742482187369" src="/assets/images/1742482187369-65fdbb1a89064201382c9a95d9d0662f.png" width="601" height="405" class="img_ev3q"></p><p>图1.3　应用直接访问硬件的不合理设计</p></div></article><nav class="pagination-nav" aria-label="博文列表分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/page/7"><div class="pagination-nav__label">较新的博文</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/page/9"><div class="pagination-nav__label">较旧的博文</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>