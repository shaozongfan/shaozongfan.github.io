"use strict";(self.webpackChunkshaozongfan_website=self.webpackChunkshaozongfan_website||[]).push([[4195],{3905:function(e,t,n){n.d(t,{Zo:function(){return _},kt:function(){return l}});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},c=Object.keys(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)n=c[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var d=r.createContext({}),o=function(e){var t=r.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},_=function(e){var t=o(e.components);return r.createElement(d.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},a=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,c=e.originalType,d=e.parentName,_=u(e,["components","mdxType","originalType","parentName"]),a=o(n),l=i,p=a["".concat(d,".").concat(l)]||a[l]||h[l]||c;return n?r.createElement(p,s(s({ref:t},_),{},{components:n})):r.createElement(p,s({ref:t},_))}));function l(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var c=n.length,s=new Array(c);s[0]=a;var u={};for(var d in t)hasOwnProperty.call(t,d)&&(u[d]=t[d]);u.originalType=e,u.mdxType="string"==typeof e?e:i,s[1]=u;for(var o=2;o<c;o++)s[o]=n[o];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}a.displayName="MDXCreateElement"},85801:function(e,t,n){n.r(t),n.d(t,{assets:function(){return _},contentTitle:function(){return d},default:function(){return l},frontMatter:function(){return u},metadata:function(){return o},toc:function(){return h}});var r=n(87462),i=n(63366),c=(n(67294),n(3905)),s=["components"],u={},d="16.2.1\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784",o={unversionedId:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",id:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",title:"16.2.1\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784",description:"USB\u4e3b\u673a\u63a7\u5236\u5668\u6709\u8fd9\u4e9b\u89c4\u683c\uff1aOHCI\uff08Open Host Controller Interface\uff09\u3001UHCI\uff08Universal Host Controller Interface\uff09\u3001EHCI\uff08Enhanced Host Controller Interface\uff09\u548cxHCI\uff08eXtensible Host Controller Interface\uff09\u3002OHCI\u9a71\u52a8\u7a0b\u5e8f\u7528\u6765\u4e3a\u975ePC\u7cfb\u7edf\u4e0a\u4ee5\u53ca\u5e26\u6709SiS\u548cALi\u82af\u7247\u7ec4\u7684PC\u4e3b\u677f\u4e0a\u7684USB\u82af\u7247\u63d0\u4f9b\u652f\u6301\u3002UHCI\u9a71\u52a8\u7a0b\u5e8f\u591a\u7528\u6765\u4e3a\u5927\u591a\u6570\u5176\u4ed6PC\u4e3b\u677f\uff08\u5305\u62ecIntel\u548cVia\uff09\u4e0a\u7684USB\u82af\u7247\u63d0\u4f9b\u652f\u6301\u3002EHCI\u7531USB 2.0\u89c4\u8303\u6240\u63d0\u51fa\uff0c\u5b83\u517c\u5bb9\u4e8eOHCI\u548cUHCI\u3002\u7531\u4e8eUHCI\u7684\u786c\u4ef6\u7ebf\u8def\u6bd4OHCI\u7b80\u5355\uff0c\u6240\u4ee5\u6210\u672c\u8f83\u4f4e\uff0c\u4f46\u9700\u8981\u8f83\u590d\u6742\u7684\u9a71\u52a8\u7a0b\u5e8f\uff0cCPU\u8d1f\u8377\u7a0d\u91cd\u3002xHCI\uff0c\u5373\u53ef\u6269\u5c55\u7684\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\u662fIntel\u516c\u53f8\u5f00\u53d1\u7684\u4e00\u4e2aUSB\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\uff0c\u5b83\u76ee\u524d\u4e3b\u8981\u662f\u9762\u5411USB 3.0\u7684\uff0c\u540c\u65f6\u5b83\u4e5f\u652f\u6301USB 2.0\u53ca\u4ee5\u4e0b\u7684\u8bbe\u5907\u3002",source:"@site/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8.md",sourceDirName:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3",slug:"/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",permalink:"/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",draft:!1,editUrl:"https://github.com/shaozongfan/shaozongfan.github.io/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"16.1.1\u3000\u4e3b\u673a\u4fa7\u4e0e\u8bbe\u5907\u4fa7USB\u9a71\u52a8",permalink:"/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.1\u3000Linux USB\u9a71\u52a8\u5c42\u6b21"},next:{title:"16.3.1\u3000USB\u8bbe\u5907\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784",permalink:"/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8"}},_={},h=[{value:"1.\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",id:"1\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",level:2},{value:"2.EHCI\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",id:"2ehci\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",level:2}],a={toc:h};function l(e){var t=e.components,n=(0,i.Z)(e,s);return(0,c.kt)("wrapper",(0,r.Z)({},a,n,{components:t,mdxType:"MDXLayout"}),(0,c.kt)("h1",{id:"1621usb\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784"},"16.2.1\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784"),(0,c.kt)("p",null,"USB\u4e3b\u673a\u63a7\u5236\u5668\u6709\u8fd9\u4e9b\u89c4\u683c\uff1aOHCI\uff08Open Host Controller Interface\uff09\u3001UHCI\uff08Universal Host Controller Interface\uff09\u3001EHCI\uff08Enhanced Host Controller Interface\uff09\u548cxHCI\uff08eXtensible Host Controller Interface\uff09\u3002OHCI\u9a71\u52a8\u7a0b\u5e8f\u7528\u6765\u4e3a\u975ePC\u7cfb\u7edf\u4e0a\u4ee5\u53ca\u5e26\u6709SiS\u548cALi\u82af\u7247\u7ec4\u7684PC\u4e3b\u677f\u4e0a\u7684USB\u82af\u7247\u63d0\u4f9b\u652f\u6301\u3002UHCI\u9a71\u52a8\u7a0b\u5e8f\u591a\u7528\u6765\u4e3a\u5927\u591a\u6570\u5176\u4ed6PC\u4e3b\u677f\uff08\u5305\u62ecIntel\u548cVia\uff09\u4e0a\u7684USB\u82af\u7247\u63d0\u4f9b\u652f\u6301\u3002EHCI\u7531USB 2.0\u89c4\u8303\u6240\u63d0\u51fa\uff0c\u5b83\u517c\u5bb9\u4e8eOHCI\u548cUHCI\u3002\u7531\u4e8eUHCI\u7684\u786c\u4ef6\u7ebf\u8def\u6bd4OHCI\u7b80\u5355\uff0c\u6240\u4ee5\u6210\u672c\u8f83\u4f4e\uff0c\u4f46\u9700\u8981\u8f83\u590d\u6742\u7684\u9a71\u52a8\u7a0b\u5e8f\uff0cCPU\u8d1f\u8377\u7a0d\u91cd\u3002xHCI\uff0c\u5373\u53ef\u6269\u5c55\u7684\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\u662fIntel\u516c\u53f8\u5f00\u53d1\u7684\u4e00\u4e2aUSB\u4e3b\u673a\u63a7\u5236\u5668\u63a5\u53e3\uff0c\u5b83\u76ee\u524d\u4e3b\u8981\u662f\u9762\u5411USB 3.0\u7684\uff0c\u540c\u65f6\u5b83\u4e5f\u652f\u6301USB 2.0\u53ca\u4ee5\u4e0b\u7684\u8bbe\u5907\u3002"),(0,c.kt)("h2",{id:"1\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8"},"1.\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8"),(0,c.kt)("p",null,"\u5728Linux\u5185\u6838\u4e2d\uff0c\u7528usb_hcd\u7ed3\u6784\u4f53\u63cf\u8ff0USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\uff0c\u5b83\u5305\u542bUSB\u4e3b\u673a\u63a7\u5236\u5668\u7684\u201c\u5bb6\u52a1\u201d\u4fe1\u606f\u3001\u786c\u4ef6\u8d44\u6e90\u3001\u72b6\u6001\u63cf\u8ff0\u548c\u7528\u4e8e\u64cd\u4f5c\u4e3b\u673a\u63a7\u5236\u5668\u7684hc_driver\u7b49\uff0c\u5176\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u535516.6\u6240\u793a"),(0,c.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.6\u3000usb_hcd\u7ed3\u6784\u4f53"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"}," 1struct usb_hcd {\n 2   struct usb_bus         self;           /* hcd is-a bus */\n 3   struct kref        kref;               /* reference counter */\n 4\n 5   const char         *product_desc;      /* product/vendor string */\n 6   int            speed;                  /* Speed for this roothub.\n 7                           * May be different from\n 8                           * hcd->driver->flags & HCD_MASK\n 9                           */\n10   char           irq_descr[24];          /* driver + bus # */\n11\n12   struct timer_list rh_timer;            /* drives root-hub polling */\n13   struct urb     *status_urb;            /* the current status urb */\n14#ifdef CONfiG_PM\n15   struct work_struct    wakeup_work;     /* for remote wakeup */\n16#endif\n17\n18   const struct hc_driver    *driver;     /* hw-specific hooks */\n19\n20   struct usb_phy        *usb_phy;\n21   struct phy        *phy;\n22\n23   unsigned long     flags;\n24\n25   \u2026\n26\n27   /* The HC driver's private data is stored at the end of\n28   * this structure.\n29   */\n30   unsigned long hcd_priv[0]\n31            __attribute__ ((aligned(sizeof(s64))));\n32};\n")),(0,c.kt)("p",null,"usb_hcd\u7ed3\u6784\u4f53\u4e2d\u7b2c18\u884c\u7684hc_driver\u6210\u5458\u975e\u5e38\u91cd\u8981\uff0c\u5b83\u5305\u542b\u5177\u4f53\u7684\u7528\u4e8e\u64cd\u4f5c\u4e3b\u673a\u63a7\u5236\u5668\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u5373\u201chw-specific hooks\u201d\uff0c\u5176\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u535516.7\u6240\u793a\u3002"),(0,c.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.7\u3000hc_driver\u7ed3\u6784\u4f53"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},' 1struct hc_driver {\n 2   const char   *description;          /* "ehci-hcd" etc */\n 3   const char   *product_desc;         /* product/vendor string */\n 4   size_t       hcd_priv_size;         /* size of private data */\n 5\n 6   /* irq handler */\n 7   irqreturn_t(*irq) (struct usb_hcd *hcd);\n 8\n 9   int flags;\n10\n11   /* called to init HCD and root hub */\n12   int (*reset) (struct usb_hcd *hcd);\n13   int (*start) (struct usb_hcd *hcd);\n14   ...\n15   /* cleanly make HCD stop writing memory and doing I/O */\n16   void (*stop) (struct usb_hcd *hcd);\n17\n18   /* shutdown HCD */\n19   void (*shutdown) (struct usb_hcd *hcd);\n20\n21   /* return current frame number */\n22   int (*get_frame_number) (struct usb_hcd *hcd);\n23\n24   /* manage i/o requests, device state */\n25   int (*urb_enqueue)(struct usb_hcd *hcd,\n26                      struct urb *urb, gfp_t mem_flags);\n27   int (*urb_dequeue)(struct usb_hcd *hcd,\n28               struct urb *urb, int status);\n29   ...\n30        /* Allocate endpoint resources and add them to a new schedule */\n31   int (*add_endpoint)(struct usb_hcd *, struct usb_device *,\n32               struct usb_host_endpoint *);\n33        /* Drop an endpoint from a new schedule */\n34   int (*drop_endpoint)(struct usb_hcd *, struct usb_device *,\n35                        struct usb_host_endpoint *);\n36\n37   int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);\n38   void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);\n39        /* Returns the hardware-chosen device address */\n40   int (*address_device)(struct usb_hcd *, struct usb_device *udev);\n41   ...\n42   int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);\n43   /* USB 3.0 Link Power Management */\n44        /* Returns the USB3 hub-encoded value for the U1/U2 timeout. */\n45   int (*enable_usb3_lpm_timeout)(struct usb_hcd *,\n46           struct usb_device *, enum usb3_link_state state);\n47   int (*disable_usb3_lpm_timeout)(struct usb_hcd *,\n48           struct usb_device *, enum usb3_link_state state);\n49   int (*find_raw_port_number)(struct usb_hcd *, int);\n50   /* Call for power on/off the port if necessary */\n51   int (*port_power)(struct usb_hcd *hcd, int portnum, bool enable);\n52};\n')),(0,c.kt)("p",null,"\u5728Linux\u5185\u6838\u4e2d\uff0c\u4f7f\u7528\u5982\u4e0b\u51fd\u6570\u6765\u521b\u5efaHCD\uff1a"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,\n      struct device *dev, char *bus_name);\n")),(0,c.kt)("p",null,"\u5982\u4e0b\u51fd\u6570\u88ab\u7528\u6765\u589e\u52a0\u548c\u79fb\u9664HCD\uff1a"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"int usb_add_hcd(struct usb_hcd *hcd,\n       unsigned int irqnum, unsigned long irqflags);\nvoid usb_remove_hcd(struct usb_hcd *hcd);\n")),(0,c.kt)("p",null,"\u7b2c25\u884c\u7684urb_enqueue\uff08\uff09\u51fd\u6570\u975e\u5e38\u5173\u952e\uff0c\u5b9e\u9645\u4e0a\uff0c\u4e0a\u5c42\u901a\u8fc7usb_submit_urb\uff08\uff09\u63d0\u4ea41\u4e2aUSB\u8bf7\u6c42\u540e\uff0c\u8be5\u51fd\u6570\u8c03\u7528usb_hcd_submit_urb\uff08\uff09\uff0c\u5e76\u6700\u7ec8\u8c03\u7528\u81f3usb_hcd\u7684driver\u6210\u5458\uff08hc_driver\u7c7b\u578b\uff09\u7684urb_enqueue\uff08\uff09\u51fd\u6570\u3002"),(0,c.kt)("h2",{id:"2ehci\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8"},"2.EHCI\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8"),(0,c.kt)("p",null,"EHCI HCD\u9a71\u52a8\u5c5e\u4e8eHCD\u9a71\u52a8\u7684\u5b9e\u4f8b\uff0c\u5b83\u5b9a\u4e49\u4e86\u4e00\u4e2aehci_hcd\u7ed3\u6784\u4f53\uff0c\u901a\u5e38\u4f5c\u4e3a\u4ee3\u7801\u6e05\u535516.6\u5b9a\u4e49\u7684usb_hcd\u7ed3\u6784\u4f53\u7684\u79c1\u6709\u6570\u636e\uff08hcd_priv\uff09\uff0c\u8fd9\u4e2a\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\u4f4d\u4e8edrivers/usb/host/ehci.h\u4e2d\uff0c\u5982\u4ee3\u7801\u6e05\u535516.8\u6240\u793a\u3002"),(0,c.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.8\u3000ehci_hcd\u7ed3\u6784\u4f53"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"}," 1struct ehci_hcd {                      /* one per controller */\n 2   /* timing support */\n 3   enum ehci_hrtimer_event    next_hrtimer_event;\n 4   unsigned     enabled_hrtimer_events;\n 5   ktime_t          hr_timeouts[EHCI_HRTIMER_NUM_EVENTS];\n 6   struct hrtimer       hrtimer;\n 7\n 8   int          PSS_poll_count;\n 9   int          ASS_poll_count;\n10   int          died_poll_count;\n11   ...\n12   /* general schedule support */\n13   bool         scanning:1;\n14   bool         need_rescan:1;\n15   bool         intr_unlinking:1;\n16   bool         iaa_in_progress:1;\n17   bool         async_unlinking:1;\n18   bool         shutdown:1;\n19   struct ehci_qh        *qh_scan_next;\n20\n21   /* async schedule support */\n22   struct ehci_qh        *async;\n23   struct ehci_qh        *dummy;         /* For AMD quirk use */\n24   struct list_head  async_unlink;\n25   struct list_head  async_idle;\n26   unsigned     async_unlink_cycle;\n27   unsigned     async_count;             /* async activity count */\n28\n29   /* periodic schedule support */\n30#define    DEFAULT_I_TDPS       1024   /* some HCs can do less */\n31   unsigned      periodic_size;\n32   __hc32            *periodic;          /* hw periodic table */\n33   dma_addr_t        periodic_dma;\n34   struct list_head  intr_qh_list;\n35   unsigned     i_thresh;                /* uframes HC might cache */\n36   ...\n37   /* bandwidth usage */\n38#define EHCI_BANDWIDTH_SIZE 64\n39#define EHCI_BANDWIDTH_FRAMES   (EHCI_BANDWIDTH_SIZE >> 3)\n40   u8           bandwidth[EHCI_BANDWIDTH_SIZE];\n41                         /* us allocated per uframe */\n42   u8           tt_budget[EHCI_BANDWIDTH_SIZE];\n43                         /* us budgeted per uframe */\n44   struct list_head tt_list;\n45\n46   /* platform-specific data -- must come last */\n47   unsigned long    priv[0] __aligned(sizeof(s64));\n48};\n")),(0,c.kt)("p",null,"\u4f7f\u7528\u5982\u4e0b\u5185\u8054\u51fd\u6570\u53ef\u5b9e\u73b0usb_hcd\u548cehci_hcd\u7684\u76f8\u4e92\u8f6c\u6362\uff1a"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"struct ehci_hcd *hcd_to_ehci (struct usb_hcd *hcd);\nstruct usb_hcd *ehci_to_hcd (const struct ohci_hcd *ohci);\n")),(0,c.kt)("p",null,"\u4eceusb_hcd\u5f97\u5230ehci_hcd\u53ea\u662f\u53d6\u5f97\u201c\u79c1\u6709\u201d\u6570\u636e\uff0c\u800c\u4eceehci_hcd\u5f97\u5230usb_hcd\u5219\u662f\u901a\u8fc7container_of\uff08\uff09\u4ece\u7ed3\u6784\u4f53\u6210\u5458\u83b7\u5f97\u7ed3\u6784\u4f53\u6307\u9488\u3002"),(0,c.kt)("p",null,"\u4f7f\u7528\u5982\u4e0b\u51fd\u6570\u53ef\u521d\u59cb\u5316EHCI\u4e3b\u673a\u63a7\u5236\u5668\uff1a"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"static int ehci_init(struct usb_hcd *hcd);\n")),(0,c.kt)("p",null,"\u5982\u4e0b\u51fd\u6570\u5206\u522b\u7528\u4e8e\u5f00\u542f\u3001\u505c\u6b62\u53ca\u590d\u4f4dEHCI\u63a7\u5236\u5668\uff1a"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"static int ehci_run (struct usb_hcd *hcd);\nstatic void ehci_stop (struct usb_hcd *hcd);\nstatic int ehci_reset (struct ehci_hcd *ehci);\n")),(0,c.kt)("p",null,"\u4e0a\u8ff0\u51fd\u6570\u5728drivers/usb/host/ehci-hcd.c\u6587\u4ef6\u4e2d\u88ab\u586b\u5145\u7ed9\u4e86\u4e00\u4e2ahc_driver\u7ed3\u6784\u4f53\u7684generic\u7684\u5b9e\u4f8behci_hc_driver\u3002"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"static const struct hc_driver ehci_hc_driver = {\n       ...\n       .reset =             ehci_setup,\n       .start =             ehci_run,\n       .stop =              ehci_stop,\n       .shutdown =          ehci_shutdown,\n}\n")),(0,c.kt)("p",null,"drivers/usb/host/ehci-hcd.c\u5b9e\u73b0\u4e86\u7edd\u5927\u591a\u6570ECHI\u4e3b\u673a\u9a71\u52a8\u7684\u5de5\u4f5c\uff0c\u5177\u4f53\u7684EHCI\u5b9e\u4f8b\u7b80\u5355\u5730\u8c03\u7528"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},"void ehci_init_driver(struct hc_driver *drv,\n             const struct ehci_driver_overrides *over);\n")),(0,c.kt)("p",null,"\u521d\u59cb\u5316hc_driver\u5373\u53ef\uff0c\u8fd9\u4e2a\u51fd\u6570\u4f1a\u88abgeneric\u7684ehci_hc_driver\u5b9e\u4f8b\u590d\u5236\u7ed9\u6bcf\u4e2a\u5177\u4f53\u5e95\u5c42\u9a71\u52a8\u7684\u5b9e\u4f8b\uff0c\u5f53\u7136\u5e95\u5c42\u9a71\u52a8\u53ef\u4ee5\u901a\u8fc7\u7b2c2\u4e2a\u53c2\u6570\uff0c\u5373ehci_driver_overrides\u91cd\u5199\u4e2d\u95f4\u5c42\u7684reset\uff08\uff09\u3001port_power\uff08\uff09\u8fd92\u4e2a\u51fd\u6570\uff0c\u53e6\u5916\u4e5f\u53ef\u4ee5\u586b\u5145\u4e00\u4e9b\u989d\u5916\u7684\u79c1\u6709\u6570\u636e\uff0c\u8fd9\u4e00\u70b9\u4ece\u4ee3\u7801\u6e05\u535516.9ehci_init_driver\uff08\uff09\u7684\u5b9e\u73b0\u4e2d\u53ef\u4ee5\u770b\u51fa\u3002"),(0,c.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.9\u3000ehci_init_driver\u7684\u5b9e\u73b0"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"}," 1void ehci_init_driver(struct hc_driver *drv,\n 2               const struct ehci_driver_overrides *over)\n 3{\n 4        /* Copy the generic table to drv and then apply the overrides */\n 5        *drv = ehci_hc_driver;\n 6\n 7        if (over) {\n 8               drv->hcd_priv_size += over->extra_priv_size;\n 9               if (over->reset)\n10                      drv->reset = over->reset;\n11               if (over->port_power)\n12                      drv->port_power = over->port_power;\n13         }\n14 }\n")),(0,c.kt)("h1",{id:"1622\u5b9e\u4f8bchipidea-usb\u4e3b\u673a\u9a71\u52a8"},"16.2.2\u3000\u5b9e\u4f8b\uff1aChipidea USB\u4e3b\u673a\u9a71\u52a8"),(0,c.kt)("p",null,"Chipidea\u7684USB IP\u5728\u5d4c\u5165\u5f0f\u7cfb\u7edf\u4e2d\u5e94\u7528\u6bd4\u8f83\u5e7f\u6cdb\uff0c\u5b83\u7684\u9a71\u52a8\u4f4d\u4e8edrivers/usb/chipidea/\u76ee\u5f55\u4e0b"),(0,c.kt)("p",null,"\u5f53Chipidea USB\u9a71\u52a8\u7684\u5185\u6838\u4ee3\u7801drivers/usb/chipidea/core.c\u4e2d\u7684ci_hdrc_probe\uff08\uff09\u88ab\u6267\u884c\u540e\uff08\u5373\u4e00\u4e2aplatform_device\u4e0eci_hdrc_driver\u8fd9\u4e2aplatform_driver\u5339\u914d\u4e0a\u4e86\uff09\uff0c\u5b83\u4f1a\u8c03\u7528drivers/usb/chipidea/host.c\u4e2d\u7684ci_hdrc_host_init\uff08\uff09\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u5b8c\u6210hc_driver\u7684\u521d\u59cb\u5316\u5e76\u8d4b\u503c\u4e00\u7cfb\u5217\u4e0eChipidea\u5e73\u53f0\u76f8\u5173\u7684\u79c1\u6709\u6570\u636e\uff0c\u5982\u4ee3\u7801\u6e05\u535516.10\u6240\u793a\u3002"),(0,c.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.10\u3000Chipidea USB host\u9a71\u52a8\u521d\u59cb\u5316"),(0,c.kt)("pre",null,(0,c.kt)("code",{parentName:"pre"},' 1int ci_hdrc_host_init(struct ci_hdrc *ci)\n 2{\n 3        struct ci_role_driver *rdrv;\n 4\n 5        if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))\n 6               return -ENXIO;\n 7\n 8        rdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);\n 9        if (!rdrv)\n10               return -ENOMEM;\n11\n12        rdrv->start    = host_start;\n13        rdrv->stop     = host_stop;\n14        rdrv->irq      = host_irq;\n15        rdrv->name     = "host";\n16        ci->roles[CI_ROLE_HOST] = rdrv;\n17\n18        ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);\n19\n20        return 0;\n21 }\n')))}l.isMDXComponent=!0}}]);