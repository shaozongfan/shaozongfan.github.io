"use strict";(self.webpackChunkshaozongfan_website=self.webpackChunkshaozongfan_website||[]).push([[1441],{3905:function(e,n,l){l.d(n,{Zo:function(){return d},kt:function(){return p}});var t=l(67294);function o(e,n,l){return n in e?Object.defineProperty(e,n,{value:l,enumerable:!0,configurable:!0,writable:!0}):e[n]=l,e}function r(e,n){var l=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),l.push.apply(l,t)}return l}function i(e){for(var n=1;n<arguments.length;n++){var l=null!=arguments[n]?arguments[n]:{};n%2?r(Object(l),!0).forEach((function(n){o(e,n,l[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(l)):r(Object(l)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(l,n))}))}return e}function m(e,n){if(null==e)return{};var l,t,o=function(e,n){if(null==e)return{};var l,t,o={},r=Object.keys(e);for(t=0;t<r.length;t++)l=r[t],n.indexOf(l)>=0||(o[l]=e[l]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)l=r[t],n.indexOf(l)>=0||Object.prototype.propertyIsEnumerable.call(e,l)&&(o[l]=e[l])}return o}var a=t.createContext({}),_=function(e){var n=t.useContext(a),l=n;return e&&(l="function"==typeof e?e(n):i(i({},n),e)),l},d=function(e){var n=_(e.components);return t.createElement(a.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},u=t.forwardRef((function(e,n){var l=e.components,o=e.mdxType,r=e.originalType,a=e.parentName,d=m(e,["components","mdxType","originalType","parentName"]),u=_(l),p=o,s=u["".concat(a,".").concat(p)]||u[p]||c[p]||r;return l?t.createElement(s,i(i({ref:n},d),{},{components:l})):t.createElement(s,i({ref:n},d))}));function p(e,n){var l=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=l.length,i=new Array(r);i[0]=u;var m={};for(var a in n)hasOwnProperty.call(n,a)&&(m[a]=n[a]);m.originalType=e,m.mdxType="string"==typeof e?e:o,i[1]=m;for(var _=2;_<r;_++)i[_]=l[_];return t.createElement.apply(null,i)}return t.createElement.apply(null,l)}u.displayName="MDXCreateElement"},50065:function(e,n,l){l.r(n),l.d(n,{assets:function(){return d},contentTitle:function(){return a},default:function(){return p},frontMatter:function(){return m},metadata:function(){return _},toc:function(){return c}});var t=l(87462),o=l(63366),r=(l(67294),l(3905)),i=["components"],m={},a="6.3.1\u3000\u5934\u6587\u4ef6\u3001\u5b8f\u53ca\u8bbe\u5907\u7ed3\u6784\u4f53",_={unversionedId:"linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.3\u3000globalmem\u8bbe\u5907\u9a71\u52a8",id:"linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.3\u3000globalmem\u8bbe\u5907\u9a71\u52a8",title:"6.3.1\u3000\u5934\u6587\u4ef6\u3001\u5b8f\u53ca\u8bbe\u5907\u7ed3\u6784\u4f53",description:"\u5728globalmem\u5b57\u7b26\u8bbe\u5907\u9a71\u52a8\u4e2d\uff0c\u5e94\u5305\u542b\u5b83\u8981\u4f7f\u7528\u7684\u5934\u6587\u4ef6\uff0c\u5e76\u5b9a\u4e49globalmem\u8bbe\u5907\u7ed3\u6784\u4f53\u53ca\u76f8\u5173\u5b8f\u3002",source:"@site/docs/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.3\u3000globalmem\u8bbe\u5907\u9a71\u52a8.md",sourceDirName:"linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3",slug:"/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.3\u3000globalmem\u8bbe\u5907\u9a71\u52a8",permalink:"/docs/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.3\u3000globalmem\u8bbe\u5907\u9a71\u52a8",draft:!1,editUrl:"https://github.com/shaozongfan/shaozongfan.github.io/docs/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.3\u3000globalmem\u8bbe\u5907\u9a71\u52a8.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"6.2\u3000globalmem\u865a\u62df\u8bbe\u5907\u5b9e\u4f8b\u63cf\u8ff0",permalink:"/docs/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/6.2\u3000globalmem\u865a\u62df\u8bbe\u5907\u5b9e\u4f8b\u63cf\u8ff0"},next:{title:"7.10\u3000\u603b\u7ed3",permalink:"/docs/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/7.10\u3000\u603b\u7ed3"}},d={},c=[{value:"1.globalmem\u8bbe\u5907\u9a71\u52a8\u7684ioctl\uff08\uff09\u51fd\u6570",id:"1globalmem\u8bbe\u5907\u9a71\u52a8\u7684ioctl\u51fd\u6570",level:2},{value:"2.ioctl\uff08\uff09\u547d\u4ee4",id:"2ioctl\u547d\u4ee4",level:2},{value:"3.\u9884\u5b9a\u4e49\u547d\u4ee4",id:"3\u9884\u5b9a\u4e49\u547d\u4ee4",level:2}],u={toc:c};function p(e){var n=e.components,m=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,t.Z)({},u,m,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"631\u5934\u6587\u4ef6\u5b8f\u53ca\u8bbe\u5907\u7ed3\u6784\u4f53"},"6.3.1\u3000\u5934\u6587\u4ef6\u3001\u5b8f\u53ca\u8bbe\u5907\u7ed3\u6784\u4f53"),(0,r.kt)("p",null,"\u5728globalmem\u5b57\u7b26\u8bbe\u5907\u9a71\u52a8\u4e2d\uff0c\u5e94\u5305\u542b\u5b83\u8981\u4f7f\u7528\u7684\u5934\u6587\u4ef6\uff0c\u5e76\u5b9a\u4e49globalmem\u8bbe\u5907\u7ed3\u6784\u4f53\u53ca\u76f8\u5173\u5b8f\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.8\u3000globalmem\u8bbe\u5907\u7ed3\u6784\u4f53\u548c\u5b8f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," 1#include <linux/module.h>\n 2#include <linux/fs.h>\n 3#include <linux/init.h>\n 4#include <linux/cdev.h>\n 5#include <linux/slab.h>\n 6#include <linux/uaccess.h>\n 7\n 8#define GLOBALMEM_SIZE   0x1000\n 9#define MEM_CLEAR 0x1\n10#define GLOBALMEM_MAJOR 230\n11\n12static int globalmem_major = GLOBALMEM_MAJOR;\n13module_param(globalmem_major, int, S_IRUGO);\n14\n15struct globalmem_dev {\n16 struct cdev cdev;\n17 unsigned char mem[GLOBALMEM_SIZE];\n18};\n19\n20struct globalmem_dev *globalmem_devp;\n")),(0,r.kt)("p",null,"\u4ece\u7b2c15~18\u884c\u4ee3\u7801\u53ef\u4ee5\u770b\u51fa\uff0c\u5b9a\u4e49\u7684globalmem_dev\u8bbe\u5907\u7ed3\u6784\u4f53\u5305\u542b\u4e86\u5bf9\u5e94\u4e8eglobalmem\u5b57\u7b26\u8bbe\u5907\u7684cdev\u3001\u4f7f\u7528\u7684\u5185\u5b58mem","[GLOBALMEM_SIZE]","\u3002\u5f53\u7136\uff0c\u7a0b\u5e8f\u4e2d\u5e76\u4e0d\u4e00\u5b9a\u8981\u628amem","[GLOBALMEM_SIZE]","\u548ccdev\u5305\u542b\u5728\u4e00\u4e2a\u8bbe\u5907\u7ed3\u6784\u4f53\u4e2d\uff0c\u4f46\u8fd9\u6837\u5b9a\u4e49\u7684\u597d\u5904\u5728\u4e8e\uff0c\u5b83\u501f\u7528\u4e86\u9762\u5411\u5bf9\u8c61\u7a0b\u5e8f\u8bbe\u8ba1\u4e2d\u201c\u5c01\u88c5\u201d\u7684\u601d\u60f3\uff0c\u4f53\u73b0\u4e86\u4e00\u79cd\u826f\u597d\u7684\u7f16\u7a0b\u4e60\u60ef\u3002"),(0,r.kt)("h1",{id:"632\u52a0\u8f7d\u4e0e\u5378\u8f7d\u8bbe\u5907\u9a71\u52a8"},"6.3.2\u3000\u52a0\u8f7d\u4e0e\u5378\u8f7d\u8bbe\u5907\u9a71\u52a8"),(0,r.kt)("p",null,"globalmem\u8bbe\u5907\u9a71\u52a8\u7684\u6a21\u5757\u52a0\u8f7d\u548c\u5378\u8f7d\u51fd\u6570\u9075\u5faa\u4ee3\u7801\u6e05\u53556.5\u7684\u7c7b\u4f3c\u6a21\u677f\uff0c\u5176\u5b9e\u73b0\u7684\u5de5\u4f5c\u4e0e\u4ee3\u7801\u6e05\u53556.5\u5b8c\u5168\u4e00\u81f4\uff0c\u5982\u4ee3\u7801\u6e05\u53556.9\u6240\u793a\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.9\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u6a21\u5757\u7684\u52a0\u8f7d\u4e0e\u5378\u8f7d\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' 1static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)\n 2{\n 3  int err, devno = MKDEV(globalmem_major, index);\n 4\n 5  cdev_init(&dev->cdev, &globalmem_fops);\n 6  dev->cdev.owner = THIS_MODULE;\n 7  err = cdev_add(&dev->cdev, devno, 1);\n 8  if (err)\n 9       printk(KERN_NOTICE "Error %d adding globalmem%d", err, index);\n10}\n11\n12static int __init globalmem_init(void)\n13{\n14  int ret;\n15  dev_t devno = MKDEV(globalmem_major, 0);\n16\n17  if (globalmem_major)\n18       ret = register_chrdev_region(devno, 1, "globalmem");\n19  else {\n20       ret = alloc_chrdev_region(&devno, 0, 1, "globalmem");\n21       globalmem_major = MAJOR(devno);\n22  }\n23  if (ret < 0)\n24      return ret;\n25\n26  globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);\n27  if (!globalmem_devp) {\n28       ret = -ENOMEM;\n29       goto fail_malloc;\n30  }\n31\n32  globalmem_setup_cdev(globalmem_devp, 0);\n33  return 0;\n34\n35  fail_malloc:\n36  unregister_chrdev_region(devno, 1);\n37  return ret;\n38}\n39module_init(globalmem_init);\n')),(0,r.kt)("p",null,"\u7b2c1~10\u884c\u7684globalmem_setup_cdev\uff08\uff09\u51fd\u6570\u5b8c\u6210cdev\u7684\u521d\u59cb\u5316\u548c\u6dfb\u52a0\uff0c17~22\u884c\u5b8c\u6210\u4e86\u8bbe\u5907\u53f7\u7684\u7533\u8bf7\uff0c\u7b2c26\u884c\u8c03\u7528kzalloc\uff08\uff09\u7533\u8bf7\u4e86\u4e00\u4efdglobalmem_dev\u7ed3\u6784\u4f53\u7684\u5185\u5b58\u5e76\u6e050\u3002\u5728cdev_init\uff08\uff09\u51fd\u6570\u4e2d\uff0c\u4e0eglobalmem\u7684cdev\u5173\u8054\u7684file_operations\u7ed3\u6784\u4f53\u5982\u4ee3\u7801\u6e05\u53556.10\u6240\u793a\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.10\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u7684\u6587\u4ef6\u64cd\u4f5c\u7ed3\u6784\u4f53"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1static const struct file_operations globalmem_fops = {\n2   .owner = THIS_MODULE,\n3   .llseek = globalmem_llseek,\n4   .read = globalmem_read,\n5   .write = globalmem_write,\n6   .unlocked_ioctl = globalmem_ioctl,\n7   .open = globalmem_open,\n8   .release = globalmem_release,\n9};\n")),(0,r.kt)("h1",{id:"633\u8bfb\u5199\u51fd\u6570"},"6.3.3\u3000\u8bfb\u5199\u51fd\u6570"),(0,r.kt)("p",null,"globalmem\u8bbe\u5907\u9a71\u52a8\u7684\u8bfb\u5199\u51fd\u6570\u4e3b\u8981\u662f\u8ba9\u8bbe\u5907\u7ed3\u6784\u4f53\u7684mem[]\u6570\u7ec4\u4e0e\u7528\u6237\u7a7a\u95f4\u4ea4\u4e92\u6570\u636e\uff0c\u5e76\u968f\u7740\u8bbf\u95ee\u7684\u5b57\u8282\u6570\u53d8\u66f4\u66f4\u65b0\u6587\u4ef6\u8bfb\u5199\u504f\u79fb\u4f4d\u7f6e\u3002\u8bfb\u548c\u5199\u51fd\u6570\u7684\u5b9e\u73b0\u5206\u522b\u5982\u4ee3\u7801\u6e05\u53556.11\u548c6.12\u6240\u793a"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.11\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u7684\u8bfb\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' 1static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size,\n 2              loff_t * ppos)\n 3{\n 4 unsigned long p = *ppos;\n 5 unsigned int count = size;\n 6 int ret = 0;\n 7 struct globalmem_dev *dev = filp->private_data;\n 8\n 9 if (p >= GLOBALMEM_SIZE)\n10      return 0;\n11 if (count > GLOBALMEM_SIZE - p)\n12     count = GLOBALMEM_SIZE - p;\n13\n14 if (copy_to_user(buf, dev->mem + p, count)) {\n15     ret = -EFAULT;\n16 } else {\n17     *ppos += count;\n18     ret = count;\n19\n20     printk(KERN_INFO "read %u bytes(s) from %lu\\n", count, p);\n21 }\n22\n23 return ret;\n24}\n')),(0,r.kt)("p",null,"*ppos\u662f\u8981\u8bfb\u7684\u4f4d\u7f6e\u76f8\u5bf9\u4e8e\u6587\u4ef6\u5f00\u5934\u7684\u504f\u79fb\uff0c\u5982\u679c\u8be5\u504f\u79fb\u5927\u4e8e\u6216\u7b49\u4e8eGLOBALMEM_SIZE\uff0c\u610f\u5473\u7740\u5df2\u7ecf\u5230\u8fbe\u6587\u4ef6\u672b\u5c3e\uff0c\u6240\u4ee5\u8fd4\u56de0\uff08EOF\uff09\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.12\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u7684\u5199\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' 1static ssize_t globalmem_write(struct file *filp, const char __user * buf,\n 2                size_t size, loff_t * ppos)\n 3{\n 4 unsigned long p = *ppos;\n 5 unsigned int count = size;\n 6 int ret = 0;\n 7 struct globalmem_dev *dev = filp->private_data;\n 8\n 9 if (p >= GLOBALMEM_SIZE)\n10     return 0;\n11 if (count > GLOBALMEM_SIZE - p)\n12     count = GLOBALMEM_SIZE - p;\n13\n14 if (copy_from_user(dev->mem + p, buf, count))\n15     ret = -EFAULT;\n16 else {\n17     *ppos += count;\n18     ret = count;\n19\n20     printk(KERN_INFO "written %u bytes(s) from %lu\\n", count, p);\n21 }\n22\n23 return ret;\n24}\n')),(0,r.kt)("h1",{id:"634seek\u51fd\u6570"},"6.3.4\u3000seek\u51fd\u6570"),(0,r.kt)("p",null,"seek\uff08\uff09\u51fd\u6570\u5bf9\u6587\u4ef6\u5b9a\u4f4d\u7684\u8d77\u59cb\u5730\u5740\u53ef\u4ee5\u662f\u6587\u4ef6\u5f00\u5934\uff08SEEK_SET\uff0c0\uff09\u3001\u5f53\u524d\u4f4d\u7f6e\uff08SEEK_CUR\uff0c1\uff09\u548c\u6587\u4ef6\u5c3e\uff08SEEK_END\uff0c2\uff09\uff0c\u5047\u8bbeglobalmem\u652f\u6301\u4ece\u6587\u4ef6\u5f00\u5934\u548c\u5f53\u524d\u4f4d\u7f6e\u7684\u76f8\u5bf9\u504f\u79fb\u3002"),(0,r.kt)("p",null,"\u5728\u5b9a\u4f4d\u7684\u65f6\u5019\uff0c\u5e94\u8be5\u68c0\u67e5\u7528\u6237\u8bf7\u6c42\u7684\u5408\u6cd5\u6027\uff0c\u82e5\u4e0d\u5408\u6cd5\uff0c\u51fd\u6570\u8fd4\u56de-EINVAL\uff0c\u5408\u6cd5\u65f6\u66f4\u65b0\u6587\u4ef6\u7684\u5f53\u524d\u4f4d\u7f6e\u5e76\u8fd4\u56de\u8be5\u4f4d\u7f6e\uff0c\u5982\u4ee3\u7801\u6e05\u53556.13\u6240\u793a\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.13\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u7684seek\uff08\uff09\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," 1static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)\n 2{\n 3  loff_t ret = 0;\n 4  switch (orig) {\n 5  case 0: /* \u4ece\u6587\u4ef6\u5f00\u5934\u4f4d\u7f6eseek */\n 6       if (offset< 0) {\n 7            ret = -EINVAL;\n 8            break;\n 9       }\n10       if ((unsigned int)offset > GLOBALMEM_SIZE) {\n11            ret = -EINVAL;\n12            break;\n13       }\n14       filp->f_pos = (unsigned int)offset;\n15       ret = filp->f_pos;\n16       break;\n17  case 1: /* \u4ece\u6587\u4ef6\u5f53\u524d\u4f4d\u7f6e\u5f00\u59cbseek */\n18       if ((filp->f_pos + offset) > GLOBALMEM_SIZE) {\n19            ret = -EINVAL;\n20            break;\n21       }\n22       if ((filp->f_pos + offset) < 0) {\n23            ret = -EINVAL;\n24            break;\n25       }\n26       filp->f_pos += offset;\n27       ret = filp->f_pos;\n28       break;\n29  default:\n30       ret = -EINVAL;\n31       break;\n32  }\n33  return ret;\n34}\n")),(0,r.kt)("h1",{id:"635ioctl\u51fd\u6570"},"6.3.5\u3000ioctl\u51fd\u6570"),(0,r.kt)("h2",{id:"1globalmem\u8bbe\u5907\u9a71\u52a8\u7684ioctl\u51fd\u6570"},"1.globalmem\u8bbe\u5907\u9a71\u52a8\u7684ioctl\uff08\uff09\u51fd\u6570"),(0,r.kt)("p",null,"globalmem\u8bbe\u5907\u9a71\u52a8\u7684ioctl\uff08\uff09\u51fd\u6570\u63a5\u53d7MEM_CLEAR\u547d\u4ee4\uff0c\u8fd9\u4e2a\u547d\u4ee4\u4f1a\u5c06\u5168\u5c40\u5185\u5b58\u7684\u6709\u6548\u6570\u636e\u957f\u5ea6\u6e050\uff0c\u5bf9\u4e8e\u8bbe\u5907\u4e0d\u652f\u6301\u7684\u547d\u4ee4\uff0cioctl\uff08\uff09\u51fd\u6570\u5e94\u8be5\u8fd4\u56de-EINVAL\uff0c\u5982\u4ee3\u7801\u6e05\u53556.14\u6240\u793a\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.14\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u7684I/O\u63a7\u5236\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' 1static long globalmem_ioctl(struct file *filp, unsigned int cmd,\n 2                unsigned long arg)\n 3{\n 4  struct globalmem_dev *dev = filp->private_data;\n 5\n 6  switch (cmd) {\n 7  case MEM_CLEAR:\n 8       memset(dev->mem, 0, GLOBALMEM_SIZE);\n 9       printk(KERN_INFO "globalmem is set to zero\\n");\n10       break;\n11\n12  default:\n13       return -EINVAL;\n14  }\n15\n16  return 0;\n17}\n')),(0,r.kt)("p",null,"\u5728\u4e0a\u8ff0\u7a0b\u5e8f\u4e2d\uff0cMEM_CLEAR\u88ab\u5b8f\u5b9a\u4e49\u4e3a0x01\uff0c\u5b9e\u9645\u4e0a\u8fd9\u5e76\u4e0d\u662f\u4e00\u79cd\u503c\u5f97\u63a8\u8350\u7684\u65b9\u6cd5\uff0c\u7b80\u5355\u5730\u5bf9\u547d\u4ee4\u5b9a\u4e49\u4e3a0x0\u30010x1\u30010x2\u7b49\u7c7b\u4f3c\u503c\u4f1a\u5bfc\u81f4\u4e0d\u540c\u7684\u8bbe\u5907\u9a71\u52a8\u62e5\u6709\u76f8\u540c\u7684\u547d\u4ee4\u53f7\u3002\u5982\u679c\u8bbe\u5907A\u3001B\u90fd\u652f\u63010x0\u30010x1\u30010x2\u8fd9\u6837\u7684\u547d\u4ee4\uff0c\u5c31\u4f1a\u9020\u6210\u547d\u4ee4\u7801\u7684\u6c61\u67d3\u3002\u56e0\u6b64\uff0cLinux\u5185\u6838\u63a8\u8350\u91c7\u7528\u4e00\u5957\u7edf\u4e00\u7684ioctl\uff08\uff09\u547d\u4ee4\u751f\u6210\u65b9\u5f0f"),(0,r.kt)("h2",{id:"2ioctl\u547d\u4ee4"},"2.ioctl\uff08\uff09\u547d\u4ee4"),(0,r.kt)("p",null,"Linux\u5efa\u8bae\u4ee5\u5982\u56fe6.2\u6240\u793a\u7684\u65b9\u5f0f\u5b9a\u4e49ioctl\uff08\uff09\u7684\u547d\u4ee4\u3002"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"1742913948756",src:l(85787).Z,width:"739",height:"117"})),(0,r.kt)("p",null,"\u56fe6.2\u3000I/O\u63a7\u5236\u547d\u4ee4\u7684\u7ec4\u6210"),(0,r.kt)("p",null,"\u547d\u4ee4\u7801\u7684\u8bbe\u5907\u7c7b\u578b\u5b57\u6bb5\u4e3a\u4e00\u4e2a\u201c\u5e7b\u6570\u201d\uff0c\u53ef\u4ee5\u662f0~0xff\u7684\u503c\uff0c\u5185\u6838\u4e2d\u7684ioctl-number.txt\u7ed9\u51fa\u4e86\u4e00\u4e9b\u63a8\u8350\u7684\u548c\u5df2\u7ecf\u88ab\u4f7f\u7528\u7684\u201c\u5e7b\u6570\u201d\uff0c\u65b0\u8bbe\u5907\u9a71\u52a8\u5b9a\u4e49\u201c\u5e7b\u6570\u201d\u7684\u65f6\u5019\u8981\u907f\u514d\u4e0e\u5176\u51b2\u7a81\u3002"),(0,r.kt)("p",null,"\u547d\u4ee4\u7801\u7684\u5e8f\u5217\u53f7\u4e5f\u662f8\u4f4d\u5bbd\u3002"),(0,r.kt)("p",null,"\u547d\u4ee4\u7801\u7684\u65b9\u5411\u5b57\u6bb5\u4e3a2\u4f4d\uff0c\u8be5\u5b57\u6bb5\u8868\u793a\u6570\u636e\u4f20\u9001\u7684\u65b9\u5411\uff0c\u53ef\u80fd\u7684\u503c\u662f_IOC_NONE\uff08\u65e0\u6570\u636e\u4f20\u8f93\uff09\u3001_IOC_READ\uff08\u8bfb\uff09\u3001_IOC_WRITE\uff08\u5199\uff09\u548c_IOC_READ|_IOC_WRITE\uff08\u53cc\u5411\uff09\u3002\u6570\u636e\u4f20\u9001\u7684\u65b9\u5411\u662f\u4ece\u5e94\u7528\u7a0b\u5e8f\u7684\u89d2\u5ea6\u6765\u770b\u7684\u3002"),(0,r.kt)("p",null,"\u547d\u4ee4\u7801\u7684\u6570\u636e\u957f\u5ea6\u5b57\u6bb5\u8868\u793a\u6d89\u53ca\u7684\u7528\u6237\u6570\u636e\u7684\u5927\u5c0f\uff0c\u8fd9\u4e2a\u6210\u5458\u7684\u5bbd\u5ea6\u4f9d\u8d56\u4e8e\u4f53\u7cfb\u7ed3\u6784\uff0c\u901a\u5e38\u662f13\u6216\u800514\u4f4d\u3002"),(0,r.kt)("p",null,"\u5185\u6838\u8fd8\u5b9a\u4e49\u4e86_IO\uff08\uff09\u3001_IOR\uff08\uff09\u3001_IOW\uff08\uff09\u548c_IOWR\uff08\uff09\u8fd94\u4e2a\u5b8f\u6765\u8f85\u52a9\u751f\u6210\u547d\u4ee4\uff0c\u8fd94\u4e2a\u5b8f\u7684\u901a\u7528\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u53556.15\u6240\u793a"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.15\u3000_IO\uff08\uff09\u3001_IOR\uff08\uff09\u3001_IOW\uff08\uff09\u548c_IOWR\uff08\uff09\u5b8f\u5b9a\u4e49"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," 1#define _IO(type,nr)         _IOC(_IOC_NONE,(type),(nr),0)\n 2#define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),\\\n 3                                 (_IOC_TYPECHECK(size)))\n 4#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),\\\n 5                                 (_IOC_TYPECHECK(size)))\n 6#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),  \\\n 7                                 (_IOC_TYPECHECK(size)))\n 8/* _IO\u3001_IOR\u7b49\u4f7f\u7528\u7684_IOC\u5b8f*/\n 9#define _IOC(dir,type,nr,size) \\\n10     (((dir)  << _IOC_DIRSHIFT) | \\\n11     ((type) << _IOC_TYPESHIFT) | \\\n12     ((nr)   << _IOC_NRSHIFT) | \\\n13     ((size) << _IOC_SIZESHIFT))\n")),(0,r.kt)("p",null,"\u7531\u6b64\u53ef\u89c1\uff0c\u8fd9\u51e0\u4e2a\u5b8f\u7684\u4f5c\u7528\u662f\u6839\u636e\u4f20\u5165\u7684type\uff08\u8bbe\u5907\u7c7b\u578b\u5b57\u6bb5\uff09\u3001nr\uff08\u5e8f\u5217\u53f7\u5b57\u6bb5\uff09\u3001size\uff08\u6570\u636e\u957f\u5ea6\u5b57\u6bb5\uff09\u548c\u5b8f\u540d\u9690\u542b\u7684\u65b9\u5411\u5b57\u6bb5\u79fb\u4f4d\u7ec4\u5408\u751f\u6210\u547d\u4ee4\u7801\u3002"),(0,r.kt)("p",null,"\u7531\u4e8eglobalmem\u7684MEM_CLEAR\u547d\u4ee4\u4e0d\u6d89\u53ca\u6570\u636e\u4f20\u8f93\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u5b9a\u4e49\u4e3a\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#define GLOBALMEM_MAGIC 'g'\n#define MEM_CLEAR _IO(GLOBALMEM_MAGIC,0)\n")),(0,r.kt)("h2",{id:"3\u9884\u5b9a\u4e49\u547d\u4ee4"},"3.\u9884\u5b9a\u4e49\u547d\u4ee4"),(0,r.kt)("p",null,"\u5185\u6838\u4e2d\u9884\u5b9a\u4e49\u4e86\u4e00\u4e9bI/O\u63a7\u5236\u547d\u4ee4\uff0c\u5982\u679c\u67d0\u8bbe\u5907\u9a71\u52a8\u4e2d\u5305\u542b\u4e86\u4e0e\u9884\u5b9a\u4e49\u547d\u4ee4\u4e00\u6837\u7684\u547d\u4ee4\u7801\uff0c\u8fd9\u4e9b\u547d\u4ee4\u4f1a\u4f5c\u4e3a\u9884\u5b9a\u4e49\u547d\u4ee4\u88ab\u5185\u6838\u5904\u7406\u800c\u4e0d\u662f\u88ab\u8bbe\u5907\u9a71\u52a8\u5904\u7406\uff0c\u4e0b\u9762\u5217\u4e3e\u4e00\u4e9b\u5e38\u7528\u7684\u9884\u5b9a\u4e49\u547d\u4ee4\u3002"),(0,r.kt)("p",null,"FIOCLEX\uff1a\u5373File IOctl Close on Exec\uff0c\u5bf9\u6587\u4ef6\u8bbe\u7f6e\u4e13\u7528\u6807\u5fd7\uff0c\u901a\u77e5\u5185\u6838\u5f53exec\uff08\uff09\u7cfb\u7edf\u8c03\u7528\u53d1\u751f\u65f6\u81ea\u52a8\u5173\u95ed\u6253\u5f00\u7684\u6587\u4ef6\u3002"),(0,r.kt)("p",null,"FIONCLEX\uff1a\u5373File IOctl Not Close on Exec\uff0c\u4e0eFIOCLEX\u6807\u5fd7\u76f8\u53cd\uff0c\u6e05\u9664\u7531FIOCLEX\u547d\u4ee4\u8bbe\u7f6e\u7684\u6807\u5fd7\u3002"),(0,r.kt)("p",null,"FIOQSIZE\uff1a\u83b7\u5f97\u4e00\u4e2a\u6587\u4ef6\u6216\u8005\u76ee\u5f55\u7684\u5927\u5c0f\uff0c\u5f53\u7528\u4e8e\u8bbe\u5907\u6587\u4ef6\u65f6\uff0c\u8fd4\u56de\u4e00\u4e2aENOTTY\u9519\u8bef"),(0,r.kt)("p",null,"FIONBIO\uff1a\u5373File IOctl Non-Blocking I/O\uff0c\u8fd9\u4e2a\u8c03\u7528\u4fee\u6539\u5728filp->f_flags\u4e2d\u7684O_NONBLOCK\u6807\u5fd7\u3002"),(0,r.kt)("p",null,"FIOCLEX\u3001FIONCLEX\u3001FIOQSIZE\u548cFIONBIO\u8fd9\u4e9b\u5b8f\u5b9a\u4e49\u5728\u5185\u6838\u7684include/uapi/asm-generic/ioctls.h\u6587\u4ef6\u4e2d\u3002"),(0,r.kt)("h1",{id:"636\u4f7f\u7528\u6587\u4ef6\u79c1\u6709\u6570\u636e"},"6.3.6\u3000\u4f7f\u7528\u6587\u4ef6\u79c1\u6709\u6570\u636e"),(0,r.kt)("p",null,"6.3.1~6.3.5\u8282\u7ed9\u51fa\u7684\u4ee3\u7801\u5b8c\u6574\u5730\u5b9e\u73b0\u4e86\u9884\u671f\u7684globalmem\u96cf\u5f62\uff0c\u4ee3\u7801\u6e05\u53556.11\u7684\u7b2c7\u884c\uff0c\u4ee3\u7801\u6e05\u53556.12\u7684\u7b2c7\u884c\uff0c\u4ee3\u7801\u6e05\u53556.14\u7684\u7b2c4\u884c\uff0c\u90fd\u4f7f\u7528\u4e86struct globalmem_dev*dev=filp->private_data\u83b7\u53d6globalmem_dev\u7684\u5b9e\u4f8b\u6307\u9488\u3002\u5b9e\u9645\u4e0a\uff0c\u5927\u591a\u6570Linux\u9a71\u52a8\u9075\u5faa\u4e00\u4e2a\u201c\u6f5c\u89c4\u5219\u201d\uff0c\u90a3\u5c31\u662f\u5c06\u6587\u4ef6\u7684\u79c1\u6709\u6570\u636eprivate_data\u6307\u5411\u8bbe\u5907\u7ed3\u6784\u4f53\uff0c\u518d\u7528read\uff08\uff09\u3001write\uff08\uff09\u3001ioctl\uff08\uff09\u3001llseek\uff08\uff09\u7b49\u51fd\u6570\u901a\u8fc7private_data\u8bbf\u95ee\u8bbe\u5907\u7ed3\u6784\u4f53\u3002\u79c1\u6709\u6570\u636e\u7684\u6982\u5ff5\u5728Linux\u9a71\u52a8\u7684\u5404\u4e2a\u5b50\u7cfb\u7edf\u4e2d\u5e7f\u6cdb\u5b58\u5728\uff0c\u5b9e\u9645\u4e0a\u4f53\u73b0\u4e86Linux\u7684\u9762\u5411\u5bf9\u8c61\u7684\u8bbe\u8ba1\u601d\u60f3\u3002\u5bf9\u4e8eglobalmem\u9a71\u52a8\u800c\u8a00\uff0c\u79c1\u6709\u6570\u636e\u7684\u8bbe\u7f6e\u662f\u5728globalmem_open\uff08\uff09\u4e2d\u5b8c\u6210\u7684\uff0c\u5982\u4ee3\u7801\u6e05\u53556.16\u6240\u793a\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.16\u3000globalmem\u8bbe\u5907\u9a71\u52a8\u7684open\uff08\uff09\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," 1static int globalmem_open(struct inode *inode, struct file *filp)\n 2{\n 3   filp->private_data = globalmem_devp;\n 4   return 0;\n 5}\n")),(0,r.kt)("p",null,"\u4e3a\u4e86\u8ba9\u8bfb\u8005\u5efa\u7acb\u5b57\u7b26\u8bbe\u5907\u9a71\u52a8\u7684\u5168\u8c8c\u89c6\u56fe\uff0c\u4ee3\u7801\u6e05\u53556.17\u5217\u51fa\u4e86\u5b8c\u6574\u7684\u4f7f\u7528\u6587\u4ef6\u79c1\u6709\u6570\u636e\u7684globalmem\u7684\u8bbe\u5907\u9a71\u52a8\uff0c\u672c\u7a0b\u5e8f\u4f4d\u4e8e\u672c\u4e66\u914d\u5957\u865a\u62df\u673a\u4ee3\u7801\u7684/kernel/drivers/globalmem/ch6\u76ee\u5f55\u4e0b\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.17\u3000\u4f7f\u7528\u6587\u4ef6\u79c1\u6709\u6570\u636e\u7684globalmem\u7684\u8bbe\u5907\u9a71\u52a8"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'  1/*\n  2 * a simple char device driver: globalmem without mutex\n  3 *\n  4 * Copyright (C) 2014 Barry Song  (baohua@kernel.org)\n  5 *\n  6 * Licensed under GPLv2 or later.\n  7 */\n  8\n  9#include <linux/module.h>\n 10#include <linux/fs.h>\n 11#include <linux/init.h>\n 12#include <linux/cdev.h>\n 13#include <linux/slab.h>\n 14#include <linux/uaccess.h>\n 15\n 16#define GLOBALMEM_SIZE   0x1000\n 17#define MEM_CLEAR 0x1\n 18#define GLOBALMEM_MAJOR 230\n 19\n 20static int globalmem_major = GLOBALMEM_MAJOR;\n 21module_param(globalmem_major, int, S_IRUGO);\n 22\n 23struct globalmem_dev {\n 24   struct cdev cdev;\n 25   unsigned char mem[GLOBALMEM_SIZE];\n 26};\n 27\n 28struct globalmem_dev *globalmem_devp;\n 29\n 30static int globalmem_open(struct inode *inode, struct file *filp)\n 31{\n 32   filp->private_data = globalmem_devp;\n 33   return 0;\n 34}\n 35\n 36static int globalmem_release(struct inode *inode, struct file *filp)\n 37{\n 38   return 0;\n 39}\n 40\n 41static long globalmem_ioctl(struct file *filp, unsigned int cmd,\n 42               unsigned long arg)\n 43{\n 44 struct globalmem_dev *dev = filp->private_data;\n 45\n 46 switch (cmd) {\n 47 case MEM_CLEAR:\n 48      memset(dev->mem, 0, GLOBALMEM_SIZE);\n 49      printk(KERN_INFO "globalmem is set to zero\\n");\n 50      break;\n 51\n 52 default:\n 53      return -EINVAL;\n 54 }\n 55\n 56 return 0;\n 57}\n 58\n 59static ssize_t globalmem_read(struct file *filp, char __user * buf, size_t size,\n 60                 loff_t * ppos)\n 61{\n 62 unsigned long p = *ppos;\n 63 unsigned int count = size;\n 64 int ret = 0;\n 65 struct globalmem_dev *dev = filp->private_data;\n 66\n 67 if (p >= GLOBALMEM_SIZE)\n 68      return 0;\n 69 if (count > GLOBALMEM_SIZE - p)\n 70      count = GLOBALMEM_SIZE - p;\n 71\n 72 if (copy_to_user(buf, dev->mem + p, count)) {\n 73      ret = -EFAULT;\n 74 } else {\n 75      *ppos += count;\n 76      ret = count;\n 77\n 78      printk(KERN_INFO "read %u bytes(s) from %lu\\n", count, p);\n 79 }\n 80\n 81 return ret;\n 82}\n 83\n 84static ssize_t globalmem_write(struct file *filp, const char __user * buf,\n 85                  size_t size, loff_t * ppos)\n 86{\n 87 unsigned long p = *ppos;\n 88 unsigned int count = size;\n 89 int ret = 0;\n 90 struct globalmem_dev *dev = filp->private_data;\n 91\n 92 if (p >= GLOBALMEM_SIZE)\n 93      return 0;\n 94 if (count > GLOBALMEM_SIZE - p)\n 95      count = GLOBALMEM_SIZE - p;\n 96\n 97 if (copy_from_user(dev->mem + p, buf, count))\n 98      ret = -EFAULT;\n 99 else {\n100      *ppos += count;\n101      ret = count;\n102\n103      printk(KERN_INFO "written %u bytes(s) from %lu\\n", count, p);\n104 }\n105\n106 return ret;\n107}\n108\n109static loff_t globalmem_llseek(struct file *filp, loff_t offset, int orig)\n110{\n111 loff_t ret = 0;\n112 switch (orig) {\n113 case 0:\n114      if (offset < 0) {\n115           ret = -EINVAL;\n116           break;\n117      }\n118      if ((unsigned int)offset > GLOBALMEM_SIZE) {\n119           ret = -EINVAL;\n120           break;\n121      }\n122      filp->f_pos = (unsigned int)offset;\n123      ret = filp->f_pos;\n124      break;\n125 case 1:\n126      if ((filp->f_pos + offset) > GLOBALMEM_SIZE) {\n127           ret = -EINVAL;\n128           break;\n129      }\n130      if ((filp->f_pos + offset) < 0) {\n131           ret = -EINVAL;\n132           break;\n133      }\n134      filp->f_pos += offset;\n135      ret = filp->f_pos;\n136      break;\n137 default:\n138      ret = -EINVAL;\n139      break;\n140 }\n141 return ret;\n142}\n143\n144static const struct file_operations globalmem_fops = {\n145 .owner = THIS_MODULE,\n146 .llseek = globalmem_llseek,\n147 .read = globalmem_read,\n148 .write = globalmem_write,\n149 .unlocked_ioctl = globalmem_ioctl,\n150 .open = globalmem_open,\n151 .release = globalmem_release,\n152};\n153\n154static void globalmem_setup_cdev(struct globalmem_dev *dev, int index)\n155{\n156 int err, devno = MKDEV(globalmem_major, index);\n157\n158 cdev_init(&dev->cdev, &globalmem_fops);\n159 dev->cdev.owner = THIS_MODULE;\n160 err = cdev_add(&dev->cdev, devno, 1);\n161 if (err)\n162      printk(KERN_NOTICE "Error %d adding globalmem%d", err, index);\n163}\n164\n165static int __init globalmem_init(void)\n166{\n167 int ret;\n168 dev_t devno = MKDEV(globalmem_major, 0);\n169\n170 if (globalmem_major)\n171      ret = register_chrdev_region(devno, 1, "globalmem");\n172 else {\n173      ret = alloc_chrdev_region(&devno, 0, 1, "globalmem");\n174      globalmem_major = MAJOR(devno);\n175 }\n176 if (ret < 0)\n177      return ret;\n178\n179 globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);\n180 if (!globalmem_devp) {\n181      ret = -ENOMEM;\n182      goto fail_malloc;\n183 }\n184\n185 globalmem_setup_cdev(globalmem_devp, 0);\n186 return 0;\n187\n188 fail_malloc:\n189 unregister_chrdev_region(devno, 1);\n190 return ret;\n191}\n192module_init(globalmem_init);\n193\n194static void __exit globalmem_exit(void)\n195{\n196 cdev_del(&globalmem_devp->cdev);\n197 kfree(globalmem_devp);\n198 unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);\n199}\n200module_exit(globalmem_exit);\n201\n202MODULE_AUTHOR("Barry Song <baohua@kernel.org>");\n203MODULE_LICENSE("GPL v2"); \n')),(0,r.kt)("p",null,"\u5982\u679cglobalmem\u4e0d\u53ea\u5305\u62ec\u4e00\u4e2a\u8bbe\u5907\uff0c\u800c\u662f\u540c\u65f6\u5305\u62ec\u4e24\u4e2a\u6216\u4e24\u4e2a\u4ee5\u4e0a\u7684\u8bbe\u5907\uff0c\u91c7\u7528private_data\u7684\u4f18\u52bf\u5c31\u4f1a\u96c6\u4e2d\u663e\u73b0\u51fa\u6765\u3002\u5728\u4e0d\u5bf9\u4ee3\u7801\u6e05\u53556.17\u4e2d\u7684globalmem_read\uff08\uff09\u3001globalmem_write\uff08\uff09\u3001globalmem_ioctl\uff08\uff09\u7b49\u91cd\u8981\u51fd\u6570\u53caglobalmem_fops\u7ed3\u6784\u4f53\u7b49\u6570\u636e\u7ed3\u6784\u8fdb\u884c\u4efb\u4f55\u4fee\u6539\u7684\u524d\u63d0\u4e0b\uff0c\u53ea\u662f\u7b80\u5355\u5730\u4fee\u6539globalmem_init\uff08\uff09\u3001globalmem_exit\uff08\uff09\u548cglobalmem_open\uff08\uff09\uff0c\u5c31\u53ef\u4ee5\u8f7b\u677e\u5730\u8ba9globalmem\u9a71\u52a8\u4e2d\u5305\u542bN\u4e2a\u540c\u6837\u7684\u8bbe\u5907\uff08\u6b21\u8bbe\u5907\u53f7\u5206\u4e3a0~N\uff09\uff0c\u5982\u4ee3\u7801\u6e05\u53556.18\u5217\u51fa\u4e86\u652f\u6301\u591a\u4e2a\u5b9e\u4f8b\u7684globalmem\u548c\u652f\u6301\u5355\u5b9e\u4f8b\u7684globalmem\u9a71\u52a8\u7684\u5dee\u5f02\u90e8\u5206\u3002"),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.18\u3000\u652f\u6301N\u4e2aglobalmem\u8bbe\u5907\u7684globalmem\u9a71\u52a8"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},' 1#define GLOBALMEM_SIZE   0x1000\n 2#define MEM_CLEAR 0x1\n 3#define GLOBALMEM_MAJOR 230\n 4#define DEVICE_NUM   10\n 5\n 6static int globalmem_open(struct inode *inode, struct file *filp)\n 7{\n 8  struct globalmem_dev *dev = container_of(inode->i_cdev,\n 9                struct globalmem_dev, cdev);\n10  filp->private_data = dev;\n11  return 0;\n12}\n13\n14static int __init globalmem_init(void)\n15{\n16  int ret;\n17  int i;\n18  dev_t devno = MKDEV(globalmem_major, 0);\n19\n20  if (globalmem_major)\n21       ret = register_chrdev_region(devno, DEVICE_NUM, "globalmem");\n22  else {\n23       ret = alloc_chrdev_region(&devno, 0, DEVICE_NUM, "globalmem");\n24       globalmem_major = MAJOR(devno);\n25  }\n26  if (ret < 0)\n27       return ret;\n28\n29  globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL);\n30  if (!globalmem_devp) {\n31       ret = -ENOMEM;\n32       goto fail_malloc;\n33 }\n34\n35  for (i = 0; i < DEVICE_NUM; i++)\n36       globalmem_setup_cdev(globalmem_devp + i, i);\n37\n38  return 0;\n39\n40fail_malloc:\n41  unregister_chrdev_region(devno, DEVICE_NUM);\n42  return ret;\n43}\n44module_init(globalmem_init);\n45\n46static void __exit globalmem_exit(void)\n47{\n48  int i;\n49  for (i = 0; i < DEVICE_NUM; i++)\n50       cdev_del(&(globalmem_devp + i)->cdev);\n51  kfree(globalmem_devp);\n52  unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);\n53}\n54module_exit(globalmem_exit);\n')),(0,r.kt)("p",null,"\u4ee3\u7801\u6e05\u53556.18\u7b2c8\u884c\u8c03\u7528\u7684container_of\uff08\uff09\u7684\u4f5c\u7528\u662f\u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u7684\u6307\u9488\u627e\u5230\u5bf9\u5e94\u7ed3\u6784\u4f53\u7684\u6307\u9488\uff0c\u8fd9\u4e2a\u6280\u5de7\u5728Linux\u5185\u6838\u7f16\u7a0b\u4e2d\u5341\u5206\u5e38\u7528\u3002\u5728container_of\uff08inode->i_cdev\uff0cstruct globalmem_dev\uff0ccdev\uff09\u8bed\u53e5\u4e2d\uff0c\u4f20\u7ed9container_of\uff08\uff09\u7684\u7b2c1\u4e2a\u53c2\u6570\u662f\u7ed3\u6784\u4f53\u6210\u5458\u7684\u6307\u9488\uff0c\u7b2c2\u4e2a\u53c2\u6570\u4e3a\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u7c7b\u578b\uff0c\u7b2c3\u4e2a\u53c2\u6570\u4e3a\u4f20\u5165\u7684\u7b2c1\u4e2a\u53c2\u6570\u5373\u7ed3\u6784\u4f53\u6210\u5458\u7684\u7c7b\u578b\uff0ccontainer_of\uff08\uff09\u8fd4\u56de\u503c\u4e3a\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u6307\u9488\u3002"),(0,r.kt)("p",null,"\u4ece\u4ee3\u7801\u6e05\u53556.18\u53ef\u4ee5\u770b\u51fa\uff0c\u6211\u4eec\u4ec5\u4ec5\u8fdb\u884c\u4e86\u6781\u5176\u5c11\u91cf\u7684\u66f4\u6539\u5c31\u4f7f\u5f97globalmem\u9a71\u52a8\u652f\u6301\u591a\u4e2a\u5b9e\u4f8b\uff0c\u8fd9\u4e00\u70b9\u53ef\u4ee5\u770b\u51fa\u79c1\u6709\u6570\u636e\u7684\u9b54\u529b\u3002\u5b8c\u6574\u7684\u4ee3\u7801\u4f4d\u4e8ekernel/drivers/globalmem/ch6/multi_globalmem.c\u4e0b\u3002\u9ad8\u4eaeglobalmem.c\u548cmulti_globalmem.c\uff08\u4ee5\u201c-\u201d\u548c\u201c+\u201d\u5f00\u5934\u7684\u4ee3\u7801\uff09\u7684\u533a\u522b\u5982\u4e0b\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'@@ -29,7 +30,9 @@ struct globalmem_dev *globalmem_devp;\n static int globalmem_open(struct inode *inode, struct file *filp)\n {\n-    filp->private_data = globalmem_devp;\n+    struct globalmem_dev *dev = container_of(inode->i_cdev,\n+                    struct globalmem_dev, cdev);\n+    filp->private_data = dev;\n     return 0;\n }\n@@ -165,37 +168,42 @@ static void globalmem_setup_cdev(struct globalmem_dev *dev,\n    int index)\n static int __init globalmem_init(void)\n {\n     int ret;\n+    int i;\n     dev_t devno = MKDEV(globalmem_major, 0);\n     if (globalmem_major)\n-         ret = register_chrdev_region(devno, 1, "globalmem");\n+         ret = register_chrdev_region(devno, DEVICE_NUM, "globalmem");\n     else {\n-         ret = alloc_chrdev_region(&devno, 0, 1, "globalmem");\n+         ret = alloc_chrdev_region(&devno, 0, DEVICE_NUM, "globalmem");\n          globalmem_major = MAJOR(devno);\n     }\n     if (ret < 0)\n          return ret;\n-    globalmem_devp = kzalloc(sizeof(struct globalmem_dev), GFP_KERNEL);\n+    globalmem_devp = kzalloc(sizeof(struct globalmem_dev) * DEVICE_NUM, GFP_KERNEL);\n     if (!globalmem_devp) {\n          ret = -ENOMEM;\n          goto fail_malloc;\n     }\n-    globalmem_setup_cdev(globalmem_devp, 0);\n+    for (i = 0; i < DEVICE_NUM; i++)\n+         globalmem_setup_cdev(globalmem_devp + i, i);\n+\n     return 0;\n- fail_malloc:\n-    unregister_chrdev_region(devno, 1);\n+fail_malloc:\n+    unregister_chrdev_region(devno, DEVICE_NUM);\n     return ret;\n }\n module_init(globalmem_init);\n static void __exit globalmem_exit(void)\n {\n-    cdev_del(&globalmem_devp->cdev);\n+    int i;\n+    for (i = 0; i < DEVICE_NUM; i++)\n+         cdev_del(&(globalmem_devp + i)->cdev);\n     kfree(globalmem_devp);\n-    unregister_chrdev_region(MKDEV(globalmem_major, 0), 1);\n+    unregister_chrdev_region(MKDEV(globalmem_major, 0), DEVICE_NUM);\n }\n module_exit(globalmem_exit);\n')),(0,r.kt)("h1",{id:"64globalmem\u9a71\u52a8\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u9a8c\u8bc1"},"6.4\u3000globalmem\u9a71\u52a8\u5728\u7528\u6237\u7a7a\u95f4\u4e2d\u7684\u9a8c\u8bc1"),(0,r.kt)("p",null,"\u5728globalmem\u7684\u6e90\u4ee3\u7801\u76ee\u5f55\u901a\u8fc7\u201cmake\u201d\u547d\u4ee4\u7f16\u8bd1globalmem\u7684\u9a71\u52a8\uff0c\u5f97\u5230globalmem.ko\u6587\u4ef6\u3002\u8fd0\u884c"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"baohua@baohua-VirtualBox:~/develop/training/kernel/drivers/globalmem/ch6$ sudo\n    insmod globalmem.ko\n")),(0,r.kt)("p",null,"\u547d\u4ee4\u52a0\u8f7d\u6a21\u5757\uff0c\u901a\u8fc7\u201clnsmod\u201d\u547d\u4ee4\uff0c\u53d1\u73b0globalmem\u6a21\u5757\u5df2\u88ab\u52a0\u8f7d\u3002\u518d\u901a\u8fc7\u201ccat/proc/devices\u201d\u547d\u4ee4\u67e5\u770b\uff0c\u53d1\u73b0\u591a\u51fa\u4e86\u4e3b\u8bbe\u5907\u53f7\u4e3a230\u7684\u201cglobalmem\u201d\u5b57\u7b26\u8bbe\u5907\u9a71\u52a8\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"$ cat /proc/devices\nCharacter devices:\n  1mem\n  4/dev/vc/0\n  4tty\n  4ttyS\n  5/dev/tty\n  5/dev/console\n  5/dev/ptmx\n  7vcs\n 10misc\n 13input\n 14sound\n 21sg\n 29fb\n116alsa\n128ptm\n136pts\n180usb\n189usb_device\n202cpu/msr\n203cpu/cpuid\n226drm\n230globalmem\n249hidraw\n250usbmon\n251bsg\n252ptp\n253pps\n254rtc\n")),(0,r.kt)("p",null,"\u63a5\u4e0b\u6765\uff0c\u901a\u8fc7\u547d\u4ee4"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"#mknod /dev/globalmem c 230 0\n")),(0,r.kt)("p",null,"\u521b\u5efa\u201c/dev/globalmem\u201d\u8bbe\u5907\u8282\u70b9\uff0c\u5e76\u901a\u8fc7\u201cecho'hello world'>/dev/globalmem\u201d\u547d\u4ee4\u548c\u201ccat/dev/globalmem\u201d\u547d\u4ee4\u5206\u522b\u9a8c\u8bc1\u8bbe\u5907\u7684\u5199\u548c\u8bfb\uff0c\u7ed3\u679c\u8bc1\u660e\u201chello world\u201d\u5b57\u7b26\u4e32\u88ab\u6b63\u786e\u5730\u5199\u5165\u4e86globalmem\u5b57\u7b26\u8bbe\u5907\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'# echo "hello world" > /dev/globalmem\n# cat /dev/globalmem\nhello world\n')),(0,r.kt)("p",null,"\u5982\u679c\u542f\u7528\u4e86sysfs\u6587\u4ef6\u7cfb\u7edf\uff0c\u5c06\u53d1\u73b0\u591a\u51fa\u4e86/sys/module/globalmem\u76ee\u5f55\uff0c\u8be5\u76ee\u5f55\u4e0b\u7684\u6811\u5f62\u7ed3\u6784\u4e3a\uff1a"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},".\u251c\u2500\u2500\n coresize\u251c\u2500\u2500\n holders\u251c\u2500\u2500\n initsize\u251c\u2500\u2500\n initstate\u251c\u2500\u2500\n notes\u251c\u2500\u2500\n parameters\u2502\n   \u2514\u2500\u2500\nglobalmem_major\u251c\u2500\u2500\n refcnt\u251c\u2500\u2500\n sections\u2502\n   \u2514\u2500\u2500\n __param\u251c\u2500\u2500\n taint\u2514\u2500\u2500\n uevent\n")),(0,r.kt)("p",null,"refcnt\u8bb0\u5f55\u4e86globalmem\u6a21\u5757\u7684\u5f15\u7528\u8ba1\u6570\uff0csections\u4e0b\u5305\u542b\u7684\u51e0\u4e2a\u6587\u4ef6\u5219\u7ed9\u51fa\u4e86globalmem\u6240\u5305\u542b\u7684BSS\u3001\u6570\u636e\u6bb5\u548c\u4ee3\u7801\u6bb5\u7b49\u7684\u5730\u5740\u53ca\u5176\u4ed6\u4fe1\u606f\u3002"),(0,r.kt)("p",null,"\u5bf9\u4e8e\u4ee3\u7801\u6e05\u53556.18\u7ed9\u51fa\u7684\u652f\u6301N\u4e2aglobalmem\u8bbe\u5907\u7684\u9a71\u52a8\uff0c\u5728\u52a0\u8f7d\u6a21\u5757\u540e\u9700\u521b\u5efa\u591a\u4e2a\u8bbe\u5907\u8282\u70b9\uff0c\u5982\u8fd0\u884cmknod/dev/globalmem0c 2300\u4f7f\u5f97/dev/globalmem0\u5bf9\u5e94\u4e3b\u8bbe\u5907\u53f7\u4e3aglobalmem_major\u3001\u6b21\u8bbe\u5907\u53f7\u4e3a0\u7684\u8bbe\u5907\uff0c\u8fd0\u884cmknod/dev/globalmem1c 2301\u4f7f\u5f97/dev/globalmem1\u5bf9\u5e94\u4e3b\u8bbe\u5907\u53f7\u4e3aglobalmem_major\u3001\u6b21\u8bbe\u5907\u53f7\u4e3a1\u7684\u8bbe\u5907\u3002\u5206\u522b\u8bfb\u5199/dev/globalmem0\u548c/dev/globalmem1\uff0c\u53d1\u73b0\u90fd\u8bfb\u5199\u5230\u4e86\u6b63\u786e\u7684\u5bf9\u5e94\u7684\u8bbe\u5907\u3002"))}p.isMDXComponent=!0},85787:function(e,n,l){n.Z=l.p+"assets/images/1742913948756-5de8acea4a796bfdcaf2b2a25eb4e728.png"}}]);