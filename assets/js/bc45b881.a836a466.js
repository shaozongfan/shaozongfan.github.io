"use strict";(self.webpackChunkshaozongfan_website=self.webpackChunkshaozongfan_website||[]).push([[78126],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return p}});var r=t(67294);function d(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function _(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?_(Object(t),!0).forEach((function(n){d(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):_(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,d=function(e,n){if(null==e)return{};var t,r,d={},_=Object.keys(e);for(r=0;r<_.length;r++)t=_[r],n.indexOf(t)>=0||(d[t]=e[t]);return d}(e,n);if(Object.getOwnPropertySymbols){var _=Object.getOwnPropertySymbols(e);for(r=0;r<_.length;r++)t=_[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(d[t]=e[t])}return d}var s=r.createContext({}),a=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=a(e.components);return r.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,d=e.mdxType,_=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),m=a(t),p=d,l=m["".concat(s,".").concat(p)]||m[p]||u[p]||_;return t?r.createElement(l,o(o({ref:n},c),{},{components:t})):r.createElement(l,o({ref:n},c))}));function p(e,n){var t=arguments,d=n&&n.mdxType;if("string"==typeof e||d){var _=t.length,o=new Array(_);o[0]=m;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:d,o[1]=i;for(var a=2;a<_;a++)o[a]=t[a];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},90530:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return p},frontMatter:function(){return i},metadata:function(){return a},toc:function(){return u}});var r=t(87462),d=t(63366),_=(t(67294),t(3905)),o=["components"],i={},s="14.9.1\u3000DM9000\u7f51\u5361\u786c\u4ef6\u63cf\u8ff0",a={permalink:"/blog/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/14.9\u3000DM9000\u7f51\u5361\u8bbe\u5907\u9a71\u52a8\u5b9e\u4f8b",editUrl:"https://github.com/shaozongfan/shaozongfan.github.io/blog/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/14.9\u3000DM9000\u7f51\u5361\u8bbe\u5907\u9a71\u52a8\u5b9e\u4f8b.md",source:"@site/blog/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/14.9\u3000DM9000\u7f51\u5361\u8bbe\u5907\u9a71\u52a8\u5b9e\u4f8b.md",title:"14.9.1\u3000DM9000\u7f51\u5361\u786c\u4ef6\u63cf\u8ff0",description:"DM9000\u662f\u5f00\u53d1\u677f\u91c7\u7528\u7684\u7f51\u7edc\u82af\u7247\uff0c\u662f\u4e00\u4e2a\u9ad8\u5ea6\u96c6\u6210\u4e14\u529f\u8017\u5f88\u4f4e\u7684\u9ad8\u901f\u7f51\u7edc\u63a7\u5236\u5668\uff0c\u53ef\u4ee5\u548cCPU\u76f4\u8fde\uff0c\u652f\u630110/100MB\u4ee5\u592a\u7f51\u8fde\u63a5\uff0c\u82af\u7247\u5185\u90e8\u81ea\u5e264KB\u53cc\u5b57\u8282\u7684SRAM\uff083KB\u7528\u6765\u53d1\u9001\uff0c13KB\u7528\u6765\u63a5\u6536\uff09\u3002\u9488\u5bf9\u4e0d\u540c\u7684\u5904\u7406\u5668\uff0c\u63a5\u53e3\u652f\u63018\u4f4d\u300116\u4f4d\u548c32\u4f4d\u3002DM9000\u4e00\u822c\u76f4\u63a5\u6302\u5728\u5916\u9762\u7684\u5185\u5b58\u603b\u7ebf\u4e0a\u3002",date:"2025-09-15T14:44:14.361Z",formattedDate:"2025\u5e749\u670815\u65e5",tags:[],readingTime:6.04,truncated:!1,authors:[],frontMatter:{},prevItem:{title:"21.1.1\u3000GDB\u7684\u57fa\u672c\u7528\u6cd5",permalink:"/blog/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/21.1\u3000GDB\u8c03\u8bd5\u5668\u7684\u7528\u6cd5"},nextItem:{title:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/13.9\u3000\u603b\u7ed3",permalink:"/blog/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/13.9\u3000\u603b\u7ed3"}},c={authorsImageUrls:[]},u=[],m={toc:u};function p(e){var n=e.components,t=(0,d.Z)(e,o);return(0,_.kt)("wrapper",(0,r.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,_.kt)("p",null,"DM9000\u662f\u5f00\u53d1\u677f\u91c7\u7528\u7684\u7f51\u7edc\u82af\u7247\uff0c\u662f\u4e00\u4e2a\u9ad8\u5ea6\u96c6\u6210\u4e14\u529f\u8017\u5f88\u4f4e\u7684\u9ad8\u901f\u7f51\u7edc\u63a7\u5236\u5668\uff0c\u53ef\u4ee5\u548cCPU\u76f4\u8fde\uff0c\u652f\u630110/100MB\u4ee5\u592a\u7f51\u8fde\u63a5\uff0c\u82af\u7247\u5185\u90e8\u81ea\u5e264KB\u53cc\u5b57\u8282\u7684SRAM\uff083KB\u7528\u6765\u53d1\u9001\uff0c13KB\u7528\u6765\u63a5\u6536\uff09\u3002\u9488\u5bf9\u4e0d\u540c\u7684\u5904\u7406\u5668\uff0c\u63a5\u53e3\u652f\u63018\u4f4d\u300116\u4f4d\u548c32\u4f4d\u3002DM9000\u4e00\u822c\u76f4\u63a5\u6302\u5728\u5916\u9762\u7684\u5185\u5b58\u603b\u7ebf\u4e0a\u3002"),(0,_.kt)("h1",{id:"1492dm9000\u7f51\u5361\u9a71\u52a8\u8bbe\u8ba1\u5206\u6790"},"14.9.2\u3000DM9000\u7f51\u5361\u9a71\u52a8\u8bbe\u8ba1\u5206\u6790"),(0,_.kt)("p",null,"DM9000\u7f51\u5361\u9a71\u52a8\u4f4d\u4e8e\u5185\u6838\u6e90\u4ee3\u7801\u7684drivers/net/dm9000.c\u4e2d\uff0c\u5b83\u57fa\u4e8e\u5e73\u53f0\u9a71\u52a8\u67b6\u6784\uff0c\u4ee3\u7801\u6e05\u535514.19\u62bd\u53d6\u4e86\u5b83\u7684\u4e3b\u5e72\u3002\u5176\u6838\u5fc3\u5de5\u4f5c\u662f\u5b9e\u73b0\u4e86\u524d\u6587\u6240\u8ff0net_device\u7ed3\u6784\u4f53\u4e2d\u7684hard_start_xmit\uff08\uff09\u3001open\uff08\uff09\u3001stop\uff08\uff09\u3001set_multicast_list\uff08\uff09\u3001do_ioctl\uff08\uff09\u3001tx_timeout\uff08\uff09\u7b49\u6210\u5458\u51fd\u6570\uff0c\u5e76\u501f\u52a9\u4e2d\u65ad\u8f85\u52a9\u8fdb\u884c\u7f51\u7edc\u6570\u636e\u5305\u7684\u6536\u53d1\uff0c\u53e6\u5916\u5b83\u4e5f\u5b9e\u73b0\u4e86ethtool_ops\u4e2d\u7684\u6210\u5458\u51fd\u6570\u3002\u7279\u522b\u6ce8\u610f\u4ee3\u7801\u4e2d\u7684\u9ed1\u4f53\u90e8\u5206\uff0c\u5b83\u6807\u660e\u4e86\u5173\u952e\u7684\u6570\u636e\u6536\u53d1\u6d41\u7a0b\u3002"),(0,_.kt)("p",null,"\u4ee3\u7801\u6e05\u535514.19\u3000DM9000\u7f51\u5361\u9a71\u52a8"),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre"},'  1static const struct ethtool_ops dm9000_ethtool_ops = {\n  2        .get_drvinfo            = dm9000_get_drvinfo,\n  3        .get_settings           = dm9000_get_settings,\n  4        .set_settings           = dm9000_set_settings,\n  5        .get_msglevel           = dm9000_get_msglevel,\n  6        .set_msglevel           = dm9000_set_msglevel,\n  7        \u2026\n 8};\n  9\n 10/* Our watchdog timed out. Called by the networking layer */\n 11static void dm9000_timeout(struct net_device *dev)\n 12{\n 13        ...\n 14        netif_stop_queue(dev);\n 15        dm9000_init_dm9000(dev);\n 16        dm9000_unmask_interrupts(db);\n 17        /* We can accept TX packets again */\n 18        dev->trans_start = jiffies; /* prevent tx timeout */\n 19        netif_wake_queue(dev);\n 20\n 21        \u2026\n 22}\n 23\n 24 static int\n 25 dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)\n 26 {\n 27         ...\n 28         /* TX control: First packet immediately send, second packet queue */\n 29         if (db->tx_pkt_cnt == 1) {\n 30                 dm9000_send_packet(dev, skb->ip_summed, skb->len);\n 31         } else {\n 32                 /* Second packet */\n 33                 db->queue_pkt_len = skb->len;\n 34                 db->queue_ip_summed = skb->ip_summed;\n 35                 netif_stop_queue(dev);\n 36         }\n 37\n 38         spin_unlock_irqrestore(&db->lock, flags);\n 39\n 40         /* free this SKB */\n 41         dev_consume_skb_any(skb);\n 42\n 43         return NETDEV_TX_OK;\n 44 }\n 45\n 46 static void dm9000_tx_done(struct net_device *dev, board_info_t *db)\n 47 {\n 48         int tx_status = ior(db, DM9000_NSR);    /* Got TX status */\n 49\n 50         if (tx_status & (NSR_TX2END | NSR_TX1END)) {\n 51                 /* One packet sent complete */\n 52                 db->tx_pkt_cnt--;\n 53                 dev->stats.tx_packets++;\n 54\n 55                 if (netif_msg_tx_done(db))\n 56                         dev_dbg(db->dev, "tx done, NSR %02x\\n", tx_status);\n 57\n 58                 /* Queue packet check & send */\n 59                 if (db->tx_pkt_cnt > 0)\n 60                         dm9000_send_packet(dev, db->queue_ip_summed,\n 61                                            db->queue_pkt_len);\n 62                 netif_wake_queue(dev);\n 63         }\n 64 }\n 65\n 66 static void\n 67 dm9000_rx(struct net_device *dev)\n 68 {\n 69         ...\n 70\n 71         /* Check packet ready or not */\n 72         do {\n 73                 ...\n 74\n 75                 /* Move data from DM9000*/\n 76                 if (GoodPacket &&\n 77                     ((skb = netdev_alloc_skb(dev, RxLen + 4)) != NULL)) {\n 78                         skb_reserve(skb, 2);\n 79                         rdptr = (u8*) skb_put(skb, RxLen - 4);\n 80\n 81                         /* Read received packet from RX SRAM */\n 82\n 83                         (db->inblk)(db->io_data, rdptr, RxLen);\n 84                         dev->stats.rx_bytes += RxLen;\n 85\n 86                         /* Pass to upper layer */\n 87                         skb->protocol = eth_type_trans(skb, dev);\n 88                         if (dev->features & NETIF_F_RXCSUM) {\n 89                                 if ((((rxbyte & 0x1c) << 3) & rxbyte) == 0)\n 90                                         skb->ip_summed = CHECKSUM_UNNECESSARY;\n 91                                 else\n 92                                         skb_checksum_none_assert(skb);\n 93                         }\n 94                         netif_rx(skb);\n 95                         dev->stats.rx_packets++;\n 96\n 97                 }...\n 98         } while (rxbyte & DM9000_PKT_RDY);\n 99 }\n100\n101 static irqreturn_t dm9000_interrupt(int irq, void *dev_id)\n102 {\n103         ...\n104         /* Received the coming packet */\n105         if (int_status & ISR_PRS)\n106                 dm9000_rx(dev);\n107\n108         /* Trnasmit Interrupt check */\n109         if (int_status & ISR_PTS)\n110                 dm9000_tx_done(dev, db);\n111\n112         ...\n113         return IRQ_HANDLED;\n114 }\n115\n116 static int\n117 dm9000_open(struct net_device *dev)\n118 {\n119         ...\n120\n121         /* Initialize DM9000board */\n122         dm9000_init_dm9000(dev);\n123\n124         if (request_irq(dev->irq, dm9000_interrupt, irqflags, dev->name, dev))\n125                 return -EAGAIN;\n126         ...\n127\n128         mii_check_media(&db->mii, netif_msg_link(db), 1);\n129         netif_start_queue(dev);\n130\n131         return 0;\n132 }\n133\n134 static int\n135 dm9000_stop(struct net_device *ndev)\n136 {\n137         ...\n138\n139         netif_stop_queue(ndev);\n140         netif_carrier_off(ndev);\n141\n142         /* free interrupt */\n143         free_irq(ndev->irq, ndev);\n144\n145         dm9000_shutdown(ndev);\n146\n147         return 0;\n148 }\n149\n150 static const struct net_device_ops dm9000_netdev_ops = {\n151         .ndo_open               = dm9000_open,\n152         .ndo_stop               = dm9000_stop,\n153         .ndo_start_xmit         = dm9000_start_xmit,\n154         .ndo_tx_timeout         = dm9000_timeout,\n155         .ndo_set_rx_mode        = dm9000_hash_table,\n156         .ndo_do_ioctl           = dm9000_ioctl,\n157         .ndo_change_mtu         = eth_change_mtu,\n158         .ndo_set_features       = dm9000_set_features,\n159         .ndo_validate_addr      = eth_validate_addr,\n160         .ndo_set_mac_address    = eth_mac_addr,\n161 #ifdef CONFIG_NET_POLL_CONTROLLER\n162         .ndo_poll_controller    = dm9000_poll_controller,\n163 #endif\n164 };\n165\n166\n167 /*\n168  * Search DM9000board, allocate space and register it\n169  */\n170 static int\n171 dm9000_probe(struct platform_device *pdev)\n172 {\n173         ...\n174\n175         /* Init network device */\n176         ndev = alloc_etherdev(sizeof(struct board_info));\n177         ...\n178\n179         /* setup board info structure */\n180         db = netdev_priv(ndev);\n181\n182         ...\n183\n184         ...\n185         /* driver system function */\n186         ether_setup(ndev);\n187\n188         ndev->netdev_ops        = &dm9000_netdev_ops;\n189         ndev->watchdog_timeo    = msecs_to_jiffies(watchdog);\n190         ndev->ethtool_ops       = &dm9000_ethtool_ops;\n191\n192         ...\n193         ret = register_netdev(ndev);\n194\n195 }\n196\n197 static int\n198 dm9000_drv_remove(struct platform_device *pdev)\n199 {\n200         struct net_device *ndev = platform_get_drvdata(pdev);\n201\n202         unregister_netdev(ndev);\n203         dm9000_release_board(pdev, netdev_priv(ndev));\n204         free_netdev(ndev);              /* free device structure */\n205         ...\n206 }\n207\n208 #ifdef CONFIG_OF\n209 static const struct of_device_id dm9000_of_matches[] = {\n210         { .compatible = "davicom,dm9000", },\n211         { /* sentinel */ }\n212 };\n213 MODULE_DEVICE_TABLE(of, dm9000_of_matches);\n214 #endif\n215\n216 static struct platform_driver dm9000_driver = {\n217         .driver = {\n218                 .name    = "dm9000",\n219                 .owner   = THIS_MODULE,\n220                 .pm      = &dm9000_drv_pm_ops,\n221                 .of_match_table = of_match_ptr(dm9000_of_matches),\n222         },\n223         .probe   = dm9000_probe,\n224         .remove  = dm9000_drv_remove,\n225 };\n226\n227 module_platform_driver(dm9000_driver);\n')),(0,_.kt)("p",null,"DM9000\u9a71\u52a8\u7684\u5b9e\u73b0\u4e0e\u5177\u4f53CPU\u65e0\u5173\uff0c\u5728\u5c06\u8be5\u9a71\u52a8\u79fb\u690d\u5230\u7279\u5b9a\u7535\u8def\u677f\u65f6\uff0c\u53ea\u9700\u8981\u5728\u677f\u6587\u4ef6\u4e2d\u4e3a\u4e0e\u677f\u4e0aDM9000\u5bf9\u5e94\u7684\u5e73\u53f0\u8bbe\u5907\u7684\u5bc4\u5b58\u5668\u548c\u6570\u636e\u57fa\u5730\u5740\u8fdb\u884c\u8d4b\u503c\uff0c\u5e76\u6307\u5b9a\u6b63\u786e\u7684IRQ\u8d44\u6e90\u5373\u53ef\uff0c\u4ee3\u7801\u6e05\u535514.20\u7ed9\u51fa\u4e86\u5728arch/arm/mach-at91/board-sam9261ek.c\u677f\u6587\u4ef6\u4e2d\u5bf9DM9000\u6dfb\u52a0\u7684\u5185\u5bb9\u3002"),(0,_.kt)("p",null,"\u4ee3\u7801\u6e05\u535514.20\u3000board-sam9261ek\u677f\u6587\u4ef6\u4e2d\u7684DM9000\u7684\u5e73\u53f0\u8bbe\u5907"),(0,_.kt)("pre",null,(0,_.kt)("code",{parentName:"pre"},' 1static struct resource dm9000_resource[] = {\n 2        [0] = {\n 3                .start  = AT91_CHIPSELECT_2,\n 4                .end    = AT91_CHIPSELECT_2+ 3,\n 5                .flags  = IORESOURCE_MEM\n 6        },\n 7        [1] = {\n 8                .start  = AT91_CHIPSELECT_2+ 0x44,\n 9                .end    = AT91_CHIPSELECT_2+ 0xFF,\n10                .flags  = IORESOURCE_MEM\n11        },\n12        [2] = {\n13                .flags  = IORESOURCE_IRQ\n14                        | IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE,\n15        }\n16};\n17\n18static struct dm9000_plat_data dm9000_platdata = {\n19        .flags          = DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM,\n20};\n21\n22static struct platform_device dm9000_device = {\n23        .name           = "dm9000",\n24        .id             = 0,\n25        .num_resources  = ARRAY_SIZE(dm9000_resource),\n26        .resource       = dm9000_resource,\n27        .dev            = {\n28                .platform_data  = &dm9000_platdata,\n29        }\n30};\n')))}p.isMDXComponent=!0}}]);