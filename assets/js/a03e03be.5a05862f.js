"use strict";(self.webpackChunkshaozongfan_website=self.webpackChunkshaozongfan_website||[]).push([[2655],{3905:function(e,n,t){t.d(n,{Zo:function(){return b},kt:function(){return c}});var r=t(67294);function u(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){u(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,u=function(e,n){if(null==e)return{};var t,r,u={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(u[t]=e[t]);return u}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(u[t]=e[t])}return u}var _=r.createContext({}),d=function(e){var n=r.useContext(_),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},b=function(e){var n=d(e.components);return r.createElement(_.Provider,{value:n},e.children)},a={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},o=r.forwardRef((function(e,n){var t=e.components,u=e.mdxType,s=e.originalType,_=e.parentName,b=l(e,["components","mdxType","originalType","parentName"]),o=d(t),c=u,p=o["".concat(_,".").concat(c)]||o[c]||a[c]||s;return t?r.createElement(p,i(i({ref:n},b),{},{components:t})):r.createElement(p,i({ref:n},b))}));function c(e,n){var t=arguments,u=n&&n.mdxType;if("string"==typeof e||u){var s=t.length,i=new Array(s);i[0]=o;var l={};for(var _ in n)hasOwnProperty.call(n,_)&&(l[_]=n[_]);l.originalType=e,l.mdxType="string"==typeof e?e:u,i[1]=l;for(var d=2;d<s;d++)i[d]=t[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}o.displayName="MDXCreateElement"},76024:function(e,n,t){t.r(n),t.d(n,{assets:function(){return b},contentTitle:function(){return _},default:function(){return c},frontMatter:function(){return l},metadata:function(){return d},toc:function(){return a}});var r=t(87462),u=t(63366),s=(t(67294),t(3905)),i=["components"],l={},_="16.3.1\u3000USB\u8bbe\u5907\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784",d={unversionedId:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8",id:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8",title:"16.3.1\u3000USB\u8bbe\u5907\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784",description:"\u8fd9\u91cc\u6240\u8bf4\u7684USB\u8bbe\u5907\u9a71\u52a8\u6307\u7684\u662f\u4ece\u4e3b\u673a\u89d2\u5ea6\u6765\u770b\uff0c\u600e\u6837\u8bbf\u95ee\u88ab\u63d2\u5165\u7684USB\u8bbe\u5907\uff0c\u800c\u4e0d\u662f\u6307USB\u8bbe\u5907\u5185\u90e8\u672c\u8eab\u8fd0\u884c\u7684\u56fa\u4ef6\u7a0b\u5e8f\u3002Linux\u7cfb\u7edf\u5b9e\u73b0\u4e86\u51e0\u7c7b\u901a\u7528\u7684USB\u8bbe\u5907\u9a71\u52a8\uff08\u4e5f\u79f0\u5ba2\u6237\u9a71\u52a8\uff09\uff0c\u5212\u5206\u4e3a\u5982\u4e0b\u51e0\u4e2a\u8bbe\u5907\u7c7b\u3002",source:"@site/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8.md",sourceDirName:"\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3",slug:"/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8",permalink:"/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8",draft:!1,editUrl:"https://github.com/shaozongfan/shaozongfan.github.io/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.3\u3000USB\u8bbe\u5907\u9a71\u52a8.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"16.2.1\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784",permalink:"/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.2\u3000USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8"},next:{title:"16.4.1\u3000UDC\u548cGadget\u9a71\u52a8\u7684\u5173\u952e\u6570\u636e\u7ed3\u6784\u4e0eAPI",permalink:"/docs/\u6280\u672f\u535a\u5ba2/\u5d4c\u5165\u5f0f/linux\u8bbe\u5907\u9a71\u52a8\u5f00\u53d1\u8be6\u89e3/16.4\u3000USB UDC\u4e0eGadget\u9a71\u52a8"}},b={},a=[{value:"1.urb\u7ed3\u6784\u4f53",id:"1urb\u7ed3\u6784\u4f53",level:2},{value:"2.URB\u5904\u7406\u6d41\u7a0b",id:"2urb\u5904\u7406\u6d41\u7a0b",level:2},{value:"1\uff09\u88ab\u4e00\u4e2aUSB\u8bbe\u5907\u9a71\u52a8\u521b\u5efa\u3002",id:"1\u88ab\u4e00\u4e2ausb\u8bbe\u5907\u9a71\u52a8\u521b\u5efa",level:3},{value:"2\uff09\u521d\u59cb\u5316\uff0c\u88ab\u5b89\u6392\u7ed9\u4e00\u4e2a\u7279\u5b9aUSB\u8bbe\u5907\u7684\u7279\u5b9a\u7aef\u70b9\u3002",id:"2\u521d\u59cb\u5316\u88ab\u5b89\u6392\u7ed9\u4e00\u4e2a\u7279\u5b9ausb\u8bbe\u5907\u7684\u7279\u5b9a\u7aef\u70b9",level:3},{value:"3\uff09\u88abUSB\u8bbe\u5907\u9a71\u52a8\u63d0\u4ea4\u7ed9USB\u6838\u5fc3\u3002",id:"3\u88abusb\u8bbe\u5907\u9a71\u52a8\u63d0\u4ea4\u7ed9usb\u6838\u5fc3",level:3},{value:"4\uff09\u63d0\u4ea4\u7531USB\u6838\u5fc3\u6307\u5b9a\u7684USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u3002",id:"4\u63d0\u4ea4\u7531usb\u6838\u5fc3\u6307\u5b9a\u7684usb\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8",level:3},{value:"5\uff09\u88abUSB\u4e3b\u673a\u63a7\u5236\u5668\u5904\u7406\uff0c\u8fdb\u884c\u4e00\u6b21\u5230USB\u8bbe\u5907\u7684\u4f20\u9001\u3002",id:"5\u88abusb\u4e3b\u673a\u63a7\u5236\u5668\u5904\u7406\u8fdb\u884c\u4e00\u6b21\u5230usb\u8bbe\u5907\u7684\u4f20\u9001",level:3},{value:"6\uff09\u5f53URB\u5b8c\u6210\uff0cUSB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u901a\u77e5USB\u8bbe\u5907\u9a71\u52a8\u3002",id:"6\u5f53urb\u5b8c\u6210usb\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u901a\u77e5usb\u8bbe\u5907\u9a71\u52a8",level:3},{value:"3.\u7b80\u5355\u7684\u6279\u91cf\u4e0e\u63a7\u5236URB",id:"3\u7b80\u5355\u7684\u6279\u91cf\u4e0e\u63a7\u5236urb",level:2},{value:"\uff081\uff09usb_bulk_msg\uff08\uff09",id:"1usb_bulk_msg",level:3},{value:"\uff082\uff09usb_control_msg\uff08\uff09\u51fd\u6570",id:"2usb_control_msg\u51fd\u6570",level:2}],o={toc:a};function c(e){var n=e.components,l=(0,u.Z)(e,i);return(0,s.kt)("wrapper",(0,r.Z)({},o,l,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"1631usb\u8bbe\u5907\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784"},"16.3.1\u3000USB\u8bbe\u5907\u9a71\u52a8\u7684\u6574\u4f53\u7ed3\u6784"),(0,s.kt)("p",null,"\u8fd9\u91cc\u6240\u8bf4\u7684USB\u8bbe\u5907\u9a71\u52a8\u6307\u7684\u662f\u4ece\u4e3b\u673a\u89d2\u5ea6\u6765\u770b\uff0c\u600e\u6837\u8bbf\u95ee\u88ab\u63d2\u5165\u7684USB\u8bbe\u5907\uff0c\u800c\u4e0d\u662f\u6307USB\u8bbe\u5907\u5185\u90e8\u672c\u8eab\u8fd0\u884c\u7684\u56fa\u4ef6\u7a0b\u5e8f\u3002Linux\u7cfb\u7edf\u5b9e\u73b0\u4e86\u51e0\u7c7b\u901a\u7528\u7684USB\u8bbe\u5907\u9a71\u52a8\uff08\u4e5f\u79f0\u5ba2\u6237\u9a71\u52a8\uff09\uff0c\u5212\u5206\u4e3a\u5982\u4e0b\u51e0\u4e2a\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xb7\u97f3\u9891\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u901a\u4fe1\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7HID\uff08\u4eba\u673a\u63a5\u53e3\uff09\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u663e\u793a\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u6d77\u91cf\u5b58\u50a8\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u7535\u6e90\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u6253\u5370\u8bbe\u5907\u7c7b\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u96c6\u7ebf\u5668\u8bbe\u5907\u7c7b\u3002")),(0,s.kt)("p",null,"\u4e00\u822c\u7684\u901a\u7528Linux\u8bbe\u5907\uff08\u5982U\u76d8\u3001USB\u9f20\u6807\u3001USB\u952e\u76d8\u7b49\uff09\u90fd\u4e0d\u9700\u8981\u5de5\u7a0b\u5e08\u518d\u7f16\u5199\u9a71\u52a8\uff0c\u800c\u5de5\u7a0b\u5e08\u9700\u8981\u7f16\u5199\u7684\u662f\u7279\u5b9a\u5382\u5546\u3001\u7279\u5b9a\u82af\u7247\u7684\u9a71\u52a8\uff0c\u800c\u4e14\u5f80\u5f80\u4e5f\u53ef\u4ee5\u53c2\u8003\u5df2\u7ecf\u5728\u5185\u6838\u4e2d\u63d0\u4f9b\u7684\u9a71\u52a8\u6a21\u677f\u3002"),(0,s.kt)("p",null,"Linux\u5185\u6838\u4e3a\u5404\u7c7bUSB\u8bbe\u5907\u5206\u914d\u4e86\u76f8\u5e94\u7684\u8bbe\u5907\u53f7\uff0c\u5982ACM USB\u8c03\u5236\u89e3\u8c03\u5668\u7684\u4e3b\u8bbe\u5907\u53f7\u4e3a166\uff08\u9ed8\u8ba4\u8bbe\u5907\u540d/dev/ttyACMn\uff09\u3001USB\u6253\u5370\u673a\u7684\u4e3b\u8bbe\u5907\u53f7\u4e3a180\uff0c\u6b21\u8bbe\u5907\u53f7\u4e3a0~15\uff08\u9ed8\u8ba4\u8bbe\u5907\u540d/dev/lpn\uff09\u3001USB\u4e32\u53e3\u7684\u4e3b\u8bbe\u5907\u53f7\u4e3a188\uff08\u9ed8\u8ba4\u8bbe\u5907\u540d/dev/ttyUSBn\uff09\u7b49\uff0c\u8be6\u89c1",(0,s.kt)("a",{parentName:"p",href:"http://www.lanana.org/"},"http://www.lanana.org/")," \u7f51\u7ad9\u7684\u8bbe\u5907\u5217\u8868\u3002"),(0,s.kt)("p",null,"\u5728debugfs\u4e0b\uff0c/sys/kernel/debug/usb/devices\u5305\u542b\u4e86USB\u7684\u8bbe\u5907\u4fe1\u606f\uff0c\u5728Ubuntu\u4e0a\u63d2\u5165\u4e00\u4e2aU\u76d8\u540e\uff0c\u6211\u4eec\u5728/sys/kernel/debug/usb/devices\u4e2d\u53ef\u770b\u5230\u7c7b\u4f3c\u4fe1\u606f\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"$ sudo cat /sys/kernel/debug/usb/devices\nT:  Bus=02 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 8\nB:  Alloc=  2/900 us ( 0%), #Int=  1, #Iso=  0\nD:  Ver= 1.10 Cls=09(hub  ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1\nP:  Vendor=1d6b ProdID=0001 Rev= 4.00\nS:  Manufacturer=Linux 4.0.0-rc1 ohci_hcd\nS:  Product=OHCI PCI host controller\nS:  SerialNumber=0000:00:06.0\nC:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA\nI:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub\nE:  Ad=81(I) Atr=03(Int.) MxPS=   2 Ivl=255ms\u2026\nT:  Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=480  MxCh= 0\nD:  Ver= 2.10 Cls=00(>ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1\nP:  Vendor=0930 ProdID=6545 Rev= 1.00\nS:  Manufacturer=Kingston\nS:  Product=DataTraveler 3.0\nS:  SerialNumber=60A44C3FAE22EEA0797900F7\nC:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=498mA\nI:* If#= 0 Alt= 0 #EPs= 2 Cls=08(stor.) Sub=06 Prot=50 Driver=usb-storage\nE:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms\nE:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms\n")),(0,s.kt)("p",null,"\u901a\u8fc7\u5206\u6790\u4e0a\u8ff0\u8bb0\u5f55\u4fe1\u606f\uff0c\u53ef\u4ee5\u5f97\u5230\u7cfb\u7edf\u4e2dUSB\u7684\u5b8c\u6574\u4fe1\u606f\u3002USBView\uff08",(0,s.kt)("a",{parentName:"p",href:"http://www.kroah.com/linux-usb/"},"http://www.kroah.com/linux-usb/")," \uff09\u662f\u4e00\u4e2a\u56fe\u5f62\u5316\u7684GTK\u5de5\u5177\uff0c\u53ef\u4ee5\u663e\u793aUSB\u4fe1\u606f\u3002"),(0,s.kt)("p",null,"\u6b64\u5916\uff0c\u5728sysfs\u6587\u4ef6\u7cfb\u7edf\u4e2d\uff0c\u540c\u6837\u5305\u542b\u4e86USB\u76f8\u5173\u4fe1\u606f\u7684\u63cf\u8ff0\uff0c\u4f46\u53ea\u9650\u4e8e\u63a5\u53e3\u7ea7\u522b\u3002USB\u8bbe\u5907\u548cUSB\u63a5\u53e3\u5728sysfs\u4e2d\u5747\u8868\u793a\u4e3a\u5355\u72ec\u7684USB\u8bbe\u5907\uff0c\u5176\u76ee\u5f55\u547d\u540d\u89c4\u5219\u5982\u4e0b\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"\u6839\u96c6\u7ebf\u5668\n-\u96c6\u7ebf\u5668\u7aef\u53e3\u53f7\uff08\n-\u96c6\u7ebf\u5668\u7aef\u53e3\u53f7\n-...\uff09\n:\u914d\u7f6e\n.\u63a5\u53e3\n")),(0,s.kt)("p",null,"\u4e0b\u9762\u7ed9\u51fa\u4e00\u4e2a/sys/bus/usb\u76ee\u5f55\u4e0b\u7684\u6811\u5f62\u7ed3\u6784\u5b9e\u4f8b\uff0c\u5176\u4e2d\u7684\u591a\u6570\u6587\u4ef6\u90fd\u662f\u951a\u5b9a\u5230/sys/devices\u53ca/sys/drivers\u4e2d\u76f8\u5e94\u6587\u4ef6\u7684\u94fe\u63a5\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},".\u251c\u2500\u2500\n\n\n devices\u2502\n\n\n   \u251c\u2500\u2500\n\n\n 1-0:1.0 -> ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-0:1.0\u2502\n\n\n   \u251c\u2500\u2500\n\n\n 1-1 -> ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1\u2502\n\n\n   \u251c\u2500\u2500\n\n\n 1-1:1.0 -> ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0\u2502\n\n\n   \u251c\u2500\u2500\n\n\n 2-0:1.0 -> ../../../devices/pci0000:00/0000:00:06.0/usb2/2-0:1.0\u2502\n\n\n   \u251c\u2500\u2500\n\n\n 2-1 -> ../../../devices/pci0000:00/0000:00:06.0/usb2/2-1\u2502\n\n\n   \u251c\u2500\u2500\n\n\n 2-1:1.0 -> ../../../devices/pci0000:00/0000:00:06.0/usb2/2-1/2-1:1.0\u2502\n\n\n   \u251c\u2500\u2500\n\n\n usb1 -> ../../../devices/pci0000:00/0000:00:0b.0/usb1\u2502\n\n\n   \u2514\u2500\u2500\n\n\n usb2 -> ../../../devices/pci0000:00/0000:00:06.0/usb2\u251c\u2500\u2500\n\n\n drivers\u2502\n\n\n   \u251c\u2500\u2500\n\n\n hub\u2502\n\n\n   \u2502\n\n\n   \u251c\u2500\u2500\n\n\n 1-0:1.0 -> ../../../../devices/pci0000:00/0000:00:0b.0/usb1/1-0:1.0\u2502\n\n\n   \u2502\n\n\n   \u251c\u2500\u2500\n\n\n 2-0:1.0 -> ../../../../devices/pci0000:00/0000:00:06.0/usb2/2-0:1.0\u2502\n\n\n   \u2502\n\n\n   \u251c\u2500\u2500\n\n\n bind\u2502\n\n\n   \u2502\n\n\n   \u251c\u2500\u2500\n module -> ../../../../module/usbcore\u2502\n   \u2502\n   \u251c\u2500\u2500\n new_id\u2502\n   \u2502\n   \u251c\u2500\u2500\n remove_id\u2502\n   \u2502\n   \u251c\u2500\u2500\n uevent\u2502\n   \u2502\n   \u2514\u2500\u2500\n unbind\u2502\n   \u251c\u2500\u2500\n usb\u2502\n   \u2502\n   \u251c\u2500\u2500\n 1-1 -> ../../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1\u2502\n   \u2502\n   \u251c\u2500\u2500\n 2-1 -> ../../../../devices/pci0000:00/0000:00:06.0/usb2/2-1\u2502\n   \u2502\n   \u251c\u2500\u2500\n bind\u2502\n   \u2502\n   \u251c\u2500\u2500\n uevent\u2502\n   \u2502\n   \u251c\u2500\u2500\n unbind\u2502\n   \u2502\n   \u251c\u2500\u2500\n usb1 -> ../../../../devices/pci0000:00/0000:00:0b.0/usb1\u2502\n   \u2502\n   \u2514\u2500\u2500\n\n usb2 -> ../../../../devices/pci0000:00/0000:00:06.0/usb2\n")),(0,s.kt)("p",null,"\u6b63\u5982tty_driver\u3001i2c_driver\u7b49\uff0c\u5728Linux\u5185\u6838\u4e2d\uff0c\u4f7f\u7528usb_driver\u7ed3\u6784\u4f53\u63cf\u8ff0\u4e00\u4e2aUSB\u8bbe\u5907\u9a71\u52a8\uff0cusb_driver\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u535516.11\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.11\u3000usb_driver\u7ed3\u6784\u4f53"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1struct usb_driver {\n 2        const char *name;\n 3\n 4        int (*probe) (struct usb_interface *intf,\n 5                    const struct usb_device_id *id);\n 6\n 7        void (*disconnect) (struct usb_interface *intf);\n 8\n 9        int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,\n10                     void *buf);\n11\n12        int (*suspend) (struct usb_interface *intf, pm_message_t message);\n13        int (*resume) (struct usb_interface *intf);\n14        int (*reset_resume)(struct usb_interface *intf);\n15\n16        int (*pre_reset)(struct usb_interface *intf);\n17        int (*post_reset)(struct usb_interface *intf);\n18\n19        const struct usb_device_id *id_table;\n20\n21        struct usb_dynids dynids;\n22        struct usbdrv_wrap drvwrap;\n23        unsigned int no_dynamic_id:1;\n24        unsigned int supports_autosuspend:1;\n25        unsigned int disable_hub_initiated_lpm:1;\n26        unsigned int soft_unbind:1;\n27};\n")),(0,s.kt)("p",null,"\u5728\u7f16\u5199\u65b0\u7684USB\u8bbe\u5907\u9a71\u52a8\u65f6\uff0c\u4e3b\u8981\u5e94\u8be5\u5b8c\u6210\u7684\u5de5\u4f5c\u662fprobe\uff08\uff09\u548cdisconnect\uff08\uff09\u51fd\u6570\uff0c\u5373\u63a2\u6d4b\u548c\u65ad\u5f00\u51fd\u6570\uff0c\u5b83\u4eec\u5206\u522b\u5728\u8bbe\u5907\u88ab\u63d2\u5165\u548c\u62d4\u51fa\u7684\u65f6\u5019\u8c03\u7528\uff0c\u7528\u4e8e\u521d\u59cb\u5316\u548c\u91ca\u653e\u8f6f\u786c\u4ef6\u8d44\u6e90\u3002\u5bf9usb_driver\u7684\u6ce8\u518c\u548c\u6ce8\u9500\u53ef\u901a\u8fc7\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570\u5b8c\u6210\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"int usb_register(struct usb_driver *new_driver)\nvoid usb_deregister(struct usb_driver *driver);\n")),(0,s.kt)("p",null,"usb_driver\u7ed3\u6784\u4f53\u4e2d\u7684id_table\u6210\u5458\u63cf\u8ff0\u4e86\u8fd9\u4e2aUSB\u9a71\u52a8\u6240\u652f\u6301\u7684USB\u8bbe\u5907\u5217\u8868\uff0c\u5b83\u6307\u5411\u4e00\u4e2ausb_device_id\u6570\u7ec4\uff0cusb_device_id\u7ed3\u6784\u4f53\u5305\u542b\u6709USB\u8bbe\u5907\u7684\u5236\u9020\u5546ID\u3001\u4ea7\u54c1ID\u3001\u4ea7\u54c1\u7248\u672c\u3001\u8bbe\u5907\u7c7b\u3001\u63a5\u53e3\u7c7b\u7b49\u4fe1\u606f\u53ca\u5176\u8981\u5339\u914d\u6807\u5fd7\u6210\u5458match_flags\uff08\u6807\u660e\u8981\u4e0e\u54ea\u4e9b\u6210\u5458\u5339\u914d\uff0c\u5305\u542bDEV_LO\u3001DEV_HI\u3001DEV_CLASS\u3001DEV_SUBCLASS\u3001DEV_PROTOCOL\u3001INT_CLASS\u3001INT_SUBCLASS\u3001INT_PROTOCOL\uff09\u3002\u53ef\u4ee5\u501f\u52a9\u4e0b\u9762\u4e00\u7ec4\u5b8f\u6765\u751f\u6210usb_device_id\u7ed3\u6784\u4f53\u7684\u5b9e\u4f8b\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"USB_DEVICE(vendor, product)\n")),(0,s.kt)("p",null,"\u8be5\u5b8f\u6839\u636e\u5236\u9020\u5546ID\u548c\u4ea7\u54c1ID\u751f\u6210\u4e00\u4e2ausb_device_id\u7ed3\u6784\u4f53\u7684\u5b9e\u4f8b\uff0c\u5728\u6570\u7ec4\u4e2d\u589e\u52a0\u8be5\u5143\u7d20\u5c06\u610f\u5473\u7740\u8be5\u9a71\u52a8\u53ef\u652f\u6301\u4e0e\u5236\u9020\u5546ID\u3001\u4ea7\u54c1ID\u5339\u914d\u7684\u8bbe\u5907\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"USB_DEVICE_VER(vendor, product, lo, hi)\n")),(0,s.kt)("p",null,"\u8be5\u5b8f\u6839\u636e\u5236\u9020\u5546ID\u3001\u4ea7\u54c1ID\u3001\u4ea7\u54c1\u7248\u672c\u7684\u6700\u5c0f\u503c\u548c\u6700\u5927\u503c\u751f\u6210\u4e00\u4e2ausb_device_id\u7ed3\u6784\u4f53\u7684\u5b9e\u4f8b\uff0c\u5728\u6570\u7ec4\u4e2d\u589e\u52a0\u8be5\u5143\u7d20\u5c06\u610f\u5473\u7740\u8be5\u9a71\u52a8\u53ef\u652f\u6301\u4e0e\u5236\u9020\u5546ID\u3001\u4ea7\u54c1ID\u5339\u914d\u548clo~hi\u8303\u56f4\u5185\u7248\u672c\u7684\u8bbe\u5907\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"USB_DEVICE_INFO(class, subclass, protocol)\n")),(0,s.kt)("p",null,"\u8be5\u5b8f\u7528\u4e8e\u521b\u5efa\u4e00\u4e2a\u5339\u914d\u8bbe\u5907\u6307\u5b9a\u7c7b\u578b\u7684usb_device_id\u7ed3\u6784\u4f53\u5b9e\u4f8b\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"USB_INTERFACE_INFO(class, subclass, protocol)\n")),(0,s.kt)("p",null,"\u8be5\u5b8f\u7528\u4e8e\u521b\u5efa\u4e00\u4e2a\u5339\u914d\u63a5\u53e3\u6307\u5b9a\u7c7b\u578b\u7684usb_device_id\u7ed3\u6784\u4f53\u5b9e\u4f8b\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.12\u6240\u793a\u4e3a\u4e24\u4e2a\u7528\u4e8e\u63cf\u8ff0\u67d0USB\u9a71\u52a8\u652f\u6301\u7684USB\u8bbe\u5907\u7684usb_device_id\u7ed3\u6784\u4f53\u6570\u7ec4\u5b9e\u4f8b\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.12\u3000usb_device_id\u7ed3\u6784\u4f53\u6570\u7ec4\u5b9e\u4f8b"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1/* \u672c\u9a71\u52a8\u652f\u6301\u7684USB\u8bbe\u5907\u5217\u8868*/\n 2\n 3/* \u5b9e\u4f8b1 */\n 4static struct usb_device_id id_table [] = {\n 5   { USB_DEVICE(VENDOR_ID, PRODUCT_ID) },\n 6   { },\n 7};\n 8MODULE_DEVICE_TABLE (usb, id_table);\n 9\n10/* \u5b9e\u4f8b2 */\n11static struct usb_device_id id_table [] = {\n12   { .idVendor = 0x10D2, .match_flags = USB_DEVICE_ID_MATCH_VENDOR, },\n13   { },\n14};\n15MODULE_DEVICE_TABLE (usb, id_table);\n")),(0,s.kt)("p",null,"\u5f53USB\u6838\u5fc3\u68c0\u6d4b\u5230\u67d0\u4e2a\u8bbe\u5907\u7684\u5c5e\u6027\u548c\u67d0\u4e2a\u9a71\u52a8\u7a0b\u5e8f\u7684usb_device_id\u7ed3\u6784\u4f53\u6240\u643a\u5e26\u7684\u4fe1\u606f\u4e00\u81f4\u65f6\uff0c\u8fd9\u4e2a\u9a71\u52a8\u7a0b\u5e8f\u7684probe\uff08\uff09\u51fd\u6570\u5c31\u88ab\u6267\u884c\uff08\u5982\u679c\u8fd9\u4e2aUSB\u9a71\u52a8\u662f\u4e2a\u6a21\u5757\u7684\u8bdd\uff0c\u76f8\u5173\u7684.ko\u8fd8\u5e94\u88abLinux\u81ea\u52a8\u52a0\u8f7d\uff09\u3002\u62d4\u6389\u8bbe\u5907\u6216\u8005\u5378\u6389\u9a71\u52a8\u6a21\u5757\u540e\uff0cUSB\u6838\u5fc3\u5c31\u6267\u884cdisconnect\uff08\uff09\u51fd\u6570\u6765\u54cd\u5e94\u8fd9\u4e2a\u52a8\u4f5c\u3002"),(0,s.kt)("p",null,"\u4e0a\u8ff0usb_driver\u7ed3\u6784\u4f53\u4e2d\u7684\u51fd\u6570\u662fUSB\u8bbe\u5907\u9a71\u52a8\u4e2d\u4e0eUSB\u76f8\u5173\u7684\u90e8\u5206\uff0c\u800cUSB\u53ea\u662f\u4e00\u4e2a\u603b\u7ebf\uff0cUSB\u8bbe\u5907\u9a71\u52a8\u771f\u6b63\u7684\u4e3b\u4f53\u5de5\u4f5c\u4ecd\u7136\u662fUSB\u8bbe\u5907\u672c\u8eab\u6240\u5c5e\u7c7b\u578b\u7684\u9a71\u52a8\uff0c\u5982\u5b57\u7b26\u8bbe\u5907\u3001tty\u8bbe\u5907\u3001\u5757\u8bbe\u5907\u3001\u8f93\u5165\u8bbe\u5907\u7b49\u3002\u56e0\u6b64USB\u8bbe\u5907\u9a71\u52a8\u5305\u542b\u5176\u4f5c\u4e3a\u603b\u7ebf\u4e0a\u6302\u63a5\u8bbe\u5907\u7684\u9a71\u52a8\u548c\u672c\u8eab\u6240\u5c5e\u8bbe\u5907\u7c7b\u578b\u7684\u9a71\u52a8\u4e24\u90e8\u5206\u3002"),(0,s.kt)("p",null,"\u4e0eplatform_driver\u3001i2c_driver\u7c7b\u4f3c\uff0cusb_driver\u8d77\u5230\u4e86\u201c\u7275\u7ebf\u201d\u7684\u4f5c\u7528\uff0c\u5373\u5728probe\uff08\uff09\u91cc\u6ce8\u518c\u76f8\u5e94\u7684\u5b57\u7b26\u3001tty\u7b49\u8bbe\u5907\uff0c\u5728disconnect\uff08\uff09\u6ce8\u9500\u76f8\u5e94\u7684\u5b57\u7b26\u3001tty\u7b49\u8bbe\u5907\uff0c\u800c\u539f\u5148\u5bf9\u8bbe\u5907\u7684\u6ce8\u518c\u548c\u6ce8\u9500\u4e00\u822c\u76f4\u63a5\u53d1\u751f\u5728\u6a21\u5757\u52a0\u8f7d\u548c\u5378\u8f7d\u51fd\u6570\u4e2d\u3002"),(0,s.kt)("p",null,"\u5c3d\u7ba1USB\u672c\u8eab\u6240\u5c5e\u8bbe\u5907\u9a71\u52a8\u7684\u7ed3\u6784\u4e0e\u5176\u6302\u4e0d\u6302\u5728USB\u603b\u7ebf\u4e0a\u6ca1\u4ec0\u4e48\u5173\u7cfb\uff0c\u4f46\u662f\u636e\u6b64\u5728\u8bbf\u95ee\u65b9\u5f0f\u4e0a\u5374\u6709\u5f88\u5927\u7684\u53d8\u5316\uff0c\u4f8b\u5982\uff0c\u5bf9\u4e8eUSB\u63a5\u53e3\u7684\u5b57\u7b26\u8bbe\u5907\u800c\u8a00\uff0c\u5c3d\u7ba1\u4ecd\u7136\u662fwrite\uff08\uff09\u3001read\uff08\uff09\u3001ioctl\uff08\uff09\u8fd9\u4e9b\u51fd\u6570\uff0c\u4f46\u662f\u5728\u8fd9\u4e9b\u51fd\u6570\u4e2d\uff0c\u8d2f\u7a7f\u59cb\u7ec8\u7684\u662f\u79f0\u4e3aURB\u7684USB\u8bf7\u6c42\u5757\u3002"),(0,s.kt)("p",null,"\u5982\u56fe16.3\u6240\u793a\uff0c\u5728\u8fd9\u68f5\u6811\u91cc\uff0c\u6211\u4eec\u628a\u6811\u6839\u6bd4\u4f5c\u4e3b\u673a\u63a7\u5236\u5668\uff0c\u6811\u53f6\u6bd4\u4f5c\u5177\u4f53\u7684USB\u8bbe\u5907\uff0c\u6811\u5e72\u548c\u6811\u679d\u5c31\u662fUSB\u603b\u7ebf\u3002\u6811\u53f6\u672c\u8eab\u4e0e\u6811\u679d\u901a\u8fc7usb_driver\u8fde\u63a5\uff0c\u800c\u6811\u53f6\u672c\u8eab\u7684\u9a71\u52a8\uff08\u8bfb\u5199\u3001\u63a7\u5236\uff09\u5219\u9700\u8981\u901a\u8fc7\u5176\u6811\u53f6\u8bbe\u5907\u672c\u8eab\u6240\u5c5e\u7c7b\u8bbe\u5907\u9a71\u52a8\u6765\u5b8c\u6210\u3002\u6811\u6839\u548c\u6811\u53f6\u4e4b\u95f4\u7684\u201c\u901a\u4fe1\u201d\u4f9d\u9760\u5728\u6811\u5e72\u548c\u6811\u679d\u91cc\u201c\u6d41\u6dcc\u201d\u7684URB\u6765\u5b8c\u6210\u3002"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"1745247374129",src:t(12137).Z,width:"1402",height:"1039"})),(0,s.kt)("p",null,"\u56fe16.3\u3000USB\u8bbe\u5907\u9a71\u52a8\u7ed3\u6784"),(0,s.kt)("p",null,"\u7531\u6b64\u53ef\u89c1\uff0cusb_driver\u672c\u8eab\u53ea\u662f\u6709\u627e\u5230USB\u8bbe\u5907\u3001\u7ba1\u7406USB\u8bbe\u5907\u8fde\u63a5\u548c\u65ad\u5f00\u7684\u4f5c\u7528\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u5b83\u662f\u516c\u53f8\u5165\u53e3\u5904\u7684\u201c\u6253\u5361\u673a\u201d\uff0c\u53ef\u4ee5\u83b7\u5f97\u5458\u5de5\uff08USB\u8bbe\u5907\uff09\u7684\u4e0a/\u4e0b\u73ed\u60c5\u51b5\u3002\u6811\u53f6\u548c\u5458\u5de5\u4e00\u6837\uff0c\u53ef\u4ee5\u662f\u7814\u53d1\u5de5\u7a0b\u5e08\u4e5f\u53ef\u4ee5\u662f\u9500\u552e\u5de5\u7a0b\u5e08\uff0c\u800c\u4f5c\u4e3aUSB\u8bbe\u5907\u7684\u6811\u53f6\u53ef\u4ee5\u662f\u5b57\u7b26\u6811\u53f6\u3001\u7f51\u7edc\u6811\u53f6\u6216\u5757\u6811\u53f6\uff0c\u56e0\u6b64\u5fc5\u987b\u5b9e\u73b0\u76f8\u5e94\u8bbe\u5907\u7c7b\u7684\u9a71\u52a8\u3002"),(0,s.kt)("h1",{id:"1632usb\u8bf7\u6c42\u5757"},"16.3.2\u3000USB\u8bf7\u6c42\u5757"),(0,s.kt)("h2",{id:"1urb\u7ed3\u6784\u4f53"},"1.urb\u7ed3\u6784\u4f53"),(0,s.kt)("p",null,"USB\u8bf7\u6c42\u5757\uff08USB Request Block\uff0cURB\uff09\u662fUSB\u8bbe\u5907\u9a71\u52a8\u4e2d\u7528\u6765\u63cf\u8ff0\u4e0eUSB\u8bbe\u5907\u901a\u4fe1\u6240\u7528\u7684\u57fa\u672c\u8f7d\u4f53\u548c\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u975e\u5e38\u7c7b\u4f3c\u4e8e\u7f51\u7edc\u8bbe\u5907\u9a71\u52a8\u4e2d\u7684sk_buff\u7ed3\u6784\u4f53\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.13\u3000URB\u7ed3\u6784\u4f53"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1struct urb {\n 2        ...\n 3        /* public: documented fields in the urb that can be used by drivers */\n 4        struct list_head urb_list;      /* list head for use by the urb's\n 5                                      * current owner */\n 6        ...\n 7        struct usb_host_endpoint *ep;   /* (internal) pointer to endpoint */\n 8        unsigned int pipe;              /* (in) pipe information */\n 9        unsigned int stream_id;         /* (in) stream ID */\n10        int status;                     /* (return) non-ISO status */\n11        unsigned int transfer_flags;    /* (in) URB_SHORT_NOT_OK | ...*/\n12        void *transfer_buffer;          /* (in) associated data buffer */\n13        dma_addr_t transfer_dma;        /* (in) dma addr for transfer_buffer */\n14        struct scatterlist *sg;         /* (in) scatter gather buffer list */\n15        int num_mapped_sgs;             /* (internal) mapped sg entries */\n16        int num_sgs;                    /* (in) number of entries in the sg list */\n17        u32 transfer_buffer_length;     /* (in) data buffer length */\n18        u32 actual_length;              /* (return) actual transfer length */\n19        unsigned char *setup_packet;    /* (in) setup packet (control only) */\n20        dma_addr_t setup_dma;           /* (in) dma addr for setup_packet */\n21        int start_frame;                /* (modify) start frame (ISO) */\n22        int number_of_packets;          /* (in) number of ISO packets */\n23        int interval;                   /* (modify) transfer interval\n24                                       * (INT/ISO) */\n25        int error_count;                /* (return) number of ISO errors */\n26        void *context;                  /* (in) context for completion */\n27        usb_complete_t complete;        /* (in) completion routine */\n28        struct usb_iso_packet_descriptor iso_frame_desc[0];\n29                                        /* (in) ISO ONLY */\n30};\n")),(0,s.kt)("h2",{id:"2urb\u5904\u7406\u6d41\u7a0b"},"2.URB\u5904\u7406\u6d41\u7a0b"),(0,s.kt)("p",null,"USB\u8bbe\u5907\u4e2d\u7684\u6bcf\u4e2a\u7aef\u70b9\u90fd\u5904\u7406\u4e00\u4e2aURB\u961f\u5217\uff0c\u5728\u961f\u5217\u88ab\u6e05\u7a7a\u4e4b\u524d\uff0c\u4e00\u4e2aURB\u7684\u5178\u578b\u751f\u547d\u5468\u671f\u5982\u4e0b\u3002"),(0,s.kt)("h3",{id:"1\u88ab\u4e00\u4e2ausb\u8bbe\u5907\u9a71\u52a8\u521b\u5efa"},"1\uff09\u88ab\u4e00\u4e2aUSB\u8bbe\u5907\u9a71\u52a8\u521b\u5efa\u3002"),(0,s.kt)("p",null,"\u521b\u5efaURB\u7ed3\u6784\u4f53\u7684\u51fd\u6570\u4e3a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);\n")),(0,s.kt)("p",null,"iso_packets\u662f\u8fd9\u4e2aURB\u5e94\u5f53\u5305\u542b\u7684\u7b49\u65f6\u6570\u636e\u5305\u7684\u6570\u76ee\uff0c\u82e5\u4e3a0\u8868\u793a\u4e0d\u521b\u5efa\u7b49\u65f6\u6570\u636e\u5305\u3002mem_flags\u53c2\u6570\u662f\u5206\u914d\u5185\u5b58\u7684\u6807\u5fd7\uff0c\u548ckmalloc\uff08\uff09\u51fd\u6570\u7684\u5206\u914d\u6807\u5fd7\u53c2\u6570\u542b\u4e49\u76f8\u540c\u3002\u5982\u679c\u5206\u914d\u6210\u529f\uff0c\u8be5\u51fd\u6570\u8fd4\u56de\u4e00\u4e2aURB\u7ed3\u6784\u4f53\u6307\u9488\uff0c\u5426\u5219\u8fd4\u56de0\u3002"),(0,s.kt)("p",null,"URB\u7ed3\u6784\u4f53\u5728\u9a71\u52a8\u4e2d\u4e0d\u5b9c\u9759\u6001\u521b\u5efa\uff0c\u56e0\u4e3a\u8fd9\u53ef\u80fd\u7834\u574fUSB\u6838\u5fc3\u7ed9URB\u4f7f\u7528\u7684\u5f15\u7528\u8ba1\u6570\u65b9\u6cd5\u3002"),(0,s.kt)("p",null,"usb_alloc_urb\uff08\uff09\u7684\u201c\u53cd\u51fd\u6570\u201d\u4e3a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_free_urb(struct urb *urb);\n")),(0,s.kt)("p",null,"\u8be5\u51fd\u6570\u7528\u4e8e\u91ca\u653e\u7531usb_alloc_urb\uff08\uff09\u5206\u914d\u7684URB\u7ed3\u6784\u4f53\u3002"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_free_urb(struct urb *urb);\n")),(0,s.kt)("p",null,"\u8be5\u51fd\u6570\u7528\u4e8e\u91ca\u653e\u7531usb_alloc_urb\uff08\uff09\u5206\u914d\u7684URB\u7ed3\u6784\u4f53\u3002"),(0,s.kt)("h3",{id:"2\u521d\u59cb\u5316\u88ab\u5b89\u6392\u7ed9\u4e00\u4e2a\u7279\u5b9ausb\u8bbe\u5907\u7684\u7279\u5b9a\u7aef\u70b9"},"2\uff09\u521d\u59cb\u5316\uff0c\u88ab\u5b89\u6392\u7ed9\u4e00\u4e2a\u7279\u5b9aUSB\u8bbe\u5907\u7684\u7279\u5b9a\u7aef\u70b9\u3002"),(0,s.kt)("p",null,"\u5bf9\u4e8e\u4e2d\u65adURB\uff0c\u4f7f\u7528usb_fill_int_urb\uff08\uff09\u51fd\u6570\u6765\u521d\u59cb\u5316URB\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_fill_int_urb(struct urb *urb, struct usb_device *dev,\n unsigned int pipe, void *transfer_buffer,\n int buffer_length, usb_complete_t complete,\n void *context, int interval);\n")),(0,s.kt)("p",null,"URB\u53c2\u6570\u6307\u5411\u8981\u88ab\u521d\u59cb\u5316\u7684URB\u7684\u6307\u9488\uff1bdev\u6307\u5411\u8fd9\u4e2aURB\u8981\u88ab\u53d1\u9001\u5230\u7684USB\u8bbe\u5907\uff1bpipe\u662f\u8fd9\u4e2aURB\u8981\u88ab\u53d1\u9001\u5230\u7684USB\u8bbe\u5907\u7684\u7279\u5b9a\u7aef\u70b9\uff1btransfer_buffer\u662f\u6307\u5411\u53d1\u9001\u6570\u636e\u6216\u63a5\u6536\u6570\u636e\u7684\u7f13\u51b2\u533a\u7684\u6307\u9488\uff0c\u548cURB\u4e00\u6837\uff0c\u5b83\u4e5f\u4e0d\u80fd\u662f\u9759\u6001\u7f13\u51b2\u533a\uff0c\u5fc5\u987b\u4f7f\u7528kmalloc\uff08\uff09\u6765\u5206\u914d\uff1bbuffer_length\u662ftransfer_buffer\u6307\u9488\u6240\u6307\u5411\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff1bcomplete\u6307\u9488\u6307\u5411\u5f53\u8fd9\u4e2aURB\u5b8c\u6210\u65f6\u88ab\u8c03\u7528\u7684\u5b8c\u6210\u5904\u7406\u51fd\u6570\uff1bcontext\u662f\u5b8c\u6210\u5904\u7406\u51fd\u6570\u7684\u201c\u4e0a\u4e0b\u6587\u201d\uff1binterval\u662f\u8fd9\u4e2aURB\u5e94\u5f53\u88ab\u8c03\u5ea6\u7684\u95f4\u9694\u3002"),(0,s.kt)("p",null,"\u4e0a\u8ff0\u51fd\u6570\u53c2\u6570\u4e2d\u7684pipe\u4f7f\u7528usb_sndintpipe\uff08\uff09\u6216usb_rcvintpipe\uff08\uff09\u521b\u5efa\u3002"),(0,s.kt)("p",null,"\u5bf9\u4e8e\u6279\u91cfURB\uff0c\u4f7f\u7528usb_fill_bulk_urb\uff08\uff09\u51fd\u6570\u6765\u521d\u59cb\u5316\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_fill_bulk_urb(struct urb *urb, struct usb_device *dev,\n unsigned int pipe, void *transfer_buffer,\n int buffer_length, usb_complete_t complete,\n void *context);\n")),(0,s.kt)("p",null,"\u9664\u4e86\u6ca1\u6709\u5bf9\u5e94\u4e8e\u8c03\u5ea6\u95f4\u9694\u7684interval\u53c2\u6570\u4ee5\u5916\uff0c\u8be5\u51fd\u6570\u7684\u53c2\u6570\u548cusb_fill_int_urb\uff08\uff09\u51fd\u6570\u7684\u53c2\u6570\u542b\u4e49\u76f8\u540c\u3002"),(0,s.kt)("p",null,"\u4e0a\u8ff0\u51fd\u6570\u53c2\u6570\u4e2d\u7684pipe\u4f7f\u7528usb_sndbulkpipe\uff08\uff09\u6216\u8005usb_rcvbulkpipe\uff08\uff09\u51fd\u6570\u6765\u521b\u5efa\u3002"),(0,s.kt)("p",null,"\u5bf9\u4e8e\u63a7\u5236URB\uff0c\u4f7f\u7528usb_fill_control_urb\uff08\uff09\u51fd\u6570\u6765\u521d\u59cb\u5316\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_fill_control_urb(struct urb *urb, struct usb_device *dev,\n unsigned int pipe, unsigned char *setup_packet,\n void *transfer_buffer, int buffer_length,\n usb_complete_t complete, void *context);\n")),(0,s.kt)("p",null,"\u9664\u4e86\u589e\u52a0\u4e86\u65b0\u7684setup_packet\u53c2\u6570\u4ee5\u5916\uff0c\u8be5\u51fd\u6570\u7684\u53c2\u6570\u548cusb_fill_bulk_urb\uff08\uff09\u51fd\u6570\u7684\u53c2\u6570\u542b\u4e49\u76f8\u540c\u3002setup_packet\u53c2\u6570\u6307\u5411\u5373\u5c06\u88ab\u53d1\u9001\u5230\u7aef\u70b9\u7684\u8bbe\u7f6e\u6570\u636e\u5305\u3002"),(0,s.kt)("p",null,"\u4e0a\u8ff0\u51fd\u6570\u53c2\u6570\u4e2d\u7684pipe\u4f7f\u7528usb_sndctrlpipe\uff08\uff09\u6216usb_rcvictrlpipe\uff08\uff09\u51fd\u6570\u6765\u521b\u5efa\u3002"),(0,s.kt)("p",null,"\u7b49\u65f6URB\u6ca1\u6709\u50cf\u4e2d\u65ad\u3001\u63a7\u5236\u548c\u6279\u91cfURB\u7684\u521d\u59cb\u5316\u51fd\u6570usb_fill_iso_urb\uff08\uff09\uff0c\u6211\u4eec\u53ea\u80fd\u624b\u52a8\u5bf9\u5b83\u521d\u59cb\u5316\uff0c\u800c\u540e\u624d\u80fd\u63d0\u4ea4\u7ed9USB\u6838\u5fc3\u3002\u4ee3\u7801\u6e05\u535516.14\u7ed9\u51fa\u4e86\u521d\u59cb\u5316\u7b49\u65f6URB\u7684\u4f8b\u5b50\uff0c\u5b83\u6765\u81eadrivers/media/usb/uvc/uvc_video.c\u6587\u4ef6\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.14\u3000\u521d\u59cb\u5316\u7b49\u65f6URB"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1        for (i = 0; i < UVC_URBS; ++i) {\n 2               urb = usb_alloc_urb(npackets, gfp_flags);\n 3               if (urb == NULL) {\n 4                      uvc_uninit_video(stream, 1);\n 5                      return -ENOMEM;\n 6               }\n 7\n 8               urb->dev = stream->dev->udev;\n 9               urb->context = stream;\n10               urb->pipe = usb_rcvisocpipe(stream->dev->udev,\n11                                 ep->desc.bEndpointAddress);\n12#ifndef CONfiG_DMA_NONCOHERENT\n13               urb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n14               urb->transfer_dma = stream->urb_dma[i];\n15#else\n16               urb->transfer_flags = URB_ISO_ASAP;\n17#endif\n18               urb->interval = ep->desc.bInterval;\n19               urb->transfer_buffer = stream->urb_buffer[i];\n20               urb->complete = uvc_video_complete;\n21               urb->number_of_packets = npackets;\n22               urb->transfer_buffer_length = size;\n23\n24               for (j = 0; j < npackets; ++j) {\n25                      urb->iso_frame_desc[j].offset = j * psize;\n26                      urb->iso_frame_desc[j].length = psize;\n27               }\n28\n29               stream->urb[i] = urb;\n30        }\n")),(0,s.kt)("h3",{id:"3\u88abusb\u8bbe\u5907\u9a71\u52a8\u63d0\u4ea4\u7ed9usb\u6838\u5fc3"},"3\uff09\u88abUSB\u8bbe\u5907\u9a71\u52a8\u63d0\u4ea4\u7ed9USB\u6838\u5fc3\u3002"),(0,s.kt)("p",null,"\u5728\u5b8c\u6210\u7b2c1\uff09\u30012\uff09\u6b65\u7684\u521b\u5efa\u548c\u521d\u59cb\u5316URB\u540e\uff0cURB\u4fbf\u53ef\u4ee5\u63d0\u4ea4\u7ed9USB\u6838\u5fc3\u4e86\uff0c\u53ef\u901a\u8fc7usb_submit_urb\uff08\uff09\u51fd\u6570\u6765\u5b8c\u6210\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"int usb_submit_urb(struct urb *urb, gfp_t mem_flags);\n")),(0,s.kt)("p",null,"URB\u53c2\u6570\u662f\u6307\u5411URB\u7684\u6307\u9488\uff0cmem_flags\u53c2\u6570\u4e0e\u4f20\u9012\u7ed9kmalloc\uff08\uff09\u51fd\u6570\u53c2\u6570\u7684\u610f\u4e49\u76f8\u540c\uff0c\u5b83\u7528\u4e8e\u544a\u77e5USB\u6838\u5fc3\u5982\u4f55\u5728\u6b64\u65f6\u5206\u914d\u5185\u5b58\u7f13\u51b2\u533a\u3002"),(0,s.kt)("p",null,"\u5728\u63d0\u4ea4URB\u5230USB\u6838\u5fc3\u540e\uff0c\u76f4\u5230\u5b8c\u6210\u51fd\u6570\u88ab\u8c03\u7528\u4e4b\u524d\uff0c\u4e0d\u8981\u8bbf\u95eeURB\u4e2d\u7684\u4efb\u4f55\u6210\u5458\u3002"),(0,s.kt)("p",null,"usb_submit_urb\uff08\uff09\u5728\u539f\u5b50\u4e0a\u4e0b\u6587\u548c\u8fdb\u7a0b\u4e0a\u4e0b\u6587\u4e2d\u90fd\u53ef\u4ee5\u88ab\u8c03\u7528\uff0cmem_flags\u53d8\u91cf\u9700\u6839\u636e\u8c03\u7528\u73af\u5883\u8fdb\u884c\u76f8\u5e94\u7684\u8bbe\u7f6e\uff0c\u5982\u4e0b\u6240\u793a\u3002"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xb7GFP_ATOMIC\uff1a\u5728\u4e2d\u65ad\u5904\u7406\u51fd\u6570\u3001\u5e95\u534a\u90e8\u3001tasklet\u3001\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570\u4ee5\u53caURB\u5b8c\u6210\u51fd\u6570\u4e2d\uff0c\u5728\u8c03\u7528\u8005\u6301\u6709\u81ea\u65cb\u9501\u6216\u8005\u8bfb\u5199\u9501\u65f6\u4ee5\u53ca\u5f53\u9a71\u52a8\u5c06current->state\u4fee\u6539\u4e3a\u975eTASK_RUNNING\u65f6\uff0c\u5e94\u4f7f\u7528\u6b64\u6807\u5fd7\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7GFP_NOIO\uff1a\u5728\u5b58\u50a8\u8bbe\u5907\u7684\u5757I/O\u548c\u9519\u8bef\u5904\u7406\u8def\u5f84\u4e2d\uff0c\u5e94\u4f7f\u7528\u6b64\u6807\u5fd7\uff1b"),(0,s.kt)("li",{parentName:"ul"},"\xb7GFP_KERNEL\uff1a\u5982\u679c\u6ca1\u6709\u4efb\u4f55\u7406\u7531\u4f7f\u7528GFP_ATOMIC\u548cGFP_NOIO\uff0c\u5c31\u4f7f\u7528GFP_KERNEL\u3002")),(0,s.kt)("p",null,"\u5982\u679cusb_submit_urb\uff08\uff09\u8c03\u7528\u6210\u529f\uff0c\u5373URB\u7684\u63a7\u5236\u6743\u88ab\u79fb\u4ea4\u7ed9USB\u6838\u5fc3\uff0c\u8be5\u51fd\u6570\u8fd4\u56de0\uff1b\u5426\u5219\uff0c\u8fd4\u56de\u9519\u8bef\u53f7\u3002"),(0,s.kt)("h3",{id:"4\u63d0\u4ea4\u7531usb\u6838\u5fc3\u6307\u5b9a\u7684usb\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8"},"4\uff09\u63d0\u4ea4\u7531USB\u6838\u5fc3\u6307\u5b9a\u7684USB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u3002"),(0,s.kt)("h3",{id:"5\u88abusb\u4e3b\u673a\u63a7\u5236\u5668\u5904\u7406\u8fdb\u884c\u4e00\u6b21\u5230usb\u8bbe\u5907\u7684\u4f20\u9001"},"5\uff09\u88abUSB\u4e3b\u673a\u63a7\u5236\u5668\u5904\u7406\uff0c\u8fdb\u884c\u4e00\u6b21\u5230USB\u8bbe\u5907\u7684\u4f20\u9001\u3002"),(0,s.kt)("p",null,"\u7b2c4\uff09~5\uff09\u6b65\u7531USB\u6838\u5fc3\u548c\u4e3b\u673a\u63a7\u5236\u5668\u5b8c\u6210\uff0c\u4e0d\u53d7USB\u8bbe\u5907\u9a71\u52a8\u7684\u63a7\u5236\u3002"),(0,s.kt)("h3",{id:"6\u5f53urb\u5b8c\u6210usb\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u901a\u77e5usb\u8bbe\u5907\u9a71\u52a8"},"6\uff09\u5f53URB\u5b8c\u6210\uff0cUSB\u4e3b\u673a\u63a7\u5236\u5668\u9a71\u52a8\u901a\u77e5USB\u8bbe\u5907\u9a71\u52a8\u3002"),(0,s.kt)("p",null,"\u5728\u5982\u4e0b3\u79cd\u60c5\u51b5\u4e0b\uff0cURB\u5c06\u7ed3\u675f\uff0cURB\u5b8c\u6210\u56de\u8c03\u51fd\u6570\u5c06\u88ab\u8c03\u7528\uff08\u5b8c\u6210\u56de\u8c03\u662f\u901a\u8fc7usb_fill_xxx_urb\u7684\u53c2\u6570\u4f20\u5165\u7684\uff09\u3002\u5728\u5b8c\u6210\u56de\u8c03\u4e2d\uff0c\u6211\u4eec\u901a\u5e38\u8981\u8fdb\u884curb->status\u7684\u5224\u65ad\u3002"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xb7URB\u88ab\u6210\u529f\u53d1\u9001\u7ed9\u8bbe\u5907\uff0c\u5e76\u4e14\u8bbe\u5907\u8fd4\u56de\u6b63\u786e\u7684\u786e\u8ba4\u3002\u5982\u679curb->status\u4e3a0\uff0c\u610f\u5473\u7740\u5bf9\u4e8e\u4e00\u4e2a\u8f93\u51faURB\uff0c\u6570\u636e\u88ab\u6210\u529f\u53d1\u9001\uff1b\u5bf9\u4e8e\u4e00\u4e2a\u8f93\u5165URB\uff0c\u8bf7\u6c42\u7684\u6570\u636e\u88ab\u6210\u529f\u6536\u5230\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u5982\u679c\u53d1\u9001\u6570\u636e\u5230\u8bbe\u5907\u6216\u4ece\u8bbe\u5907\u63a5\u6536\u6570\u636e\u65f6\u53d1\u751f\u4e86\u9519\u8bef\uff0curb->status\u5c06\u8bb0\u5f55\u9519\u8bef\u503c\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7URB\u88ab\u4eceUSB\u6838\u5fc3\u201c\u53bb\u9664\u8fde\u63a5\u201d\uff0c\u8fd9\u53d1\u751f\u5728\u9a71\u52a8\u901a\u8fc7usb_unlink_urb\uff08\uff09\u6216usb_kill_urb\uff08\uff09\u51fd\u6570\u53d6\u6d88\u6216URB\u867d\u5df2\u63d0\u4ea4\u800cUSB\u8bbe\u5907\u88ab\u62d4\u51fa\u7684\u60c5\u51b5\u4e0b")),(0,s.kt)("p",null,"usb_unlink_urb\uff08\uff09\u548cusb_kill_urb\uff08\uff09\u8fd9\u4e24\u4e2a\u51fd\u6570\u7528\u4e8e\u53d6\u6d88\u5df2\u63d0\u4ea4\u7684URB\uff0c\u5176\u53c2\u6570\u4e3a\u8981\u88ab\u53d6\u6d88\u7684URB\u6307\u9488\u3002usb_unlink_urb\uff08\uff09\u662f\u5f02\u6b65\u7684\uff0c\u641e\u5b9a\u540e\u5bf9\u5e94\u7684\u5b8c\u6210\u56de\u8c03\u4f1a\u88ab\u8c03\u7528\uff1b\u800cusb_kill_urb\uff08\uff09\u4f1a\u5f7b\u5e95\u7ec8\u6b62URB\u7684\u751f\u547d\u5468\u671f\u5e76\u7b49\u5f85\u8fd9\u4e00\u884c\u4e3a\uff0c\u5b83\u901a\u5e38\u5728\u8bbe\u5907\u7684disconnect\uff08\uff09\u51fd\u6570\u4e2d\u88ab\u8c03\u7528\u3002"),(0,s.kt)("p",null,"\u5f53URB\u751f\u547d\u7ed3\u675f\u65f6\uff08\u5904\u7406\u5b8c\u6210\u6216\u88ab\u89e3\u9664\u94fe\u63a5\uff09\uff0c\u5728URB\u7684\u5b8c\u6210\u56de\u8c03\u4e2d\u901a\u8fc7URB\u7ed3\u6784\u4f53\u7684status\u6210\u5458\u53ef\u4ee5\u83b7\u77e5\u5176\u539f\u56e0\uff0c\u59820\u8868\u793a\u4f20\u8f93\u6210\u529f\uff0c-ENOENT\u8868\u793a\u88abusb_kill_urb\uff08\uff09\u6740\u6b7b\uff0c-ECONNRESET\u8868\u793a\u88abusb_unlink_urb\uff08\uff09\u6740\u6b7b\uff0c-EPROTO\u8868\u793a\u4f20\u8f93\u4e2d\u53d1\u751f\u4e86bitstuff\u9519\u8bef\u6216\u8005\u786c\u4ef6\u672a\u80fd\u53ca\u65f6\u6536\u5230\u54cd\u5e94\u6570\u636e\u5305\uff0c-ENODEV\u8868\u793aUSB\u8bbe\u5907\u5df2\u88ab\u79fb\u9664\uff0c-EXDEV\u8868\u793a\u7b49\u65f6\u4f20\u8f93\u4ec5\u5b8c\u6210\u4e86\u4e00\u90e8\u5206\u7b49\u3002"),(0,s.kt)("p",null,"\u5bf9\u4ee5\u4e0aURB\u7684\u5904\u7406\u6b65\u9aa4\u8fdb\u884c\u4e00\u4e2a\u603b\u7ed3\uff0c\u56fe16.4\u7ed9\u51fa\u4e86\u4e00\u4e2aURB\u7684\u5b8c\u6574\u5904\u7406\u6d41\u7a0b\uff0c\u865a\u7ebf\u6846\u7684usb_unlink_urb\uff08\uff09\u548cusb_kill_urb\uff08\uff09\u5e76\u4e0d\u4e00\u5b9a\u4f1a\u53d1\u751f\uff0c\u5b83\u4eec\u53ea\u662f\u5728URB\u6b63\u5728\u88abUSB\u6838\u5fc3\u548c\u4e3b\u673a\u63a7\u5236\u5668\u5904\u7406\u65f6\u53c8\u88ab\u9a71\u52a8\u7a0b\u5e8f\u53d6\u6d88\u7684\u60c5\u51b5\u4e0b\u624d\u53d1\u751f\u3002"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"1745247828456",src:t(64683).Z,width:"994",height:"664"})),(0,s.kt)("p",null,"\u56fe16.4\u3000URB\u5904\u7406\u6d41\u7a0b"),(0,s.kt)("h2",{id:"3\u7b80\u5355\u7684\u6279\u91cf\u4e0e\u63a7\u5236urb"},"3.\u7b80\u5355\u7684\u6279\u91cf\u4e0e\u63a7\u5236URB"),(0,s.kt)("p",null,"\u6709\u65f6USB\u9a71\u52a8\u7a0b\u5e8f\u53ea\u662f\u4eceUSB\u8bbe\u5907\u4e0a\u63a5\u6536\u6216\u5411USB\u8bbe\u5907\u53d1\u9001\u4e00\u4e9b\u7b80\u5355\u7684\u6570\u636e\uff0c\u8fd9\u65f6\u5019\uff0c\u6ca1\u6709\u5fc5\u8981\u5c06URB\u521b\u5efa\u3001\u521d\u59cb\u5316\u3001\u63d0\u4ea4\u3001\u5b8c\u6210\u5904\u7406\u7684\u6574\u4e2a\u6d41\u7a0b\u8d70\u4e00\u904d\uff0c\u800c\u53ef\u4ee5\u4f7f\u7528\u4e24\u4e2a\u66f4\u7b80\u5355\u7684\u51fd\u6570\uff0c\u5982\u4e0b\u6240\u793a\u3002"),(0,s.kt)("h3",{id:"1usb_bulk_msg"},"\uff081\uff09usb_bulk_msg\uff08\uff09"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n                 void *data, int len, int *actual_length,\n                 int timeout);\n")),(0,s.kt)("p",null,"usb_dev\u53c2\u6570\u4e3a\u6279\u91cf\u6d88\u606f\u8981\u53d1\u9001\u7684USB\u8bbe\u5907\u7684\u6307\u9488\uff0cpipe\u4e3a\u6279\u91cf\u6d88\u606f\u8981\u53d1\u9001\u5230\u7684USB\u8bbe\u5907\u7684\u7aef\u70b9\uff0cdata\u53c2\u6570\u4e3a\u6307\u5411\u8981\u53d1\u9001\u6216\u63a5\u6536\u7684\u6570\u636e\u7f13\u51b2\u533a\u7684\u6307\u9488\uff0clen\u53c2\u6570\u4e3adata\u53c2\u6570\u6240\u6307\u5411\u7684\u7f13\u51b2\u533a\u7684\u957f\u5ea6\uff0cactual_length\u7528\u4e8e\u8fd4\u56de\u5b9e\u9645\u53d1\u9001\u6216\u63a5\u6536\u7684\u5b57\u8282\u6570\uff0ctimeout\u662f\u53d1\u9001\u8d85\u65f6\uff0c\u4ee5jiffies\u4e3a\u5355\u4f4d\uff0c0\u610f\u5473\u7740\u6c38\u8fdc\u7b49\u5f85\u3002"),(0,s.kt)("p",null,"\u5982\u679c\u51fd\u6570\u8c03\u7528\u6210\u529f\uff0c\u8fd4\u56de0\uff1b\u5426\u5219\uff0c\u8fd4\u56de1\u4e2a\u8d1f\u7684\u9519\u8bef\u503c"),(0,s.kt)("h2",{id:"2usb_control_msg\u51fd\u6570"},"\uff082\uff09usb_control_msg\uff08\uff09\u51fd\u6570"),(0,s.kt)("p",null,"usb_control_msg\uff08\uff09\u51fd\u6570\u4e0eusb_bulk_msg\uff08\uff09\u51fd\u6570\u7c7b\u4f3c\uff0c\u4e0d\u8fc7\u5b83\u63d0\u4f9b\u7ed9\u9a71\u52a8\u53d1\u9001\u548c\u7ed3\u675fUSB\u63a7\u5236\u4fe1\u606f\u800c\u4e0d\u662f\u6279\u91cf\u4fe1\u606f\u7684\u80fd\u529b\uff0c\u8be5\u51fd\u6570\u7684\u539f\u578b\u4e3a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\n                    __u8 requesttype, __u16 value, __u16 index, void *data,\n                    __u16 size, int timeout);\n")),(0,s.kt)("p",null,"dev\u6307\u5411\u63a7\u5236\u6d88\u606f\u53d1\u5f80\u7684USB\u8bbe\u5907\uff0cpipe\u662f\u63a7\u5236\u6d88\u606f\u8981\u53d1\u5f80\u7684USB\u8bbe\u5907\u7684\u7aef\u70b9\uff0crequest\u662f\u8fd9\u4e2a\u63a7\u5236\u6d88\u606f\u7684USB\u8bf7\u6c42\u503c\uff0crequesttype\u662f\u8fd9\u4e2a\u63a7\u5236\u6d88\u606f\u7684USB\u8bf7\u6c42\u7c7b\u578b\uff0cvalue\u662f\u8fd9\u4e2a\u63a7\u5236\u6d88\u606f\u7684USB\u6d88\u606f\u503c\uff0cindex\u662f\u8fd9\u4e2a\u63a7\u5236\u6d88\u606f\u7684USB\u6d88\u606f\u7d22\u5f15\u503c\uff0cdata\u6307\u5411\u8981\u53d1\u9001\u6216\u63a5\u6536\u7684\u6570\u636e\u7f13\u51b2\u533a\uff0csize\u662fdata\u53c2\u6570\u6240\u6307\u5411\u7684\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff0ctimeout\u662f\u53d1\u9001\u8d85\u65f6\uff0c\u4ee5\u6beb\u79d2\u4e3a\u5355\u4f4d\uff0c0\u610f\u5473\u7740\u6c38\u8fdc\u7b49\u5f85\u3002"),(0,s.kt)("p",null,"\u53c2\u6570request\u3001requesttype\u3001value\u548cindex\u4e0eUSB\u89c4\u8303\u4e2d\u5b9a\u4e49\u7684USB\u63a7\u5236\u6d88\u606f\u76f4\u63a5\u5bf9\u5e94\u3002"),(0,s.kt)("p",null,"\u5982\u679c\u51fd\u6570\u8c03\u7528\u6210\u529f\uff0c\u8be5\u51fd\u6570\u8fd4\u56de\u53d1\u9001\u5230\u8bbe\u5907\u6216\u4ece\u8bbe\u5907\u63a5\u6536\u5230\u7684\u5b57\u8282\u6570\uff1b\u5426\u5219\uff0c\u8fd4\u56de\u4e00\u4e2a\u8d1f\u7684\u9519\u8bef\u503c\u3002"),(0,s.kt)("p",null,"\u5bf9usb_bulk_msg\uff08\uff09\u548cusb_control_msg\uff08\uff09\u51fd\u6570\u7684\u4f7f\u7528\u8981\u7279\u522b\u614e\u91cd\uff0c\u7531\u4e8e\u5b83\u4eec\u662f\u540c\u6b65\u7684\uff0c\u56e0\u6b64\u4e0d\u80fd\u5728\u4e2d\u65ad\u4e0a\u4e0b\u6587\u548c\u6301\u6709\u81ea\u65cb\u9501\u7684\u60c5\u51b5\u4e0b\u4f7f\u7528\u3002\u800c\u4e14\uff0c\u8be5\u51fd\u6570\u4e5f\u4e0d\u80fd\u88ab\u4efb\u4f55\u5176\u4ed6\u51fd\u6570\u53d6\u6d88\uff0c\u56e0\u6b64\uff0c\u52a1\u5fc5\u8981\u4f7f\u5f97\u9a71\u52a8\u7a0b\u5e8f\u7684disconnect\uff08\uff09\u51fd\u6570\u638c\u63e1\u8db3\u591f\u7684\u4fe1\u606f\uff0c\u4ee5\u5224\u65ad\u548c\u7b49\u5f85\u8be5\u8c03\u7528\u7684\u7ed3\u675f\u3002"),(0,s.kt)("h1",{id:"1633\u63a2\u6d4b\u548c\u65ad\u5f00\u51fd\u6570"},"16.3.3\u3000\u63a2\u6d4b\u548c\u65ad\u5f00\u51fd\u6570"),(0,s.kt)("p",null,"\u5728USB\u8bbe\u5907\u9a71\u52a8usb_driver\u7ed3\u6784\u4f53\u7684probe\uff08\uff09\u51fd\u6570\u4e2d\uff0c\u5e94\u8be5\u5b8c\u6210\u5982\u4e0b\u5de5\u4f5c\u3002"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xb7\u63a2\u6d4b\u8bbe\u5907\u7684\u7aef\u70b9\u5730\u5740\u3001\u7f13\u51b2\u533a\u5927\u5c0f\uff0c\u521d\u59cb\u5316\u4efb\u4f55\u53ef\u80fd\u7528\u4e8e\u63a7\u5236USB\u8bbe\u5907\u7684\u6570\u636e\u7ed3\u6784\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u628a\u5df2\u521d\u59cb\u5316\u7684\u6570\u636e\u7ed3\u6784\u7684\u6307\u9488\u4fdd\u5b58\u5230\u63a5\u53e3\u8bbe\u5907\u4e2d\u3002")),(0,s.kt)("p",null,"usb_set_intfdata\uff08\uff09\u51fd\u6570\u53ef\u4ee5\u8bbe\u7f6eusb_interface\u7684\u79c1\u6709\u6570\u636e\uff0c\u8fd9\u4e2a\u51fd\u6570\u7684\u539f\u578b\u4e3a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_set_intfdata (struct usb_interface *intf, void *data);\n")),(0,s.kt)("p",null,"\u8fd9\u4e2a\u51fd\u6570\u7684\u201c\u53cd\u51fd\u6570\u201d\u7528\u4e8e\u5f97\u5230usb_interface\u7684\u79c1\u6709\u6570\u636e\uff0c\u5176\u539f\u578b\u4e3a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void *usb_get_intfdata (struct usb_interface *intf);\n")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xb7\u6ce8\u518cUSB\u8bbe\u5907\u3002")),(0,s.kt)("p",null,"\u5982\u679c\u662f\u7b80\u5355\u7684\u5b57\u7b26\u8bbe\u5907\uff0c\u5219\u53ef\u8c03\u7528usb_register_dev\uff08\uff09\uff0c\u8fd9\u4e2a\u51fd\u6570\u7684\u539f\u578b\u4e3a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"int usb_register_dev(struct usb_interface *intf,\n                     struct usb_class_driver *class_driver);\n")),(0,s.kt)("p",null,"\u4e0a\u8ff0\u51fd\u6570\u4e2d\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\u4e3ausb_class_driver\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e2a\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u535516.15\u6240\u793a"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.15\u3000usb_class_driver\u7ed3\u6784\u4f53"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1struct usb_class_driver {\n 2        char *name;\n 3        char *(*devnode)(struct device *dev, umode_t *mode);\n 4        const struct file_operations *fops;\n 5        int minor_base;\n 6};\n")),(0,s.kt)("p",null,"\u5bf9\u4e8e\u5b57\u7b26\u8bbe\u5907\u800c\u8a00\uff0cusb_class_driver\u7ed3\u6784\u4f53\u7684fops\u6210\u5458\u4e2d\u7684write\uff08\uff09\u3001read\uff08\uff09\u3001ioctl\uff08\uff09\u7b49\u51fd\u6570\u7684\u5730\u4f4d\u5b8c\u5168\u7b49\u540c\u4e8e\u672c\u4e66\u7b2c6\u7ae0\u4e2d\u7684file_operations\u6210\u5458\u51fd\u6570\u3002"),(0,s.kt)("p",null,"\u5982\u679c\u662f\u5176\u4ed6\u7c7b\u578b\u7684\u8bbe\u5907\uff0c\u5982tty\u8bbe\u5907\uff0c\u5219\u8c03\u7528\u5bf9\u5e94\u8bbe\u5907\u7684\u6ce8\u518c\u51fd\u6570\u3002"),(0,s.kt)("p",null,"\u5728USB\u8bbe\u5907\u9a71\u52a8usb_driver\u7ed3\u6784\u4f53\u7684probe\uff08\uff09\u51fd\u6570\u4e2d\uff0c\u5e94\u8be5\u5b8c\u6210\u5982\u4e0b\u5de5\u4f5c\u3002"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xb7\u91ca\u653e\u6240\u6709\u4e3a\u8bbe\u5907\u5206\u914d\u7684\u8d44\u6e90\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u8bbe\u7f6e\u63a5\u53e3\u8bbe\u5907\u7684\u6570\u636e\u6307\u9488\u4e3aNULL\u3002"),(0,s.kt)("li",{parentName:"ul"},"\xb7\u6ce8\u9500USB\u8bbe\u5907\u3002")),(0,s.kt)("p",null,"\u5bf9\u4e8e\u5b57\u7b26\u8bbe\u5907\uff0c\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528usb_register_dev\uff08\uff09\u51fd\u6570\u7684\u201c\u53cd\u51fd\u6570\u201d\uff0c\u5982\u4e0b\u6240\u793a\uff1a"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"void usb_deregister_dev(struct usb_interface *intf,\n                        struct usb_class_driver *class_driver);\n")),(0,s.kt)("p",null,"\u5bf9\u4e8e\u5176\u4ed6\u7c7b\u578b\u7684\u8bbe\u5907\uff0c\u5982tty\u8bbe\u5907\uff0c\u5219\u8c03\u7528\u5bf9\u5e94\u8bbe\u5907\u7684\u6ce8\u9500\u51fd\u6570\u3002"),(0,s.kt)("h1",{id:"1634usb\u9aa8\u67b6\u7a0b\u5e8f"},"16.3.4\u3000USB\u9aa8\u67b6\u7a0b\u5e8f"),(0,s.kt)("p",null,"Linux\u5185\u6838\u6e90\u4ee3\u7801\u4e2d\u7684driver/usb/usb-skeleton.c\u6587\u4ef6\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6700\u57fa\u7840\u7684USB\u9a71\u52a8\u7a0b\u5e8f\uff0c\u5373USB\u9aa8\u67b6\u7a0b\u5e8f\uff0c\u5b83\u53ef\u88ab\u770b\u4f5c\u4e00\u4e2a\u6700\u7b80\u5355\u7684USB\u8bbe\u5907\u9a71\u52a8\u5b9e\u4f8b\u3002\u5c3d\u7ba1\u5177\u4f53\u7684USB\u8bbe\u5907\u9a71\u52a8\u5343\u5dee\u4e07\u522b\uff0c\u4f46\u5176\u9aa8\u67b6\u5219\u4e07\u53d8\u4e0d\u79bb\u5176\u5b97"),(0,s.kt)("p",null,"\u9996\u5148\u770b\u770bUSB\u9aa8\u67b6\u7a0b\u5e8f\u7684usb_driver\u7ed3\u6784\u4f53\u5b9a\u4e49\uff0c\u5982\u4ee3\u7801\u6e05\u535516.16\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.16\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684usb_driver\u7ed3\u6784\u4f53"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static struct usb_driver skel_driver = {\n 2        .name =         "skeleton",\n 3        .probe =        skel_probe,\n 4        .disconnect =   skel_disconnect,\n 5        .suspend =      skel_suspend,\n 6        .resume =       skel_resume,\n 7        .pre_reset =    skel_pre_reset,\n 8        .post_reset =   skel_post_reset,\n 9        .id_table =     skel_table,\n10        .supports_autosuspend = 1,\n11};\n')),(0,s.kt)("p",null,"\u4ece\u4e0a\u8ff0\u4ee3\u7801\u7b2c9\u884c\u53ef\u4ee5\u770b\u51fa\uff0c\u5b83\u6240\u652f\u6301\u7684USB\u8bbe\u5907\u7684\u5217\u8868\u6570\u7ec4\u4e3askel_table[]\uff0c\u5176\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u535516.17\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.17\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684id_table"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1static struct usb_device_id skel_table [] = {\n 2    { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },\n 3    { }                  /* Terminating entry */\n 4};\n 5MODULE_DEVICE_TABLE(usb, skel_table);\n")),(0,s.kt)("p",null,"\u5bf9\u4e0a\u8ff0usb_driver\u7684\u6ce8\u518c\u548c\u6ce8\u9500\u53d1\u751f\u5728USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u6a21\u5757\u52a0\u8f7d\u4e0e\u5378\u8f7d\u51fd\u6570\u5185\uff0c\u5176\u5206\u522b\u8c03\u7528\u4e86usb_register\uff08\uff09\u548cusb_deregister\uff08\uff09\uff0c\u4e0d\u8fc7\u8fd9\u4e2a\u6ce8\u518c\u548c\u6ce8\u9500\u7684\u4ee3\u7801\u5374\u4e0d\u7528\u5199\u51fa\u6765\uff0c\u76f4\u63a5\u7528\u4e00\u4e2a\u5feb\u6377\u5b8fmodule_usb_driver\u5373\u53ef\uff0c\u5982\u4ee3\u7801\u6e05\u535516.18\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.18\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u6a21\u5757\u52a0\u8f7d"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static struct usb_driver skel_driver = {\n 2        .name =        "skeleton",\n 3        .probe =       skel_probe,\n 4        .disconnect =   skel_disconnect,\n 5        .suspend =     skel_suspend,\n 6        .resume =      skel_resume,\n 7        .pre_reset =    skel_pre_reset,\n 8        .post_reset =   skel_post_reset,\n 9        .id_table =     skel_table,\n10        .supports_autosuspend = 1,\n11};\n12\n13module_usb_driver(skel_driver);\n')),(0,s.kt)("p",null,"\u5728usb_driver\u7684probe\uff08\uff09\u6210\u5458\u51fd\u6570\u4e2d\uff0c\u4f1a\u6839\u636eusb_interface\u7684\u6210\u5458\u5bfb\u627e\u7b2c\u4e00\u4e2a\u6279\u91cf\u8f93\u5165\u548c\u8f93\u51fa\u7aef\u70b9\uff0c\u5c06\u7aef\u70b9\u5730\u5740\u3001\u7f13\u51b2\u533a\u7b49\u4fe1\u606f\u5b58\u5165\u4e3aUSB\u9aa8\u67b6\u7a0b\u5e8f\u5b9a\u4e49\u7684usb_skel\u7ed3\u6784\u4f53\u4e2d\uff0c\u5e76\u5c06usb_skel\u5b9e\u4f8b\u7684\u6307\u9488\u4f20\u5165usb_set_intfdata\uff08\uff09\u4e2d\u4ee5\u4f5c\u4e3aUSB\u63a5\u53e3\u7684\u79c1\u6709\u6570\u636e\uff0c\u6700\u540e\uff0c\u5b83\u4f1a\u6ce8\u518cUSB\u8bbe\u5907\uff0c\u5982\u4ee3\u7801\u6e05\u535516.19\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.19\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684probe\uff08\uff09\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1static int skel_probe(struct usb_interface *interface,\n 2            const struct usb_device_id *id)\n 3{\n 4   struct usb_skel *dev;\n 5   struct usb_host_interface *iface_desc;\n 6   struct usb_endpoint_descriptor *endpoint;\n 7   size_t buffer_size;\n 8   int i;\n 9   int retval = -ENOMEM;\n10\n11   /* allocate memory for our device state and initialize it */\n12   dev = kzalloc(sizeof(*dev), GFP_KERNEL);\n13   ...\n14   kref_init(&dev->kref);\n15   sema_init(&dev->limit_sem, WRITES_IN_FLIGHT);\n16   mutex_init(&dev->io_mutex);\n17   spin_lock_init(&dev->err_lock);\n18   init_usb_anchor(&dev->submitted);\n19   init_waitqueue_head(&dev->bulk_in_wait);\n20\n21   dev->udev = usb_get_dev(interface_to_usbdev(interface));\n22   dev->interface = interface;\n23\n24   /* set up the endpoint information */\n25   /* use only the first bulk-in and bulk-out endpoints */\n26   iface_desc = interface->cur_altsetting;\n27   for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n28       endpoint = &iface_desc->endpoint[i].desc;\n29\n30       if (!dev->bulk_in_endpointAddr &&\n31          usb_endpoint_is_bulk_in(endpoint)) {\n32           /* we found a bulk in endpoint */\n33           buffer_size = usb_endpoint_maxp(endpoint);\n34           dev->bulk_in_size = buffer_size;\n35           dev->bulk_in_endpointAddr = endpoint->bEndpointAddress;\n36           dev->bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);\n37           ...\n38           dev->bulk_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n39           ...\n40       }\n41\n42       if (!dev->bulk_out_endpointAddr &&\n43          usb_endpoint_is_bulk_out(endpoint)) {\n44           /* we found a bulk out endpoint */\n45           dev->bulk_out_endpointAddr = endpoint->bEndpointAddress;\n46       }\n47   }\n48   ...\n49\n50   /* save our data pointer in this interface device */\n51   usb_set_intfdata(interface, dev);\n52\n53   /* we can register the device now, as it is ready */\n54   retval = usb_register_dev(interface, &skel_class);\n55   ...\n56   return 0;\n57   ...\n58}\n")),(0,s.kt)("p",null,"usb_skel\u7ed3\u6784\u4f53\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u4e00\u4e2a\u79c1\u6709\u6570\u636e\u7ed3\u6784\u4f53\uff0c\u5176\u5b9a\u4e49\u5982\u4ee3\u7801\u6e05\u535516.20\u6240\u793a\uff0c\u5e94\u8be5\u6839\u636e\u5177\u4f53\u7684\u8bbe\u5907\u91cf\u8eab\u5b9a\u5236\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.20\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u81ea\u5b9a\u4e49\u6570\u636e\u7ed3\u6784usb_skel"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1struct usb_skel {\n 2        struct usb_device      *udev;         /* the usb device for this device */\n 3        struct usb_interface   *interface;    /* the interface for this device */\n 4        struct semaphore limit_sem;    /* limiting the number of writes in progress */\n 5        struct usb_anchor submitted;   /* in case we need to retract our submissions */\n 6        struct urb  *bulk_in_urb;             /* the urb to read data with */\n 7        unsigned char  *bulk_in_buffer;       /* the buffer to receive data */\n 8        size_t bulk_in_size;                  /* the size of the receive buffer */\n 9        size_t  bulk_in_filled;               /* number of bytes in the buffer */\n10        size_t   bulk_in_copied;              /* already copied to user space */\n11        __u8 bulk_in_endpointAddr;         /* the address of the bulk in endpoint */\n12        __u8  bulk_out_endpointAddr;        /* the address of the bulk out endpoint */\n13        int                  errors;          /* the last request tanked */\n14        bool                 ongoing_read;    /* a read is going on */\n15        spinlock_t            err_lock;       /* lock for errors */\n16        struct kref           kref;\n17        struct mutex          io_mutex;       /* synchronize I/O with disconnect */\n18        wait_queue_head_t      bulk_in_wait;     /* to wait for an ongoing read */\n19};\n")),(0,s.kt)("p",null,"USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u65ad\u5f00\u51fd\u6570\u4f1a\u5b8c\u6210\u4e0eprobe\uff08\uff09\u51fd\u6570\u76f8\u53cd\u7684\u5de5\u4f5c\uff0c\u5373\u8bbe\u7f6e\u63a5\u53e3\u6570\u636e\u4e3aNULL\uff0c\u6ce8\u9500USB\u8bbe\u5907\uff0c\u5982\u4ee3\u7801\u6e05\u535516.21\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.21\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u65ad\u5f00\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static void skel_disconnect(struct usb_interface *interface)\n 2{\n 3        struct usb_skel *dev;\n 4        int minor = interface->minor;\n 5\n 6        dev = usb_get_intfdata(interface);\n 7        usb_set_intfdata(interface, NULL);\n 8\n 9        /* give back our minor */\n10        usb_deregister_dev(interface, &skel_class);\n11\n12        /* prevent more I/O from starting */\n13        mutex_lock(&dev->io_mutex);\n14        dev->interface = NULL;\n15        mutex_unlock(&dev->io_mutex);\n16\n17        usb_kill_anchored_urbs(&dev->submitted);\n18\n19        /* decrement our usage count */\n20        kref_put(&dev->kref, skel_delete);\n21\n22        dev_info(&interface->dev, "USB Skeleton #%d now disconnected", minor);\n23}\n')),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.19\u7b2c54\u884cusb_register_dev\uff08interface\uff0c&skel_class\uff09\u4e2d\u7684\u7b2c\u4e8c\u4e2a\u53c2\u6570\u5305\u542b\u4e86\u5b57\u7b26\u8bbe\u5907\u7684file_operations\u7ed3\u6784\u4f53\u6307\u9488\uff0c\u800c\u8fd9\u4e2a\u7ed3\u6784\u4f53\u4e2d\u7684\u6210\u5458\u5b9e\u73b0\u4e5f\u662fUSB\u5b57\u7b26\u8bbe\u5907\u7684\u53e6\u4e00\u4e2a\u7ec4\u6210\u6210\u5206\u3002\u4ee3\u7801\u6e05\u535516.22\u7ed9\u51fa\u4e86USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u5b57\u7b26\u8bbe\u5907\u6587\u4ef6\u64cd\u4f5cfile_operations\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.22\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u5b57\u7b26\u8bbe\u5907\u6587\u4ef6\u64cd\u4f5c\u7ed3\u6784\u4f53"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1static const struct file_operations skel_fops = {\n 2        .owner =       THIS_MODULE,\n 3        .read =        skel_read,\n 4        .write =       skel_write,\n 5        .open =        skel_open,\n 6        .release =     skel_release,\n 7        .flush =        skel_flush,\n 8        .llseek =      noop_llseek,\n 9};\n")),(0,s.kt)("p",null,"\u7531\u4e8e\u53ea\u662f\u4e00\u4e2a\u8c61\u5f81\u6027\u7684\u9aa8\u67b6\u7a0b\u5e8f\uff0copen\uff08\uff09\u6210\u5458\u51fd\u6570\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u5b83\u6839\u636eusb_driver\u548c\u6b21\u8bbe\u5907\u53f7\u901a\u8fc7usb_find_interface\uff08\uff09\u83b7\u5f97USB\u63a5\u53e3\uff0c\u4e4b\u540e\u901a\u8fc7usb_get_intfdata\uff08\uff09\u83b7\u5f97\u63a5\u53e3\u7684\u79c1\u6709\u6570\u636e\u5e76\u8d4b\u4e88file->private_data\uff0c\u5982\u4ee3\u7801\u6e05\u535516.23\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.23\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u5b57\u7b26\u8bbe\u5907open\uff08\uff09\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1static int skel_open(struct inode *inode, struct file *file)\n 2{\n 3        struct usb_skel *dev;\n 4        struct usb_interface *interface;\n 5        int subminor;\n 6        int retval = 0;\n 7\n 8        subminor = iminor(inode);\n 9\n10        interface = usb_find_interface(&skel_driver, subminor);\n11        ...\n12        dev = usb_get_intfdata(interface);\n13        ...\n14\n15        retval = usb_autopm_get_interface(interface);\n16        if (retval)\n17               goto exit;\n18\n19        /* increment our usage count for the device */\n20        kref_get(&dev->kref);\n21\n22        /* save our object in the file's private structure */\n23        file->private_data = dev;\n24\n25exit:\n26        return retval;\n27}\n")),(0,s.kt)("p",null,"\u7531\u4e8e\u5728open\uff08\uff09\u51fd\u6570\u4e2d\u5e76\u6ca1\u6709\u7533\u8bf7\u4efb\u4f55\u8f6f\u4ef6\u548c\u786c\u4ef6\u8d44\u6e90\uff0c\u6240\u4ee5\u4e0eopen\uff08\uff09\u51fd\u6570\u5bf9\u5e94\u7684release\uff08\uff09\u51fd\u6570\u4e0d\u7528\u8fdb\u884c\u8d44\u6e90\u7684\u91ca\u653e\uff0c\u800c\u53ea\u9700\u8fdb\u884c\u51cf\u5c11\u5728open\uff08\uff09\u4e2d\u589e\u52a0\u7684\u5f15\u7528\u8ba1\u6570\u7b49\u5de5\u4f5c\u3002"),(0,s.kt)("p",null,"\u63a5\u4e0b\u6765\u8981\u5206\u6790\u7684\u662f\u8bfb\u5199\u51fd\u6570\uff0c\u524d\u9762\u5df2\u7ecf\u63d0\u5230\uff0c\u5728\u8bbf\u95eeUSB\u8bbe\u5907\u7684\u65f6\u5019\uff0c\u8d2f\u7a7f\u5176\u4e2d\u7684\u201c\u4e2d\u67a2\u795e\u7ecf\u201d\u662fURB\u7ed3\u6784\u4f53\u3002"),(0,s.kt)("p",null,"\u5728skel_write\uff08\uff09\u51fd\u6570\u4e2d\u8fdb\u884c\u7684\u5173\u4e8eURB\u7684\u64cd\u4f5c\u4e0e16.3.2\u5c0f\u8282\u7684\u63cf\u8ff0\u5b8c\u5168\u5bf9\u5e94\uff0c\u5373\u8fdb\u884c\u4e86URB\u7684\u5206\u914d\uff08\u8c03\u7528usb_alloc_urb\uff08\uff09\uff09\u3001\u521d\u59cb\u5316\uff08\u8c03\u7528usb_fill_bulk_urb\uff08\uff09\uff09\u548c\u63d0\u4ea4\uff08\u8c03\u7528usb_submit_urb\uff08\uff09\uff09\u7684\u64cd\u4f5c\uff0c\u5982\u4ee3\u7801\u6e05\u535516.24\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.24\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u5b57\u7b26\u8bbe\u5907\u5199\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1static ssize_t skel_write(struct file *file, const char *user_buffer,\n 2               size_t count, loff_t *ppos)\n 3{\n 4    struct usb_skel *dev;\n 5    int retval = 0;\n 6    struct urb *urb = NULL;\n 7    char *buf = NULL;\n 8    size_t writesize = min(count, (size_t)MAX_TRANSFER);\n 9\n10    dev = file->private_data;\n11    ...\n12    spin_lock_irq(&dev->err_lock);\n13    retval = dev->errors;\n14    ...\n15    spin_unlock_irq(&dev->err_lock);\n16    ...\n17\n18    /* create a urb, and a buffer for it, and copy the data to the urb */\n19    urb = usb_alloc_urb(0, GFP_KERNEL);\n20 ...\n21\n22    buf = usb_alloc_coherent(dev->udev, writesize, GFP_KERNEL,\n23                    &urb->transfer_dma);\n24    ...\n25\n26    if (copy_from_user(buf, user_buffer, writesize)) {\n27         retval = -EFAULT;\n28         goto error;\n29    }\n30\n31    /* this lock makes sure we don't submit URBs to gone devices */\n32    mutex_lock(&dev->io_mutex);\n33    ...\n34\n35    /* initialize the urb properly */\n36    usb_fill_bulk_urb(urb, dev->udev,\n37               usb_sndbulkpipe(dev->udev, dev->bulk_out_endpointAddr),\n38               buf, writesize, skel_write_bulk_callback, dev);\n39    urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n40    usb_anchor_urb(urb, &dev->submitted);\n41\n42    /* send the data out the bulk port */\n43    retval = usb_submit_urb(urb, GFP_KERNEL);\n44    mutex_unlock(&dev->io_mutex);\n45    ...\n46    usb_free_urb(urb);\n47\n48    return writesize;\n49    ...\n50}\n")),(0,s.kt)("p",null,"\u5728\u5199\u51fd\u6570\u4e2d\u53d1\u8d77\u7684URB\u7ed3\u675f\u540e\uff0c\u7b2c38\u884c\u586b\u5165\u7684\u5b8c\u6210\u51fd\u6570skel_write_bulk_callback\uff08\uff09\u5c06\u88ab\u8c03\u7528\uff0c\u5b83\u4f1a\u8fdb\u884curb->status\u7684\u5224\u65ad\uff0c\u5982\u4ee3\u7801\u6e05\u535516.25\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.25\u3000USB\u9aa8\u67b6\u7a0b\u5e8f\u7684\u5b57\u7b26\u8bbe\u5907\u5199\u64cd\u4f5c\u5b8c\u6210\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static void skel_write_bulk_callback(struct urb *urb)\n 2{\n 3        struct usb_skel *dev;\n 4\n 5        dev = urb->context;\n 6\n 7        /* sync/async unlink faults aren\'t errors */\n 8        if (urb->status) {\n 9               if (!(urb->status == -ENOENT ||\n10                   urb->status == -ECONNRESET ||\n11                   urb->status == -ESHUTDOWN))\n12                      dev_err(&dev->interface->dev,\n13                            "%s - nonzero write bulk status received: %d\\n",\n14                            __func__, urb->status);\n15\n16               spin_lock(&dev->err_lock);\n17               dev->errors = urb->status;\n18               spin_unlock(&dev->err_lock);\n19        }\n20\n21        /* free up our allocated buffer */\n22        usb_free_coherent(urb->dev, urb->transfer_buffer_length,\n23                      urb->transfer_buffer, urb->transfer_dma);\n24        up(&dev->limit_sem);\n25}\n')),(0,s.kt)("h1",{id:"1635\u5b9e\u4f8busb\u952e\u76d8\u9a71\u52a8"},"16.3.5\u3000\u5b9e\u4f8b\uff1aUSB\u952e\u76d8\u9a71\u52a8"),(0,s.kt)("p",null,"\u5728Linux\u7cfb\u7edf\u4e2d\uff0c\u952e\u76d8\u88ab\u8ba4\u5b9a\u4e3a\u6807\u51c6\u8f93\u5165\u8bbe\u5907\uff0c\u5bf9\u4e8e\u4e00\u4e2aUSB\u952e\u76d8\u800c\u8a00\uff0c\u5176\u9a71\u52a8\u4e3b\u8981\u7531\u4e24\u90e8\u5206\u7ec4\u6210\uff1ausb_driver\u7684\u6210\u5458\u51fd\u6570\u4ee5\u53ca\u8f93\u5165\u8bbe\u5907\u9a71\u52a8\u7684input_event\u83b7\u53d6\u548c\u62a5\u544a\u3002"),(0,s.kt)("p",null,"\u5728USB\u952e\u76d8\u8bbe\u5907\u9a71\u52a8\u7684\u6a21\u5757\u52a0\u8f7d\u548c\u5378\u8f7d\u51fd\u6570\u4e2d\uff0c\u5c06\u5206\u522b\u6ce8\u518c\u548c\u6ce8\u9500\u5bf9\u5e94\u4e8eUSB\u952e\u76d8\u7684usb_driver\u7ed3\u6784\u4f53usb_kbd_driver\uff0c\u4ee3\u7801\u6e05\u535516.26\u6240\u793a\u4e3a\u6a21\u5757\u52a0\u8f7d\u4e0e\u5378\u8f7d\u51fd\u6570\u4ee5\u53causb_driver\u7ed3\u6784\u4f53\u7684\u5b9a\u4e49\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.26\u3000USB\u952e\u76d8\u8bbe\u5907\u9a71\u52a8\u7684\u6a21\u5757\u52a0\u8f7d\u4e0e\u5378\u8f7d\u51fd\u6570\u4ee5\u53causb_driver\u7ed3\u6784\u4f53"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static struct usb_device_id usb_kbd_id_table [] = {\n 2        { USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,\n 3               USB_INTERFACE_PROTOCOL_KEYBOARD) },\n 4        { }                                      /* Terminating entry */\n 5};\n 6\n 7MODULE_DEVICE_TABLE (usb, usb_kbd_id_table);\n 8\n 9static struct usb_driver usb_kbd_driver = {\n10        .name =        "usbkbd",\n11        .probe =       usb_kbd_probe,\n12        .disconnect =   usb_kbd_disconnect,\n13        .id_table =    usb_kbd_id_table,\n14};\n15\n16module_usb_driver(usb_kbd_driver);\n')),(0,s.kt)("p",null,"\u5728usb_driver\u7684probe\uff08\uff09\u51fd\u6570\u4e2d\uff0c\u5c06\u8fdb\u884c\u8f93\u5165\u8bbe\u5907\u7684\u521d\u59cb\u5316\u548c\u6ce8\u518c\uff0cUSB\u952e\u76d8\u8981\u4f7f\u7528\u7684\u4e2d\u65adURB\u548c\u63a7\u5236URB\u7684\u521d\u59cb\u5316\uff0c\u5e76\u8bbe\u7f6e\u63a5\u53e3\u7684\u79c1\u6709\u6570\u636e\uff0c\u5982\u4ee3\u7801\u6e05\u535516.27\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.27\u3000USB\u952e\u76d8\u8bbe\u5907\u9a71\u52a8\u7684probe\uff08\uff09\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static int usb_kbd_probe(struct usb_interface *iface,\n 2             const struct usb_device_id *id)\n 3{\n 4    struct usb_device *dev = interface_to_usbdev(iface);\n 5    struct usb_host_interface *interface;\n 6    struct usb_endpoint_descriptor *endpoint;\n 7    struct usb_kbd *kbd;\n 8    struct input_dev *input_dev;\n 9    ...\n10    interface = iface->cur_altsetting;\n11\n12    endpoint = &interface->endpoint[0].desc;\n13\n14    pipe = usb_rcvintpipe(dev, endpoint->bEndpointAddress);\n15    maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));\n16\n17    kbd = kzalloc(sizeof(struct usb_kbd), GFP_KERNEL);\n18    input_dev = input_allocate_device();\n19\n20    if (usb_kbd_alloc_mem(dev, kbd))\n21        goto fail2;\n22\n23    kbd->usbdev = dev;\n24    kbd->dev = input_dev;\n25    ...\n26    usb_make_path(dev, kbd->phys, sizeof(kbd->phys));\n27    strlcat(kbd->phys, "/input0", sizeof(kbd->phys));\n28\n29    input_dev->name = kbd->name;\n30    input_dev->phys = kbd->phys;\n31    usb_to_input_id(dev, &input_dev->id);\n32    input_dev->dev.parent = &iface->dev;\n33\n34    input_set_drvdata(input_dev, kbd);\n35\n36    input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |\n37        BIT_MASK(EV_REP);\n38    ...\n39    input_dev->event = usb_kbd_event;\n40    input_dev->open = usb_kbd_open;\n41    input_dev->close = usb_kbd_close;\n42\n43    usb_fill_int_urb(kbd->irq, dev, pipe,\n44              kbd->new, (maxp > 8   8 : maxp),\n45              usb_kbd_irq, kbd, endpoint->bInterval);\n46    kbd->irq->transfer_dma = kbd->new_dma;\n47    kbd->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n48    ...\n49    usb_fill_control_urb(kbd->led, dev, usb_sndctrlpipe(dev, 0),\n50                 (void *) kbd->cr, kbd->leds, 1,\n51                 usb_kbd_led, kbd);\n52    kbd->led->transfer_dma = kbd->leds_dma;\n53    kbd->led->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n54\n55    error = input_register_device(kbd->dev);\n56    if (error)\n57        goto fail2;\n58\n59    usb_set_intfdata(iface, kbd);\n60    device_set_wakeup_enable(&dev->dev, 1);\n61    return 0;\n62    ...\n63}\n')),(0,s.kt)("p",null,"\u5728usb_driver\u7684\u65ad\u5f00\u51fd\u6570\u4e2d\uff0c\u5c06\u8bbe\u7f6e\u63a5\u53e3\u79c1\u6709\u6570\u636e\u4e3aNULL\u3001\u7ec8\u6b62\u5df2\u63d0\u4ea4\u7684URB\u5e76\u6ce8\u9500\u8f93\u5165\u8bbe\u5907\uff0c\u5982\u4ee3\u7801\u6e05\u535516.28\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.28\u3000USB\u952e\u76d8\u8bbe\u5907\u9a71\u52a8\u7684\u65ad\u5f00\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"}," 1static void usb_kbd_disconnect(struct usb_interface *intf)\n 2{\n 3   struct usb_kbd *kbd = usb_get_intfdata (intf);\n 4\n 5   usb_set_intfdata(intf, NULL);\n 6   if (kbd) {\n 7       usb_kill_urb(kbd->irq);\n 8       input_unregister_device(kbd->dev);\n 9       usb_kill_urb(kbd->led);\n10        usb_kbd_free_mem(interface_to_usbdev(intf), kbd);\n11       kfree(kbd);\n12   }\n13}\n")),(0,s.kt)("p",null,"\u952e\u76d8\u4e3b\u8981\u4f9d\u8d56\u4e8e\u4e2d\u65ad\u4f20\u8f93\u6a21\u5f0f\uff0c\u5728\u952e\u76d8\u4e2d\u65adURB\u7684\u5b8c\u6210\u51fd\u6570usb_kbd_irq\uff08\uff09\u4e2d\uff08\u901a\u8fc7\u4ee3\u7801\u6e05\u535516.27\u7684\u7b2c45\u884c\u53ef\u4ee5\u770b\u51fa\uff09\uff0c\u5c06\u4f1a\u901a\u8fc7input_report_key\uff08\uff09\u62a5\u544a\u6309\u952e\u4e8b\u4ef6\uff0c\u901a\u8fc7input_sync\uff08\uff09\u62a5\u544a\u540c\u6b65\u4e8b\u4ef6\uff0c\u5982\u4ee3\u7801\u6e05\u535516.29\u6240\u793a\u3002"),(0,s.kt)("p",null,"\u4ee3\u7801\u6e05\u535516.29\u3000USB\u952e\u76d8\u8bbe\u5907\u9a71\u52a8\u7684\u4e2d\u65adURB\u5b8c\u6210\u51fd\u6570"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},' 1static void usb_kbd_irq(struct urb *urb)\n 2{\n 3   ...\n 4   for (i = 0; i < 8; i++)\n 5       input_report_key(kbd->dev, usb_kbd_keycode[i + 224], (kbd->new[0] >> i) & 1);\n 6\n 7   for (i = 2; i < 8; i++) {\n 8\n 9       if (kbd->old[i]>3 && memscan(kbd->new + 2, kbd->old[i], 6)==kbd->new + 8) {\n10           if (usb_kbd_keycode[kbd->old[i]])\n11               input_report_key(kbd->dev, usb_kbd_keycode[kbd->old[i]], 0);\n12           else\n13               hid_info(urb->dev,\n14                    "Unknown key (scancode %#x) released.\\n",\n15                    kbd->old[i]);\n16       }\n17\n18       if (kbd->new[i] > 3&&memscan(kbd->old + 2, kbd->new[i], 6)==kbd->old + 8) {\n19           if (usb_kbd_keycode[kbd->new[i]])\n20               input_report_key(kbd->dev, usb_kbd_keycode[kbd->new[i]], 1);\n21           else\n22               hid_info(urb->dev,\n23                    "Unknown key (scancode %#x) pressed.\\n",\n24                    kbd->new[i]);\n25       }\n26   }\n27\n28   input_sync(kbd->dev);\n29\n30   ...\n31}\n')),(0,s.kt)("p",null,"\u4eceUSB\u952e\u76d8\u9a71\u52a8\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u8fdb\u4e00\u6b65\u770b\u5230\u4e86usb_driver\u672c\u8eab\u53ea\u662f\u8d77\u4e00\u4e2a\u6302\u63a5\u603b\u7ebf\u7684\u4f5c\u7528\uff0c\u800c\u5177\u4f53\u8bbe\u5907\u7c7b\u578b\u7684\u9a71\u52a8\u4ecd\u7136\u662f\u5de5\u4f5c\u7684\u4e3b\u4f53\uff0c\u4f8b\u5982\u952e\u76d8\u5c31\u662finput\u3001USB\u4e32\u53e3\u5c31\u662ftty\uff0c\u53ea\u662f\u5728\u8fd9\u4e9b\u8bbe\u5907\u5e95\u5c42\u8fdb\u884c\u786c\u4ef6\u8bbf\u95ee\u7684\u65f6\u5019\uff0c\u8c03\u7528\u7684\u90fd\u662f\u4e0eURB\u76f8\u5173\u7684\u63a5\u53e3\uff0c\u8fd9\u5957USB\u6838\u5fc3\u5c42API\u2014URB\u7684\u5b58\u5728\u4f7f\u6211\u4eec\u65e0\u987b\u5173\u5fc3\u5e95\u5c42USB\u4e3b\u673a\u63a7\u5236\u5668\u7684\u5177\u4f53\u7ec6\u8282\uff0c\u56e0\u6b64\uff0cUSB\u8bbe\u5907\u9a71\u52a8\u4e5f\u53d8\u5f97\u4e0e\u5e73\u53f0\u65e0\u5173\uff0c\u540c\u6837\u7684\u9a71\u52a8\u53ef\u5e94\u7528\u4e8e\u4e0d\u540c\u7684SoC\u3002"))}c.isMDXComponent=!0},12137:function(e,n,t){n.Z=t.p+"assets/images/1745247374129-31e34ded71baa9955f6b54aa9479649f.png"},64683:function(e,n,t){n.Z=t.p+"assets/images/1745247828456-9341f4f96bfe430b601dc646a057ffe5.png"}}]);