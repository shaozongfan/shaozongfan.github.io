<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-奔跑吧linux/基础架构/1、处理器架构面试题">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">1．请简述精简指令集RISC和复杂指令集CISC的区别。 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/docs/奔跑吧linux/基础架构/1、处理器架构面试题"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="1．请简述精简指令集RISC和复杂指令集CISC的区别。 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="​	20世纪70年代，IBM的John Cocke研究发现，处理器提供的大量指令集和复杂寻址方式并不会被编译器生成的代码用到：20%的简单指令经常被用到，占程序总指令数的80%；而指令集里其余80%的复杂指令很少被用到，只占程序总指令数的20%。基于这种情况，他将指令集和处理器重新进行了设计，在新的设计中只保留了常用的简单指令，这样处理器不需要浪费太多的晶体管去完成那些很复杂又很少使用的复杂指令。通常，大部分简单指令能在一个周期内完成，符合这种情况的指令集叫作精简指令集计算机（Reduced Instruction Set Computer，RISC）指令集，以前的指令集叫作复杂指令集计算机（Complex Instruction Set Computer，CISC）指令集。"><meta data-rh="true" property="og:description" content="​	20世纪70年代，IBM的John Cocke研究发现，处理器提供的大量指令集和复杂寻址方式并不会被编译器生成的代码用到：20%的简单指令经常被用到，占程序总指令数的80%；而指令集里其余80%的复杂指令很少被用到，只占程序总指令数的20%。基于这种情况，他将指令集和处理器重新进行了设计，在新的设计中只保留了常用的简单指令，这样处理器不需要浪费太多的晶体管去完成那些很复杂又很少使用的复杂指令。通常，大部分简单指令能在一个周期内完成，符合这种情况的指令集叫作精简指令集计算机（Reduced Instruction Set Computer，RISC）指令集，以前的指令集叫作复杂指令集计算机（Complex Instruction Set Computer，CISC）指令集。"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/docs/奔跑吧linux/基础架构/1、处理器架构面试题"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/奔跑吧linux/基础架构/1、处理器架构面试题" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/奔跑吧linux/基础架构/1、处理器架构面试题" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ccca8cd0.css">
<link rel="preload" href="/assets/js/runtime~main.1c06d183.js" as="script">
<link rel="preload" href="/assets/js/main.63ebc7ad.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/AI相关/AI核心技能">AI相关</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">docs/intro.md</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/linux设备驱动开发详解/1.1　设备驱动的作用">linux设备驱动开发详解</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人博客/docusaurus2.4">个人博客</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人生活/2025国家生育政策8大补贴汇总">个人生活</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/人生哲学/人生的底层逻辑">人生哲学</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs">笔记本开篇序言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/奔跑吧linux/arm64体系结构编程与实践/A64指令集其他重要指令面试题">奔跑吧linux</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/奔跑吧linux/arm64体系结构编程与实践/A64指令集其他重要指令面试题">arm64体系结构编程与实践</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/奔跑吧linux/基础架构/1、处理器架构面试题">基础架构</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/奔跑吧linux/基础架构/1、处理器架构面试题">1．请简述精简指令集RISC和复杂指令集CISC的区别。</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/2、ARM64在linux内核中的实现面试题">1．ARM64处理器中有两个页表基地址寄存器TTBR0和TTBR1，处理器如何使用它们？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/3、内存管理预备知识面试题">1．请简述内存架构中UMA和NUMA的区别。</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/4、物理内存与虚拟内存面试题">1．请简述Linux内核在理想情况下页面分配器（page allocator）是如何分配出连续物理页面的。</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/5、内存管理高级专题面试题">1．page数据结构中的_refcount和_mapcount有什么区别？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/6、内存管理实战案例面试题">1．Linux内核的内存管理模块都对哪些页面进行了统计？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/7、进程管理基本概念面试题">1．进程是什么？</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/8、进程管理调度与负载均衡面试题">1．请简述进程优先级、nice值和权重之间的关系。</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux/基础架构/9、进程管理调试和案例面试题">1．如何查看进程的调度信息？</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/奔跑吧linux/调试与案例分析/1、并发与同步面试题">调试与案例分析</a></div></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">奔跑吧linux内核（第2版）卷1：基础架构</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/网络/网络问题">网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/调试/Linux内核追踪神器：perf实现原理剖析">调试</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">奔跑吧linux</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">基础架构</span><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">1．请简述精简指令集RISC和复杂指令集CISC的区别。</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>1．请简述精简指令集RISC和复杂指令集CISC的区别。</h1><p>​	20世纪70年代，IBM的John Cocke研究发现，处理器提供的大量指令集和复杂寻址方式并不会被编译器生成的代码用到：20%的简单指令经常被用到，占程序总指令数的80%；而指令集里其余80%的复杂指令很少被用到，只占程序总指令数的20%。基于这种情况，他将指令集和处理器重新进行了设计，在新的设计中只保留了常用的简单指令，这样处理器不需要浪费太多的晶体管去完成那些很复杂又很少使用的复杂指令。通常，大部分简单指令能在一个周期内完成，符合这种情况的指令集叫作精简指令集计算机（Reduced Instruction Set Computer，RISC）指令集，以前的指令集叫作复杂指令集计算机（Complex Instruction Set Computer，CISC）指令集。</p><p>​	IBM、加州大学伯克利分校的David Patterson以及斯坦福大学的John Hennessy是研究RISC的先驱。Power处理器来自IBM，ARM/SPARC处理器受到加州大学伯克利分校的RISC的影响，MIPS来自斯坦福大学。当前还在使用的最出名的CISC指令集是Intel/AMD的x86指令集。</p><h1>2．请简述数值0x1234 5678在大小端字节序处理器的存储器中的存储方式。</h1><p>大端模式指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。在大端模式下，应该这样读取0x1234 5678。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0000430: 1234 5678 0000 0000 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000440: 0000 0000 0000 0000 0000 0000 0100 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>小端模式指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。在小端模式下，应该这样读取0x1234 5678。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0000430: 7856 3412 0000 0000 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000440: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>3．请简述在你所熟悉的处理器（如双核Cortex-A9）中一条存储读写指令的执行全过程。</h1><p>指令首先进入流水线（pipeline）的前端（front-end），包括预取（fetch）和译码（decode），经过分发（dispatch）和调度（schedule）后进入执行单元，最后提交执行结果。所有的指令采用顺序方式通过前端，并采用乱序的方式进行发射，然后乱序执行，最后用顺序方式提交执行结果，并将最终结果更新到加载-存储队列（Load-Store Queue，LSQ）单元。LSQ单元是指令流水线的一        个执行部件，可以理解为存储子系统的最高层，它接收来自CPU的存储器指令，并连接着存储器子系统。其主要功能是将来自CPU的存储器请求发送到存储器子系统，并处理其下存储器子系统的应答数据和消息。</p><h1>4．请简述内存屏障（memory barrier）产生的原因</h1><p>若程序在执行时的实际内存访问顺序和程序代码编写的访问顺序不一致，会导致内存乱序访问。内存乱序访问的出现是为了提高程序执行时的效率。内存乱序访问主要发生在如下两个阶段。</p><p>（1）编译时，编译器优化导致内存乱序访问。</p><p>（2）执行时，多个CPU间交互引起的内存乱序访问。</p><h1>5．ARM有几条内存屏障指令？它们之间有什么区别？</h1><p>内存屏障指令的基本原则如下。</p><p>所有在内存屏障指令之前的数据访问必须在内存屏障指令之前完成。</p><p>所有在内存屏障指令后面的数据访问必须等待内存屏障指令执行完。</p><p>多条内存屏障指令是按顺序执行的。</p><p>DMB:</p><p>DSB:</p><p>ISB:</p><h1>6．请简述高速缓存（cache）的工作方式。</h1><p>处理器在访问存储器时，会把虚拟地址同时传递给TLB和高速缓存。TLB是一个用于存储虚拟地址到物理地址转换的小缓存，处理器先使用有效页帧号（Effective Page Number，EPN）在TLB中查找最终的实际页帧号（Real Page Number，RPN）。如果其间发生TLB未命中（TLB miss），将会带来一系列严重的系统惩罚，处理器需要查询页表。假设发生TLB命中（TLB hit），就会很快获得合适的RPN，并得到相应的物理地址（Physical Address，PA）。</p><p>同时，处理器通过高速缓存编码地址的索引（index）域可以很快找到相应的高速缓存行对应的组。但是这里的高速缓存行的数据不一定是处理器所需要的，因此有必要进行一些检查，将高速缓存行中存放的标记域和通过MMU转换得到的物理地址的标记域进行比较。如果相同并且状态位匹配，就会发生高速缓存命中（cache hit），处理器通过字节选择与对齐（byte select and align）部件，就可以获取所需要的数据。如果发生高速缓存未命中（cache miss），处理器需要用物理地址进一步访问主存储器来获得最终数据，数据也会填充到相应的高速缓存行中。上述为VIPT类型的高速缓存组织方式</p><h1>7．高速缓存的映射方式有全关联（full-associative）、直接映射（direct-mapping）和组相联（set-associative）3种方式，请简述它们之间的区别。为什么现代的处理器都使用组相联的高速缓存映射方式？</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="71-直接映射当每组只有一个高速缓存行时高速缓存称为直接映射高速缓存">7.1 直接映射当每组只有一个高速缓存行时，高速缓存称为直接映射高速缓存。<a class="hash-link" href="#71-直接映射当每组只有一个高速缓存行时高速缓存称为直接映射高速缓存" title="标题的直接链接">​</a></h2><p>下面用一个简单的高速缓存来说明。如图1.5所示，这个高速缓存只有4个高速缓存行，每行有4个字（Word），1个字是4字节，共64字节。高速缓存控制器可以使用Bit<!-- -->[3:2]<!-- -->来选择高速缓存行中的字，使用Bit<!-- -->[5:4]<!-- -->作为索引，来选择4个高速缓存行中的1个，其余的位用于存储标记值。</p><p>在这个高速缓存中查询，当索引域和标记域的值与查询的地址相等并且有效位显示这个高速缓存行包含有效数据时，则发生高速缓存命中，可以使用偏移量域来寻址高速缓存行中的数据。如果高速缓存行包含有效数据，但是标记域是其他地址的值，那么这个高速缓存行需要被替换。因此，在这个高速缓存中，主存储器中所有Bit<!-- -->[5:4]<!-- -->相同值的地址都会映射到同一个高速缓存行中，并且同一时刻只有1个高速缓存行。若高速缓存行被频繁换入、换出，会导致严重的高速缓存颠簸（cache thrashing）。</p><p><img loading="lazy" alt="1742135934329" src="/assets/images/1742135934329-c8d900750dd38f746d30579dd888f464.png" width="1123" height="999" class="img_ev3q"></p><p>​																图 直接映射的高速缓存和地址</p><p>假设在下面的代码片段中，result、data1和data2分别指向0x00、0x40和0x80地址，它们都会使用同一个高速缓存行。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void add_array(int *data1, int *data2, int *result, int size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i=0 ; i&lt;size ; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         result[i] = data1[i] + data2[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当第一次读data1（即0x40地址）的数据时，因为数据不在高速缓存行中，所以把从0x40到0x4F地址的数据填充到高速缓存行中。</p><p>当读data2（即0x80地址）的数据时，数据不在高速缓存行中，需要把从0x80到0x8F地址的数据填充到高速缓存行中。因为0x80和0x40地址映射到同一个高速缓存行，所以高速缓存行发生替换操作。</p><p>当把result写入0x00地址时，同样发生了高速缓存行替换操作。</p><p>因此上面的代码片段会发生严重的高速缓存颠簸，性能会很低。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="72组相联">7.2．组相联<a class="hash-link" href="#72组相联" title="标题的直接链接">​</a></h2><p>为了解决直接映射高速缓存中的高速缓存颠簸问题，组相联的高速缓存结构在现代处理器中得到广泛应用。</p><p>如图1.6所示，以一个2路组相联的高速缓存为例，每一路包括4个高速缓存行，因此每个组有两个高速缓存行，可以提供高速缓存行替换。</p><p>地址0x00、0x40或者0x80的数据可以映射到同一个组的任意一个高速缓存行。当高速缓存行要进行替换操作时，有50%的概率可以不被替换，从而解决了高速缓存颠簸问题。</p><p><img loading="lazy" alt="1742136174809" src="/assets/images/1742136174809-bc7fe7f87e5b5824951f5f0e9dbdef4a.png" width="1209" height="750" class="img_ev3q"></p><p>​																	图2路组相联的高速缓存</p><h1>8．在一个32KB的4路组相联的高速缓存中，其中高速缓存行为32字节，请画出这个高速缓存的高速缓存行（line）、路（way）和组（set）的示意图。</h1><h3 class="anchor anchorWithStickyNavbar_LWe7" id="组相联的高速缓存">组相联的高速缓存<a class="hash-link" href="#组相联的高速缓存" title="标题的直接链接">​</a></h3><p>在Cortex-A7和Cortex-A9的处理器上可以看到32KB大小的4路组相联高速缓存。下面来分析这个高速缓存的结构。</p><p>高速缓存的总大小为32KB，并且是4路的，所以每一路的大小为8KB。</p><p>​																		way_size = 32KB/ 4 = 8KB</p><p>高速缓存行的大小为32字节，所以每一路包含的高速缓存行数量如下。</p><p>​																	num_cache_line = 8KB/32B = 256</p><p>所以在高速缓存编码的地址中，Bit<!-- -->[4:0]<!-- -->用于选择高速缓存行中的数据，其中Bit<!-- -->[4:2]<!-- -->可以用于寻址8个字，Bit<!-- -->[1:0]<!-- -->可以用于寻址每个字中的字节。Bit<!-- -->[12:5]<!-- -->用于在索引域中选择每一路上的高速缓存行，Bit<!-- -->[31:13]<!-- -->用作标记域，如图1.7所示。这里，V表示有效位，D表示脏位。</p><p><img loading="lazy" alt="1742136273726" src="/assets/images/1742136273726-41add01ee41db3fba844e8ce91b3c680.png" width="1446" height="999" class="img_ev3q"></p><p>​												图1.7　32KB大小的4路组相联高速缓存结构</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="pipt和vivt的区别">PIPT和VIVT的区别<a class="hash-link" href="#pipt和vivt的区别" title="标题的直接链接">​</a></h3><p>处理器在访问存储器时，访问的地址是虚拟地址（Virtual Address，VA），经过TLB和MMU的映射后变成了物理地址（Physical Address，PA）。TLB只用于加速虚拟地址到物理地址的转换。得到物理地址之后，若每次都直接从物理内存中读取数据，显然会很慢。实际上，处理器都配置了多级的高速缓存来加快数据的访问速度，那么查询高速缓存时使用虚拟地址还是物理地址呢？</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="1物理高速缓存">1．物理高速缓存<a class="hash-link" href="#1物理高速缓存" title="标题的直接链接">​</a></h4><p>当处理器查询MMU和TLB并得到物理地址之后，使用物理地址查询高速缓存，这种高速缓存称为物理高速缓存。使用物理高速缓存的缺点就是处理器在查询MMU和TLB后才能访问高速缓存，增加了流水线的延迟时间。物理高速缓存的工作流程如图1.8所示。</p><p><img loading="lazy" alt="1742136369568" src="/assets/images/1742136369568-4d4b985e14072d990526185d9082e973.png" width="1444" height="445" class="img_ev3q"></p><p>​																			图1.8　物理高速缓存的工作流程</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="2虚拟高速缓存">2．虚拟高速缓存<a class="hash-link" href="#2虚拟高速缓存" title="标题的直接链接">​</a></h4><p>若处理器使用虚拟地址来寻址高速缓存，这种高速缓存称为虚拟高速缓存。处理器在寻址时，首先把虚拟地址发送到高速缓存，若在高速缓存里找到需要的数据，就不再需要访问TLB和物理内存。虚拟高速缓存的工作流程如图1.9所示。</p><p><img loading="lazy" alt="1742136508633" src="/assets/images/1742136508633-1bf42680cb86ab71033abc56fc5525d1.png" width="1443" height="445" class="img_ev3q"></p><p>​																			图1.9　虚拟高速缓存的工作流程</p><h1>9．高速缓存重名问题和同名问题是什么？</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="重名aliasing问题3">重名（aliasing）问题<!-- -->[3]<!-- -->。<a class="hash-link" href="#重名aliasing问题3" title="标题的直接链接">​</a></h2><p>在操作系统中，多个不同的虚拟地址可能映射相同的物理地址。由于采用虚拟高速缓存，因此这些不同的虚拟地址会占用高速缓存中不同的高速缓存行，但是它们对应的是相同的物理地址，这样会引发问题。第一，浪费高速缓存空间，造成高速缓存等效容量减少，整体性能降低。第二，当执行写操作时，只更新了其中一个虚拟地址对应的高速缓存，而其他虚拟地址对应的高速缓存并没有更新。那么处理器访问其他虚拟地址时可能得到旧数据。如图1.10所示，如果VA1映射到PA，VA2也映射到PA，那么在虚拟高速缓存中可能同时缓存了VA1和VA2。当程序往VA1写入数据时，虚拟高速缓存中VA1对应的高速缓存行和PA的内容会被更改，但是VA2还保存着旧数据。这样，一个物理地址在虚拟高速缓存中保存了两份数据，这样会产生歧义。</p><p><img loading="lazy" alt="1742136580882" src="/assets/images/1742136580882-8923a61029a5840f924a897ef41799eb.png" width="1404" height="505" class="img_ev3q"></p><p>​																	▲图1.10　重名问题</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="同名homonyms问题">同名（homonyms）问题。<a class="hash-link" href="#同名homonyms问题" title="标题的直接链接">​</a></h2><p>同名问题指的是相同的虚拟地址对应不同的物理地址，因为操作系统中不同的进程会存在很多相同的虚拟地址，而这些相同的虚拟地址在经过MMU转换后得到不同的物理地址，这就产生了同名问题。同名问题最常见的地方是进程切换。当一个进程切换到另外一个进程时，若新进程使用虚拟地址来访问高速缓存，新进程会访问到旧进程遗留下来的高速缓存，这些高速缓存数据对于新进程来说是错误和没用的。解决办法是在进程切换时使旧进程遗留下来的高速缓存都无效，这样就能保证新进程执行时得到“干净的”虚拟高速缓存。同样，需要使TLB无效，因为新进程在切换后会得到一个旧进程使用的TLB，里面存放了旧进程的虚拟地址到物理地址的转换结果，这对于新进程来说是无用的，因此需要把TLB清空。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="综上所述">综上所述，<a class="hash-link" href="#综上所述" title="标题的直接链接">​</a></h2><p>重名问题是多个虚拟地址映射到同一个物理地址引发的问题，</p><p>而同名问题是一个虚拟地址可能出于进程切换等原因映射到不同的物理地址而引发的问题。</p><h1>10．ARM9处理器的数据高速缓存组织方式使用虚拟索引虚拟标签（Virtual Index Virtual Tag，VIVT）方式，而在Cortex-A7处理器中使用物理索引物理标签（Physical Index Physical Tag，PIPT），请简述PIPT与VIVT相比的优势。</h1><p>高速缓存可以设计成通过虚拟地址或者物理地址来访问，这在处理器设计时就确定下来了，并且对高速缓存的管理有很大的影响。高速缓存可以分成如下3类。</p><p>VIVT：使用虚拟地址的索引域和虚拟地址的标记域，相当于虚拟高速缓存。</p><p>PIPT：使用物理地址的索引域和物理地址的标记域，相当于物理高速缓存。</p><p>VIPT：使用虚拟地址的索引域和物理地址的标记域。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-避免歧义和别名问题">1. <strong>避免歧义和别名问题</strong><a class="hash-link" href="#1-避免歧义和别名问题" title="标题的直接链接">​</a></h3><ul><li><strong>VIVT</strong>：使用虚拟地址作为索引和标签，容易出现歧义（Ambiguity）和别名（Aliasing）问题。不同虚拟地址可能映射到相同的物理地址，导致缓存数据不一致。</li><li><strong>PIPT</strong>：完全使用物理地址进行索引和标签匹配，物理地址是唯一的，不存在歧义和别名问题。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-减少操作系统维护开销">2. <strong>减少操作系统维护开销</strong><a class="hash-link" href="#2-减少操作系统维护开销" title="标题的直接链接">​</a></h3><ul><li><strong>VIVT</strong>：在进程切换或修改虚拟地址到物理地址的映射时，必须清空缓存（flush cache），这会导致大量缓存未命中，增加系统开销。</li><li><strong>PIPT</strong>：由于使用物理地址，进程切换时不需要清空缓存，减少了操作系统在缓存管理上的维护成本。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-提高缓存一致性">3. <strong>提高缓存一致性</strong><a class="hash-link" href="#3-提高缓存一致性" title="标题的直接链接">​</a></h3><ul><li><strong>VIVT</strong>：由于别名问题，缓存一致性难以维护，尤其是在多任务系统中。</li><li><strong>PIPT</strong>：物理地址的唯一性确保了缓存的一致性，特别适合多任务操作系统。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-硬件设计和性能">4. <strong>硬件设计和性能</strong><a class="hash-link" href="#4-硬件设计和性能" title="标题的直接链接">​</a></h3><ul><li><strong>VIVT</strong>：硬件设计简单，访问速度快，因为不需要进行虚拟地址到物理地址的转换。</li><li><strong>PIPT</strong>：硬件设计相对复杂，因为需要在访问缓存前进行地址转换（通过MMU或TLB），但这种设计避免了VIVT的别名问题，提高了系统的整体性能。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-适用场景">5. <strong>适用场景</strong><a class="hash-link" href="#5-适用场景" title="标题的直接链接">​</a></h3><ul><li><strong>VIVT</strong>：适用于对延迟敏感且地址空间切换不频繁的场景，例如一些嵌入式系统。</li><li><strong>PIPT</strong>：适用于需要高缓存一致性和多任务支持的系统，如高性能服务器和现代多核处理器。</li></ul><h1>11．VIVT类型的高速缓存有什么缺点？请简述操作系统需要做什么事情来克服这些缺点。</h1><p>VIVT（Virtually Indexed Virtually Tagged）类型的高速缓存存在以下主要缺点：</p><ol><li><strong>歧义（Ambiguity）问题</strong>：由于VIVT使用虚拟地址作为索引（index）和标签（tag），不同进程的相同虚拟地址可能映射到不同的物理地址。这会导致缓存中出现同名异物的情况，即不同的数据在缓存中具有相同的tag和index，从而无法正确区分。</li><li><strong>别名（Alias）问题</strong>：当多个虚拟地址映射到同一个物理地址时，可能会导致缓存中出现多个副本，这称为别名问题。</li><li><strong>性能问题</strong>：为了解决歧义和别名问题，操作系统需要在进程切换时清空缓存（flush cache），这会导致大量的缓存未命中（cache miss），从而降低系统性能。</li></ol><p>为了克服这些缺点，操作系统需要采取以下措施：</p><ol><li><strong>进程切换时清空缓存</strong>：在进程切换时，操作系统需要执行flush操作，包括将缓存中的数据写回主存储器（clean）和使缓存无效（invalidate），以避免新进程误命中上一个进程的缓存数据。</li><li><strong>避免共享映射中的别名问题</strong>：在建立共享映射时，操作系统需要确保返回的虚拟地址按照缓存大小对齐，从而避免多个虚拟地址映射到同一个物理地址。</li><li><strong>优化缓存更新策略</strong>：对于写回（write-back）缓存，操作系统需要确保在清空缓存时将已修改的数据写回主存储器，以避免数据丢失。</li></ol><h1>12．虚拟索引物理标签（Virtual Index Physical Tag，VIPT）类型的高速缓存在什么情况下会出现高速缓存重名问题？</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="vipt方式">VIPT方式<a class="hash-link" href="#vipt方式" title="标题的直接链接">​</a></h2><p>处理器输出的虚拟地址会同时发送到TLB/MMU进行地址翻译，以及在高速缓存中进行索引和查询高速缓存。在TLB/MMU里，会把VPN翻译成PFN，同时用虚拟地址的索引域和偏移量来查询高速缓存。高速缓存和TLB/MMU可以同时工作，当TLB/MMU完成地址翻译后，再用物理标记域来匹配高速缓存行，如图1.11所示。采用VIPT方式的好处之一是在多任务操作系统中，修改了虚拟地址到物理地址映射关系，不需要对相应的高速缓存进行无效操作。</p><p><img loading="lazy" alt="1742136776235" src="/assets/images/1742136776235-5ad8ad1edaf2b099c643c4a5b47461e0.png" width="1371" height="984" class="img_ev3q"></p><p>​														▲图1.11　VIPT的高速缓存工作方式</p><p>采用VIPT方式也可能导致高速缓存重名问题。在VIPT中，若使用虚拟地址的索引域来查找高速缓存组，可能导致多个高速缓存组映射到同一个物理地址。以Linux 内核为例，它是以4KB为一个页面大小进行管理的，那么对于一个页面来说，虚拟地址和物理地址的低12位（Bit <!-- -->[11:0]<!-- -->）是一样的。因此，不同的虚拟地址会映射到同一个物理地址，这些虚拟页面的低12位是一样的。</p><p>如果索引域位于Bit<!-- -->[11:0]<!-- -->，就不会发生高速缓存重名问题，因为该范围相当于一个页面内的地址。那什么情况下索引域会在Bit<!-- -->[11:0]<!-- -->内呢？索引域是用于在一个高速缓存的路中查找高速缓存行的，当一个高速缓存路的大小在4KB范围内，索引域必然在Bit<!-- -->[11:0]<!-- -->范围内。例如，如果高速缓存行大小是32字节，那么偏移量域占5位，有128个高速缓存组，索引域占7位，这种情况下刚好不会发生重名。</p><p>如图1.12所示，假设高速缓存的路大小是8KB，并且两个虚拟页面Page1和Page2同时映射到同一个物理页面，我们研究其中的虚拟地址VA1和VA2，这两个虚拟地址的第12位可能是0，也可能是1。当VA1的第12位为0、VA2的第12位为1时，在高速缓存中会在两个不同的地方存储了同一个PA的值，这样就导致了重名问题。当修改虚拟地址VA1的内容后，访问虚拟地址VA2会得到一个旧值，导致错误发生。</p><p>Cortex-A系列处理器的数据高速缓存开始采用PIPT方式。对于PIPT方式，索引域和标记域都采用物理地址，高速缓存中只有一个高速缓存组与之对应，不会产生高速缓存重名问题。PIPT方式在芯片设计里的逻辑比VIPT要复杂得多。</p><h1>13．请画出在二级页表架构中虚拟地址到物理地址查询页表的过程。</h1><p>二级页表的查询过程。VA<!-- -->[31:20]<!-- -->用作一级页表的索引值，一共有12位，最多可以索引4096个页表项；VA<!-- -->[19:12]<!-- -->用作二级页表的索引值，一共有8位，最多可以索引256个页表项。当操作系统复制一个新进程时，首先会创建一级页表，分配16KB页面。本场景中，一级页表有4096个页表项，每个页表项占4字节，因此一级页表大小是16KB。当操作系统准备让该进程执行时，设置一级页表在物理内存中的起始地址到页表基地址寄存器中。进程执行过程中需要访问物理内存，因为一级页表的页表项是空的，这会触发缺页异常。在缺页异常里分配一个二级页表，并且把二级页表的起始地址填充到一级页表的相应页表项中。接着，分配一个物理页面，并把这个物理页面的帧号填充到二级页表的对应页表项中，从而完成页表的填充。随着进程的执行，它需要访问越来越多的物理内存，操作系统会逐步地把页表填充和建立起来。</p><p><img loading="lazy" alt="1742137183208" src="/assets/images/1742137183208-61f4fc146a255a1d974c61b1c57f1b39.png" width="1318" height="1054" class="img_ev3q"></p><p>​														图1.15　ARMv7-A架构二级页表的查询过程</p><p>当TLB未命中时，处理器的MMU查询页表的过程如下。</p><p>处理器根据页表基地址控制寄存器（TTBCR）和虚拟地址来判断使用哪个页表基地址寄存器，是TTBR0还是TTBR1。页表基地址寄存器中存放着一级页表的基地址。</p><p>处理器以VA<!-- -->[31:20]<!-- -->作为索引值，在一级页表中找到页表项，一级页表中一共有4096个页表项。一级页表的表项中存放二级页表的物理基地址。处理器使用VA<!-- -->[19:12]<!-- -->作为索引值，在二级页表中找到相应的页表项，二级页表中有256个页表项。</p><p>二级页表的页表项里存放4KB页的物理基地址，这样，处理器就完成了页表的查询和翻译工作。</p><p>图1.16所示的4KB映射的一级页表的项中，Bit<!-- -->[1:0]<!-- -->表示页表映射的项，Bit<!-- -->[31:10]<!-- -->指向二级页表的物理基地址。</p><p><img loading="lazy" alt="1742137254681" src="/assets/images/1742137254681-48622467d07d5c436b54be009f18f616.png" width="1264" height="124" class="img_ev3q"></p><p>​																▲图1.16　4KB映射的一级页表的项</p><p>图1.17所示的4KB映射的二级页表的项中，Bit<!-- -->[31:12]<!-- -->指向4KB大小的页面的物理基地址。</p><p><img loading="lazy" alt="1742137294241" src="/assets/images/1742137294241-95fca89725327992bcf3b89960fe2002.png" width="1263" height="124" class="img_ev3q"></p><p>​																	▲图1.17　4KB映射的二级页表的项</p><h1>14．在多核处理器中，高速缓存的一致性是如何实现的？请简述MESI协议的含义。</h1><h1>15．高速缓存在Linux内核中有哪些应用？</h1><h1>16．请简述ARM big.LITTLE架构，包括总线连接和高速缓存管理等。</h1><h1>17．高速缓存一致性（cache coherency）和一致性内存模型（memory consistency）有什么区别？</h1><h1>18．请简述高速缓存的回写策略。</h1><h1>19．请简述高速缓存行的替换策略。</h1><h1>20．多进程间频繁切换对转换旁视缓冲（Translation Look-aside Buffer，TLB）有什么影响？现代的处理器是如何解决这个问题的？</h1><h1>21．请简述NUMA架构的特点。</h1><h1>22．ARM从Cortex系列开始性能有了质的飞跃，如Cortex-A8/A15/A53/A72，请指出Cortex系列在芯片设计方面的重大改进。</h1><h1>23．若对非对齐的内存进行读写，处理器会如何操作？</h1><h1>24．若两个不同进程都能让处理器的使用率达到100%，它们对处理器的功耗影响是否一样？</h1><h1>25．为什么页表存放在主内存中而不是存放在芯片内部的寄存器中？</h1><h1>26．为什么页表要设计成多级页表？直接使用一级页表是否可行？多级页表又引入了什么问题？</h1><h1>27．内存管理单元（Memory Management Unit，MMU）查询页表的目的是找到虚拟地址对应的物理地址，页表项中有指向下一级页表基地址的指针，那它指向的是下一级页表基地址的物理地址还是虚拟地址？</h1><h1>28．假设系统中有4个CPU，每个CPU都有各自的一级高速缓存，处理器内部实现的是MESI协议，它们都想访问相同地址的数据A，大小为64字节，这4个CPU的高速缓存在初始状态下都没有缓存数据A。在T0时刻，CPU0访问数据A。在T1时刻，CPU1访问数据A。在T2时刻，CPU2访问数据A。在T3时刻，CPU3想更新数据A的内容。请依次说明，T0～T3时刻，4个CPU中高速缓存行的变化情况。</h1><h1>29．什么是高速缓存伪共享？请阐述高速缓存伪共享发生时高速缓存行状态变化情况，以及软件应该如何避免高速缓存伪共享。</h1><h1>30．CPU和高速缓存之间，高速缓存和主存之间，主存和辅存之间数据交换的单位分别是什么？</h1><h1>31．操作系统选择大粒度的页面有什么好处？选择小粒度页面有什么好处？</h1><h1>32．引入分页机制的虚拟内存是为了解决什么问题？</h1><h1>33．缺页异常相比一般的中断存在哪些区别？</h1><h1>34．高速缓存设计中，如何实现更高的性能？</h1></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/shaozongfan/shaozongfan.github.io/docs/奔跑吧linux/基础架构/1、处理器架构面试题.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/奔跑吧linux/arm64体系结构编程与实践/高级缓存基础面试题"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">1．为什么需要高速缓存？</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/奔跑吧linux/基础架构/2、ARM64在linux内核中的实现面试题"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">1．ARM64处理器中有两个页表基地址寄存器TTBR0和TTBR1，处理器如何使用它们？</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#71-直接映射当每组只有一个高速缓存行时高速缓存称为直接映射高速缓存" class="table-of-contents__link toc-highlight">7.1 直接映射当每组只有一个高速缓存行时，高速缓存称为直接映射高速缓存。</a></li><li><a href="#72组相联" class="table-of-contents__link toc-highlight">7.2．组相联</a><ul><li><a href="#组相联的高速缓存" class="table-of-contents__link toc-highlight">组相联的高速缓存</a></li><li><a href="#pipt和vivt的区别" class="table-of-contents__link toc-highlight">PIPT和VIVT的区别</a></li></ul></li><li><a href="#重名aliasing问题3" class="table-of-contents__link toc-highlight">重名（aliasing）问题3。</a></li><li><a href="#同名homonyms问题" class="table-of-contents__link toc-highlight">同名（homonyms）问题。</a></li><li><a href="#综上所述" class="table-of-contents__link toc-highlight">综上所述，</a><ul><li><a href="#1-避免歧义和别名问题" class="table-of-contents__link toc-highlight">1. <strong>避免歧义和别名问题</strong></a></li><li><a href="#2-减少操作系统维护开销" class="table-of-contents__link toc-highlight">2. <strong>减少操作系统维护开销</strong></a></li><li><a href="#3-提高缓存一致性" class="table-of-contents__link toc-highlight">3. <strong>提高缓存一致性</strong></a></li><li><a href="#4-硬件设计和性能" class="table-of-contents__link toc-highlight">4. <strong>硬件设计和性能</strong></a></li><li><a href="#5-适用场景" class="table-of-contents__link toc-highlight">5. <strong>适用场景</strong></a></li></ul></li><li><a href="#vipt方式" class="table-of-contents__link toc-highlight">VIPT方式</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1c06d183.js"></script>
<script src="/assets/js/main.63ebc7ad.js"></script>
</body>
</html>