<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">第1章　处理器架构 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="第1章　处理器架构 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="本章的高频面试题"><meta data-rh="true" property="og:description" content="本章的高频面试题"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ccca8cd0.css">
<link rel="preload" href="/assets/js/runtime~main.1c06d183.js" as="script">
<link rel="preload" href="/assets/js/main.63ebc7ad.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/AI相关/AI核心技能">AI相关</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">docs/intro.md</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/linux设备驱动开发详解/1.1　设备驱动的作用">linux设备驱动开发详解</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人博客/docusaurus2.4">个人博客</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人生活/2025国家生育政策8大补贴汇总">个人生活</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/人生哲学/人生的底层逻辑">人生哲学</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs">笔记本开篇序言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/奔跑吧linux/arm64体系结构编程与实践/A64指令集其他重要指令面试题">奔跑吧linux</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">奔跑吧linux内核（第2版）卷1：基础架构</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">第1章　处理器架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现">第2章  ARM64在linux内核中的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第4章　物理内存与虚拟内存">第4章　物理内存与虚拟内存</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/网络/网络问题">网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/调试/Linux内核追踪神器：perf实现原理剖析">调试</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">奔跑吧linux内核（第2版）卷1：基础架构</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">第1章　处理器架构</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>第1章　处理器架构</h1></header><p>本章的高频面试题</p><p>1．请简述精简指令集RISC和复杂指令集CISC的区别。</p><p>通常，大部分简单指令能在一个周期内完成，符合这种情况的指令集叫作精简指令集计算机（Reduced Instruction Set Computer，RISC）指令集，以前的指令集叫作复杂指令集计算机（Complex Instruction Set Computer，CISC）指令集。</p><p>2．请简述数值0x1234 5678在大小端字节序处理器的存储器中的存储方式。</p><p>在大端模式下，应该这样读取0x1234 5678</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0000430: 1234 5678 0000 0000 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000440: 0000 0000 0000 0000 0000 0000 0100 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在小端模式下，应该这样读取0x1234 5678。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0000430: 7856 3412 0000 0000 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000440: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>3．请简述在你所熟悉的处理器（如双核Cortex-A9）中一条存储读写指令的执行全过程。</p><p>一条存储-读-写指令的执行全过程很难用一句话来描述。在一个支持超标量和乱序执行技术的处理器当中，把一条存储-读-写指令的执行过程分解为若干步骤。指令首先进入流水线（pipeline）的前端（front-end），包括预取（fetch）和译码（decode），经过分发（dispatch）和调度（schedule）后进入执行单元，最后提交执行结果。所有的指令采用顺序方式通过前端，并采用乱序的方式进行发射，然后乱序执行，最后用顺序方式提交执行结果，并将最终结果更新到加载-存储队列（Load-Store Queue，LSQ）单元。LSQ单元是指令流水线的一个执行部件，可以理解为存储子系统的最高层，它接收来自CPU的存储器指令，并连接着存储器子系统。其主要功能是将来自CPU的存储器请求发送到存储器子系统，并处理其下存储器子系统的应答数据和消息。</p><p>4．请简述内存屏障（memory barrier）产生的原因。</p><p>若程序在执行时的实际内存访问顺序和程序代码编写的访问顺序不一致，会导致内存乱序访问。内存乱序访问的出现是为了提高程序执行时的效率。内存乱序访问主要发生在如下两个阶段。</p><p>（1）编译时，编译器优化导致内存乱序访问。</p><p>（2）执行时，多个CPU间交互引起的内存乱序访问。</p><p>编译器会把符合人类思维逻辑的代码（如C语言的代码）翻译成符合CPU运算规则的汇编指令，编译器了解底层CPU的思维逻辑，因此它会在翻译汇编指令时对其进行优化。如内存访问指令的重新排序可以提高指令级并行效率。然而，这些优化可能会与程序员原始的代码逻辑不符，导致一些错误发生。</p><p>5．ARM有几条内存屏障指令？它们之间有什么区别？</p><p>ARM64处理器把内存屏障指令细分为数据存储屏障指令、数据同步屏障指令以及指令同步屏障指令。</p><p>6．请简述高速缓存（cache）的工作方式。</p><p><img loading="lazy" alt="1747925453203" src="/assets/images/1747925453203-2c271cb7fddc9efd64d3027f0fa431cb.png" width="1459" height="1063" class="img_ev3q"></p><p>处理器在访问存储器时，会把虚拟地址同时传递给TLB和高速缓存。TLB是一个用于存储虚拟地址到物理地址转换的小缓存，处理器先使用有效页帧号（Effective Page Number，EPN）在TLB中查找最终的实际页帧号（Real Page Number，RPN）。如果其间发生TLB未命中（TLB miss），将会带来一系列严重的系统惩罚，处理器需要查询页表。假设发生TLB命中（TLB hit），就会很快获得合适的RPN，并得到相应的物理地址（Physical Address，PA）。</p><p>同时，处理器通过高速缓存编码地址的索引（index）域可以很快找到相应的高速缓存行对应的组。但是这里的高速缓存行的数据不一定是处理器所需要的，因此有必要进行一些检查，将高速缓存行中存放的标记域和通过MMU转换得到的物理地址的标记域进行比较。如果相同并且状态位匹配，就会发生高速缓存命中（cache hit），处理器通过字节选择与对齐（byte select and align）部件，就可以获取所需要的数据。如果发生高速缓存未命中（cache miss），处理器需要用物理地址进一步访问主存储器来获得最终数据，数据也会填充到相应的高速缓存行中。上述为VIPT类型的高速缓存组织方式</p><p>7．高速缓存的映射方式有全关联（full-associative）、直接映射（direct-mapping）和组相联（set-associative）3种方式，请简述它们之间的区别。为什么现代的处理器都使用组相联的高速缓存映射方式？</p><p>直接映射：当每组只有一个高速缓存行时，高速缓存称为直接映射高速缓存。</p><p>组相联：以一个2路组相联的高速缓存为例，每一路包括4个高速缓存行，因此每个组有两个高速缓存行，可以提供高速缓存行替换。</p><p>8．在一个32KB的4路组相联的高速缓存中，其中高速缓存行为32字节，请画出这个高速缓存的高速缓存行（line）、路（way）和组（set）的示意图。</p><p>高速缓存的总大小为32KB，并且是4路的，所以每一路的大小为8KB。</p><p>way_size = 32KB/ 4 = 8KB</p><p>高速缓存行的大小为32字节，所以每一路包含的高速缓存行数量如下。</p><p>num_cache_line = 8KB/32B = 256</p><p>所以在高速缓存编码的地址中，Bit<!-- -->[4:0]<!-- -->用于选择高速缓存行中的数据，其中Bit<!-- -->[4:2]<!-- -->可以用于寻址8个字，Bit<!-- -->[1:0]<!-- -->可以用于寻址每个字中的字节。Bit<!-- -->[12:5]<!-- -->用于在索引域中选择每一路上的高速缓存行，Bit<!-- -->[31:13]<!-- -->用作标记域，如图1.7所示。这里，V表示有效位，D表示脏位。</p><p><img loading="lazy" alt="1748270532531" src="/assets/images/1748270532531-2f4769f3c10c82898e845432f62dccf9.png" width="1446" height="999" class="img_ev3q"></p><p>9．高速缓存重名问题和同名问题是什么？</p><p>重名问题是多个虚拟地址映射到同一个物理地址引发的问题，</p><p>而同名问题是一个虚拟地址可能出于进程切换等原因映射到不同的物理地址而引发的问题。</p><p>10．ARM9处理器的数据高速缓存组织方式使用虚拟索引虚拟标签（Virtual Index Virtual Tag，VIVT）方式，而在Cortex-A7处理器中使用物理索引物理标签（Physical Index Physical Tag，PIPT），请简述PIPT与VIVT相比的优势。</p><p>PIPT避免了重名问题和同名问题</p><p>11．VIVT类型的高速缓存有什么缺点？请简述操作系统需要做什么事情来克服这些缺点。</p><p>采用VIVT的方式，不用经过MMU的翻译，直接使用虚拟地址的索引域和标记域来查找高速缓存行，这种方式会导致高速缓存重名问题。例如，一个物理地址的内容可以出现在多个高速缓存行中，当系统改变了虚拟地址到物理地址的映射时，需要清洗（clean）这些高速缓存并使它们无效，这会导致系统性能降低。</p><p>12．虚拟索引物理标签（Virtual Index Physical Tag，VIPT）类型的高速缓存在什么情况下会出现高速缓存重名问题？</p><p>如图所示，假设高速缓存的路大小是8KB，并且两个虚拟页面Page1和Page2同时映射到同一个物理页面，我们研究其中的虚拟地址VA1和VA2，这两个虚拟地址的第12位可能是0，也可能是1。当VA1的第12位为0、VA2的第12位为1时，在高速缓存中会在两个不同的地方存储了同一个PA的值，这样就导致了重名问题。当修改虚拟地址VA1的内容后，访问虚拟地址VA2会得到一个旧值，导致错误发生。</p><p><img loading="lazy" alt="1748355586283" src="/assets/images/1748355586283-89ba2e1e5d20b7abc39ba917241cfa85.png" width="1657" height="1249" class="img_ev3q"></p><p>假如高速缓存的路大小是4KB，则索引高速缓存行用的地址共12位，即此时linux内核以4KB一个页面大小进行管理时，此时不会存在高速缓存重名的问题。</p><p>13．请画出在二级页表架构中虚拟地址到物理地址查询页表的过程。</p><p><img loading="lazy" alt="1748356406054" src="/assets/images/1748356406054-dc2c31aa9151c0d35fc68b225d72602c.png" width="1315" height="1047" class="img_ev3q"></p><p>14．在多核处理器中，高速缓存的一致性是如何实现的？请简述MESI协议的含义。</p><p>高速缓存一致性协议主要有两大类别：一类是监听协议（snooping protocol），每个高速缓存都要被监听或者监听其他高速缓存的总线活动；另一类是目录协议（directory protocol），用于全局统一管理高速缓存状态。</p><p>MESI协议的名字源于该协议使用的修改（Modified，M）、独占（Exclusive，E）、共享（Shared，S）和失效（Invalid，I）这四个状态。</p><p>15．高速缓存在Linux内核中有哪些应用？</p><p><img loading="lazy" alt="1749564071976" src="/assets/images/1749564071976-ccf3644f0b7348898ac9cb917ffa2aaa.png" width="969" height="528" class="img_ev3q"></p><p><img loading="lazy" alt="1749564110385" src="/assets/images/1749564110385-826c95b48abdc7edd61ce6189268667f.png" width="967" height="352" class="img_ev3q"></p><p>16．请简述ARM big.LITTLE架构，包括总线连接和高速缓存管理等。</p><p>针对性能优化过的处理器内核称为大核，针对低功耗待机优化过的处理器内核称为小核。</p><p><img loading="lazy" alt="1749564429306" src="/assets/images/1749564429306-8e2e5daf7058fc8464d84afec428708d.png" width="1342" height="601" class="img_ev3q"></p><p><img loading="lazy" alt="1749564462634" src="/assets/images/1749564462634-fd73666e7e7555748b2e391d613da420.png" width="967" height="427" class="img_ev3q"></p><p>17．高速缓存一致性（cache coherency）和一致性内存模型（memory consistency）有什么区别？</p><p><img loading="lazy" alt="1749564919282" src="/assets/images/1749564919282-20a4e33a2b15c4fcadf8fbfea696db6a.png" width="967" height="321" class="img_ev3q"></p><p>18．请简述高速缓存的回写策略。</p><p><img loading="lazy" alt="1749565457606" src="/assets/images/1749565457606-8d9bd35241fe241b8d41cacfb5ebdb22.png" width="970" height="382" class="img_ev3q"></p><p>19．请简述高速缓存行的替换策略。</p><p><img loading="lazy" alt="1749565786244" src="/assets/images/1749565786244-49e00875dd38b1f5f9c461222dba6551.png" width="967" height="396" class="img_ev3q"></p><p><img loading="lazy" alt="1749566145864" src="/assets/images/1749566145864-ad040a7efb465514657de0574cc06a4d.png" width="964" height="160" class="img_ev3q"></p><p>20．多进程间频繁切换对转换旁视缓冲（Translation Look-aside Buffer，TLB）有什么影响？现代的处理器是如何解决这个问题的？</p><p>发生TLB未命中（TLB miss），将会带来一系列严重的系统惩罚，处理器需要查询页表。</p><p>21．请简述NUMA架构的特点。</p><p><img loading="lazy" alt="1749566731833" src="/assets/images/1749566731833-c278c2d9dea2d8e67fc00f29429bd9f8.png" width="969" height="334" class="img_ev3q"></p><p><img loading="lazy" alt="1749566754778" src="/assets/images/1749566754778-d07dec41f856992518146a5b1082a99a.png" width="1062" height="277" class="img_ev3q"></p><p>22．ARM从Cortex系列开始性能有了质的飞跃，如Cortex-A8/A15/A53/A72，请指出Cortex系列在芯片设计方面的重大改进。</p><p><img loading="lazy" alt="1749566823319" src="/assets/images/1749566823319-9a3baadf0927277ff5e4fdbec5bbe272.png" width="976" height="1639" class="img_ev3q"></p><p>23．若对非对齐的内存进行读写，处理器会如何操作？</p><p><img loading="lazy" alt="1749566896283" src="/assets/images/1749566896283-5e85bf56c556b3395487f4ffbfa8b6e7.png" width="973" height="1005" class="img_ev3q"></p><p>24．若两个不同进程都能让处理器的使用率达到100%，它们对处理器的功耗影响是否一样？</p><p>不相同，有CPU消耗型进程，有IO消耗型进程，CPU消耗型功耗大于IO消耗型</p><p>25．为什么页表存放在主内存中而不是存放在芯片内部的寄存器中？</p><p>因为页表占用的空间较大，如果放在芯片内部会使芯片设计的难度大好多倍</p><p>26．为什么页表要设计成多级页表？直接使用一级页表是否可行？多级页表又引入了什么问题？</p><p>因为可以节省内存空间， 直接使用一级页表占用大量内存，多级页表引入了地址转换富在和内存碎片的风险</p><p>27．内存管理单元（Memory Management Unit，MMU）查询页表的目的是找到虚拟地址对应的物理地址，页表项中有指向下一级页表基地址的指针，那它指向的是下一级页表基地址的物理地址还是虚拟地址？</p><p>物理地址，如果使虚拟地址会陷入死循环</p><p>28．假设系统中有4个CPU，每个CPU都有各自的一级高速缓存，处理器内部实现的是MESI协议，它们都想访问相同地址的数据A，大小为64字节，这4个CPU的高速缓存在初始状态下都没有缓存数据A。在T0时刻，CPU0访问数据A。在T1时刻，CPU1访问数据A。在T2时刻，CPU2访问数据A。在T3时刻，CPU3想更新数据A的内容。请依次说明，T0～T3时刻，4个CPU中高速缓存行的变化情况。</p><p><img loading="lazy" alt="1750172156587" src="/assets/images/1750172156587-f27b22fa190c9e19f15c6575366660f9.png" width="967" height="1618" class="img_ev3q"></p><p>29．什么是高速缓存伪共享？请阐述高速缓存伪共享发生时高速缓存行状态变化情况，以及软件应该如何避免高速缓存伪共享。</p><p><img loading="lazy" alt="1750172128804" src="/assets/images/1750172128804-b67ae89050e60de66dcb700264582012.png" width="978" height="384" class="img_ev3q"></p><p>30．CPU和高速缓存之间，高速缓存和主存之间，主存和辅存之间数据交换的单位分别是什么？</p><p>CPU和高速缓存之间数据交换单位是cache line，</p><p>高速缓存和主存之间数据交换单位是cache line，</p><p>主存和辅存之间数据交换单位是块（4KB、8KB、、、），</p><p>31．操作系统选择大粒度的页面有什么好处？选择小粒度页面有什么好处？</p><p>大粒度可以减少tlb miss，小粒度可以减少内存碎片</p><p>32．引入分页机制的虚拟内存是为了解决什么问题？</p><p>内存空间的限制</p><p>内存碎片问题</p><p>内存保护问题</p><p>33．缺页异常相比一般的中断存在哪些区别？</p><p>触发原因不一样，处理机制不一样，优先级不一样</p><p>34．高速缓存设计中，如何实现更高的性能？</p><p>提高缓存命中率，减少命中时间，降低失效代价，合理设计缓存容量和替换策略</p><p>Linux 5.x内核已经支持几十种处理器（CPU）架构，目前市面上较流行的两种架构是x86_64和ARM64。x86_64架构主要用于PC和服务器，ARM64架构主要用于移动设备等。本书重点讲述Linux内核的设计与实现，离开了处理器体系结构，操作系统就犹如空中楼阁。目前大部分的Linux内核图书是基于x86架构讲解的，但是国内还是有相当多的开发者采用ARM处理器来进行手机、物联网（Internet of Things，IoT）设备、嵌入式设备等产品的开发。因此本书基于x86_64和ARM64架构来讲述Linux内核的设计与实现。</p><p>关于x86_64架构，请参考Intel公司的官方文档“Intel 64 and IA-32 Architectures Software Developer’s Manual”。</p><p>关于ARM架构，ARM公司的官方文档已经有很多详细资料，其中描述ARMv8-A架构的官方文档有“ARM Architecture Reference Manual, ARMv8, for ARMv8-A architecture profile, v8.4”。另外，《ARM Cortex-A Series Programmer’s Guide for ARMv8-A, version 1.0》讲述了ARM Cortex处理器的编程技巧。</p><p>读者可以从Intel官网和ARM官网中下载上述资料。本书的重点是Linux内核本身，不会用过多的篇幅来介绍x86_64和ARM64架构的细节。</p><p>可能有些读者对ARM处理器的命名感到疑惑。ARM公司除了提供处理器IP和配套工具以外，还定义了一系列的ARM兼容指令集来构建整个ARM的软件生态系统。从ARMv4指令集开始被人熟知，兼容ARMv4指令集的处理器架构有ARM7-TDMI，典型处理器是三星的S3C44B0X。兼容ARMv4T指令集的处理器架构有ARM920T，典型处理器是三星的S3C2440，有些读者还买过基于S3C2440的开发板。兼容ARMv5指令集的处理器架构有ARM926EJ-S，典型处理器有NXP的i.MX2 Series。兼容ARMv6指令集的处理器架构有ARM11 MPCore。而ARMv7指令集对应的处理器系列以Cortex命名，又分成A、R和M系列，通常A系列针对大型嵌入式系统（如手机），R系列针对实时性系统，M系列针对单片机市场。Cortex-A系列处理器上市后，由于处理性能的大幅提高和较好的功耗控制，使得手机和平板电脑市场迅猛发展。另外，一些新的应用需求正在“酝酿”，如大内存、虚拟化、安全特性（Trustzone<!-- -->[1]<!-- -->），以及更高的能效比（大小核）等。虚拟化和安全特性在ARMv7架构中已经实现，但是对大内存的支持显得有点“捉襟见肘”，虽然可以通过大物理地址扩展（Large Physical Address Extensions，LPAE）技术支持40位的物理地址空间，但是由于32位的处理器最多支持4GB的虚拟地址空间，因此不适合虚拟内存需求巨大的应用。于是ARM公司设计了一套全新的指令集，即ARMv8-A指令集，它可支持64位指令集，并且向前兼容ARMv7-A指令集。因此定义AArch64和AArch32两套执行环境分别来执行64位和32位指令集，软件可以动态切换执行环境。为了行文方便，在本书中AArch64也称为ARM64，AArch32也称为ARM32。</p><h1>1.1　处理器架构介绍</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="111精简指令集和复杂指令集">1.1.1　精简指令集和复杂指令集<a class="hash-link" href="#111精简指令集和复杂指令集" title="标题的直接链接">​</a></h2><p>20世纪70年代，IBM的John Cocke研究发现，处理器提供的大量指令集和复杂寻址方式并不会被编译器生成的代码用到：20%的简单指令经常被用到，占程序总指令数的80%；而指令集里其余80%的复杂指令很少被用到，只占程序总指令数的20%。基于这种情况，他将指令集和处理器重新进行了设计，在新的设计中只保留了常用的简单指令，这样处理器不需要浪费太多的晶体管去完成那些很复杂又很少使用的复杂指令。通常，大部分简单指令能在一个周期内完成，符合这种情况的指令集叫作精简指令集计算机（Reduced Instruction Set Computer，RISC）指令集，以前的指令集叫作复杂指令集计算机（Complex Instruction Set Computer，CISC）指令集。</p><p>IBM、加州大学伯克利分校的David Patterson以及斯坦福大学的John Hennessy是研究RISC的先驱。Power处理器来自IBM，ARM/SPARC处理器受到加州大学伯克利分校的RISC的影响，MIPS来自斯坦福大学。当前还在使用的最出名的CISC指令集是Intel/AMD的x86指令集。</p><p>RISC处理器通过更合理的微架构在性能上超越了当时传统的CISC处理器。在最初的较量中，Intel处理器败下阵来，服务器处理器的市场大部分被RISC阵营占据。Intel的David Papworth和他的同事一起设计了Pentium Pro处理器，x86指令集被译码成类似于RISC指令的微操作（micro-operations，μops）指令，以后的执行过程采用RISC内核的方式。CISC这个“古老”的架构通过巧妙的设计，又一次焕发生机，Intel的x86处理器的性能逐渐超过同期的RISC处理器。</p><p>RISC和CISC都是时代的产物，RISC在思想上更先进。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="112大小端字节序">1.1.2　大/小端字节序<a class="hash-link" href="#112大小端字节序" title="标题的直接链接">​</a></h2><p>计算机操作系统是以字节为单位存储信息的，每个地址单元都对应1字节，1字节为8位。但在32位处理器中，C语言中除了8位的char类型之外，还有16位的short类型、32位的int类型。另外，对于16位、32位等位数更高的处理器，由于寄存器宽度大于1字节，必然存在如何安排多字节的问题，因此导致了大端存储模式（big-endian）和小端存储模式（little-endian）的产生。如一个16位的short类型变量X在内存中的地址为0x0010，X的值为0x1122，其中，0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，将0x22放在高地址中。小端模式则刚好相反。很多的ARM处理器默认使用小端模式，有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。Cortex-A系列的处理器可以通过软件来配置大/小端模式。大/小端模式在处理器访问内存时用于描述寄存器的字节顺序和内存中的字节顺序之间的关系。</p><p>大端模式指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。</p><p>在大端模式下，应该这样读取0x1234 5678。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0000430: 1234 5678 0000 0000 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000440: 0000 0000 0000 0000 0000 0000 0100 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因此，大端模式下地址的增长顺序与值的增长顺序相同。</p><p>小端模式指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。</p><p>在小端模式下，应该这样读取0x1234 5678。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">0000430: 7856 3412 0000 0000 0000 0000 0000 0000</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000440: 0000 0000 0000 0000 0000 0000 0000 0000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因此，小端模式下地址的增长顺序与值的增长顺序相反。</p><p>从上面大/小端模式的内存视图可知，同样是读取0x1234 5678，但是该值在内存中的布局不一样。</p><p>如何判断处理器是大端模式还是小端模式？联合体（union）的存放顺序是所有成员都从低地址开始存放，利用该特性可以轻松判断CPU对内存采用大端模式还是小端模式读写。</p><p>如果以下代码的输出结果是true，则为小端模式；否则，为大端模式。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int checkCPU(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{ </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    union w </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int  a; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        char b; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } c; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    c.a = 1; </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (c.b == 1); </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="113一条存储读写指令的执行全过程">1.1.3　一条存储读写指令的执行全过程<a class="hash-link" href="#113一条存储读写指令的执行全过程" title="标题的直接链接">​</a></h2><p>经典处理器架构的流水线是5级流水线，分别是取指、译码、执行、数据内存访问和写回。</p><p>现代处理器在设计上都采用了超标量架构（superscalar architecture）和乱序（Out-of-Order，OoO）执行技术，极大地提高了处理器计算能力。超标量技术能够在一个时钟周期内执行多条指令，实现指令级的并行，有效提高指令级的并行效率（Instruction Level Parallelism，ILP），同时增加整个高速缓存和内存层次结构的实现难度。</p><p>一条存储-读-写指令的执行全过程很难用一句话来描述。在一个支持超标量和乱序执行技术的处理器当中，把一条存储-读-写指令的执行过程分解为若干步骤。指令首先进入流水线（pipeline）的前端（front-end），包括预取（fetch）和译码（decode），经过分发（dispatch）和调度（schedule）后进入执行单元，最后提交执行结果。所有的指令采用顺序方式通过前端，并采用乱序的方式进行发射，然后乱序执行，最后用顺序方式提交执行结果，并将最终结果更新到加载-存储队列（Load-Store Queue，LSQ）单元。LSQ单元是指令流水线的一个执行部件，可以理解为存储子系统的最高层，它接收来自CPU的存储器指令，并连接着存储器子系统。其主要功能是将来自CPU的存储器请求发送到存储器子系统，并处理其下存储器子系统的应答数据和消息。</p><p>很多程序员对乱序执行的理解有误差。对于一串给定的指令序列，为了提高效率，处理器会找出非真正数据依赖和地址依赖的指令，让它们并行执行。但是在提交执行结果时，是按照指令次序提交的。总的来说，顺序提交指令，然后乱序执行，最后顺序提交执行结果。如果有两条没有数据依赖的数据指令，那么后面那条指令读的数据先返回，它的结果也不能先写回最终寄存器，而必须等到前一条指令完成之后才可以。</p><p>对于读指令，当处理器在等待数据从缓存或者内存返回时，它处于什么状态呢？是停顿，还是继续执行别的指令？对于乱序执行的处理器，可以执行后面的指令；对于顺序执行的处理器，会使流水线停顿，直到读取的数据返回。</p><p>如图1.1所示，在x86微处理器的经典架构中，指令预取单元会从L1指令高速缓存中加载指令，并做指令的预译码。在取指令阶段，不仅需要从指令高速缓存中取出多条指令，还需要决定下一个周期取指令的地址。当遇到条件跳转指令时，它不能确定是否需要跳转。处理器会使用分支预测单元试图猜测每条跳转指令是否会执行。当它猜测的准确率很高时，流水线充满了指令，这样可以实现高的性能。</p><p><img loading="lazy" alt="1747748767990" src="/assets/images/1747748767990-435fa10440ac2fcf37ec9c253d78a5d1.png" width="1401" height="1272" class="img_ev3q"></p><p>▲图1.1　x86微处理器的经典架构</p><p>接着，在指令译码单元，把指令译码成微操作（macro-ops）指令，并由分发部件分发到整数单元（integer unit）或者浮点数单元（float point unit）。整数单元由整数调度器、执行单元以及整数重命名单元组成。整数单元的执行单元包含算术逻辑单元（Arithmetic-Logic Unit，ALU）、地址生成单元（Address Generation Unit，AGU）、乘法单元（MUL）以及高级位运算（Advanced Bit Manipulation，ABM）单元。在ALU计算完成之后，进入AGU。计算有效地址后，将结果发送到LSQ单元。浮点数单元的执行单元包括浮点数加法（FADD）运算单元、浮点数乘法（FMUL）运算单元和浮点数存储（FSTOR）单元等。LSQ单元根据处理器系统要求的内存一致性（memory consistency）模型确定访问时序。另外，LSQ单元还需要处理存储器指令间的依赖关系。最后，LSQ单元需要准备一级缓存使用的地址，包括有效地址的计算和虚实地址转换，将地址发送到L1数据高速缓存中。如果L1数据高速缓存未命中，则访问L2高速缓存以及L3高速缓存。如果高速缓存都没有命中，则需要通过内存控制器来访问物理内存。</p><p>如图1.2所示，在Cortex-A9处理器中，存储指令首先通过主存储器或者L2高速缓存加载到L1指令高速缓存中，通过总线接口单元（BIU）中的主接口连接到主存储器。</p><p><img loading="lazy" alt="image-20250520215033679" src="/assets/images/image-20250520215033679-f9a3a73ae94768f6817201cc1c3fcf9b.png" width="1246" height="1633" class="img_ev3q"></p><p>▲图1.2　Cortex-A9处理器的内部架构<!-- -->[2]</p><p>在指令预取阶段（instruction prefetch stage），主要做指令预取和分支预测，然后指令通过指令队列和预测队列送到译码器，进行指令的译码工作。译码器（decoder）支持两路译码，可以同时译码两条指令。在寄存器重命名阶段（register rename stage）会做寄存器重命名，避免指令进行不必要的顺序化操作，提高处理器的指令级并行能力。在指令分发阶段（dispatch stage），这里支持4路猜测发射和乱序执行（Out-of-Order Multi-Issue with Speculation），因此它支持基于推测的乱序的发射功能。然后在执行单元（ALU/MUL/FPU/NEON）中乱序执行指令，最终的计算结果会在乱序写回阶段写入寄存器中。存储指令会计算有效地址并将其发送到内存系统中的加载存储单元（Load Store Unit，LSU），最终LSU会访问L1数据高速缓存。在ARM中，只有可缓存的内存地址才需要访问高速缓存。</p><p>在多处理器环境下，还需要考虑高速缓存的一致性问题。L1和L2高速缓存控制器需要保证高速缓存的一致性，在Cortex-A9中，高速缓存的一致性是由MESI协议来实现的。Cortex-A9处理器内置了一级缓存模块，由窥探控制单元（Snoop Control Unit，SCU）来实现高速缓存的一致性管理。L2高速缓存需要外接芯片（如PL310）。在最糟糕的情况下需要访问主存储器，并将数据重新传递给LSQ，完成一次存储器读写的全过程。</p><p>涉及计算机体系结构中的众多术语比较晦涩难懂，现在对部分术语做简单解释。</p><p>超标量架构：早期的单发射架构微处理器的流水线设计目标是做到平均每个时钟周期能执行一条指令，但这一目标不能满足提高处理器性能的要求。为了提高处理器的性能，处理器要具有每个时钟周期发射执行多条指令的能力。超标量体系结构可描述一种微处理器设计理念，它能够让处理器在一个时钟周期执行多条指令。乱序执行：CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元的技术，避免处理器在计算对象不可获取时等待，从而导致流水线停顿。</p><p>乱序执行：CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元的技术，避免处理器在计算对象不可获取时等待，从而导致流水线停顿。</p><p>寄存器重命名：现代处理器中的一种技术，用于避免机器指令或者微操作不必要的顺序化执行，提高处理器的指令级并行能力。它在乱序执行的流水线中有两个作用—消除指令之间的寄存器读后写相关（Write-after-Read，WAR）和写后写相关（Write-after-Write，WAW），当指令执行发生例外或者转移指令猜测错误而取消后面的指令时，可用于保证现场的精确性。当一条指令要把内容写入一个结果寄存器时不直接写入这个结果寄存器，而是先写入一个中间寄存器进行过渡，当这条指令提交时再写入结果寄存器。</p><p>分支预测：当处理一条分支指令时，可能会产生跳转，从而打断流水线指令的处理，因为处理器无法确定该指令的下一条指令，直到分支指令执行完毕。流水线越长，处理器等待的时间便越长，分支预测技术就是为了解决这一问题而出现的。分支预测是处理器在程序分支指令执行前预测其结果的一种机制。在ARM中，使用全局分支预测器进行分支预测，该预测器由分支目标缓冲器（Branch Target Buffer，BTB）、全局历史缓冲器（Global History Buffer，GHB）、MicroBTB，以及返回栈缓冲器（return stack buffer）组成。</p><p>译码器：指令由操作码和地址码组成。操作码表示要执行的操作性质，即执行什么操作；地址码是操作码执行时的操作对象的地址。计算机执行一条指定的指令时，必须首先分析这条指令的操作码是什么，以决定操作的性质和方法，然后才能控制计算机其他各部件协同完成指令表达的功能，这个分析工作由译码器来完成。Cortex-A57可以支持3路译码器，即同时对3条指令译码，而Cortex-A9处理器只能同时对两条指令译码。</p><p>调度器：负责把指令或微操作指令分发到相应的执行单元执行，例如，Cortex-A9处理器的调度器单元通过4个接口和执行单元连接，因此每个时钟周期可以同时分发4条指令。</p><p>ALU：处理器的执行单元，主要包括进行算术运算、逻辑运算和关系运算的部件。</p><p>LSQ/LSU：指令流水线的一个执行部件，其主要功能是将来自CPU的存储器请求发送到存储器子系统，并处理其下存储器子系统的应答数据和消息。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="114内存屏障产生的原因">1.1.4　内存屏障产生的原因<a class="hash-link" href="#114内存屏障产生的原因" title="标题的直接链接">​</a></h2><p>若程序在执行时的实际内存访问顺序和程序代码编写的访问顺序不一致，会导致内存乱序访问。内存乱序访问的出现是为了提高程序执行时的效率。内存乱序访问主要发生在如下两个阶段。</p><p>（1）编译时，编译器优化导致内存乱序访问。</p><p>（2）执行时，多个CPU间交互引起的内存乱序访问。</p><p>编译器会把符合人类思维逻辑的代码（如C语言的代码）翻译成符合CPU运算规则的汇编指令，编译器了解底层CPU的思维逻辑，因此它会在翻译汇编指令时对其进行优化。如内存访问指令的重新排序可以提高指令级并行效率。然而，这些优化可能会与程序员原始的代码逻辑不符，导致一些错误发生。编译时的乱序访问可以通过barrier()函数来规避。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define barrier() __asm__ __volatile__ (&quot;&quot; ::: &quot;memory&quot;)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>barrier()函数告诉编译器，不要为了性能优化而将这些代码重排。</p><p>由于现代处理器普遍采用超标量架构、乱序发射以及乱序执行等技术来提高指令级并行效率，因此指令的执行序列在处理器流水线中可能被打乱，与程序代码编写时序列不一致。另外，现代处理器采用多级存储结构，如何保证处理器对存储子系统访问的正确性也是一大挑战。</p><p>例如，在一个系统中含有n个处理器P1～Pn，假设每个处理器包含Si个存储器操作，那么从全局来看，可能的存储器访问序列有多种组合。为了保证内存访问的一致性，需要按照某种规则来选出合适的组合，这个规则叫作内存一致性模型（memory consistency model）。这个规则需要在保证正确性的前提下，同时保证多个处理器访问时有较高的并行度。</p><p>在一个单核处理器系统中，保证访问内存的正确性比较简单。每次存储器读操作所获得的结果是最近写入的结果，但是在多个处理器并发访问存储器的情况下就很难保证其正确性了。我们很容易想到使用一个全局时间比例（global time scale）部件来决定存储器访问时序，从而判断最近访问的数据。这种访问的内存一致性模型是严格一致性（strict consistency）内存模型，称为原子一致性（atomic consistency）内存模型。实现全局时间比例部件的代价比较大，因此退而求其次。采用每一个处理器的局部时间比例（local time scale）部件来确定最新数据的内存模型称为顺序一致性（sequential consistency）内存模型。处理器一致性（processor consistency）内存模型是顺序一致性内存模型的进一步弱化，仅要求来自同一个处理器的写操作具有一致性的访问即可。</p><p>以上这些内存一致性模型是针对存储器的读写指令展开的，还有一类目前广泛使用的模型，这类模型使用内存同步指令（也称为内存屏障指令）。在这种模型下，存储器访问指令被分成数据指令和同步指令两大类，弱一致性（weak consistency）内存模型就是基于内存屏障指令的。</p><p>1986年，Dubois等发表的论文描述了弱一致性内存模型的定义，在这个定义中使用全局同步变量（global synchronizing variable）来描述一个同步访问。在一个多处理器系统中，满足如下3个条件的内存访问称为弱一致性的内存访问。</p><ul><li>所有处理器对全局同步变量的访问是顺序一致的。</li><li>在之前的全局数据（global data）访问完成之前，任何处理器不能访问全局同步变量。</li><li>在全局同步变量释放之前，任何处理器不能访问全局数据。</li></ul><p>弱一致性内存模型要求同步访问（访问全局同步变量）是顺序一致的，在一个同步访问可以执行之前，之前的所有数据访问必须完成。在一个正常的数据访问可以执行之前，所有之前的同步访问必须完成。这实质上把一致性问题留给了程序员来解决。在ARM处理器中使用内存屏障指令的方式来实现同步访问。内存屏障指令的基本原则如下。</p><ul><li>所有在内存屏障指令之前的数据访问必须在内存屏障指令之前完成。</li><li>所有在内存屏障指令后面的数据访问必须等待内存屏障指令执行完。</li><li>多条内存屏障指令是按顺序执行的。</li></ul><p>当然，处理器会根据内存屏障的作用范围进行细分，例如，ARM64处理器把内存屏障指令细分为数据存储屏障指令、数据同步屏障指令以及指令同步屏障指令。</p><p>关于内存屏障指令的例子如下。</p><p>例1-1：假设有两个CPU内核A和B，同时访问Addr1和Addr2。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Core A:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   STR R0, [Addr1]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   LDR R1, [Addr2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Core B:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   STR R2, [Addr2]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   LDR R3, [Addr1]</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面的代码片段中，没有任何的同步措施。对于Core A、寄存器R1、Core B和寄存器R3，可能得到如下4种不同的结果。</p><ul><li>A得到旧的值，B也得到旧的值。</li><li>A得到旧的值，B得到新的值。</li><li>A得到新的值，B得到旧的值。</li><li>A得到新的值，B也得到新的值。</li></ul><p>例1-2：假设Core A把新数据写入Msg地址，Core B需要判断Flag置位后才读取新数据。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">Core A:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       STR R0, [Msg] @ 写新数据到Msg地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       STR R1, [Flag] @ Flag标志表示新数据可以读</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Core B:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   Poll_loop:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       LDR R1, [Flag]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       CMP R1,#0       @ 判断Flag有没有置位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       BEQ Poll_loop</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       LDR R0, [Msg]   @ 读取新数据</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上面的代码片段中，Core B可能读不到最新的数据，Core B可能出于乱序执行的原因先读取Msg，然后读取Flag。在弱一致性内存模型中，处理器不知道Msg和Flag存在数据依赖性，所以程序员必须使用内存屏障指令来显式地告诉处理器这两个变量有数据依赖关系。Core A需要在两个存储指令之间插入DMB指令来保证两个存储指令的执行顺序。Core B需要在“LDR R0, <!-- -->[Msg]<!-- -->”之前插入DMB指令来保证直到Flag置位才读取Msg。</p><p>例1-3：在一个设备驱动中，写一个命令到一个外设寄存器中，然后等待状态的变化。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">STR R0, [Addr]        @ 写一个命令到外设寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">DSB</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Poll_loop:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    LDR R1, [Flag]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    CMP R1,#0         @ 等待状态寄存器的变化</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    BEQ Poll_loop</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在STR存储指令之后插入DSB指令，强制让写命令完成，然后执行读取Flag的判断循环。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="115高速缓存的工作方式">1.1.5　高速缓存的工作方式<a class="hash-link" href="#115高速缓存的工作方式" title="标题的直接链接">​</a></h2><p>处理器访问主存储器使用地址编码方式。高速缓存也使用类似的地址编码方式，因此处理器使用这些编码地址可以访问各级高速缓存。图1.3所示为一个经典的高速缓存架构。</p><p><img loading="lazy" alt="image-20250520221255446" src="/assets/images/image-20250520221255446-1eabdf5c240f932399fc628f1e5e0b65.png" width="1461" height="1066" class="img_ev3q"></p><p>▲图1.3　经典的高速缓存架构</p><p>处理器在访问存储器时，会把虚拟地址同时传递给TLB和高速缓存。TLB是一个用于存储虚拟地址到物理地址转换的小缓存，处理器先使用有效页帧号（Effective Page Number，EPN）在TLB中查找最终的实际页帧号（Real Page Number，RPN）。如果其间发生TLB未命中（TLB miss），将会带来一系列严重的系统惩罚，处理器需要查询页表。假设发生TLB命中（TLB hit），就会很快获得合适的RPN，并得到相应的物理地址（Physical Address，PA）。</p><p>同时，处理器通过高速缓存编码地址的索引（index）域可以很快找到相应的高速缓存行对应的组。但是这里的高速缓存行的数据不一定是处理器所需要的，因此有必要进行一些检查，将高速缓存行中存放的标记域和通过MMU转换得到的物理地址的标记域进行比较。如果相同并且状态位匹配，就会发生高速缓存命中（cache hit），处理器通过字节选择与对齐（byte select and align）部件，就可以获取所需要的数据。如果发生高速缓存未命中（cache miss），处理器需要用物理地址进一步访问主存储器来获得最终数据，数据也会填充到相应的高速缓存行中。上述为VIPT类型的高速缓存组织方式，这将在1.1.8节中详细介绍。</p><p>图1.4所示为高速缓存的基本结构。</p><p><img loading="lazy" alt="1747924577673" src="/assets/images/1747924577673-d9e6f6bf41195e43f989e3515cf055b2.png" width="1518" height="658" class="img_ev3q"></p><p>▲图1.4　高速缓存的基本结构</p><p>地址：处理器访问高速缓存时的地址编码，分成3个部分，分别是偏移量（offset）域、索引域和标记（tag）域。</p><p>高速缓存行：高速缓存中最小的访问单元，包含一小段主存储器中的数据。常见的高速缓存行大小是32字节或64字节。</p><p>索引域：高速缓存地址编码的一部分，用于索引和查找地址在高速缓存中的哪一行。</p><p>组：由相同索引域的高速缓存行组成。</p><p>路：在组相连的高速缓存中，高速缓存分成大小相同的几个块。</p><p>标记：高速缓存地址编码的一部分，通常是高速缓存地址的高位部分，用于判断高速缓存行缓存的数据的地址是否和处理器寻址地址一致。</p><p>偏移量（offset）：高速缓存行中的偏移量。处理器可以按字（word）或者字节（Byte）来寻址高速缓存行的内容。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="116高速缓存的映射方式">1.1.6　高速缓存的映射方式<a class="hash-link" href="#116高速缓存的映射方式" title="标题的直接链接">​</a></h2><p>根据每组的高速缓存行数，高速缓存可以分为不同的类。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1直接映射">1．直接映射<a class="hash-link" href="#1直接映射" title="标题的直接链接">​</a></h3><p>当每组只有一个高速缓存行时，高速缓存称为直接映射高速缓存。</p><p>下面用一个简单的高速缓存来说明。如图1.5所示，这个高速缓存只有4个高速缓存行，每行有4个字（Word），1个字是4字节，共64字节。高速缓存控制器可以使用Bit<!-- -->[3:2]<!-- -->来选择高速缓存行中的字，使用Bit<!-- -->[5:4]<!-- -->作为索引，来选择4个高速缓存行中的1个，其余的位用于存储标记值。</p><p>在这个高速缓存中查询，当索引域和标记域的值与查询的地址相等并且有效位显示这个高速缓存行包含有效数据时，则发生高速缓存命中，可以使用偏移量域来寻址高速缓存行中的数据。如果高速缓存行包含有效数据，但是标记域是其他地址的值，那么这个高速缓存行需要被替换。因此，在这个高速缓存中，主存储器中所有Bit<!-- -->[5:4]<!-- -->相同值的地址都会映射到同一个高速缓存行中，并且同一时刻只有1个高速缓存行。若高速缓存行被频繁换入、换出，会导致严重的高速缓存颠簸（cache thrashing）。</p><p><img loading="lazy" alt="1747925535234" src="/assets/images/1747925535234-ec2d35aeaf95e8b19add68e3582339b7.png" width="1123" height="1002" class="img_ev3q"></p><p>▲图1.5　直接映射的高速缓存和地址</p><p>假设在下面的代码片段中，result、data1和data2分别指向0x00、0x40和0x80地址，它们都会使用同一个高速缓存行。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void add_array(int *data1, int *data2, int *result, int size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (i=0 ; i&lt;size ; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">         result[i] = data1[i] + data2[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当第一次读data1（即0x40地址）的数据时，因为数据不在高速缓存行中，所以把从0x40到0x4F地址的数据填充到高速缓存行中。</p><p>当读data2（即0x80地址）的数据时，数据不在高速缓存行中，需要把从0x80到0x8F地址的数据填充到高速缓存行中。因为0x80和0x40地址映射到同一个高速缓存行，所以高速缓存行发生替换操作。</p><p>当把result写入0x00地址时，同样发生了高速缓存行替换操作。</p><p>因此上面的代码片段会发生严重的高速缓存颠簸，性能会很低。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2组相联">2．组相联<a class="hash-link" href="#2组相联" title="标题的直接链接">​</a></h3><p>为了解决直接映射高速缓存中的高速缓存颠簸问题，组相联的高速缓存结构在现代处理器中得到广泛应用。</p><p>如图1.6所示，以一个2路组相联的高速缓存为例，每一路包括4个高速缓存行，因此每个组有两个高速缓存行，可以提供高速缓存行替换。</p><p>地址0x00、0x40或者0x80的数据可以映射到同一个组的任意一个高速缓存行。当高速缓存行要进行替换操作时，有50%的概率可以不被替换，从而解决了高速缓存颠簸问题。</p><p><img loading="lazy" alt="1748268741003" src="/assets/images/1748268741003-d590442b1bd174cb9a8e7f662fc2ac54.png" width="1209" height="753" class="img_ev3q"></p><p>▲图1.6　2路组相联的高速缓存</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="117组相联的高速缓存">1.1.7　组相联的高速缓存<a class="hash-link" href="#117组相联的高速缓存" title="标题的直接链接">​</a></h2><p>在Cortex-A7和Cortex-A9的处理器上可以看到32KB大小的4路组相联高速缓存。下面来分析这个高速缓存的结构。</p><p>高速缓存的总大小为32KB，并且是4路的，所以每一路的大小为8KB。</p><p>way_size = 32KB/ 4 = 8KB</p><p>高速缓存行的大小为32字节，所以每一路包含的高速缓存行数量如下。</p><p>num_cache_line = 8KB/32B = 256</p><p>所以在高速缓存编码的地址中，Bit<!-- -->[4:0]<!-- -->用于选择高速缓存行中的数据，其中Bit<!-- -->[4:2]<!-- -->可以用于寻址8个字，Bit<!-- -->[1:0]<!-- -->可以用于寻址每个字中的字节。Bit<!-- -->[12:5]<!-- -->用于在索引域中选择每一路上的高速缓存行，Bit<!-- -->[31:13]<!-- -->用作标记域，如图1.7所示。这里，V表示有效位，D表示脏位。</p><p><img loading="lazy" alt="1748268969067" src="/assets/images/1748268969067-7d3b6ee09dd9fcdbf44a7f8e5614d804.png" width="1449" height="996" class="img_ev3q"></p><p>▲图1.7　32KB大小的4路组相联高速缓存结构</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="118pipt和vivt的区别">1.1.8　PIPT和VIVT的区别<a class="hash-link" href="#118pipt和vivt的区别" title="标题的直接链接">​</a></h2><p>处理器在访问存储器时，访问的地址是虚拟地址（Virtual Address，VA），经过TLB和MMU的映射后变成了物理地址（Physical Address，PA）。TLB只用于加速虚拟地址到物理地址的转换。得到物理地址之后，若每次都直接从物理内存中读取数据，显然会很慢。实际上，处理器都配置了多级的高速缓存来加快数据的访问速度，那么查询高速缓存时使用虚拟地址还是物理地址呢？</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1物理高速缓存">1．物理高速缓存<a class="hash-link" href="#1物理高速缓存" title="标题的直接链接">​</a></h3><p>当处理器查询MMU和TLB并得到物理地址之后，使用物理地址查询高速缓存，这种高速缓存称为物理高速缓存。使用物理高速缓存的缺点就是处理器在查询MMU和TLB后才能访问高速缓存，增加了流水线的延迟时间。物理高速缓存的工作流程如图1.8所示。</p><p><img loading="lazy" alt="1748269325212" src="/assets/images/1748269325212-cf21ad329668e486361c0a1b089f15c7.png" width="1444" height="448" class="img_ev3q"></p><p>▲图1.8　物理高速缓存的工作流程</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2虚拟高速缓存">2．虚拟高速缓存<a class="hash-link" href="#2虚拟高速缓存" title="标题的直接链接">​</a></h3><p>若处理器使用虚拟地址来寻址高速缓存，这种高速缓存称为虚拟高速缓存。处理器在寻址时，首先把虚拟地址发送到高速缓存，若在高速缓存里找到需要的数据，就不再需要访问TLB和物理内存。虚拟高速缓存的工作流程如图1.9所示。</p><p><img loading="lazy" alt="1748269928329" src="/assets/images/1748269928329-09b9efb05efefa11874782f00b6d05c4.png" width="1444" height="444" class="img_ev3q"></p><p>▲图1.9　虚拟高速缓存的工作流程</p><p>虚拟高速缓存会引入以下问题。</p><p>重名（aliasing）问题<!-- -->[3]<!-- -->。在操作系统中，多个不同的虚拟地址可能映射相同的物理地址。由于采用虚拟高速缓存，因此这些不同的虚拟地址会占用高速缓存中不同的高速缓存行，但是它们对应的是相同的物理地址，这样会引发问题。第一，浪费高速缓存空间，造成高速缓存等效容量减少，整体性能降低。第二，当执行写操作时，只更新了其中一个虚拟地址对应的高速缓存，而其他虚拟地址对应的高速缓存并没有更新。那么处理器访问其他虚拟地址时可能得到旧数据。如图1.10所示，如果VA1映射到PA，VA2也映射到PA，那么在虚拟高速缓存中可能同时缓存了VA1和VA2。当程序往VA1写入数据时，虚拟高速缓存中VA1对应的高速缓存行和PA的内容会被更改，但是VA2还保存着旧数据。这样，一个物理地址在虚拟高速缓存中保存了两份数据，这样会产生歧义。</p><p><img loading="lazy" alt="1748270016231" src="/assets/images/1748270016231-66157244de3655d7a82f6ad1f9d47191.png" width="1398" height="508" class="img_ev3q"></p><p>▲图1.10　重名问题</p><p>同名（homonyms）问题。同名问题指的是相同的虚拟地址对应不同的物理地址，因为操作系统中不同的进程会存在很多相同的虚拟地址，而这些相同的虚拟地址在经过MMU转换后得到不同的物理地址，这就产生了同名问题。同名问题最常见的地方是进程切换。当一个进程切换到另外一个进程时，若新进程使用虚拟地址来访问高速缓存，新进程会访问到旧进程遗留下来的高速缓存，这些高速缓存数据对于新进程来说是错误和没用的。解决办法是在进程切换时使旧进程遗留下来的高速缓存都无效，这样就能保证新进程执行时得到“干净的”虚拟高速缓存。同样，需要使TLB无效，因为新进程在切换后会得到一个旧进程使用的TLB，里面存放了旧进程的虚拟地址到物理地址的转换结果，这对于新进程来说是无用的，因此需要把TLB清空。</p><p>综上所述，重名问题是多个虚拟地址映射到同一个物理地址引发的问题，而同名问题是一个虚拟地址可能出于进程切换等原因映射到不同的物理地址而引发的问题。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3高速缓存的分类">3．高速缓存的分类<a class="hash-link" href="#3高速缓存的分类" title="标题的直接链接">​</a></h3><p>在查询高速缓存时使用了索引域和标记域，那么查询高速缓存组时，我们是用虚拟地址还是物理地址的索引域呢？当找到高速缓存组时，我们是用虚拟地址还是物理地址的标记域来匹配高速缓存行呢？</p><p>高速缓存可以设计成通过虚拟地址或者物理地址来访问，这在处理器设计时就确定下来了，并且对高速缓存的管理有很大的影响。高速缓存可以分成如下3类。</p><p>VIVT：使用虚拟地址的索引域和虚拟地址的标记域，相当于虚拟高速缓存。</p><p>PIPT：使用物理地址的索引域和物理地址的标记域，相当于物理高速缓存。</p><p>VIPT：使用虚拟地址的索引域和物理地址的标记域。</p><p>早期的ARM处理器（如ARM9处理器）采用VIVT的方式，不用经过MMU的翻译，直接使用虚拟地址的索引域和标记域来查找高速缓存行，这种方式会导致高速缓存重名问题。例如，一个物理地址的内容可以出现在多个高速缓存行中，当系统改变了虚拟地址到物理地址的映射时，需要清洗（clean）这些高速缓存并使它们无效，这会导致系统性能降低。</p><p>ARM11系列处理器采用VIPT方式，即处理器输出的虚拟地址会同时发送到TLB/MMU进行地址翻译，以及在高速缓存中进行索引和查询高速缓存。在TLB/MMU里，会把VPN翻译成PFN，同时用虚拟地址的索引域和偏移量来查询高速缓存。高速缓存和TLB/MMU可以同时工作，当TLB/MMU完成地址翻译后，再用物理标记域来匹配高速缓存行，如图1.11所示。采用VIPT方式的好处之一是在多任务操作系统中，修改了虚拟地址到物理地址映射关系，不需要对相应的高速缓存进行无效操作。</p><p><img loading="lazy" alt="1748270950534" src="/assets/images/1748270950534-299324cde4758bd63cb0fae870b4d0c1.png" width="1377" height="994" class="img_ev3q"></p><p>▲图1.11　VIPT的高速缓存工作方式</p><p>采用VIPT方式也可能导致高速缓存重名问题。在VIPT中，若使用虚拟地址的索引域来查找高速缓存组，可能导致多个高速缓存组映射到同一个物理地址。以Linux 内核为例，它是以4KB为一个页面大小进行管理的，那么对于一个页面来说，虚拟地址和物理地址的低12位（Bit <!-- -->[11:0]<!-- -->）是一样的。因此，不同的虚拟地址会映射到同一个物理地址，这些虚拟页面的低12位是一样的。</p><p>如图1.12所示，假设高速缓存的路大小是8KB，并且两个虚拟页面Page1和Page2同时映射到同一个物理页面，我们研究其中的虚拟地址VA1和VA2，这两个虚拟地址的第12位可能是0，也可能是1。当VA1的第12位为0、VA2的第12位为1时，在高速缓存中会在两个不同的地方存储了同一个PA的值，这样就导致了重名问题。当修改虚拟地址VA1的内容后，访问虚拟地址VA2会得到一个旧值，导致错误发生。</p><p><img loading="lazy" alt="1748271160809" src="/assets/images/1748271160809-a3d2176098bb680a08fe637208b3deee.png" width="1657" height="1257" class="img_ev3q"></p><p>Cortex-A系列处理器的数据高速缓存开始采用PIPT方式。对于PIPT方式，索引域和标记域都采用物理地址，高速缓存中只有一个高速缓存组与之对应，不会产生高速缓存重名问题。PIPT方式在芯片设计里的逻辑比VIPT要复杂得多。</p><p>另外，对于Cortex-A系列处理器来说，高速缓存总大小是可以在芯片集成中配置的。Cortex-A系列处理器的高速缓存配置情况如表1.1所示。</p><p>表1.1　Cortex-A系统处理器的高速缓存配置情况</p><p><img loading="lazy" alt="1748271480481" src="/assets/images/1748271480481-450ed78728e5abb80fcc9b0ee1b4d312.png" width="988" height="583" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="119页表的创建和查询过程">1.1.9　页表的创建和查询过程<a class="hash-link" href="#119页表的创建和查询过程" title="标题的直接链接">​</a></h2><p>程序执行所需要的内存往往大于实际物理内存，采用传统的动态分区方法会把整个程序交换到交换分区，这样费时费力，而且效率很低。后来出现了分页机制，分页机制引入了虚拟存储器（virtual memory）的概念，它的核心思想是让程序中一部分不使用的内存可以交换到交换分区中，而程序正在使用的内存继续保留在物理内存中。因此，一个程序执行在虚拟存储器空间中，它的大小由处理器的位宽决定，如32位处理器的位宽是32位，它的地址范围是0x0000～0xFFFF FFFF，64位处理器的虚拟地址位宽是48位，因此它可以访问0x0000 0000 0000 0000到0x0000 FFFF FFFF FFFF以及0xFFFF 0000 0000 0000到0xFFFF FFFF FFFF FFFF这两段空间。在使能了分页机制的处理器中，我们通常把处理器能寻址的地址空间称为虚拟地址（virtual address）空间。和虚拟存储器对应的是物理存储器（physical memory），它对应系统中使用的物理存储设备的地址空间，如DDR内存颗粒等。</p><p>在没有使能分页机制的系统中，处理器直接寻址物理地址，把物理地址发送到内存控制器中；而在使能了分页机制的系统中，处理器直接寻址虚拟地址，这个地址不会直接发给内存控制器，而是先发送给MMU的硬件单元。MMU负责虚拟地址到物理地址的转换和翻译工作。在虚拟地址空间里按照固定大小来分页，典型页面的粒度为4KB，现代处理器都支持大粒度的页面，如16KB、64KB甚至2MB的巨页（huge page）。而在物理内存中也会分成和虚拟地址空间中大小相同的块，这称为页帧（page frame）。程序可以在虚拟地址空间里任意分配虚拟内存，但只有当程序需要访问或修改虚拟内存时操作系统才会为其分配物理页面，这个过程叫作请求调页（demand page）或者缺页异常（page fault）。</p><p>虚拟地址VA<!-- -->[31:0]<!-- -->可以分成两部分：一部分是虚拟页面内的偏移量，以4KB页为例，VA<!-- -->[11:0]<!-- -->是虚拟页面内的偏移量；另一部分用来确定属于哪个页，我们称其为虚拟页帧号（Virtual Page Frame Number，VPN）。对于物理地址，也是类似的，PA<!-- -->[11:0]<!-- -->表示物理页帧的偏移量，剩余部分表示物理页帧号（Physical Frame Number，PFN）。MMU的工作内容就是把VPN转换成PFN。处理器通常使用一张表来存储VPN到PFN的映射关系，这个表称为页表（Page Table，PT）。页表中每一个表项称为页表项（Page Table Entry，PTE）。若将整张页表存放在寄存器中，则会占用很多硬件资源，因此通常的做法是把页表放在主内存里，通过页表基地址寄存器（Translation Table Base Register，TTBR）来指向这种页表的起始地址。页表查询过程如图1.13所示。处理器发出的地址是虚拟地址，通过MMU来查询页表，处理器得到了物理地址，最后把物理地址发送给内存控制器，从而访问物理页面。</p><p><img loading="lazy" alt="1748356077277" src="/assets/images/1748356077277-c02b4c30ef0379863cca85d8006843c4.png" width="1389" height="700" class="img_ev3q"></p><p>▲图1.13　页表查询过程</p><p>下面以最简单的一级页表为例，如图1.14所示，处理器采用一级页表，虚拟地址空间的位宽是32位，寻址空间的大小是4GB，物理地址空间的位宽也是32位，最多支持4GB物理内存，页面的大小是4KB。为了能映射到4GB地址空间，需要4GB/4KB=1048576个页表项，每个页表项占用4字节，因此需要4MB大小的物理内存来存放这张页表。VA<!-- -->[11:0]<!-- -->是页面偏移量，VA<!-- -->[31:12]<!-- -->这20位是VPN，作为索引值在页表中查询页表项。页表类似于数组，VPN类似于数组的下标，用于查找数组中对应的成员。页表项中包含两部分。一部分是PFN，它代表页面在物理内存中的帧号，即页帧号，页帧号与页内偏移量就组成最终的PA。另一部分是页表项的属性，图1.14中的V表示有效位。若有效位为1，表示这个页表项对应的物理页面在物理内存中，处理器可以访问这个物理页面的内容；若有效位为0，表示这个物理页面不在内存中，可能在交换分区中。如果访问该物理页面，那么操作系统会触发缺页异常，在缺页异常中处理这种情况。当然，实际的处理器中还有很多其他的属性位，如描述物理页面是否为脏、是否可读可写等的属性位。</p><p><img loading="lazy" alt="1748356160571" src="/assets/images/1748356160571-78b9faf835065bd1258558c7d86e1914.png" width="1501" height="891" class="img_ev3q"></p><p>▲图1.14　一级页表</p><p>通常操作系统支持多进程，进程调度器会在合适的时间切换进程A到进程B来执行，如进程A使用完时间片时。另外，分页机制让每个进程都“感觉”自己拥有了全部的虚拟地址空间。为此，每个进程拥有了一套属于自己的页表，在进程切换时需要切换页表基地址。对于上述的一级页表，每个进程需要为其分配4MB的连续物理内存来存储页表，这是不能接受的，因为这样太浪费内存了。多级页表可减少页表所占用的内存空间。如图1.15所示，二级页表分成一级页表和二级页表，页表基地址寄存器指向一级页表的基地址，一级页表的页表项里存放了一个指针，指向二级页表的基地址。当处理器执行程序时它只需要把一级页表加载到内存中，并不需要把所有的二级页表都装载到内存中，而根据物理内存分配和映射情况逐步创建与分配二级页表。这样做有两个原因，第一，程序不会马上使用完所有的物理内存；第二，对于32位操作系统来说，通常操作系统配置的物理内存小于4GB，如512MB内存等。</p><p>图1.15所示为ARMv7-A架构二级页表的查询过程。VA<!-- -->[31:20]<!-- -->用作一级页表的索引值，一共有12位，最多可以索引4096个页表项；VA<!-- -->[19:12]<!-- -->用作二级页表的索引值，一共有8位，最多可以索引256个页表项。当操作系统复制一个新进程时，首先会创建一级页表，分配16KB页面。本场景中，一级页表有4096个页表项，每个页表项占4字节，因此一级页表大小是16KB。当操作系统准备让该进程执行时，设置一级页表在物理内存中的起始地址到页表基地址寄存器中。进程执行过程中需要访问物理内存，因为一级页表的页表项是空的，这会触发缺页异常。在缺页异常里分配一个二级页表，并且把二级页表的起始地址填充到一级页表的相应页表项中。接着，分配一个物理页面，并把这个物理页面的帧号填充到二级页表的对应页表项中，从而完成页表的填充。随着进程的执行，它需要访问越来越多的物理内存，操作系统会逐步地把页表填充和建立起来。</p><p><img loading="lazy" alt="1748356238994" src="/assets/images/1748356238994-3c37d73feb92ac06b07716a75316dfed.png" width="1318" height="1044" class="img_ev3q"></p><p>▲图1.15　ARMv7-A架构二级页表的查询过程</p><p>当TLB未命中时，处理器的MMU查询页表的过程如下。</p><p>处理器根据页表基地址控制寄存器（TTBCR）和虚拟地址来判断使用哪个页表基地址寄存器，是TTBR0还是TTBR1。页表基地址寄存器中存放着一级页表的基地址。处理器以VA<!-- -->[31:20]<!-- -->作为索引值，在一级页表中找到页表项，一级页表中一共有4096个页表项。</p><p>一级页表的表项中存放二级页表的物理基地址。处理器使用VA<!-- -->[19:12]<!-- -->作为索引值，在二级页表中找到相应的页表项，二级页表中有256个页表项。</p><p>二级页表的页表项里存放4KB页的物理基地址，这样，处理器就完成了页表的查询和翻译工作。</p><p>图1.16所示的4KB映射的一级页表的项中，Bit<!-- -->[1:0]<!-- -->表示页表映射的项，Bit<!-- -->[31:10]<!-- -->指向二级页表的物理基地址。</p><p><img loading="lazy" alt="1748356437180" src="/assets/images/1748356437180-2d8b428058c07bab9a7bdf135320e303.png" width="1263" height="120" class="img_ev3q"></p><p>▲图1.16　4KB映射的一级页表的项</p><p>图1.17所示的4KB映射的二级页表的项中，Bit<!-- -->[31:12]<!-- -->指向4KB大小的页面的物理基地址。</p><p><img loading="lazy" alt="1748356458413" src="/assets/images/1748356458413-20109a87289f4e32d87ae3dc82876d25.png" width="1260" height="121" class="img_ev3q"></p><p>▲图1.17　4KB映射的二级页表的项</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1110tlb">1.1.10　TLB<a class="hash-link" href="#1110tlb" title="标题的直接链接">​</a></h2><p>在现代处理器中，软件使用虚拟地址访问内存，而处理器的MMU负责把虚拟地址转换成物理地址。为了完成这个映射过程，软件和硬件要共同维护一个多级映射的页表。当处理器发现页表项无法映射到对应的物理地址时，会触发一个缺页异常，挂起出错的进程，操作系统需要处理这个缺页异常。前面提到过二级页表的查询过程，为了完成虚拟地址到物理地址的转换，查询页表需要访问两次内存，因为一级页表和二级页表都是存放在内存中的。</p><p>TLB专门用于缓存已经翻译好的页表项，一般在MMU内部。TLB是一个很小的高速缓存，TLB表项（TLB entry）数量比较少，每个TLB表项包含一个页面的相关信息，如有效位、VPN、修改位、PFN等。当处理器要访问一个虚拟地址时，首先会在TLB中查询。如果TLB中没有相应的表项（称为TLB未命中），那么需要访问页表来计算出相应的物理地址；如果TLB中有相应的表项（称为TLB命中），那么直接从TLB表项中获取物理地址，如图1.18所示。</p><p><img loading="lazy" alt="1748356536979" src="/assets/images/1748356536979-a8a2ff9af3c6dffe71d68619a4464147.png" width="1425" height="976" class="img_ev3q"></p><p>▲图1.18　TLB的查询过程</p><p>TLB内部存放的基本单位是TLB表项，TLB容量越大，所能存放的TLB表项就越多，TLB命中率就越高，但是TLB的容量是有限的。目前Linux内核默认采用4KB大小的小页面，如果一个程序使用512个小页面，即2MB大小，那么至少需要512个TLB表项才能保证不会出现TLB 未命中的情况。但是如果使用2MB大小的巨页，那么只需要一个TLB表项就可以保证不会出现TLB 未命中的情况。对于消耗的内存以吉字节为单位的大型应用程序，还可以使用以吉字节为单位的大页，从而减少TLB未命中情况的出现次数。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1111mesi协议">1.1.11　MESI协议<a class="hash-link" href="#1111mesi协议" title="标题的直接链接">​</a></h2><p>在一个处理器系统中不同CPU内核上的高速缓存和内存可能具有同一个数据的多个副本，在仅有一个CPU内核的处理器系统中不存在一致性问题。维护高速缓存一致性的关键是跟踪每一个高速缓存行的状态，并根据处理器的读写操作和总线上相应的传输内容来更新高速缓存行在不同CPU内核上的高速缓存中的状态，从而维护高速缓存一致性。维护高速缓存一致性有软件和硬件两种方式。有的处理器架构提供显式操作高速缓存的指令，如PowerPC，不过现在大多数处理器架构采用硬件方式来维护它。在处理器中通过高速缓存一致性协议来实现，这些协议维护一个有限状态机（Finite State Machine，FSM），根据存储器读写的指令或总线上的传输内容，进行状态迁移和相应的高速缓存操作来维护高速缓存一致性，不需要软件介入。</p><p>高速缓存一致性协议主要有两大类别：一类是监听协议（snooping protocol），每个高速缓存都要被监听或者监听其他高速缓存的总线活动；另一类是目录协议（directory protocol），用于全局统一管理高速缓存状态。</p><p>1983年，James Goodman提出Write-Once总线监听协议，后来演变成目前很流行的MESI协议。Write-Once总线监听协议依赖于这样的事实，即所有的总线传输事务对于处理器系统内的其他单元是可见的。总线是一个基于广播通信的介质，因而可以由每个处理器的高速缓存来进行监听。这些年来人们已经提出了数十种协议，这些协议基本上都是Write-Once总线监听协议的变种。不同的协议需要不同的通信量，通信量要求太多会浪费总线带宽，因为它使总线争用情况变多，留给其他部件使用的带宽减少。因此，芯片设计人员尝试将保持一致性协议所需要的总线通信量减少到最小，或者尝试优化某些频繁执行的操作。</p><p><img loading="lazy" alt="1748356677524" src="/assets/images/1748356677524-eef48bc243937f3d65084055daa372d3.png" width="970" height="1237" class="img_ev3q"></p><p><img loading="lazy" alt="1748356876832" src="/assets/images/1748356876832-fdf64a9314302b05b855a68ab8d28907.png" width="967" height="721" class="img_ev3q"></p><p><img loading="lazy" alt="1748356942397" src="/assets/images/1748356942397-32df9fcf140eb3515f6adef0d181dcc4.png" width="894" height="1222" class="img_ev3q"></p><p><img loading="lazy" alt="1748356984064" src="/assets/images/1748356984064-b2acce6e959c6746c4d2c6a90d0abca8.png" width="891" height="1533" class="img_ev3q"></p><p><img loading="lazy" alt="1748357001884" src="/assets/images/1748357001884-16d03b7faed4f70a35a0cee6b8bbb6a6.png" width="871" height="676" class="img_ev3q"></p><p><img loading="lazy" alt="1748357024794" src="/assets/images/1748357024794-11e7520bdb444515e84720c5a93848d9.png" width="873" height="675" class="img_ev3q"></p><p><img loading="lazy" alt="1748357044042" src="/assets/images/1748357044042-ae07433b6d4811c5b74ce81d52d9a7eb.png" width="876" height="1372" class="img_ev3q"></p><p><img loading="lazy" alt="1748357069332" src="/assets/images/1748357069332-d428d277d76994dc76d40c6ba5a4b7bd.png" width="963" height="892" class="img_ev3q"></p><p><img loading="lazy" alt="1748357085079" src="/assets/images/1748357085079-054e796c48e9035737509b15bde704a0.png" width="1576" height="853" class="img_ev3q"></p><p><img loading="lazy" alt="1748357107971" src="/assets/images/1748357107971-2e9d1b6a53f8ffb4f9298d51f39dad6c.png" width="961" height="255" class="img_ev3q"></p><p><img loading="lazy" alt="1748357121763" src="/assets/images/1748357121763-3d02e08cd57cb8c2f2e5a0ae4f3d9d82.png" width="967" height="904" class="img_ev3q"></p><p><img loading="lazy" alt="1748357137485" src="/assets/images/1748357137485-e20b4188fc24d0917466a714342ce3d3.png" width="967" height="699" class="img_ev3q"></p><p><img loading="lazy" alt="1748357166379" src="/assets/images/1748357166379-ed54b72354c98681dd9a515eb67145dc.png" width="957" height="693" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1112高速缓存伪共享">1.1.12　高速缓存伪共享<a class="hash-link" href="#1112高速缓存伪共享" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748357222490" src="/assets/images/1748357222490-307c279431cedd3a64b6fa63f141f014.png" width="972" height="571" class="img_ev3q"></p><p><img loading="lazy" alt="1748357267892" src="/assets/images/1748357267892-7ab63c8431c8dc70666e9ebecb4de1ed.png" width="1383" height="802" class="img_ev3q"></p><p><img loading="lazy" alt="1748357281605" src="/assets/images/1748357281605-95725d8a860322764c192a3cae29e933.png" width="964" height="205" class="img_ev3q"></p><p><img loading="lazy" alt="1748357335600" src="/assets/images/1748357335600-966df77cd97fe9d3a45606ab77be8d2d.png" width="967" height="1231" class="img_ev3q"></p><p><img loading="lazy" alt="1748357353024" src="/assets/images/1748357353024-0a2efd80f85fba44df1d9d497d3be322.png" width="969" height="594" class="img_ev3q"></p><p><img loading="lazy" alt="1748357428983" src="/assets/images/1748357428983-21bd66415135a70bb02687192790aaa9.png" width="982" height="594" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1113-高速缓存在linux内核中的应用">1.1.13 高速缓存在linux内核中的应用<a class="hash-link" href="#1113-高速缓存在linux内核中的应用" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748357470247" src="/assets/images/1748357470247-eded1d5130fd9360850fdd77193cf357.png" width="964" height="315" class="img_ev3q"></p><p><img loading="lazy" alt="1748357503402" src="/assets/images/1748357503402-05db17d8a529a10aa7e17532b46067d6.png" width="967" height="538" class="img_ev3q"></p><p><img loading="lazy" alt="1748357526989" src="/assets/images/1748357526989-b9fc85c68195b52ff5f0a68d41cdc87c.png" width="969" height="223" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;include/linux/cache.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define SMP_CACHE_BYTES L1_CACHE_BYTES</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define ____cacheline_aligned __attribute__ ((__aligned__ (SMP_CACHE_BYTES)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define ____cacheline_aligned_in_smp ____cacheline_aligned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifndef __cacheline_aligned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __cacheline_aligned   \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  __attribute__ ((__aligned__ (SMP_CACHE_BYTES),  \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          __section__ (&quot;.data..cacheline_aligned&quot;)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif /* __cacheline_aligned */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __cacheline_aligned_in_smp __cacheline_aligned</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define ____cacheline_internodealigned_in_smp \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    __attribute__ ((__aligned__ (1 &lt;&lt; (INTERNODE_CACHE_SHIFT))))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1748357569703" src="/assets/images/1748357569703-67c2a4198462194e04f6538ba9bfd0ba.png" width="970" height="574" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1114-arm的大小核架构">1.1.14 ARM的大/小核架构<a class="hash-link" href="#1114-arm的大小核架构" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748357609926" src="/assets/images/1748357609926-92398c72b3b86b89f8ede715f5844d23.png" width="964" height="567" class="img_ev3q"></p><p><img loading="lazy" alt="1748357624562" src="/assets/images/1748357624562-0fc2a3f5754081ab7b0aaa8aa1a1102c.png" width="799" height="607" class="img_ev3q"></p><p><img loading="lazy" alt="1748357645834" src="/assets/images/1748357645834-1c954f32bb18d8014608ec3cc203e4c8.png" width="853" height="259" class="img_ev3q"></p><p><img loading="lazy" alt="1748357670566" src="/assets/images/1748357670566-59023f307c77b19919a877dafed7a9da.png" width="1348" height="607" class="img_ev3q"></p><p><img loading="lazy" alt="1748357685561" src="/assets/images/1748357685561-b9d3dd4b2ad4244420198315557bb5e5.png" width="969" height="534" class="img_ev3q"></p><p><img loading="lazy" alt="1748357761012" src="/assets/images/1748357761012-9f2d8a7b8f8fca29de316f5b0a988d73.png" width="970" height="730" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1115-高速缓存一致性和一致性内存模型">1.1.15 高速缓存一致性和一致性内存模型<a class="hash-link" href="#1115-高速缓存一致性和一致性内存模型" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748439137713" src="/assets/images/1748439137713-74b6cda5d67dd6c4e773fc291aa684b4.png" width="964" height="322" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1116-高速缓存一致性和一致性内存模型">1.1.16 高速缓存一致性和一致性内存模型<a class="hash-link" href="#1116-高速缓存一致性和一致性内存模型" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748439568427" src="/assets/images/1748439568427-e7eb2fea64af3c30ac190308b800a4b0.png" width="963" height="880" class="img_ev3q"></p><p><img loading="lazy" alt="1748439830922" src="/assets/images/1748439830922-1fe7cbc1fc497e70d3995e88de3e4e8f.png" width="967" height="1062" class="img_ev3q"></p><p><img loading="lazy" alt="1748440017008" src="/assets/images/1748440017008-619b445d956a8d0d9ce7558f9fa650fe.png" width="967" height="153" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1117-numa">1.1.17 NUMA<a class="hash-link" href="#1117-numa" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748440063696" src="/assets/images/1748440063696-1773a83f651ea50c3bc0cf1b5009285e.png" width="967" height="600" class="img_ev3q"></p><p><img loading="lazy" alt="image-20250528214811194" src="/assets/images/image-20250528214811194-23bbb4acdcb46f27d90595fc4a554f73.png" width="1035" height="406" class="img_ev3q"></p><p><img loading="lazy" alt="1748440106123" src="/assets/images/1748440106123-913adafc24cd14ac2e0f70fa375e56d5.png" width="970" height="418" class="img_ev3q"></p><p><img loading="lazy" alt="1748440170879" src="/assets/images/1748440170879-5043b658b748f82df84931db3b4281c0.png" width="1057" height="274" class="img_ev3q"></p><p><img loading="lazy" alt="1748440186164" src="/assets/images/1748440186164-e76acfb8eca62c277b3fe7b35396b222.png" width="967" height="250" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1118-arm处理器设计">1.1.18 ARM处理器设计<a class="hash-link" href="#1118-arm处理器设计" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748440242575" src="/assets/images/1748440242575-22651aad2a9d44f013edee236a890f13.png" width="966" height="1045" class="img_ev3q"></p><p><img loading="lazy" alt="1748440548346" src="/assets/images/1748440548346-cc320d07ce66568c3520d58d0f8719b3.png" width="967" height="1036" class="img_ev3q"></p><p><img loading="lazy" alt="1748440610671" src="/assets/images/1748440610671-0b0d43387b16463cd6fc179f33c703ab.png" width="1446" height="1693" class="img_ev3q"></p><p><img loading="lazy" alt="image-20250528215711825" src="/assets/images/image-20250528215711825-769d68adfdf20203a5fb31d931c70b93.png" width="957" height="93" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1119-最新进展">1.1.19 最新进展<a class="hash-link" href="#1119-最新进展" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748440700242" src="/assets/images/1748440700242-24509afb06cc112687c52ebb092d62d3.png" width="969" height="1245" class="img_ev3q"></p><p><img loading="lazy" alt="1748440738532" src="/assets/images/1748440738532-766d145417c8fc9436f2e9ff7800cf16.png" width="967" height="1000" class="img_ev3q"></p><h1>1.2 ARM64架构</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="121-armv8-a架构">1.2.1 ARMv8-A架构<a class="hash-link" href="#121-armv8-a架构" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="image-20250528220001137" src="/assets/images/image-20250528220001137-60e6786f78b842ee213f867a113f3afd.png" width="963" height="708" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="122-采用armv8架构的常见处理器内核">1.2.2 采用ARMv8架构的常见处理器内核<a class="hash-link" href="#122-采用armv8架构的常见处理器内核" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748440852452" src="/assets/images/1748440852452-77e4fd6419233d1fdee696c0beb25fbf.png" width="967" height="705" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="123-armv8架构中的基本概念">1.2.3 ARMv8架构中的基本概念<a class="hash-link" href="#123-armv8架构中的基本概念" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748441665606" src="/assets/images/1748441665606-4621facb4cea65675ea5b75a12a4146b.png" width="966" height="1450" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="124-armv8处理器执行状态">1.2.4 ARMv8处理器执行状态<a class="hash-link" href="#124-armv8处理器执行状态" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748441702942" src="/assets/images/1748441702942-17e181bf56be1803a59532daa085f464.png" width="961" height="556" class="img_ev3q"></p><p><img loading="lazy" alt="1748441719695" src="/assets/images/1748441719695-d11a721fb7f07cbafde0056f5762eddf.png" width="1308" height="553" class="img_ev3q"></p><p><img loading="lazy" alt="1748441740645" src="/assets/images/1748441740645-43c44802dcfdfbeb2307acd466536d94.png" width="960" height="484" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="125-armv8支持的数据宽度">1.2.5 ARMv8支持的数据宽度<a class="hash-link" href="#125-armv8支持的数据宽度" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748441804763" src="/assets/images/1748441804763-c0329336be0589a1197213559829c21e.png" width="403" height="286" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="126-不对齐访问">1.2.6 不对齐访问<a class="hash-link" href="#126-不对齐访问" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748441947476" src="/assets/images/1748441947476-45004805cd8e9e5b0052994f76479520.png" width="964" height="1000" class="img_ev3q"></p><h1>1.3 ARMv8寄存器</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="131-通用寄存器">1.3.1 通用寄存器<a class="hash-link" href="#131-通用寄存器" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="image-20250528222019953" src="/assets/images/image-20250528222019953-bf3136914b66ae089426703bae325572.png" width="964" height="249" class="img_ev3q"></p><p><img loading="lazy" alt="1748442034651" src="/assets/images/1748442034651-435311cacfa86e78aec767a08dc12964.png" width="1552" height="799" class="img_ev3q"></p><p><img loading="lazy" alt="1748442055527" src="/assets/images/1748442055527-aa2a73fa6076d0e779b291933bd621c8.png" width="966" height="264" class="img_ev3q"></p><p><img loading="lazy" alt="image-20250528222129473" src="/assets/images/image-20250528222129473-62bcc2d2bda9114ad4e306dac325014d.png" width="1497" height="331" class="img_ev3q"></p><p><img loading="lazy" alt="1748442253862" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA74AAABGCAYAAADrV0joAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAFiUAABYlAUlSJPAAACBLSURBVHhe7Z3dS1tL98d/f0if643wVAoP59DiRU9B6EUQvBBBLEiFKhQD1UMR5GA4YKDmorYUNpQIJVIwUAznIggRISKKEhTE5+b5b9ZvZmdn71mzZ/ZL3kzT78WHc5pM9su8ub6z1qz5v0eP/kWSf//7395/AQAAAAAAAACAcQLCFwAAAAAAAADAWAPhCwAAAAAAAABgrIHwBQAAAAAAAAAw1kD4AgAAAAAAAAAYayB8AQAAAAAAAACMNRC+AAAAAAAAAADGGghfAAAAAAAAAABjDYQvAAAAAAAAAICxBsIXAAAAAAAAAMBYA+ELAAAAAAAAAGCsgfAFAAAAAAAAADDWQPgCAAAAAAAAABhrIHwBAAAAAAAAAIw1EL4AAAAAAAAAAMYaCF8AAAAAAAAAAGMNhC8AAAAAAAAAgLEGwhcAAAAAAAAAwFgD4QsAAAAAAAAAYKyB8AUAAAAAAAAAMNZA+AIAAHgwHr9YonxhnWYN34EMPPmDcs8mzN+BMWKCHMf0+Zgg+vFifofyc4bvUjNBT3MzlJtp8/yJqQwA4FcEwheAn4aXND1t+hyAUWOJ3OYNNWoVKuYX6KnJUM9X6PLuf3T3X8k9HW71UbQ5U4HRm4Xl1wvkmK43sizR58Y9tTr12CwPbAHhaemM7u7uqXlco/2Pm7Q4bmJCCK7lQoWOxPsVBjXPTu1R/faK6gdl2njzBz02lTEihNz8OhXLdWpci3Y+r9DqT1b/i1+v6PK0Tvsf1mneuECzTvsXfj8WtH5sZxuLT+Zo6+MuLXtzzRK71tHf8rMJ2vgq7l9Y4fPRazkPiTF0cUb16i4tqtdMYkn81r/H3X/rVDCVAQCMFBC+APwkPP27Tpf1XZo2fJeWwj+hMTAQ/tkx3hf8YqxWFYPwf1T/MGUot0mHt2GZTIaus0Cl43u6FL/JmUQ1M0izIa9pHWNdCuokIh6pDPcpsjF9Rfur5nIRMnmHJ7S544xKU6ZyWeECxUowr6Qsf1FJFDDOsxnPs+genFDj4p7/XgjLtoDqL97iQXCfK3JtXk3Z/q/WqeBWqX56Ey5sqPxU4neNKlKwd579eJeeGspt/FDa4bZGWynbYP5TWK+X5SXxmUH4Tu9Rw//33Z2o+9f+78Xf1U65u/MyzWvXjiVO+KrX7YK2WAcA9BsIXwB+BpyOSLinw/fde8Z+FeH7+MUMLb/fpWJxlwr5Jcq9mDSWi2eSns+s0Ia4RrGwToszWTw0D4l8bhk+LN9/h/KvZswe14ExJfpZOgNWN3Q3DGUiPFmj/ab/G0nTIAB6EL7eGPvrN369vlzXTsTIHdB9VNoCQbuvDWeHjtTfN/aMwiU7wxO+ubd7tF+tU/1c8ZDH0BL3nJ5b9+aQdCSF68+Rq/bbU5dyfkiunKtK5RodHV9Rq6WUSaB1vBd7TzkPSnHvPd/7FcrlpjJGNChzoD+XdBM2LBdtW8Fzx0R3vK/xcu8NZUxMif4ZLKKdUHFKF74TlP9+E/z78vt6UA+L5fDz1o/N6LXjgPAF4KcDwheAnwD1j3Mab4aNhxe+kzS7Vaa6arz28D6cSVr8UGuHAqrP1OH8hD6vphDAzgIVq2dKGK7C3Q3Vy+s9ed0HhjNDG+4JNS1GfbO2myE8lRuKAWnaaq5MTeU3cQLLYcahMHT/NJdjOCv0+VTz0F0Lca2Gp06t0JYiSkrf6nT03aWS8lmxuEfujyt+nbsrqrx7ye+nMq7CV6uvCN9VT6X4bc01l4tlm5YjXuLhCV9nSxVVFmQYclUJz88kXhJCXVcNURBZ2/nuPiFcWJIwD4o+Xnc3zZESHZ4s2edAQbPuZvA2a4I/bg7RFlha1fRCdPUgnK8aJR42fVRW5iTmzZ+gYj0s1/gyw66ZCIQvAD8dEL4AjDpzbhii5dP4MmcumwATvkaROkHL34QYuD6jQ2EcLacIh0y8phBkq4U92q9ZDKl+CF8phhqaGDJyT/VSzD7O6XWqnJt+x/G8QabfPxS6F9SGMHr304h/m0Ge2Faat9fzvrQ9T5FQW8nbCjUu6lT5tEv5pTlzGUHEYy36VLGmtfftCZXm9f46Qbm/auG7SKO/vEPLuRXxe03YXwjxnEvo7w8kfFut+76g3pMJ3wG9F+eG9peUd/TQPXPhd+Z5RS2vXU8VGsZ+Ksa24k316kSdj0xzV9+EryUKIqHeufc3QVgLnNw2HaZZGJBYwrmd1+LvTRqvs3G8ReHeXl/wy0RshnGemxHzWOPGW6QqvluiWWMZgenvkqjL5vUJVbw9vFGP79PXu3R4ekKfWXi52ifuqZJXv0sBa7844Zvcdo8ecdEP4QvAYIDwBWCk0YWEz634Q9rFHrskkTrNjJQbqqQQSYnCN8mo7lX4CtG7n0KshlyRGzHAJaKudTElhVKtTkf1qGjvdvGh72R6/3thUMV4ND3m6POp6beChLZy8tyrdXmw5n3O+khmTIJJ8pK2fujiVRjzapnpdXLrmlc3wj01ygkesA6sL5ufi0VnWA3eBCM3zqDWEcI+ELcNN2aPIhcDv57w9TP9KtseEucuTfgG9dyBzQkx7aTVb1D37PMrqhR3aeON8ozs+xMqxvbR32hVLloG5ZORob3qIqDzWohHQzkr5+X4udsRwlL1PF9XaVV+rtVrVljf7fZasr1ntEVlvX1Vqtvt+y3IhYHO58pvBUFZOQ7Zc0H4AjAqQPgCMMLoQkJF3aeUljhDj4veNsEfcp3zOhVftY2zBxe+0kv9VTH4rsWzve7sZZMr/TKTqnI/iXjOSN3pRtCFMNLUcL5pdR+Z/L7X5+4Ps194GKoUBEcfVvy9eDIb7Dbte95wIXqLM4l9Zpol4NGIe2cpwJm3qe3tld8NRvhKFPF7K9rd4rF1nq1QoXxiiTioBX05EdaXhyV8r6gpMzebxqFEfSeZndZUxuOMmjbhy4x5TnBtH1OZdJzR5wXlHT00MX5apyO50CRgobrBvKKWv6fmcVj+6FSp95RjM5vwjbZlurZ+SaVGp4xESQzG2tnw+xT9jfNSvJPfZmIeLOXngrwEzrM1cvUtAsoY9RBjWA1LvqzthlE/zhQtfzyJ/I2Q3tTg9wwZPaTWj5LkbkSEL082lkCnfyT9PZPI/seeS2a4V/qqkTN2XQhfAAYDhC8AIws3CqOkMYQ4ZkNvklbds+T9bxGuvLCxRONR3z/4XfNK9EVACiNLCMDL4z2aN4Xv6fv7TImUCtyAapSimYhnXfXZ06ziDxhnm2VG9vrEa5MhKupndSV5oWR6ly0SXH6vUj24tsDaVuL6ZXu7Dk74SoSxX+VH0HBB0gWmfiwZlvBlQpQL1u7hArrxZYHf04C+8CZD/PuT1KpD0hznE7RHyvIjJHwdlrBJK5ckfNliXMr5Xm77KO+aIxjUzMYehvBe+fvTG8uWkAnaUhPSCWwJoaLeY+X5+yl837pcQB5bxr7cv62W+7RJxWNDORud/tGV8M0OhC8AgwHCF4ARJdbz1qGxl2mvacTQe7JGrmFvbOilCeFlwpDZRONRRzcI+iJ8k+BCQ3pdPs9oZbTnMhoeCYbwsOHJoaQRmvHsS4Ye6i3qaE6rN0tbGSMT4trVmbA+p/Psj56zUA9H+N5zj6OPzBocXsvm6cni3Ukp9hLJ2l/1kPeUwkslpp3bDEv4zlBBJjjT2oF5la/P+PffdiiXMN4Tha8e6quXSxK+bN7qov4j6POg6HsFU7kYtAXCdnZqrYzxveOeX/QT25h3puh5yqO3nPk9qsftT74II5UeTe3yRb3jvXAP8ccT5TdV2pCfdcLP1YVcV/WAt0PVvc//WvH2NgfX6AIIXwAGA4QvAKMIO54hDiFAC6YzUs0wkSrDCiPGSZvWaYU2OmGjT5aoVFeNeektCr2HP4fw1cNwr8jVwy6FeFM9MyYRmVPDiltVymvfDxt2HJDJe5OBiHdP7v+LhH8b2koPAbeWnaPCQUcYGurfp1Dzfy/DduVZpYYySTBB0qyG0QbFquKFUgxVQUVNDpZK+PaPzEauzOBdtkRp6JmJTb9Pgb7w1tkPysZ7Clp1cxRGmyla/itsgwilKjVkKPfdDTXqNdr/e41W/fKlA3UsnlHl0174Oyk82H26WDyQ/bcn4TuhjU9DuUzCtw9iaEr3+NrHoZXX2hiInH2rhFszosJ39u9q+wgn0cbNr5YIBEVot1pXtP/WUEbU9XyxnnpsXh5sUk5fWBbt3ckPwOb5+q598Sau/VjfOaFSR1R7bFJF6Y/1j+p3bbo5NgoAkAyELwAjh+UoGRvXQoClNHB1keplAfXE7w0dftj1/7+DELg1fV9kdJ/oTyF8HW1132hkrmleinthkCwpZ/fyYzk6iZseDt2YV9/JT+ST1oDS9+fenlBRhg7rQk9vq9+37Qs0kXblWXXrRXNItnq8iKlvWDNECzpCjwkS1idVIcH7QKp+/JDC98kf3pmsbswxMyaax1W21zMVS/xIqqA/iO+yCl+PCzFH/a7dIwV8/7p6hvlL2hLCV5+b+HhVGb7wNeVMiJRj/ckUHcAjA9Q90B32CymP4JGZ0HVBeuomnD0cxSkq3lBJTR0rv9GWniAwICp889+VshaBye+nX8PP1tzk92yJPn+ktPdRcUFZvBXi+bXJIx1GAakLFpffVpT7aaQWvnrf4f0R3l0AhgeELwCjhuH4oiTSZhg2GvfTS7Tc8e46wkCwHQskj68wJAH6GYTv0w+asdbYM+5VfFowGKsXdSq9FcJK9RDIPcI9eNP6gxa2KOvRP8s3IozOT8j9057YalFNDiZolPzMz0nC15Z13FiWi9rW93Xluw6aQGFGdRu78AqNYi5IuiCV8L0fSqjzrEwoFCN0ZQKieWeSnr/ZJPfghJq2hYiWPH7GfA+GXATRsoQH/UGQXfiazkYOF2asvNP2iDbLtKyXWRDvrMxXDXdNOwLnD18IR0Od2Vnikr6GOvNFHo5N+HYH2+/KEH1iZoU2pHe8XKem/jy3QuhZQ49tTEX2xeq5EPTji0KiwpeJWksETbxXPbrAcPljm6aNwnKSVstX1Py6ZN1G1E7UtUCu0v9jQ8HTCt+7OhVZv0z2+IZ9FwDQTyB8ARgp9AygaTmjkpLcx4ZNpDrPFij/oaIZ7QaEgKrI831znazJP4Pw5Z5aSZBdNMIEzZeimUsZLXv24OGiCd9mjQ5jz/LlIeoB+kKL6gVKFL6CuY538IqO6oqRaijLsrya9gZq72QKfxwd4Rs15CVJhnqbLCGsBm+lDP2t7lF+1pyN+vHsOhXLQgQrgll6rmwLHwEGr2CrvsvyCMR53CNZf63nRnfhge0KW/2vGTx+0hOojeuuhS9fbGvdqnWqlBuo8NXmB4XLY2UrSxaCsd5BywrtEc63zX9O4scLC5s25F0QsPEeCauW+LkJxJiQnl3Zxx1nji10fFbDo7UEfmrbeIm6WHSQ+ZkCWPtdib+NVe9vaFOONd0znhlb3wUA9AKELwAjRDQDaHr0MxlNMCOiWadKTRjHMclALo8tR8BI7u7p8vTEcuxIDEMWvpHV/YTQcCe3yfd76lzUaGsUha+KMOa8pGSRttONT32hRTvjOI3wfSQzvQqj8++XXAgYyjJj0JRZm91PhrZq3wsyC9+B7fEdnPDl1xgQevvIaI9jLnoldmGl8pLy+p7j2AWihxW+kSzvAZr47UH4BuL6vELLRct1tP5kig6ITcAlsIc62+eHZr3chfCNLsrajtST9XspxtB00nhhItM03nk/sWWQZlFLivBuXZzR/p+/8bKyrx50IlyEsM0rC39yTlL/BlvzOMiIhRXa+GbZZy/evfcxbJs7AAC9AOELwKig77PMzA1V8vHGDBe+Z/aQankW7pLvFZXnNxakN9hQThh1++qezFETvpGw8fhkYNPvVGF0Q/Uq95qFGLxDQ8dg2N6ekfs29MZ7ick0MaMaj3pod8QrmEr4CvzsvczYM5VlHh5DYh2WMVY579SGxbBmz8H6pFpn3LBkY+NXE77T69bFnjTCd14LlZcJrRZj95Yv0GfT2cSmsaaXEUTKWM8vrtFW5N4JUTW3os060TM9CV9RL19q5Mp5wnYd1p/MfYXdw7JFw8w2HXbqwTiHhZn50xA5L1zWk3V8+lmaE8cL/5sXjfDg48R0xFwkjL1+pcxp95HtCF7E0rNJL7Kn8VX2bVVc39PlRdi/TEJ7XtRD3NYDDzG2Cmq76UcpyQVnxets2rt9VHO7SuwHAIgHwheAESFiWHRDQrISbtzvhkm0hOHoJcH5c4ftPbq7lV4ImSG2nRzn8YsV2vDDue7u2uHVqQSDyrCEr2GvojyH1Hr8E0voc0/1om8USuH/oR71fMcafsNAF74WMa6f3Snqu529dFM7A/iemv9oxpfMuKr+VjHgWPigDzPSTe2qZZXV988xARU8ZwxphG832PpxDxEZcejC1zOumYDrFu1e6ncNtx02+rvoRzGGfBrhm9juiUzSohxjyn0lzW9rxn2O09KjyMre0NEHW2IrTqqomvMq5aX47VH4BvQgfJ+qEStpxoQF59kKFWv6uNAiPCxEz+RNKZoThe8UX4TQ9/QvqHOy+P1r5buALqIHtD5qni/u6XDLMJ/G9J9WZyvQi8kwO70kMp/wZ47f6gAA6CcQvgCMAtq+o+5RBJuBiEidXqP8mzCJxn9WXTr0j5fg1xXIfYUHMnFIwjW17yMMQ/iawjZjhaqWtKVZji4gSK+YJqQfNrOzlkDHahTrhmHHwNaFczZMxlqyAOJiW/fwMGPRkNgqwrCFr953+8TADN9E4SHRs8gLUax6ozzha/HQdtDmC2MZSXVbu/e/6PGraFZe+QzG/egKPDrD5/qE9rfiMlhz7576nnf1Kt/3e17u8TgjhR6ELxdaMfdIheGIJdHX4+rZOxtX+9vUEmMzlec5Rf9jz6Pv4WURILZ3zy58I4s57Dl9bmu0ZdoSoy7esX6vPl9SIj8IXwAeCghfAB4c23mPXRKTcThOpD5+poTIimd6Or9OJZklNvjjbhbVoyd8TedIJoQma55I6xEWq/ysW3OylWGheUusocGjJHx5xlQeSsifs/ElxTEtaYRvH/f49iyoLcQZvpnvqT57KuErmPL3WnqZn3n4aVskZBcXRoJnm6TZ/J5B8LZp/nCVNhO862St5+f+lsqWRHR3V1Qv73ieN/U9WVTNtRC62tylnmXtRYeMgvBlZ2nHtGFadI9l3HnkpjO65Z7ltBntU/Q/FuWh7ftn9WtMhifpZAhfZxE+l9XtMPHakkv14O/YFblz+jWiCRDti5ozlC/uUH5e/L20tp82hiKhzMmhzqaIGgBA70D4AvDQsD+e/cEWnmgVqWo4rEyMdH5CRwdlKhbWafHFH20j9cAcJjxawtcseqPHqWhobWAP79TEoilB0xDRRVH7OA69nL53vGOgrdFnzdiK0O9QZwHrL+qeRZboRhjJxrBGDYthzZ6D9Um1/bjQSO7H2hnDDZcWlYzGHTaY91QISUOZ3MweO1f6wYWvYPXvXX9fLhe5gxC+uWJC5nSd4J2yP4c8vuY/4rd6uK7M7B5tc38RshMdMgrC13b+tb+vXi/viM/1zxiRUF3LfY2i1w8BN5U3kab/sbpRF+/4eIs9T1cwrfapu/Dcaf1vgi0J5Lyr7lO/p8N30TIRbO3H5jLRB88zjmEBvMAADAYIXwAelDn6fGr+w9cbZ/Q5sqptM+5THKHkZ3DWjzKyXzOGzMJ3gpblnke//OU/ezRv8jgYjmKRBkyqvWhsL5k0jrbN4X+aZ7j/3uqM6MeLmPZ4M+OsXcbsOTGg/zbhfdMIX3akkVomXw0N17QLChbDOrXw/X2HDq/bYbhBeYE5eywXIDZDPJ0Y4gsoaYWvtyClLkz4sGPI1PdNIzwimIQv97TquHXl/q0Tcg1lPALPrRjTaj9IIninbMI32NOvi7jrqpc4yDh3Te1Q4b0vHtlcxSMEJOy9rW0tyCp8nSmaz+/S/sGeGB+WsFlxzebBOl+MlO/ZCo/1CT4P0MPaBYZx6uR2o6JXTfqVljT9jyW8U8uo482c4T3g9+3o895d0dHHddr6pnqUVUGswPI7+KTxbNvajy0unNHhjwx93QfCF4DBAOELwANiP+y/d6TRp+/DMhp6ziQ9l6FibzaFMVf2jzjSBaRGMxRY8cLXYDB/V1fWBbqh/NcKf+4/o8lEmm7HgPaxHMUShEx+rNBhRDBUqBCc0bimnet5T/WSbjxGvclWgTw0tL3JApYQ6MlaJMFX44tWd3Eww07QB+EbhDa2rqh+sBP0o5wahpoye+1j1jeE0ex7iVMLX0P9eYslpszfqjAX6Im5OgxS+NoiEazv2zfhayoXkqbdIzibtH98Qg1lMaH5PZwHzKHn/NnU8mxeub2nS+md7AgXluAtbN/ERTt9kS4WW1sLMgrf2cD7KBfupvjY8Os3+OyiShu/y99pns1GlQpvZuipXwcyMWE0uZVoXy2k17SnV4rIwy/tei6Va9o8Kvi2Y15MS9P/OouOfoLFQmfBloV4J2d4d3JrVKpqESoMyyLo9DYdsrk/RNZNbMI0S/utHij13KqKOlPG8PdNQwRIm5IyF0H4AjAYIHwBeCicdU1s9Zvo8UbZvLNCEL9ap0Ini7PluvHXzB6aqBvOXEj4sPssRfZnpYMbYpHzfiXXZ35oL9+T1cbsVR86kSObBP7xLuwzybUiBtIwAOH7aHqO5p/p4Zjcq5W4v9eZoY3gLE6FW3lu5wwtyggBY0IlNby7fVxI7uNJULZ5XCNX/D66mCHPKlbr84SKFkOc99f+Ct+H8/iayoV0JXw9+L3UejDPK/byTFwanqGzv1fN7D6awlfuWVU8rjLRntaOcv4N80K0f/cf69nEMeheXOn51BKVpcLW5qn630ualftltc/Zmd9ZolTkEW4Gge/tX3/F93w7OV303tPlNZ83m+WYJGvG9uOLqDJ6RB0fceNJ7Y8QvgAMBghfAB4IbiAPCM0gYYYeS/qTgpJLldqVML5rVFI+j08K1LvwffpBMYB8eCgqFxHp0Q2xl5TXvdFWbuhwK0UI9ZAwZrjVEaLwc9azh5lhJ0gQNVEBlJANWCH4nUTuM2ffi2fvnPkrvdhJCx3XZ3To7lD+1QzlIiI7ivMs9Losv5f9eo/2v+2G76ovLhzvWj3SfFwrIofRnfBNBYSv+RnkQmNTtIeyYJFV+PI+KWAi0dbWApvwZVmLb+jy3L+meP5i4DUUQndVm0fV+waicIJyf+nHPMVgmg8yCX0FW5sb+l/qo7rUdzSc09z4op/5K8fxChVjvb7/o8Yn+TtRV3+KOZO1ny9yDXubL39sU860YGgQvmqCNCmk5ZFI6viA8AXgYYHwBeAh+H2d3B9Rz03/qZH77rfgvszQGwQDEL6R83gje836JXwl0iAqU10LD1a5PK7QRi6jgBwCzrzpWJjwmTMlpenQs/Dtov2NdNpKCGlN9DZl6KAzSbN/C6NfM2R7ITyC5CUV2V5Oud/Q3v4m4bvoasa+Zlj3VfjKI30+thel3B+qCOiX8P2Nlj+q4a5aNERCH+Gk7B8W4WvF+AwT5GjiJZvwjQpbU1ur3weYrvNkjdxT83j1nl/JIC+3VEjBGCkn0NvHC/mVC5S2sSCPpat2EplpDEH4Zu7PFjrv/fjFEuU/VOjo1HBdGaLtVsNw+vMKrb7eoUojWu/qFpHoucUC6TH2InyiGaA9vLwEWr4M8Zk8Eqmbd4bwBWAwQPgC8AsxfOHbJ5yptieusE6zJoNtAEgv4GJ+J/Bsb7yZoedDuncvyOduey0F71dSeTz7BTPwBiJ8xfspiWOaQpyqyX2c3Ca59X4Y1mEyHRlCysS/KYGYglEM6UnIGGf0OdhrHkW9XrL3VT/iSiV5n2SbJOEr6jkurFbMAen3vQ9T+EZ5UOHL9h1zWkKg5ZnAkkmZtAVAD9Gm1gWtSXo+s0Ib/vxVLG7S8kx4ZvtQGLjwnaBc0Zwno1lTxL3MAVGt0ta0qbwpn4MQ1KtC/CqLB2rIM9tz3UFGgbzlC4Wd/dPdvDOELwCDAcIXgF8IZuhdnylem+5pqHukBiV8wU8BM/A88RGfDTg927SsHHPiZQSOybrqPFvwvECH9TO69L2swXNpME+sT/O4TBuKSHy8WqaG59W8IjfBa2oWQxbBJj1Sf5n2FIc8fb0d1MPWa0PSLY2npr3qgubXmL2KjGTh+8ixRFmI93EzhdNr9aKGuKseS5vwVct34XVOFL5P/lCSD/UgGo0CWtk3Lr2wtQoV80tscc0TWKJO6wd7tCoErpdtWU0GlrpNHwiD8FX7cy+EY0FJUOd7s5djF/umqFDz6/2iTsV5e1kv0Zeob3VfuAfLRC3GiBJR8/iVaCP5N7FzJJb4jM0JhrDtAKXPQ/gCMBggfAH4hVj9pIjWT7YD+rMxiGuCn5NcoRL2BVum137gCCHSTeh2L0wLgz3Fvm51v7AqlmbfKYa79MQPyvs2s0P7ov4rrn+vwrohmVgcM1T4Fo7p/YIp0ZhapuplZS9ooi0d/F7q2dCsvoJjkOzlH82th+X1zPAWhjZ3vXXD+/hJ1eTnTn6XSvk5ez94Mhn9zplq960XPFHTSOL3xfZ7q1n0+4xo+403GcbT3A65H5bSlXdEG+gLbJ02sI0rZ4W2tsLs+eq8aB5PbdT+aDonHQDQOxC+AAAAAAAAAADGGghfAAAAAAAAAABjDYQvAAAAAAAAAICxBsIXAAAAAAAAAMBYA+ELAAAAAAAAAGCsgfAFAAAAAAAAADDWQPgCAAAAAAAAABhrIHwBAAAAAAAAAIw1EL4AAAAAAAAAAMYaCF8AAAAAAAAAAGMNhC8AAAAAAAAAgLEGwhcAAAAAAAAAwFgD4QsAAAAAAAAAYKyB8AUAAAAAAAAAMNZA+AIAAAAAAAAAGGsgfAEAAAAAAAAAjDUQvgAAAAAAAAAAxhoIXwAAAAAAAAAAYw2ELwAAAAAAAACAsQbCFwAAAAAAAADAWAPhCwAAAAAAAABgrIHwBQAAAAAAAAAwxvyL/h8TcQVZjrUQTAAAAABJRU5ErkJggg==" width="958" height="70" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="132-处理器状态">1.3.2 处理器状态<a class="hash-link" href="#132-处理器状态" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748442284729" src="/assets/images/1748442284729-03e1806c758b89bdfeff3da6b7f0bbb8.png" width="963" height="246" class="img_ev3q"></p><p><img loading="lazy" alt="1748442306497" src="/assets/images/1748442306497-eb7f3c32af04c5b88f984d706da9ba01.png" width="870" height="1525" class="img_ev3q"></p><p><img loading="lazy" alt="1748442324665" src="/assets/images/1748442324665-e7c37d5e554caf7ea53d39a826d2b46a.png" width="874" height="451" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="133-特殊寄存器">1.3.3 特殊寄存器<a class="hash-link" href="#133-特殊寄存器" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748442365618" src="/assets/images/1748442365618-8d8f1a96310af877559281ace3a9886b.png" width="969" height="745" class="img_ev3q"></p><p><img loading="lazy" alt="1748442387825" src="/assets/images/1748442387825-c4bfad60a6054cf54f0e2094972f5a4a.png" width="967" height="1636" class="img_ev3q"></p><p><img loading="lazy" alt="1748442414585" src="/assets/images/1748442414585-c241f0ee2c0769d84e391a8d37bfe848.png" width="1605" height="432" class="img_ev3q"></p><p><img loading="lazy" alt="1748442438046" src="/assets/images/1748442438046-2c327bd7d917e9d80884cef302bcd42d.png" width="895" height="1396" class="img_ev3q"></p><p><img loading="lazy" alt="1748443038602" src="/assets/images/1748443038602-26deb7ce76d20d8b98ac55919ed239d2.png" width="969" height="1420" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="134-系统寄存器">1.3.4 系统寄存器<a class="hash-link" href="#134-系统寄存器" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443075992" src="/assets/images/1748443075992-42f91fc46cf00360df7e4a295a7a503e.png" width="964" height="1174" class="img_ev3q"></p><h1>1.4 A64指令集</h1><p><img loading="lazy" alt="1748443145512" src="/assets/images/1748443145512-52d837c51e888d324e28194149f259f8.png" width="964" height="1402" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="141-常用的算术和搬移指令">1.4.1 常用的算术和搬移指令<a class="hash-link" href="#141-常用的算术和搬移指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443215469" src="/assets/images/1748443215469-cc7a7d51ee6f77667336a3aabe9ff38b.png" width="963" height="1507" class="img_ev3q"></p><p><img loading="lazy" alt="1748443241659" src="/assets/images/1748443241659-3085f842c007ffb93d640b1d6fd869bd.png" width="963" height="729" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="142-乘法和除法指令">1.4.2 乘法和除法指令<a class="hash-link" href="#142-乘法和除法指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443284574" src="/assets/images/1748443284574-535b6db7fd69dc18b9486e21af479dd9.png" width="966" height="1555" class="img_ev3q"></p><p><img loading="lazy" alt="1748443308304" src="/assets/images/1748443308304-b657ebe82f33b651865b1fb2b7d736db.png" width="964" height="1537" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="143-移位操作指令">1.4.3 移位操作指令<a class="hash-link" href="#143-移位操作指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443343192" src="/assets/images/1748443343192-9cd43854453d926081ec6f5a18f904f7.png" width="963" height="1131" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="144-位操作指令">1.4.4 位操作指令<a class="hash-link" href="#144-位操作指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443375966" src="/assets/images/1748443375966-bfb38b3eb5cb8ed1c0547d46fe520388.png" width="963" height="1564" class="img_ev3q"></p><p><img loading="lazy" alt="1748443392795" src="/assets/images/1748443392795-5834bab5cd4adfc86fb0f9ee26a4f672.png" width="967" height="1026" class="img_ev3q"></p><p><img loading="lazy" alt="1748443427801" src="/assets/images/1748443427801-8d92b7a91df069f5f2d905589db0bb83.png" width="970" height="1371" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="145-条件操作">1.4.5 条件操作<a class="hash-link" href="#145-条件操作" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443462628" src="/assets/images/1748443462628-47ffdd51145072a7cf2d81fb5c0ff0f3.png" width="970" height="1740" class="img_ev3q"></p><p><img loading="lazy" alt="1748443495557" src="/assets/images/1748443495557-05efc3c90d5d13f16abbc0269012d27e.png" width="960" height="960" class="img_ev3q"></p><p><img loading="lazy" alt="1748443557687" src="/assets/images/1748443557687-0270ea842985a613daa5b52f53e8e808.png" width="964" height="516" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="146-内存加载指令">1.4.6 内存加载指令<a class="hash-link" href="#146-内存加载指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443625690" src="/assets/images/1748443625690-76974b8958515632bdbb45d89accd1c3.png" width="967" height="1276" class="img_ev3q"></p><p><img loading="lazy" alt="1748443643717" src="/assets/images/1748443643717-eeb8b8eb36f063b604763d3734de8223.png" width="963" height="543" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1]  //内存地址为X1寄存器的值，加载此内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1, #8] //内存地址为X1寄存器的值+8，加载此内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1, X2] //内存地址为X1寄存器的值+X2寄存器的值，加载此内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0,[X1, X2, LSL #3] //内存地址为X1寄存器的值+(X2寄存器的值&lt;&lt;3), 加载此内存地址的值到X0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1, W2, SXTW] //先对W2的值做有符号的扩展，和X1寄存器的值相加后，将结果作为内存地址，加载//此内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1, W2, SXTW #3] //先对W2的值做有符号的扩展，然后左移3位，和X1寄存器的值相加后，将结果//作为内存地址，加载此内存地址的值到X0寄存器</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1748443666462" src="/assets/images/1748443666462-df00bfd24b9e2d2a20014d238e2e3f40.png" width="960" height="327" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0,  [X1, #8]! //前变基模式。先更新X1寄存器的值为X1寄存器的值+8，然后以新的X1寄存器的值为</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//内存地址，加载该内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1], #8  //后变基模式。以X1寄存器的值为内存地址，加载该内存地址的值到X0寄存器，然后更新</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">//X1寄存器的值为X1寄存器的值+8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">STP X0, X1, [SP, #-16]!  //把X0和X1寄存器的值压回栈中</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDP X0, X1, [SP], #16  //把X0和X1寄存器的值弹出栈</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1748443706815" src="/assets/images/1748443706815-9b4288c5eea3e426204d8d5306306a07.png" width="967" height="343" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0，=&lt;label&gt; //从label标记的地址处加载8字节到X0寄存器</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1748443724491" src="/assets/images/1748443724491-9ae5456fdaa1483a481b56d6b0066b02.png" width="966" height="124" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/kernel/head.S&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1    __primary_switch:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2        adrp  x1, init_pg_dir</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3        bl  __enable_mmu</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5        ldr  x8, =__primary_switched</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6        adrp  x0, __PHYS_OFFSET</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">7        br  x8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">8    ENDPROC(__primary_switch)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1748443753811" src="/assets/images/1748443753811-7898be015829579fa35459241c323b88.png" width="967" height="367" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1, #8] //内存地址为X1寄存器的值+8，加载此内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0,  [X1, #8]! //前变基模式。先更新X1寄存器的值为X1寄存器的值+8，然后以新的值为内存地址，加载#该内存地址的值到X0寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDR X0, [X1], #8  //后变基模式。以X1寄存器的值为内存地址，加载该内存地址的值到X0寄存器，然后更新#X1寄存器的值为X1寄存器的值+8</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1748443778897" src="/assets/images/1748443778897-3ec2151d647461996d1f370cb4837e9a.png" width="966" height="124" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="147-多字节内存加载和存储指令">1.4.7 多字节内存加载和存储指令<a class="hash-link" href="#147-多字节内存加载和存储指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443879501" src="/assets/images/1748443879501-d48f164855058444c188bda5ba3db738.png" width="969" height="202" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">LDP X3, X7, [X0]  //以X0寄存器的值为内存地址，加载此内存地址的值到X3寄存器；然后以X0寄存器的值+8  #为内存地址，加载此内存地址的值到X7寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">LDP X1, X2, [X0, #0x10]！  //前变基模式。先计算X0 = X0 + 0x10，然后以X0寄存器的值为内存地址，  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#加载此内存地址的值到X1；然后以X0寄存器的值+8为内存地址，加载此内存地址的值到X2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">STP X1, X2, [X4] //存储X1寄存器的值到地址为X4寄存器的值的内存中，然后存储X2寄存器的值到地址为X4  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#寄存器的值+8的内存中</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="148-非特权访问级别的加载和存储指令">1.4.8 非特权访问级别的加载和存储指令<a class="hash-link" href="#148-非特权访问级别的加载和存储指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748443983801" src="/assets/images/1748443983801-85b44ac68dfc3c3e882196427abc7d77.png" width="966" height="952" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="148-内存屏障指令简介">1.4.8 内存屏障指令简介<a class="hash-link" href="#148-内存屏障指令简介" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748444031423" src="/assets/images/1748444031423-96e09a2aea39be859d7a4201101fe625.png" width="970" height="1407" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1410-独占内存访问指令">1.4.10 独占内存访问指令<a class="hash-link" href="#1410-独占内存访问指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748444076083" src="/assets/images/1748444076083-bc14eeaa8b4b9be03722cef3eea2c526.png" width="966" height="1051" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1411-跳转与比较指令">1.4.11 跳转与比较指令<a class="hash-link" href="#1411-跳转与比较指令" title="标题的直接链接">​</a></h2><p><img loading="lazy" alt="1748444115544" src="/assets/images/1748444115544-cfcac1203214b29e496675ae31166150.png" width="954" height="1572" class="img_ev3q"></p><p><img loading="lazy" alt="1748444133831" src="/assets/images/1748444133831-9ab205f0a42451936150a7f393c3cb3a.png" width="967" height="1447" class="img_ev3q"></p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt; arch/arm64/kernel/entry.S &gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ENTRY(ret_from_fork)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   bl      schedule_tail            //跳转到schedule_tail函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   cbz     x19, 1f                  //判断x19是否为0，若为0，说明当前线程不是一个内核线程</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   mov     x0, x20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   blr     x19                      //若是内核线程，则跳转到x19指定的地址</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1:      get_thread_info tsk</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   b       ret_to_user              //跳转到ret_to_user函数</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ENDPROC(ret_from_fork)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，cmp指令常常用来比较两个数的大小，它内部使用SUBS指令来完成，最终结果会影响PSTATE寄存器中的C标志位。例如，下面这条CMP指令中，通过x1+NOT(x2)+1来进行计算，其中NOT(x2)表示对x2取反。如果计算结果发生了无符号数溢出，那么C标志位置1，否则C标志位为0。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">cmp x1, x2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在汇编代码中，cmp指令常常和跳转指令搭配使用。另外，cmp指令也可以和带进位的加法指令（adc指令）或者带进位的减法指令（sbc指令）一起使用，此时需要考虑C标志位。下面给出一段示例代码。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.global compare_and_return</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compare_and_return:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cmp x0, x1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sbc x0, xzr, xzr</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>compare_and_return汇编函数通过X0和X1寄存器传递两个参数，最终结果会通过X0寄存器来返回。上述代码示例可以分成如下两种情况来考虑。</p><ul><li>当X0寄存器中的值大于或等于X1寄存器中的值时，cmp指令会影响C标志位，因为C=1，所以X0 寄存器中的值= 0 − 0 −1 +1 = 0，最终结果变成0。</li><li>当X0寄存器中的值小于X1寄存器中的值时，cmp指令也会影响C标志位，因为C=0，所以X0寄存器中的值= 0 − 0 −1 −0 = −1，使用无符号数来表示则变成0xFFFF FFFF FFFF FFFF。</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1412异常处理指令">1.4.12　异常处理指令<a class="hash-link" href="#1412异常处理指令" title="标题的直接链接">​</a></h2><p>A64指令集支持多个异常处理指令，如表1.20所示。</p><p><img loading="lazy" alt="1749477212299" src="/assets/images/1749477212299-d059fd3d84ca81c0cee882c3c92435cb.png" width="984" height="819" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1413系统寄存器访问指令">1.4.13　系统寄存器访问指令<a class="hash-link" href="#1413系统寄存器访问指令" title="标题的直接链接">​</a></h2><p>在ARMv7架构中，通过访问CP15协处理器来访问系统寄存器，而在ARMv8架构中访问方式进行了大幅改进和优化。通过MRS和MSR两条指令可以直接访问系统寄存器，如表1.21所示。</p><p><img loading="lazy" alt="1749477283181" src="/assets/images/1749477283181-a015c44ff4ff52c2ea4d896ef0f2c5f4.png" width="1000" height="277" class="img_ev3q"></p><p>要访问系统特殊寄存器，指令如下。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">MRS X4, ELR_EL1   //读取ELR_EL1寄存器的值到X4寄存器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MSR SPSR_EL1, X0  //把X0寄存器的值更新到SPSR_EL1寄存器</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>ARMv8架构支持7类系统寄存器，下面以系统控制寄存器（System Control Register，SCTLR）为例。要访问系统寄存器，指令如下。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mrs  x20, sctlr_el1   //读取SCTLR_EL1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">msr  sctlr_el1, x20   //设置SCTLR_EL1</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>SCTLR_EL1可以用来设置很多系统属性，如系统大/小端等。我们可以使用MRS和MSR指令来访问系统寄存器。</p><p>除了访问系统寄存器之外，还能通过MSR和MRS指令来访问与PSTATE寄存器相关的字段，这些字段可以看作特殊用途的系统寄存器<!-- -->[12]<!-- -->，如表1.22所示。</p><p><img loading="lazy" alt="1749477604044" src="/assets/images/1749477604044-8e9d928777e66a83a76725525103a3eb.png" width="993" height="507" class="img_ev3q"></p><p>在Linux内核代码中使用如下指令来关闭本地处理器的中断。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/assembler.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.macro disable_daif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    msr     daifset, #0xf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.endm</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.macro enable_daif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     msr     daifclr, #0xf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.endm</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>disable_daif宏用来关闭本地处理器中PSTATE寄存器中的DAIF功能，也就是关闭处理器调试、系统错误、IRQ以及FIQ。而enable_daif宏用来打开上述功能。</p><p>下面是一个设置SP寄存器和获取当前异常等级的例子，代码实现在arch/arm64/kernel/ head.S汇编文件中。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/kernel/head.S&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ENTRY(el2_setup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Msr SPsel, #1            //设置SP寄存器，使用SP_EL1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mrs x0, CurrentEL        //获取当前异常等级</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cmp x0, #CurrentEL_EL2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    b.eq    1f</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>1.5　GCC内联汇编</h1><p>在Linux内核代码中常常会使用到GCC内联汇编，GCC内联汇编的格式如下。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">__asm__ __volatile__(指令部: 输出部: 输入部: 损坏部)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>GCC内联汇编在处理变量和寄存器的问题上提供了一个模板和一些约束条件。</p><p>在指令部（AssemblerTemplate）中数字前加上%，如%0、%1 等，表示需要使用寄存器的样板操作数。若指令部用到了几个不同的操作数，就说明有几个变量需要和寄存器结合。</p><p>指令部后面的输出部（OutputOperands）用于描述在指令部中可以修改的C语言变量以及约束条件。每个输出约束（constraint）通常以“=”或者“+”号开头，然后是一个字母（表示对操作数类型的说明），接着是关于变量结合的约束。输出部可以是空的。“=”号表示被修饰的操作数只具有可写属性，“+”号表示被修饰的操作数只具有可读可写属性。</p><p>输入部（InputOperands）用来描述在指令部只能读取的C语言变量以及约束条件。输入部描述的参数只有只读属性，不要试图修改输入部的参数内容，因为GCC编译器假定输入部的参数内容在内嵌汇编之前和之后都是一致的。在输入部中不能使用“=”或者“+”约束条件，否则编译器会报错。另外，输入部可以是空的。</p><p>损坏部（Clobbers）一般以“memory”结束。“memory”告诉GCC编译器，内联汇编代码改变了内存中的值，强迫编译器在执行该汇编代码前存储所有缓存的值，在执行完汇编代码之后重新加载该值，目的是防止编译乱序。“cc”表示内嵌代码修改了状态寄存器的相关标志位。</p><p>下面先看一个简单的例子，即arch_local_irq_save()函数的实现。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/irqflags.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline unsigned long arch_local_irq_save(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asm volatile(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;mrs    %0, daif         //读取PSTAT寄存器中的DAIF域到flags变量</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        &quot;msr    daifset, #2&quot;     //关闭IRQ</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : &quot;=r&quot; (flags)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        :</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        : &quot;memory&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>先看输出部，%0操作数对应&quot;=r&quot; (flags)，即flags变量，其中“=”表示被修饰的操作数的属性是只写，“r”表示使用一个通用寄存器。</p><p>接着看输入部，在上述例子中，输入部为空，没有指定参数。</p><p>最后看损坏部，以“memory”结束。</p><p>该函数主要用于把PSTATE寄存器中的DAIF域保存到临时变量flags中，然后关闭IRQ。</p><p>在输出部和输入部使用%来表示参数的序号，如%0表示第1个参数，%1表示第2个参数。为了增强代码可读性，可以使用汇编符号名字来替代以%表示的操作数，如下面的add()函数。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int add(int i, int j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    asm volatile (</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    &quot;add %w[result], %w[input_i], %w[input_j]&quot;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    : [result] &quot;=r&quot; (res)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    : [input_i] &quot;r&quot; (i), [input_j] &quot;r&quot; (j)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return res;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述是一个很简单的GCC内联汇编的例子，主要功能是把参数i的值和参数j的值相加，最后返回结果。</p><p>先看输出部，其中只定义了一个操作数。“<!-- -->[result]<!-- -->”表示定义了一个汇编符号操作数，符号名字为result，它对应&quot;=r&quot; (res)，使用了函数中定义的res变量。在汇编代码中对应%w<!-- -->[result]<!-- -->，其中w表示ARM64中的32位通用寄存器。</p><p>再看输入部，其中定义了两个操作数。同样使用汇编符号操作数的方式来定义。第一个汇编符号操作数是input<em>i，对应的是函数形参i；第二个汇编符号操作数是input</em> j，对应的是函数形参j。</p><p>GCC内联汇编操作符和修饰符如表1.23所示。</p><p><img loading="lazy" alt="1749479155494" src="/assets/images/1749479155494-b6630d0d41a327fe28a49f97af922fd6.png" width="988" height="327" class="img_ev3q"></p><p>ARM64架构中特有的操作符和修饰符如表1.24所示。</p><p><img loading="lazy" alt="1749479229085" src="/assets/images/1749479229085-d5b2080b8f1ee15c2a37e131d9b51653.png" width="982" height="1203" class="img_ev3q"></p><h1>1.6　函数调用标准和栈布局</h1><p>函数调用标准（Procedure Call Standard，PCS）用来描述父/子函数是如何编译、链接的，特别是父函数和子函数之间调用关系的约定，如栈的布局、参数的传递等。每个处理器架构都有不同的函数调用标准，本章重点介绍ARM64的函数调用标准。</p><p>ARM公司有一份描述ARM64架构函数调用的标准和规范文档，这份文档是《Procedure Call Standard for ARM 64-Bit Architecture》。</p><p>ARM64架构的通用寄存器如表1.25所示。</p><p><img loading="lazy" alt="1749479410978" src="/assets/images/1749479410978-0958882b6478139ed539079cffb8bc17.png" width="991" height="904" class="img_ev3q"></p><p>假设函数调用关系是main()→func1()→func2()，图1.31所示为栈的布局。</p><p><img loading="lazy" alt="1749479639944" src="/assets/images/1749479639944-3c1e2bdfd25a2a0d0a10d2a3ebb245ea.png" width="1206" height="1143" class="img_ev3q"></p><p>▲图1.31　栈的布局</p><p>ARM64架构的函数栈布局的关键点如下。</p><p>所有的函数调用栈都会组成一个单链表。</p><p>每个栈由两个地址来构成这个链表，这两个地址都是64位宽的，并且它们都位于栈的底部。</p><p>低地址存放：指向上一个栈帧（父函数的栈帧）的栈基地址FP，类似于链表的prev指针。本书把这个地址称为P_FP（Previous FP），以区别于处理器内部的FP寄存器。</p><p>高地址存放：当前函数的返回地址，也就是进入该函数时LR的值，本书把这个地址称为P_LR（Previous LR）。</p><p>处理器的FP和SP寄存器相同。在函数执行时FP和SP寄存器会指向该函数栈空间的FP处，即栈底。</p><p>函数返回时，ARM64处理器先把栈中的P_LR的值载入当前LR寄存器，然后再执行ret指令。</p><h1>1.7　ARM64异常处理</h1><p>在ARM64架构里，中断属于异常的一种。中断是外部设备通知处理器的一种方式，它会打断处理器正在执行的指令流。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="171异常类型">1.7.1　异常类型<a class="hash-link" href="#171异常类型" title="标题的直接链接">​</a></h2><p>本节介绍异常的类型。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1中断">1．中断<a class="hash-link" href="#1中断" title="标题的直接链接">​</a></h3><p>在ARM处理器中，中断请求分成中断请求（Interrupt Request，IRQ）和快速中断请求（Fast Interrupt Request，FIQ）两种，其中FIQ的优先级要高于IRQ。在芯片内部，分别有连接到处理器内部的IRQ和FIQ两根中断线。通常系统级芯片内部会有一个中断控制器，众多的外部设备的中断引脚会连接到中断控制器，由中断控制器来负责中断优先级调度，然后发送中断信号给ARM处理器，中断模型如图1.32所示。</p><p><img loading="lazy" alt="1749480351410" src="/assets/images/1749480351410-d6c73e3552d2bf563065e29cef7b5760.png" width="958" height="369" class="img_ev3q"></p><p>▲图1.32　中断模型</p><p>外设中发生了重要的事情之后，需要通知处理器，中断发生的时刻和当前正在执行的指令无关，因此中断的发生时间点是异步的。对于处理器来说，这常常是猝不及防的，但是又不得不停止当前执行的代码来处理中断。在ARMv8架构中，中断属于异步模式的异常。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2中止">2．中止<a class="hash-link" href="#2中止" title="标题的直接链接">​</a></h3><p>中止主要有指令中止（instruction abort）和数据中止（data abort）两种，它们通常是指访问外部存储单元时候发生了错误，处理器内部的MMU捕获这些错误并且报告给处理器。</p><p>指令中止是指当处理器尝试执行某条指令时发生的错误。而数据中止是指使用加载或者存储指令读写外部存储单元时发生的错误。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3复位">3．复位<a class="hash-link" href="#3复位" title="标题的直接链接">​</a></h3><p>复位（reset）操作是优先级最高的一种异常处理。复位操作通常用于让CPU复位引脚产生复位信号，让CPU进入复位状态，并重新启动。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4软件产生的异常">4．软件产生的异常<a class="hash-link" href="#4软件产生的异常" title="标题的直接链接">​</a></h3><p>ARMv8架构中提供了3种软件产生的异常。这些异常通常是指软件想尝试进入更高的异常等级而造成的错误。</p><p>SVC指令：允许用户模式的程序请求操作系统服务。</p><p>HVC指令：允许客机（guest OS）请求主机服务。</p><p>SMC指令：允许普通世界（normal world）中的程序请求安全监控服务。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="172同步异常和异步异常">1.7.2　同步异常和异步异常<a class="hash-link" href="#172同步异常和异步异常" title="标题的直接链接">​</a></h2><p>在ARMv8架构里把异常分成同步异常和异步异常两种。同步异常是指处理器需要等待异常处理的结果，然后继续执行后面的指令，如数据中止时我们知道发生数据异常的地址，并且在异常处理函数中修复这个地址。</p><p>常见的同步异常如下。</p><ul><li>尝试访问一个不恰当异常等级的寄存器。</li><li>尝试执行关闭或者没有定义（undefined）的指令。</li><li>使用没有对齐的SP。</li><li>尝试执行一个PC指针没有对齐的指令。</li><li>软件产生的异常，如执行SVC、HVC或SMC指令。</li><li>地址翻译或者权限等原因导致的数据异常。</li><li>地址翻译或者权限等原因导致的指令异常。</li><li>调试导致的异常，如断点异常、观察点异常、软件单步异常等。</li></ul><p>而中断发生时，处理器正在处理的指令和中断是完全没有关系的，它们之间没有依赖关系。因此，指令异常和数据异常称为同步异常，而中断称为异步异常。</p><p>常见的异步异常包括物理中断和虚拟中断。</p><p>物理中断分为3种，分别是系统错误、IRQ、FIQ。</p><p>虚拟中断分为3种，分别是vSError、vIRQ、vFIQ</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="173异常发生后的处理">1.7.3　异常发生后的处理<a class="hash-link" href="#173异常发生后的处理" title="标题的直接链接">​</a></h2><p>当一个异常发生时，CPU内核能感知异常发生，而且会对应生成一个目标异常等级（target exception level）。CPU会自动做如下一些事情<!-- -->[15]<!-- -->。</p><ul><li>把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx寄存器中。</li><li>把返回地址保存在对应目标异常等级的ELR中。</li><li>把PSTATE寄存器里的DAIF域都设置为1，相当于把调试异常、系统错误、IRQ以及FIQ都关闭了。PSTATE寄存器是ARM v8里新增的寄存器。</li><li>对于同步异常，要分析异常的原因，并把具体原因写入ESR_ELx寄存器。</li><li>设置SP，指向对应目标异常等级里的栈，自动切换SP到SP_ELx寄存器中。</li><li>从异常发生现场的异常等级切换到对应目标异常等级，然后跳转到异常向量表里执行。</li></ul><p>上述是ARMv8处理器检测到异常发生后自动做的事情。操作系统需要做的事情是从中断向量表开始，根据异常发生的类型，跳转到合适的异常向量表。异常向量表的每个项会保存一个异常处理的跳转函数，然后跳转到恰当的异常处理函数并处理异常。</p><p>当操作系统的异常处理完成后，执行一条eret指令即可从异常返回。这条指令会自动完成如下工作。</p><ul><li>从ELR_ELx寄存器中恢复PC指针。</li><li>从SPSR_ELx寄存器恢复处理器的状态。</li></ul><p>读者常常有这样的疑问，中断处理过程是关闭中断进行的，那中断处理完成后什么时候把中断打开呢？</p><p>当中断发生时，CPU会把PSTATE寄存器的值保存到对应目标异常等级的SPSR_ELx寄存器中，并且把PSTATE寄存器里的DAIF域都设置为1，这相当于把本地CPU的中断关闭了。</p><p>当中断处理完成后，操作系统调用eret指令返回中断现场，那么会把SPSR_ELx寄存器恢复到PSTATE寄存器中，这就相当于把中断打开了。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/shaozongfan/shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/奔跑吧linux/调试与案例分析/6、安全漏洞分析面试题"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">1．请简述高速侧信道攻击的原理。</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">第2章  ARM64在linux内核中的实现</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#111精简指令集和复杂指令集" class="table-of-contents__link toc-highlight">1.1.1　精简指令集和复杂指令集</a></li><li><a href="#112大小端字节序" class="table-of-contents__link toc-highlight">1.1.2　大/小端字节序</a></li><li><a href="#113一条存储读写指令的执行全过程" class="table-of-contents__link toc-highlight">1.1.3　一条存储读写指令的执行全过程</a></li><li><a href="#114内存屏障产生的原因" class="table-of-contents__link toc-highlight">1.1.4　内存屏障产生的原因</a></li><li><a href="#115高速缓存的工作方式" class="table-of-contents__link toc-highlight">1.1.5　高速缓存的工作方式</a></li><li><a href="#116高速缓存的映射方式" class="table-of-contents__link toc-highlight">1.1.6　高速缓存的映射方式</a><ul><li><a href="#1直接映射" class="table-of-contents__link toc-highlight">1．直接映射</a></li><li><a href="#2组相联" class="table-of-contents__link toc-highlight">2．组相联</a></li></ul></li><li><a href="#117组相联的高速缓存" class="table-of-contents__link toc-highlight">1.1.7　组相联的高速缓存</a></li><li><a href="#118pipt和vivt的区别" class="table-of-contents__link toc-highlight">1.1.8　PIPT和VIVT的区别</a><ul><li><a href="#1物理高速缓存" class="table-of-contents__link toc-highlight">1．物理高速缓存</a></li><li><a href="#2虚拟高速缓存" class="table-of-contents__link toc-highlight">2．虚拟高速缓存</a></li><li><a href="#3高速缓存的分类" class="table-of-contents__link toc-highlight">3．高速缓存的分类</a></li></ul></li><li><a href="#119页表的创建和查询过程" class="table-of-contents__link toc-highlight">1.1.9　页表的创建和查询过程</a></li><li><a href="#1110tlb" class="table-of-contents__link toc-highlight">1.1.10　TLB</a></li><li><a href="#1111mesi协议" class="table-of-contents__link toc-highlight">1.1.11　MESI协议</a></li><li><a href="#1112高速缓存伪共享" class="table-of-contents__link toc-highlight">1.1.12　高速缓存伪共享</a></li><li><a href="#1113-高速缓存在linux内核中的应用" class="table-of-contents__link toc-highlight">1.1.13 高速缓存在linux内核中的应用</a></li><li><a href="#1114-arm的大小核架构" class="table-of-contents__link toc-highlight">1.1.14 ARM的大/小核架构</a></li><li><a href="#1115-高速缓存一致性和一致性内存模型" class="table-of-contents__link toc-highlight">1.1.15 高速缓存一致性和一致性内存模型</a></li><li><a href="#1116-高速缓存一致性和一致性内存模型" class="table-of-contents__link toc-highlight">1.1.16 高速缓存一致性和一致性内存模型</a></li><li><a href="#1117-numa" class="table-of-contents__link toc-highlight">1.1.17 NUMA</a></li><li><a href="#1118-arm处理器设计" class="table-of-contents__link toc-highlight">1.1.18 ARM处理器设计</a></li><li><a href="#1119-最新进展" class="table-of-contents__link toc-highlight">1.1.19 最新进展</a></li><li><a href="#121-armv8-a架构" class="table-of-contents__link toc-highlight">1.2.1 ARMv8-A架构</a></li><li><a href="#122-采用armv8架构的常见处理器内核" class="table-of-contents__link toc-highlight">1.2.2 采用ARMv8架构的常见处理器内核</a></li><li><a href="#123-armv8架构中的基本概念" class="table-of-contents__link toc-highlight">1.2.3 ARMv8架构中的基本概念</a></li><li><a href="#124-armv8处理器执行状态" class="table-of-contents__link toc-highlight">1.2.4 ARMv8处理器执行状态</a></li><li><a href="#125-armv8支持的数据宽度" class="table-of-contents__link toc-highlight">1.2.5 ARMv8支持的数据宽度</a></li><li><a href="#126-不对齐访问" class="table-of-contents__link toc-highlight">1.2.6 不对齐访问</a></li><li><a href="#131-通用寄存器" class="table-of-contents__link toc-highlight">1.3.1 通用寄存器</a></li><li><a href="#132-处理器状态" class="table-of-contents__link toc-highlight">1.3.2 处理器状态</a></li><li><a href="#133-特殊寄存器" class="table-of-contents__link toc-highlight">1.3.3 特殊寄存器</a></li><li><a href="#134-系统寄存器" class="table-of-contents__link toc-highlight">1.3.4 系统寄存器</a></li><li><a href="#141-常用的算术和搬移指令" class="table-of-contents__link toc-highlight">1.4.1 常用的算术和搬移指令</a></li><li><a href="#142-乘法和除法指令" class="table-of-contents__link toc-highlight">1.4.2 乘法和除法指令</a></li><li><a href="#143-移位操作指令" class="table-of-contents__link toc-highlight">1.4.3 移位操作指令</a></li><li><a href="#144-位操作指令" class="table-of-contents__link toc-highlight">1.4.4 位操作指令</a></li><li><a href="#145-条件操作" class="table-of-contents__link toc-highlight">1.4.5 条件操作</a></li><li><a href="#146-内存加载指令" class="table-of-contents__link toc-highlight">1.4.6 内存加载指令</a></li><li><a href="#147-多字节内存加载和存储指令" class="table-of-contents__link toc-highlight">1.4.7 多字节内存加载和存储指令</a></li><li><a href="#148-非特权访问级别的加载和存储指令" class="table-of-contents__link toc-highlight">1.4.8 非特权访问级别的加载和存储指令</a></li><li><a href="#148-内存屏障指令简介" class="table-of-contents__link toc-highlight">1.4.8 内存屏障指令简介</a></li><li><a href="#1410-独占内存访问指令" class="table-of-contents__link toc-highlight">1.4.10 独占内存访问指令</a></li><li><a href="#1411-跳转与比较指令" class="table-of-contents__link toc-highlight">1.4.11 跳转与比较指令</a></li><li><a href="#1412异常处理指令" class="table-of-contents__link toc-highlight">1.4.12　异常处理指令</a></li><li><a href="#1413系统寄存器访问指令" class="table-of-contents__link toc-highlight">1.4.13　系统寄存器访问指令</a></li><li><a href="#171异常类型" class="table-of-contents__link toc-highlight">1.7.1　异常类型</a><ul><li><a href="#1中断" class="table-of-contents__link toc-highlight">1．中断</a></li><li><a href="#2中止" class="table-of-contents__link toc-highlight">2．中止</a></li><li><a href="#3复位" class="table-of-contents__link toc-highlight">3．复位</a></li><li><a href="#4软件产生的异常" class="table-of-contents__link toc-highlight">4．软件产生的异常</a></li></ul></li><li><a href="#172同步异常和异步异常" class="table-of-contents__link toc-highlight">1.7.2　同步异常和异步异常</a></li><li><a href="#173异常发生后的处理" class="table-of-contents__link toc-highlight">1.7.3　异常发生后的处理</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1c06d183.js"></script>
<script src="/assets/js/main.63ebc7ad.js"></script>
</body>
</html>