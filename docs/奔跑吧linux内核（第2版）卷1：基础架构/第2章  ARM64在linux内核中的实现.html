<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-奔跑吧linux内核（第2版）卷1：基础架构/第2章 ARM64在linux内核中的实现">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">第2章  ARM64在linux内核中的实现 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="第2章  ARM64在linux内核中的实现 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="1．ARM64处理器中有两个页表基地址寄存器TTBR0和TTBR1，处理器如何使用它们？"><meta data-rh="true" property="og:description" content="1．ARM64处理器中有两个页表基地址寄存器TTBR0和TTBR1，处理器如何使用它们？"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ccca8cd0.css">
<link rel="preload" href="/assets/js/runtime~main.1c06d183.js" as="script">
<link rel="preload" href="/assets/js/main.63ebc7ad.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/AI相关/AI核心技能">AI相关</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">docs/intro.md</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/linux设备驱动开发详解/1.1　设备驱动的作用">linux设备驱动开发详解</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人博客/docusaurus2.4">个人博客</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人生活/2025国家生育政策8大补贴汇总">个人生活</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/人生哲学/人生的底层逻辑">人生哲学</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs">笔记本开篇序言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/奔跑吧linux/arm64体系结构编程与实践/A64指令集其他重要指令面试题">奔跑吧linux</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">奔跑吧linux内核（第2版）卷1：基础架构</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">第1章　处理器架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现">第2章  ARM64在linux内核中的实现</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第4章　物理内存与虚拟内存">第4章　物理内存与虚拟内存</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/网络/网络问题">网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/调试/Linux内核追踪神器：perf实现原理剖析">调试</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">奔跑吧linux内核（第2版）卷1：基础架构</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">第2章  ARM64在linux内核中的实现</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>第2章  ARM64在linux内核中的实现</h1></header><p>1．ARM64处理器中有两个页表基地址寄存器TTBR0和TTBR1，处理器如何使用它们？</p><p>2．请简述ARM64处理器的4级页表的映射过程，假设页面粒度为4KB，地址宽度为48位。</p><p>3．在L0～L2页表项描述符中，如何判断一个页表项是块类型还是页表类型？</p><p>4．在ARM64 Linux内核中，用户空间和内核空间是如何划分的？</p><p>5．在ARM64 Linux内核中，PAGE_OFFSET表示什么意思？</p><p>6．KIMAGE_VADDR表示什么意思？</p><p>7．TEXT_OFFSET表示什么意思？</p><p>8．内核映像文件包含哪些段？这些段的作用是什么？在Sysmtem.map文件中它们分别使用哪些符号来表示段的开始和结束？</p><p>9．请画出ARM64 Linux内核的内存布局。</p><p>10．__pasymbol()宏和<!-- -->_<!-- -->pa()宏有什么区别？</p><p>11．在物理内存还没有线性映射到内核空间时，内核映像文件映射到什么地方？</p><p>12．在ARM Linux内核中，kimage_voffset代表什么意思呢？</p><p>13．在ARMv8架构中，高速缓存管理的PoC和PoU有什么区别？</p><p>14．在ARMv8架构中，ASID是什么意思？有什么作用？</p><p>15．在ARMv8架构中支持哪几种内存属性？它们都有哪些特点？</p><p>16．在ARMv8架构中，高速缓存共享属性有内部共享（inner shareable）和外部共享（outer shareable），它们有什么区别？</p><p>17．在ARMv8架构中，支持哪几条内存屏障指令？它们都有什么区别？</p><p>18．加载-获取屏障原语与存储-释放屏障原语有什么区别？分别有什么作用？</p><p>19．什么是一个段的加载地址和运行地址？</p><p>20．从U-boot跳转到内核时，为什么指令高速缓存可以打开而数据高速缓存必须关闭？21．在Linux内核启动汇编代码中，为什么要建立恒等映射？</p><p>22．在ARMv8架构中，在L0～L2页表项中包含了指向下一级页表的基地址，那么这个下一级页表基地址是物理地址还是虚拟地址？</p><p>23．MMU可以遍历页表，Linux内核也提供了软件遍历页表的函数，如walk_pgd()、__create_pgd_mapping()、follow_page()等。从软件的视角，Linux内核的pgd_t、pud_t、pmd_t以及pte_t数据结构中并没有存储一个指向下一级页表的指针（即从CPU角度来看，CPU访问这些数据结构时是以虚拟地址来访问的），它们是如何遍历的呢？pgd_t、pud_t、pmd_t以及pte_t数据结构是u64类型的变量。</p><h1>2.1　ARM64内存管理</h1><p>如图2.1所示，ARM处理器内核的MMU包括TLB和页表遍历单元（Table Walk Unit）两个部件。TLB是一个高速缓存，用于缓存页表转换的结果，从而减少页表查询的时间。一个完整的页表翻译和查找的过程叫作页表查询，页表查询的过程由硬件自动完成，但是页表的维护需要软件来完成。页表查询是一个较耗时的过程，理想的状态下，TLB里应存有页表的相关信息。当TLB未命中时，MMU才会查询页表，从而得到翻译后的物理地址。而页表通常存储在主存储器中。得到物理地址之后，首先需要查询该物理地址的内容是否在高速缓存中有最新的副本。如果没有，则说明高速缓存未命中，需要访问主存储器。</p><p><img loading="lazy" alt="1750256228169" src="/assets/images/1750256228169-35f7b349df8bcb01efcb3074007ce2d1.png" width="1195" height="205" class="img_ev3q"></p><p>▲图2.1　ARM处理器的内存管理架构</p><p>对于多任务操作系统，每个进程都拥有独立的进程地址空间。这些进程地址空间在虚拟地址空间内是相互隔离的，但是在物理地址空间可能映射同一个物理页面，那么这些进程地址空间是如何映射到物理地址空间的呢？这就需要处理器的MMU提供页表映射和管理的功能。图2.2所示为进程地址空间和物理地址空间的映射关系，左边是进程地址空间视图，右边是物理地址空间视图。进程地址空间又分成内核空间（Kernel Space）和用户空间（User Space）。无论是内核空间还是用户空间都可以通过处理器提供的页表机制映射到实际的物理地址。</p><p><img loading="lazy" alt="1750256398876" src="/assets/images/1750256398876-59936803579409ffa50b736518e61a22.png" width="996" height="1015" class="img_ev3q"></p><p>▲图2.2　进程地址空间和物理地址空间的映射关系</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="211页表">2.1.1　页表<a class="hash-link" href="#211页表" title="标题的直接链接">​</a></h2><p>在AArch64架构中的MMU支持单一阶段的页表转换，同样也支持虚拟化扩展中两阶段的页表转换。</p><p>单一阶段的页表转换：把虚拟地址（VA）翻译成物理地址（PA）。</p><p>两阶段的页表转换：包括两个阶段。在阶段1，把虚拟地址翻译成中间物理地址（Intermediate Physical Address，IPA）；在阶段2，把IPA翻译成最终PA。</p><p>另外，ARMv8架构支持多种页表格式。具体如下。</p><p>ARMv8架构的长描述符页表格式（Long Descriptor Translation Table Format）。</p><p>ARMv7架构的长描述符页表格式，需要打开大物理地址扩展（Large Physical Address Extention，LPAE）。</p><p>ARMv7架构的短描述符页表格式（Short Descriptor Translation Table Format）。</p><p>当使用AArch32处理器时，使用ARMv7架构的短描述符页表格式或长描述符页表格式来运行32位的应用程序；当使用AArch64处理器时，使用ARMv8架构的长描述符页表格式来运行64位的应用程序。</p><p>另外，ARMv8架构还支持4KB、16KB或64KB这3种页面粒度。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="212页表映射">2.1.2　页表映射<a class="hash-link" href="#212页表映射" title="标题的直接链接">​</a></h2><p>在AArch64架构中，因为地址总线位宽最多支持48位，所以VA被划分为两个空间，每个空间最多支持256TB。</p><p>低位的虚拟地址空间位于0x0000 0000 0000 0000到0x0000 FFFF FFFF FFFF。如果虚拟地址的最高位等于 0，就使用这个虚拟地址空间，并且使用TTBR0_ELx来存放页表的基地址。</p><p>高位的虚拟地址空间位于0xFFFF 0000 0000 0000到0xFFFF FFFF FFFF FFFF。如果虚拟地址的最高位等于 1，就使用这个虚拟地址空间，并且使用TTBR1_ELx来存放页表的基地址。</p><p>AArch64架构中的页表支持如下特性。</p><ul><li>最多可以支持4级页表。</li><li>输入地址的最大有效位宽为48位。</li><li>输出地址的最大有效位宽为48位。</li><li>翻译的页面粒度可以是4KB、16KB或64KB。</li></ul><p>注意，本书以4KB大小的页面和48位地址宽度为例来说明AArch64架构页表映射的过程。当然，读者也可以在Linux内核中配置其他大小的页面粒度，如16KB、64KB等。</p><p>图2.3所示为AArch64架构的地址映射，其中页面是4KB的小页面。</p><p>当TLB未命中时，处理器查询页表的过程如下。</p><p>处理器根据页表基地址控制寄存器和虚拟地址来判断使用哪个页表基地址寄存器，是TTBR0还是TTBR1。当虚拟地址第63位（简称VA<!-- -->[63]<!-- -->）为1时选择TTBR1；当VA<!-- -->[63]<!-- -->为0时选择TTBR0。页表基地址寄存器中存放着1级页表（见图2.3中的L0页表）的基地址。</p><p>处理器将VA<!-- -->[47:39]<!-- -->作为L0索引，在1级页表（L0页表）中找到页表项，1级页表有512个页表项。</p><p>1级页表的页表项中存放着2级页表（L1页表）的物理基地址。处理器将VA<!-- -->[38:30]<!-- -->作为L1索引，在2级页表中找到相应的页表项，2级页表有512个页表项。</p><p><img loading="lazy" alt="image-20250618223555275" src="/assets/images/image-20250618223555275-f338241daed3f25aeffef3a4511ddaef.png" width="1417" height="883" class="img_ev3q"></p><p>▲图2.3　AArch64架构的地址映射</p><p>2级页表的页表项中存放着3级页表（L2页表）的物理基地址。处理器以VA<!-- -->[29:21]<!-- -->作为L2索引，在3级页表（L2页表）中找到相应的页表项，3级页表有512个页表项。</p><p>3级页表的页表项中存放着4级页表（L3页表）的物理基地址。处理器以VA<!-- -->[20:12]<!-- -->作为L3索引，在4级页表（L3页表）中找到相应的页表项，4级页表有512个页表项。</p><p>4级页表的页表项里存放着4KB页面的物理基地址，然后加上VA<!-- -->[11:0]<!-- -->，就构成了新的物理地址，因此处理器就完成了页表的查询和翻译工作。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="213页表项描述符">2.1.3　页表项描述符<a class="hash-link" href="#213页表项描述符" title="标题的直接链接">​</a></h2><p>从图2.3可知，AArch64架构页表分成4级页表，每一级页表都有页表项，我们把它们称为页表项描述符，每个页表项描述符占8字节，那么这些页表项描述符的格式和内容是否都一样？</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1l0l2页表项描述符">1．L0～L2页表项描述符<a class="hash-link" href="#1l0l2页表项描述符" title="标题的直接链接">​</a></h3><p>AArch64架构中L0～L3页表项描述符的格式不完全一样，其中L0～L2页表项的内容比较类似，如图2.4所示。</p><p><img loading="lazy" alt="1750257455943" src="/assets/images/1750257455943-2ca9d539227763087964b321f23611f4.png" width="1357" height="498" class="img_ev3q"></p><p>▲图2.4　L0～L2页表项描述符</p><p>L0～L2页表项根据内容可以分成3类，一是无效的页表项，二是块（block）类型的页表项，三是页表（table）类型的页表项。</p><p>当页表项描述符Bit<!-- -->[0]<!-- -->为1时，表示有效的描述符；当Bit<!-- -->[0]<!-- -->为0时，表示无效的描述符。</p><p>页表项描述符Bit<!-- -->[1]<!-- -->用来表示类型。</p><p>页表类型：当Bit<!-- -->[1]<!-- -->为1时，表示该描述符包含了指向下一级页表的基地址，是一个页表类型的页表项。</p><p>块类型：当Bit<!-- -->[1]<!-- -->为0时表示一个大内存块（memory block）的页表项，其中包含了最终的物理地址。大内存块通常是用来描述大的连续的物理内存，如2MB或者1GB大小的物理内存。</p><p>在块类型的页表项中，Bit<!-- -->[47:n]<!-- -->表示最终输出的物理地址</p><p>若页面粒度是4KB，在L1页表项描述符中n为30，表示1GB大小的连续物理内存。在L2页表项描述符中n为21，用来表示2MB大小的连续物理内存。</p><p>若页面粒度为16KB，在L2页表项描述符中n为25，用来表示32MB大小的连续物理内存。</p><p>在块类型的页表项中，Bit<!-- -->[11:2]<!-- -->是低位属性（lower attribute），Bit<!-- -->[63:52]<!-- -->是高位属性（upper attribute）。</p><p>在页表类型的页表项描述符中，Bit<!-- -->[47:m]<!-- -->用来指向下一级页表的基地址。</p><ul><li>当页面粒度为4KB时m为12。</li><li>当页面粒度为16KB时m为14。</li><li>当页面粒度为64KB时m为16。</li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2l3页表项描述符">2．L3页表项描述符<a class="hash-link" href="#2l3页表项描述符" title="标题的直接链接">​</a></h3><p>如图2.5所示，L3页表项描述符包含5种页表项，分别是无效的页表项、保留的页表项、4KB粒度的页表项、16KB粒度的页表项、64KB粒度的页表项。</p><p><img loading="lazy" alt="1750257779107" src="/assets/images/1750257779107-5044112e2ce99ba78bb43b2b8a877517.png" width="1434" height="865" class="img_ev3q"></p><p>▲图2.5　L3页表项描述符</p><p>L3页表项描述符的格式如下。</p><p>当页表项描述符Bit<!-- -->[0]<!-- -->为1时，表示有效的描述符；为0时，表示无效的描述符。</p><p>当页表项描述符Bit<!-- -->[1]<!-- -->为0时，表示保留页表项；为1时，表示页表类型的页表项。</p><p>页表描述符Bit<!-- -->[11:2]<!-- -->是低位属性，Bit<!-- -->[63:51]<!-- -->是高位属性，如图2.6所示。</p><p>页表描述符中间的位域中包含了输出地址（output address），也就是最终物理页面的高地址段。</p><p>当页面粒度为4KB时输出地址为Bit<!-- -->[47:12]<!-- -->。</p><p>当页面粒度为16KB时输出地址为Bit<!-- -->[47:14]<!-- -->。</p><p>当页面粒度为64KB时输出地址为Bit<!-- -->[47:16]<!-- -->。</p><p><img loading="lazy" alt="1750257959806" src="/assets/images/1750257959806-5461911f537cd4dd1048ee2e0d8e2ed1.png" width="1641" height="454" class="img_ev3q"></p><p>▲图2.6　L3页表项描述符中的页面属性</p><p>L3页表项描述符中包含了低位属性和高位属性。这些属性对应的位和描述如表2.1所示。</p><p>表2.1　　页面属性对应的位和描述</p><p><img loading="lazy" alt="1750258032381" src="/assets/images/1750258032381-b3a83657521e06b437cb6e58a42efac1.png" width="838" height="1014" class="img_ev3q"></p><p><img loading="lazy" alt="1750258048470" src="/assets/images/1750258048470-47d958f719164894f3a1d4fc9122f62d.png" width="837" height="1320" class="img_ev3q"></p><p><img loading="lazy" alt="1750258068683" src="/assets/images/1750258068683-90d5719f4694a88ca706522b053a94aa.png" width="835" height="1459" class="img_ev3q"></p><p><img loading="lazy" alt="1750258096851" src="/assets/images/1750258096851-3a1d28d418143ae600d32291ac511588.png" width="976" height="459" class="img_ev3q"></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="214linux内核中的页表">2.1.4　Linux内核中的页表<a class="hash-link" href="#214linux内核中的页表" title="标题的直接链接">​</a></h2><p>在ARM64的Linux内核中采用以下4级分页模型：</p><p>页全局目录（Page Global Directory，PGD）；</p><p>页上级目录（Page Upper Directory，PUD）；</p><p>页中间目录（Page Middle Directory，PMD）；</p><p>页表（Page Table，PT）。</p><p>上述4级分页模型分别对应ARMv8架构页表的L0～L3页表。上述4级分页模型在64位虚拟地址的划分如图2.7所示。</p><p><img loading="lazy" alt="1750258443004" src="/assets/images/1750258443004-d638b623afd29867c20183d566035d99.png" width="1737" height="598" class="img_ev3q"></p><p>▲图2.7　4级分页模型在64位虚拟地址的划分</p><p>64位的虚拟地址分成如下几个部分。</p><p>Bit<!-- -->[63]<!-- -->：用来选择页表基地址寄存器。</p><p>Bit<!-- -->[62:48]<!-- -->：保留。</p><p>Bit<!-- -->[47:39]<!-- -->：表示PGD索引，即ARM64中的L0索引。</p><p>Bit<!-- -->[38:30]<!-- -->：表示PUD索引，即ARM64中的L1索引。</p><p>Bit<!-- -->[29:21]<!-- -->：表示PMD索引，即ARM64中的L2索引。</p><p>Bit<!-- -->[20:12]<!-- -->：表示PT索引，即ARM64中的L3索引</p><p>Bit<!-- -->[11:0]<!-- -->：表示页面内的偏移量</p><p>对于ARM64架构来说，目前基于ARMv8-A架构的处理器最多可以支持到48根地址线，也就是寻址248的虚拟地址空间，即虚拟地址的范围为0x0000 0000 0000 0000～0x0000 FFFF FFFF FFFF，共256TB。理论上完全可以支持64根地址线，于是最多就可以寻址264B的虚拟地址空间。但是对于目前的应用来说，256TB的虚拟地址空间已经足够使用了。因为如果支持64位虚拟地址空间，意味着处理器设计需要考虑更多的地址线，CPU的设计复杂度会增大。</p><p>基于ARMv8-A架构的处理器的虚拟地址分成两个区域。一个是0x0000 0000 0000 0000～0x0000 FFFF FFFF FFFF，另外一个是0xFFFF 0000 0000 0000～0xFFFF FFFF FFFF FFFF。</p><p>基于ARMv8-A架构的处理器可以通过配置ARM64_VA_BITS宏来设置虚拟地址的宽度。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/Kconfig&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">config ARM64_VA_BITS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        int</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        default 39 if ARM64_VA_BITS_39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        default 42 if ARM64_VA_BITS_42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        default 48 if ARM64_VA_BITS_48</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>另外，基于ARMv8-A架构的处理器支持的最大物理地址宽度也是48位。</p><p>Linux内存空间布局与地址映射的粒度和地址映射的层级有关。基于ARMv8-A架构的处理器支持的页面粒度可以是4KB、16KB或者64KB。映射的层级可以是3级或者4级。</p><p>下面是页面粒度为4KB、地址宽度为48位、4级映射的内存分布。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AArch64 Linux memory layout with 4KB pages + 4 levels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Start           End           Size    Use</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-----------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000000000000000    0000ffffffffffff 256TB      user </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000000000000   ffffffffffffffff  256TB      kernel</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面是页面粒度为4KB、地址宽度为39位、3级映射的内存分布。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">AArch64 Linux memory layout with 4KB pages + 3 levels:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Start           End           Size    Use</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">------------------------------------------------------------</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">0000000000000000  0000007fffffffff     512GB          user </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffffff8000000000  ffffffffffffffff     512GB          kernel</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Linux内核的Documentation/arm64/memory.txt文件中还有其他不同配置的内存分布。</p><p>我们的QEMU虚拟机配置为4KB页面粒度、48位地址宽度以及4级映射，本书以此为蓝本介绍ARM64的地址映射。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/configs/debian_defconfig&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_PGTABLE_LEVELS=4    //4级映射</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_ARM64_VA_BITS_48=y  //地址宽度为48位</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_ARM64_VA_BITS=48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">CONFIG_ARM64_4K_PAGES=y    //页面粒度为4KB</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由上面的信息可以计算出各级页表的大小以及在虚拟地址中的偏移量。首先计算PGD页表的偏移量和大小。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/pgtable-hwdef.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define ARM64_HW_PGTABLE_LEVEL_SHIFT(n) ((PAGE_SHIFT - 3) * (4 - (n)) + 3)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PGDIR_SHIFT        ARM64_HW_PGTABLE_LEVEL_SHIFT(4 - CONFIG_PGTABLE_LEVELS)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PGDIR_SIZE        (_AC(1, UL) &lt;&lt; PGDIR_SHIFT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PGDIR_MASK        (~(PGDIR_SIZE-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTRS_PER_PGD        (1 &lt;&lt; (MAX_USER_VA_BITS - PGDIR_SHIFT))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>PGDIR_SHIFT宏表示PGD页表在虚拟地址中的起始偏移量。根据本书所用的QEMU虚拟机的配置计算出PGDIR_SHIFT的值为39。</p><p>PGDIR_SIZE宏表示PGD页表项所能映射的区域大小。</p><p>PGDIR_MASK宏用来屏蔽虚拟地址中的PUD索引、PMD索引以及PT索引字段的所有位。</p><p>PTRS_PER_PGD宏表示PGD页表中页表项的个数。</p><p>接下来，计算PUD页表的偏移量和大小。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/pgtable-hwdef.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#if CONFIG_PGTABLE_LEVELS &gt; 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PUD_SHIFT        ARM64_HW_PGTABLE_LEVEL_SHIFT(1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PUD_SIZE        (_AC(1, UL) &lt;&lt; PUD_SHIFT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PUD_MASK        (~(PUD_SIZE-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTRS_PER_PUD        PTRS_PER_PTE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>PUD_SHIFT宏表示PUD页表在虚拟地址中的起始偏移量。根据本书所用的QEMU虚拟机的配置，计算出的PUDIR_SHIFT为30。</p><p>PUD_SIZE宏表示一个PUD页表项所能映射的区域大小。</p><p>PUD_MASK宏用来屏蔽虚拟地址中的PMD索引和PT索引字段的所有位。</p><p>PTRS_PER_PUD宏表示PUD页表中页表项的个数。接下来，计算PMD页表的偏移量和大小。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/pgtable-hwdef.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#if CONFIG_PGTABLE_LEVELS &gt; 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PMD_SHIFT        ARM64_HW_PGTABLE_LEVEL_SHIFT(2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PMD_SIZE        (_AC(1, UL) &lt;&lt; PMD_SHIFT)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PMD_MASK        (~(PMD_SIZE-1))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTRS_PER_PMD        PTRS_PER_PTE</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>PMD_SHIFT宏表示PMD页表在虚拟地址中的起始偏移量。根据本书所用的QEMU虚拟机的配置，计算出的PMDIR_SHIFT为21。</p><p>PMD_SIZE宏表示一个PMD页表项所能映射的区域大小。</p><p>PMD_MASK宏用来屏蔽虚拟地址中的PT索引字段的所有位。</p><p>PTRS_PER_PMD宏表示PMD页表中页表项的个数。最后是页表。由于设置了页面粒度为4KB，因此页表的偏移量是从第12位开始的。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">#define PTRS_PER_PTE        (1 &lt;&lt; (PAGE_SHIFT - 3))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>页表项描述符包含了丰富的属性，它们的定义如下。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arm/arm64/include/asm/pgtable-hwdef.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * L3页表项描述符</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_TYPE_MASK        (_AT(pteval_t, 3) &lt;&lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_TYPE_FAULT       (_AT(pteval_t, 0) &lt;&lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_TYPE_PAGE        (_AT(pteval_t, 3) &lt;&lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_TABLE_BIT        (_AT(pteval_t, 1) &lt;&lt; 1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_USER        (_AT(pteval_t, 1) &lt;&lt; 6)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_RDONLY        (_AT(pteval_t, 1) &lt;&lt; 7)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_SHARED        (_AT(pteval_t, 3) &lt;&lt; 8)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_AF            (_AT(pteval_t, 1) &lt;&lt; 10)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_NG            (_AT(pteval_t, 1) &lt;&lt; 11)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_DBM            (_AT(pteval_t, 1) &lt;&lt; 51)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_CONT        (_AT(pteval_t, 1) &lt;&lt; 52)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_PXN            (_AT(pteval_t, 1) &lt;&lt; 53)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_UXN            (_AT(pteval_t, 1) &lt;&lt; 54)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_HYP_XN        (_AT(pteval_t, 1) &lt;&lt; 54)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上面定义的是ARMv8架构页表项描述符的属性。Linux内核最早的设计是基于x86的，因此内存管理代码相关的宏和数据结构都基于x86架构，而后来众多的架构都需要往这个设计靠拢，特别是有一些架构中PTE的属性定义和x86的完全不一样。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/pgtable-prot.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 软件定义的PTE标志位属性</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_VALID         (_AT(pteval_t, 1) &lt;&lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_WRITE         (PTE_DBM)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_DIRTY         (_AT(pteval_t, 1) &lt;&lt; 55)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_SPECIAL       (_AT(pteval_t, 1) &lt;&lt; 56)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PTE_PROT_NONE         (_AT(pteval_t, 1) &lt;&lt; 58)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在ARMv8的L3页表项的定义中，Bit<!-- -->[58:55]<!-- -->是硬件预留给软件使用的，因此Linux内核使用这几位来实现PTE_DIRTY、PTE_SPECIAL以及PTE_PROT_NONE这几个软件实现的PTE标志位属性。需要注意的是，在ARMv8架构里页表项中的PTE_DBM位用于表示该页面是脏页，而在Linux内核中额外实现了一个软件标志位PTE_DIRTY来表示页面是脏的，它使用页表项中的第55位。</p><p>我们在看内核代码或者写内核代码时常常会操作PTE的属性，如查询页表项是否存在（present），若不存在则说明这个页表项对应的物理页面没有在内存中。对于这种操作，Linux内核中定义了很多和页表项操作有关的宏，建议读者在写内核代码时采用这些宏，而不是直接操作上述的位。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/pgtable.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define pte_present(pte)    (!!(pte_val(pte) &amp; (PTE_VALID | PTE_PROT_NONE)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define pte_young(pte)         (!!(pte_val(pte) &amp; PTE_AF))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define pte_special(pte)    (!!(pte_val(pte) &amp; PTE_SPECIAL))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define pte_write(pte)         (!!(pte_val(pte) &amp; PTE_WRITE))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define pte_user_exec(pte)     (!(pte_val(pte) &amp; PTE_UXN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define pte_cont(pte)         (!!(pte_val(pte) &amp; PTE_CONT))</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>表2.2列出了访问页表项标志位的函数。</p><p>表2.2　　访问页表项标志位的函数</p><p><img loading="lazy" alt="image-20250728222148956" src="/assets/images/image-20250728222148956-d06e02f5621d4bc334c84ddcc8849649.png" width="993" height="1047" class="img_ev3q"></p><p>表2.3列出了另外一组函数，用于设置页表项中相关标志位的函数。</p><p>表2.3　　设置页表项标志位的函数</p><p><img loading="lazy" alt="image-20250728222220200" src="/assets/images/image-20250728222220200-73dd6668df24cb89fbcdc03d748a1d98.png" width="987" height="838" class="img_ev3q"></p><p>当需要把PTE页表项写入硬件页表时，可以调用set_pte_at()函数，它最终是调用set_pte()函数来完成的。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/pgtable.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  pte_t *ptep, pte_t pte)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pte_t old_pte;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (pte_present(pte) &amp;&amp; pte_user_exec(pte) &amp;&amp; !pte_special(pte))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __sync_icache_dcache(pte);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    set_pte(ptep, pte);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static inline void set_pte(pte_t *ptep, pte_t pte)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    WRITE_ONCE(*ptep, pte);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (pte_valid_not_user(pte))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dsb(ishst);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>pte_user_exec()表示该页面属于用户态映射的页面，可调用__sync_icache_dcache()来进行高速缓存的一致性操作。</p><p>set_pte()函数的第一个参数ptep指向页表中的页表项，第二个参数pte表示新的页表项的内容。pte_valid_not_user()表示该页面不能在用户态访问，即该页面属于内核态，当它被写入硬件页表后，需要调用dsb()来保证页表更新完成。</p><p>除了对页表项相关标志位操作的宏之外，表2.4列出了与页表项操作相关的函数或宏，如pgd_offset_k()等。</p><p>表2.4　　页表项操作相关的函数或宏</p><p><img loading="lazy" alt="image-20250728222909328" src="/assets/images/image-20250728222909328-17400a66f7647f03aab620fbfdad318c.png" width="979" height="1224" class="img_ev3q"></p><p><img loading="lazy" alt="image-20250728222926103" src="/assets/images/image-20250728222926103-53cfac8685fccc90a2836d758c5b412b.png" width="989" height="591" class="img_ev3q"></p><p>表2.4中参数的说明如下。</p><p>mm表示进程的内存描述符mm_struct。</p><p>addr表示虚拟地址。</p><p>pgd表示PGD页表项。</p><p>pmd表示PMD页表项。</p><p>pud表示PUD页表项。</p><p>pte表示页表项。</p><p>prot表示页表项的属性。</p><p>page表示物理页面的描述符page数据结构。</p><p>dir表示上一级页表对应的页表项。</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="215arm64内核内存分布">2.1.5　ARM64内核内存分布<a class="hash-link" href="#215arm64内核内存分布" title="标题的直接链接">​</a></h2><p>ARM64架构处理器采用48位物理寻址机制，最多可以寻找256TB的物理地址空间。对于目前的应用来说，这已经足够了，不需要扩展到64位的物理寻址机制。虚拟地址同样最多支持48位寻址，所以在处理器架构设计上，把虚拟地址空间划分为两个空间，每个空间最多支持256TB。Linux内核在大多数架构上把两个地址空间划分为用户空间和内核空间。</p><p>用户空间：0x0000 0000 0000 0000～0x0000 FFFF FFFF FFFF。</p><p>内核空间：0xFFFF 0000 0000 0000～0xFFFF FFFF FFFF FFFF。</p><p>64位Linux内核中没有高端内存，因为48位的寻址空间已经足够大了。</p><p>在QEMU虚拟机中，ARM64架构的Linux 5.0内核的内存分布如图2.8所示。</p><p><img loading="lazy" alt="image-20250728223142038" src="/assets/images/image-20250728223142038-93ebc3909ba60125f1485c2266afb66e.png" width="1542" height="673" class="img_ev3q"></p><p>▲图2.8　ARM64架构的Linux 5.0内核的内存分布<!-- -->[1]</p><p>这部分信息的输出是在mem_init()函数中实现的。注意，该信息已经在Linux 4.16内核中删除，这里在runninglinuxkernel_5.0的实验代码中重新添加了上述输出信息。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/mm/init.c&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MLK(b, t) b, t, ((t) - (b)) &gt;&gt; 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MLM(b, t) b, t, ((t) - (b)) &gt;&gt; 20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MLG(b, t) b, t, ((t) - (b)) &gt;&gt; 30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MLK_ROUNDUP(b, t) b, t, DIV_ROUND_UP(((t) - (b)), SZ_1K)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;Virtual kernel memory layout:\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    modules : 0x%16lx - 0x%16lx   (%6ld MB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLM(MODULES_VADDR, MODULES_END));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    vmalloc : 0x%16lx - 0x%16lx   (%6ld GB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLG(VMALLOC_START, VMALLOC_END));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;      .text : 0x%16llx&quot; &quot; - 0x%16llx&quot; &quot;   (%6lld KB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLK_ROUNDUP((u64)_text, (u64)_etext));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;      .init : 0x%16llx&quot; &quot; - 0x%16llx&quot; &quot;   (%6lld KB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLK_ROUNDUP((u64)__init_begin, (u64)__init_end));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    .rodata : 0x%16llx&quot; &quot; - 0x%16llx&quot; &quot;   (%6lld KB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLK_ROUNDUP((u64)__start_rodata, (u64)__end_rodata));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;      .data : 0x%16llx&quot; &quot; - 0x%16llx&quot; &quot;   (%6lld KB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLK_ROUNDUP((u64)_sdata, (u64)_edata));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;       .bss : 0x%16llx&quot; &quot; - 0x%16llx&quot; &quot;   (%6lld KB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLK_ROUNDUP((u64)__bss_start, (u64)__bss_stop));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    fixed   : 0x%16lx - 0x%16lx   (%6ld KB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLK(FIXADDR_START, FIXADDR_TOP));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    PCI I/O : 0x%16lx - 0x%16lx   (%6ld MB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLM(PCI_IO_START, PCI_IO_END));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#ifdef CONFIG_SPARSEMEM_VMEMMAP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    vmemmap : 0x%16lx - 0x%16lx   (%6ld GB maximum)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLG(VMEMMAP_START, VMEMMAP_START + VMEMMAP_SIZE));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;             0x%16lx - 0x%16lx   (%6ld MB actual)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLM((unsigned long)phys_to_page(memblock_start_of_DRAM()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    (unsigned long)virt_to_page(high_memory)));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    memory  : 0x%16lx - 0x%16lx   (%6ld MB)\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                MLM(__phys_to_virt(memblock_start_of_DRAM()),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   (unsigned long)high_memory));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    PAGE_OFFSET  : 0x%16lx\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               PAGE_OFFSET);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    kimage_voffset : 0x%16llx\n&quot;, kimage_voffset);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    PHYS_OFFSET  : 0x%llx\n&quot;, PHYS_OFFSET);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pr_notice(&quot;    start memory  : 0x%llx\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               memblock_start_of_DRAM());</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#undef MLK</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#undef MLM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#undef MLK_ROUNDUP</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>PAGE_OFFSET表示物理内存在内核空间里做线性映射（linear mapping）的起始地址，在ARM64的Linux内核中该值定义为0xFFFF 8000 0000 0000。Linux内核在初始化时会把物理内存全部做一次线性映射，映射到内核空间的虚拟地址上。该值定义在arch/arm64/include/asm/ memory.h头文件中。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/memory.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define PAGE_OFFSET           (UL(0xffffffffffffffff) - \</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                (UL(1) &lt;&lt; (VA_BITS - 1)) + 1)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>KIMAGE_VADDR表示内核映像文件映射到内核空间的起始虚拟地址。它的值等于MODULES_END 的值，MODULES_END 表示模块区域的虚拟地址的结束地址。KIMAGE_VADDR宏的值为0xFFFF 0000 1000 0000，它的定义如下。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/include/asm/memory.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define KIMAGE_VADDR            (MODULES_END)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MODULES_END             (MODULES_VADDR + MODULES_VSIZE)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MODULES_VADDR           (BPF_JIT_REGION_END)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define MODULES_VSIZE           (SZ_128M)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>编译器在编译目标文件并且链接完成之后，即可知道内核映像文件最终的大小。接下来，将其打包成二进制文件，该操作由arch/arm64/kernel/vmlinux.ld.S控制，其中也划定了内核的内存布局。</p><p>内核映像文件本身占据的内存空间从_text到_end，并且分为如下几个段。</p><p>代码（.text）段：_text和_etext为代码段的起始与结束地址，包含了编译后的内核代码。</p><p>init段：<strong>init_begin和</strong>init_end分别为init段的起始与结束地址，包含了大部分模块初始化的数据。</p><p>数据（.data）段：_sdata和_edata分别为数据段的起始和结束地址，保存了内核的大部分变量。</p><p>bss段：<strong>bss_start和</strong>bss_stop分别为bss段的开始和结束地址，包含了未初始化的或者初始化为0的全局变量和静态变量。</p><p>上述几个段的大小在编译链接时根据内核配置来确定，因为每种配置的代码段和数据段长度都不相同，这取决于要编译哪些内核模块，但是起始地址_text总是相同的。内核编译完成之后，会生成一个System.map文件，查询这个文件可以找到这些地址的具体数值。注意，这些段的起始地址和结束地址都是链接地址，即内核空间的虚拟地址。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;System.map文件&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000010080000 t _head</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000010080000 T _text</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011a60000 T stext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011a60000 T __init_begin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011730000 R _etext</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011730000 R __start_rodata</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011a53000 R __end_rodata</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011ee0000 D __init_end</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011ee0000 D _sdata</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">ffff000011ff8a00 D _edata</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上述分析可知，内核映像文件映射到内核空间的起始地址由KIMAGE_VADDR宏来指定，而代码段的起始地址由vmlinux.ld.S链接文件控制。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/kernel/vmlinux.ld.S&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SECTIONS</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     . = KIMAGE_VADDR + TEXT_OFFSET;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码段的起始地址是由KIMAGE_VADDR + TEXT_OFFSET组成的，而TEXT_OFFSET表示代码段在地址空间的相对偏移量。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;arch/arm64/Makefile&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">TEXT_OFFSET := 0x00080000</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因此，计算代码段链接地址的起始地址，0xFFFF 0000 1000 0000 + 0x0008 0000 =0xFFFF 0000 1008 0000，这和从System.map文件查找到的_text一致。</p><p>最后我们对内存分布做一个总结，如图2.9所示</p><p><img loading="lazy" alt="image-20250728223640062" src="/assets/images/image-20250728223640062-2e48695363d2b0c198b2fc75af659936.png" width="1458" height="1496" class="img_ev3q"></p><p>▲图2.9　ARM64在Linux 5.0内核的内存分布</p><p>（1）用户空间：0x0000 0000 0000 0000～0x0000 FFFF FFFF FFFF，一共256TB。</p><p>（2）非规范区域。</p><p>（3）内核空间：0xFFFF 0000 0000 0000～0xFFFF FFFF FFFF FFFF，一共256TB。内核空间又做了如下细分。</p><p>Modules区域：0xFFFF 0000 0800 0000～0xFFFF 0000 1000 0000，大小为128MB。</p><p>vmalloc区域：0xFFFF 0000 1000 0000～0xFFFF 7DFF BFFF 0000，大小为129022GB。</p><p>固定映射（fixed）区域：0xFFFF 7DFF FE7F 9000～0xFFFF 7DFF FEC0 0000，大小为4124KB。</p><p>PCI I/O区域：0xFFFF 7DFF FEE0 0000～0xFFFF 7DFF FFE0 0000，大小为16MB。</p><p>vmemmap区域：0xFFFF 7E00 0000 0000～0xFFFF 8000 0000 0000，大小为2048GB。</p><p>线性映射区：0xFFFF 8000 0000 0000～0xFFFF FFFF FFFF FFFF，大小为128TB。</p><p>读者需要特别注意的是，内核映像文件映射的区域在vmalloc区域里，这一点和Linux 4.0内核不相同，这是为了实现KASLR特性而做的改变<!-- -->[2]<!-- -->。</p><p>Linux内核提供了一个转储（dump）页表的调试接口。读者需要在内核配置文件（以.config结尾）中使能CONFIG_ARM64_PTDUMP_DEBUGFS配置选项。该调试接口为/sys/kernel/debug/ kernel_page_tables。该调试接口会遍历内核空间所有已经映射的页面，分别显示虚拟地址区间、页表大小、页表等级、页表属性以及内存属性等信息，如图2.10所示。</p><p><img loading="lazy" alt="image-20250728223825430" src="/assets/images/image-20250728223825430-7ea01283f123017013eca6ea6702754c.png" width="1736" height="642" class="img_ev3q"></p><p>▲图2.10　调试接口显示的信息</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="216案例分析arm64的页表映射过程">2.1.6　案例分析：ARM64的页表映射过程<a class="hash-link" href="#216案例分析arm64的页表映射过程" title="标题的直接链接">​</a></h2><p>下面通过一个案例来介绍ARM64的页表映射过程。在内核初始化阶段会对内核空间的页表进行映射，实现的函数是__create_pgd_mapping()。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">&lt;start_kenrel()-&gt; setup_arch()-&gt;paging_init()&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void __init paging_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pgd_t *pgdp = pgd_set_fixmap(__pa_symbol(swapper_pg_dir));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map_kernel(pgdp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    map_mem(pgdp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pgd_clear_fixmap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在paging_init()函数中会对内核空间的多个内存段做重新映射。</p><p>map_kernel(pgdp)：对内核映像文件的各个块重新映射。在head.S文件中，我们对内核映像文件做了块映射，现在需要使用页机制来重新映射。</p><p>map_mem(pgdp)：物理内存的线性映射。物理内存会全部线性映射到以PAGE_OFFSET开始的内核空间的虚拟地址，以加速内核访问内存。</p><p>上述两个函数最终是调用<strong>create_pgd_mapping()函数来创建页表映射的。在调用该函数之前，我们需要获取PGD页表基地址。在内存线性映射完成之前，如果不能直接通过</strong>pa()这个宏来直接从线性映射地址转换到物理地址，要怎么办？</p><p>在paging_init()函数中通过如下步骤来找到PGD页表基地址。</p><p>全局变量swapper_pg_dir是内核页表的PGD页表基地址，可是这是虚拟地址，因为在内核启动的汇编代码中会做一次简单的块映射。</p><p><strong>pa_symbol()宏把内核符号的虚拟地址转换为物理地址。需要注意的是，这时物理内存的线性映射还没建立好，因此不能直接使用</strong>pa()宏。</p><p>pgd_set_fixmap()函数做一个固定映射，把swapper_pg_dir页表重新映射到固定映射区域。</p><p>内核里面有一个固定映射（fixed mapping）区域，它的范围是0xFFFF 7DFF FE7F 9000～0xFFFF 7DFF FEC0 0000，我们可以把PGD页表映射这个区域，然后才可以使用__pa()宏。</p><p>pgd_set_fixmap()函数就做这个固定映射的事情，把PGD页表的物理页面映射到固定映射区域，返回PGD页表的虚拟地址。而pgd_clear_fixmap()函数用于取消固定区域的映射。</p><p><strong>pa_symbol()宏和</strong>pa()宏的作用都是把内核虚拟地址转换为物理地址。它们两个之间有什么区别呢？</p><p>我们在内核中常常需要访问一些内核符号表的物理地址，如内核页表swapper_pg_dir、代码段的符号_text或者<strong>init_begin等。这些内核符号表的链接地址在vmalloc区域，即从KIMAGE_VADDR + TEXT_OFFSET开始的虚拟地址，它和内核空间的线性映射区是不相同的。</strong>pa()宏可以通过虚拟地址来确定区域。</p><p>在ARM64中，<strong>pa_symbol()宏通过kimagevoffset来计算。<!-- -->_<!-- -->pa_symbol()宏等同于</strong>kimg_to_phys()宏，它通过和全局变量kimage_voffset做简单减法计算即可完成计算，与Linux内核相关的代码如下。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//内存线性映射建立之前</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __pa_symbol(x)        __phys_addr_symbol(x)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __pa_symbol_nodebug(x) __kimg_to_phys((phys_addr_t)(x))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __kimg_to_phys(addr)   ((addr) - kimage_voffset)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>那kimage_voffset代表什么意思呢？如图2.11所示，当系统刚初始化时，内核映像通过块映射的方式映射到KIMAGE_VADDR + TEXT_OFFSET的虚拟地址上，因此kimage_voffset表示内核映像虚拟地址和物理地址之间的偏移量，这类似于线性映射之后的PAGE_OFFSET。</p><p>当所有物理内存都线性映射到线性映射区之后，就可以使用<strong>pa()宏来快速得到虚拟地址对应的物理地址。</strong>pa()宏内部会调用<strong>is_lm_address()宏来判断虚拟地址在哪个区域，从而选择使用</strong>lm_to_phys()或者__kimg_to_phys()来转换地址。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">//内存线性映射建立之后</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __lm_to_phys(addr)    (((addr) &amp; ~PAGE_OFFSET) + PHYS_OFFSET)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#define __kimg_to_phys(addr)  ((addr) - kimage_voffset)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p><img loading="lazy" alt="1753973146163" src="/assets/images/1753973146163-01b53214a01b836e69b9f91f43709bc5.png" width="1603" height="1420" class="img_ev3q"></p><p>▲图2.11　kimage_voffset的含义</p><p>接下来，看__create_pgd_mapping()函数的实现。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">    static void __create_pgd_mapping(pgd_t *pgdir, phys_addr_t phys,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 unsigned long virt, phys_addr_t size,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 pgprot_t prot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 phys_addr_t (*pgtable_alloc)(void),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 int flags)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long addr, length, end, next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pgd_t *pgdp = pgd_offset_raw(pgdir, virt);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    end = addr + length;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next = pgd_addr_end(addr, end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        alloc_init_pud(pgdp, addr, next, phys, prot, pgtable_alloc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                  flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        phys += next - addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (pgdp++, addr = next, addr != end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在__create_pgd_mapping ()函数中，以PGDIR_SIZE为步长遍历内存区域<!-- -->[virt,virt+size]<!-- -->，然后通过调用alloc_init_pud()来初始化PGD页表项内容和PUD。pgd_addr_end()以PGDIR_SIZE为步长。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static void alloc_init_pud(pgd_t *pgdp, unsigned long addr, unsigned long end,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               phys_addr_t phys, pgprot_t prot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               phys_addr_t (*pgtable_alloc)(void),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               int flags)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    unsigned long next;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pud_t *pudp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pgd_t pgd = READ_ONCE(*pgdp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (pgd_none(pgd)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        phys_addr_t pud_phys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pud_phys = pgtable_alloc();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        __pgd_populate(pgdp, pud_phys, PUD_TYPE_TABLE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pgd = READ_ONCE(*pgdp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pudp = pud_set_fixmap_offset(pgdp, addr);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    do {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        pud_t old_pud = READ_ONCE(*pudp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        next = pud_addr_end(addr, end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (use_1G_block(addr, next, phys) &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">           (flags &amp; NO_BLOCK_MAPPINGS) == 0) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            pud_set_huge(pudp, phys, prot);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            alloc_init_cont_pmd(pudp, addr, next, phys, prot,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        pgtable_alloc, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        phys += next - addr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    } while (pudp++, addr = next, addr != end);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pud_clear_fixmap();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>alloc_init_pud()函数会做如下事情。</p><p>（1）通过pgd_none()判断当前PGD页表项的内容是否为空。如果PGD页表项的内容为空，说明下一级页表为空，那么需要动态分配下一级页表。PUD一共有PTRS_PER_PUD个页表项，然后通过pgd_populate()把刚分配的PUD页表的基地址设置到相应的PGD页表项中。</p><p>（2）通过pud_set_fixmap_offset ()来获取相应的PUD表项。</p><p>（3）以PUD_SIZE为步长，通过while循环来设置下一级页表。</p><p>（4）use_1G_block()函数会判断是否使用1GB大小的内存块来映射。如果这里要映射的内存块大小正好是PUD_SIZE，那么只需要映射到PUD即可，接下来的PMD和PTE等到真正需要使用时再映射，通过pud_set_huge()函数来设置相应的PUD页表项。</p><p>（5）如果use_1G_block()函数判断不能通过1GB大小的内存块来映射，则调用alloc_init_cont_pmd()函数来进行下一级页表的映射。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/shaozongfan/shaozongfan.github.io/docs/奔跑吧linux内核（第2版）卷1：基础架构/第2章  ARM64在linux内核中的实现.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">第1章　处理器架构</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第4章　物理内存与虚拟内存"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">第4章　物理内存与虚拟内存</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#211页表" class="table-of-contents__link toc-highlight">2.1.1　页表</a></li><li><a href="#212页表映射" class="table-of-contents__link toc-highlight">2.1.2　页表映射</a></li><li><a href="#213页表项描述符" class="table-of-contents__link toc-highlight">2.1.3　页表项描述符</a><ul><li><a href="#1l0l2页表项描述符" class="table-of-contents__link toc-highlight">1．L0～L2页表项描述符</a></li><li><a href="#2l3页表项描述符" class="table-of-contents__link toc-highlight">2．L3页表项描述符</a></li></ul></li><li><a href="#214linux内核中的页表" class="table-of-contents__link toc-highlight">2.1.4　Linux内核中的页表</a></li><li><a href="#215arm64内核内存分布" class="table-of-contents__link toc-highlight">2.1.5　ARM64内核内存分布</a></li><li><a href="#216案例分析arm64的页表映射过程" class="table-of-contents__link toc-highlight">2.1.6　案例分析：ARM64的页表映射过程</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1c06d183.js"></script>
<script src="/assets/js/main.63ebc7ad.js"></script>
</body>
</html>