现今的SoC一般包含很多集成组件，在系统运行过程中，并不需要所有的模块都运行于最高频率和最高性能。在SoC内，某些domain可以运行在较低的频率和电压下，而其他domain可以运行在较高的频率和电压下，某个domain所支持的<频率，电压>对的集合被称为Operating Performance Point，缩写为OPP。

```
int opp_add(struct device *dev, unsigned long freq, unsigned long u_volt);
```

目前，TI OMAP CPUFreq驱动的底层就使用了OPP这种机制来获取CPU所支持的频率和电压列表。在开机的过程中，TI OMAP4芯片会注册针对CPU设备的OPP表（代码位于arch/arm/mach-omap2/中），如代码清单19.10所示。

代码清单19.10　TI OMAP4 CPU的OPP表

```
1static struct omap_opp_def __initdata omap44xx_opp_def_list[] = {
2       /* MPU OPP1 - OPP50 */
3       OPP_INITIALIZER("mpu", true, 300000000, OMAP4430_VDD_MPU_OPP50_UV),
4       /* MPU OPP2 - OPP100 */
5       OPP_INITIALIZER("mpu", true, 600000000, OMAP4430_VDD_MPU_OPP100_UV),
6       /* MPU OPP3 - OPP-Turbo */
7       OPP_INITIALIZER("mpu", true, 800000000, OMAP4430_VDD_MPU_OPPTURBO_UV),
8       /* MPU OPP4 - OPP-SB */
9       OPP_INITIALIZER("mpu", true, 1008000000, OMAP4430_VDD_MPU_OPPNITRO_UV),
10      …
11};
12/**
13 * omap4_opp_init() - initialize omap4 opp table
14 */
15int __init omap4_opp_init(void)
16{
17      …
18      r = omap_init_opp_table(omap44xx_opp_def_list,
19                   ARRAY_SIZE(omap44xx_opp_def_list));
20
21      return r;
22}
23device_initcall(omap4_opp_init);
24int __init omap_init_opp_table(struct omap_opp_def *opp_def,
25             u32 opp_def_size)
26{
27      …
28      /* Lets now register with OPP library */
29      for (i = 0; i < opp_def_size; i++, opp_def++) {
30            …
31            if (!strncmp(opp_def->hwmod_name, "mpu", 3)) {
32                   /*
33                    * All current OMAPs share voltage rail and
34                    * clock source, so CPU0 is used to represent
35                    * the MPU-SS.
36                    */
37                   dev = get_cpu_device(0);
38            } …
39            r = opp_add(dev, opp_def->freq, opp_def->u_volt);
40            …
41      }
42      return 0;
43}
```

针对与device结构体指针dev对应的domain中增加一个新的OPP，参数freq和u_volt即为该OPP对应的频率和电压。

```
int opp_enable(struct device *dev, unsigned long freq);
int opp_disable(struct device *dev, unsigned long freq);
```

上述API用于使能和禁止某个OPP，一旦被禁止，其available将成为false，之后有设备驱动想设置为这个OPP就不再可能了。譬如，当温度超过某个范围后，系统不允许1GHz的工作频率，可采用类似下面的代码实现：

```
if (cur_temp > temp_high_thresh) {
      /* Disable 1GHz if it was enabled */
      rcu_read_lock();
opp = opp_find_freq_exact(dev, 1000000000, true);
      rcu_read_unlock();
      /* just error check */
if (!IS_ERR(opp))
ret = opp_disable(dev, 1000000000);
else
goto try_something_else;
}
```

上述代码中调用的opp_find_freq_exact（）用于寻找与一个确定频率和available匹配的OPP，其原型为：

```
struct opp *opp_find_freq_exact(struct device *dev, unsigned long freq,
bool available);
```

另外，Linux还提供两个变体，opp_find_freq_floor（）用于寻找1个OPP，它的频率向上接近或等于指定的频率；opp_find_freq_ceil（）用于寻找1个OPP，它的频率向下接近或等于指定的频率，这两个函数的原型为：

```
struct opp *opp_find_freq_floor(struct device *dev, unsigned long *freq);
struct opp *opp_find_freq_ceil(struct device *dev, unsigned long *freq);
```

我们可用下面的代码分别寻找1个设备的最大和最小工作频率：

```
freq = ULONG_MAX;
rcu_read_lock();
opp_find_freq_floor(dev, &freq);
rcu_read_unlock();
freq = 0;
rcu_read_lock();
opp_find_freq_ceil(dev, &freq);
rcu_read_unlock();
```

在频率降低的同时，支撑该频率运行所需的电压也往往可以动态调低；反之，则可能需要调高，下面这两个API分别用于获取与某OPP对应的电压和频率：

```
unsigned long opp_get_voltage(struct opp *opp);
unsigned long opp_get_freq(struct opp *opp);
```

举个例子，当某CPUFreq驱动想将CPU设置为某一频率的时候，它可能会同时设置电压，其代码流程为：

```
soc_switch_to_freq_voltage(freq)
{
     /* do things */
     rcu_read_lock();
opp = opp_find_freq_ceil(dev, &freq);
     v = opp_get_voltage(opp);
     rcu_read_unlock();
if (v)
           regulator_set_voltage(.., v);
     /* do other things */
}
```

如下简单的API可用于获取某设备所支持的OPP的个数：

```
int opp_get_opp_count(struct device *dev);
```

前面提到，TI OMAP CPUFreq驱动的底层就使用了OPP这种机制来获取CPU所支持的频率和电压列表。它在omap_init_opp_table（）函数中添加了相应的OPP，在TI OMAP芯片的CPUFreq驱动drivers/cpufreq/omap-cpufreq.c中，则借助了快捷函数opp_init_cpufreq_table（）来根据前面注册的OPP建立CPUFreq的频率表：

```
static int __cpuinit omap_cpu_init(struct cpufreq_policy *policy)
{
       …
if (!freq_table)
result = opp_init_cpufreq_table(mpu_dev, &freq_table);
       …
}
```

而在CPUFreq驱动的目标成员函数omap_target（）中，则使用与OPP相关的API来获取频率和电压：

```
static int omap_target(struct cpufreq_policy *policy,
unsigned int target_freq,
unsigned int relation)
{
      …
if (mpu_reg) {
opp = opp_find_freq_ceil(mpu_dev, &freq);
              …
volt = opp_get_voltage(opp);
              …
      }
      …
}
```

drivers/cpufreq/omap-cpufreq.c相对来说较为规范，它在<频率，电压>表方面，在底层使用了OPP，在设置电压的时候又使用了规范的Regulator API。

比较新的驱动一般不太喜欢直接在代码里面固化OPP表，而是喜欢在相应的节点处添加operating-points属性，如imx27.dtsi中的：

```
cpus {
              #size-cells = <0>;
              #address-cells = <1>;
cpu: cpu@0 {
                    device_type = "cpu";
compatible = "arm,arm926ej-s";
operating-points = <
                          /* kHz uV */
                          266000 1300000
                          399000 1450000
>;
clock-latency = <62500>;
clocks = <&clks IMX27_CLK_CPU_DIV>;
voltage-tolerance = <5>;
             };
       };
```

如果CPUFreq的变化可以使用非常标准的regulator、clk API，我们甚至可以直接使用drivers/cpufreq/cpufreq-dt.c这个驱动。这样只需要在CPU节点上填充好频率电压表，然后在平台代码里面注册cpufreq-dt设备就可以了，在arch/arm/mach-imx/imx27-dt.c、arch/arm/mach-imx/mach-imx51.c中可以找到类似的例子：

```
static void __init imx27_dt_init(void)
{
struct platform_device_info devinfo = { .name = "cpufreq-dt", };
       of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
       platform_device_register_full(&devinfo);
}
```

