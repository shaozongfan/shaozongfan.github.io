# 12.4.1　主机驱动与外设驱动分离

Linux中的SPI、I2 C、USB等子系统都利用了典型的把主机驱动和外设驱动分离的想法，让主机端只负责产生总线上的传输波形，而外设端只是通过标准的API来让主机端以适当的波形访问自身。因此这里面就涉及了4个软件模块：

1）主机端的驱动。根据具体的I2 C、SPI、USB等控制器的硬件手册，操作具体的I2C、SPI、USB等控制器，产生总线的各种波形。

2）连接主机和外设的纽带。外设不直接调用主机端的驱动来产生波形，而是调一个标准的API。由这个标准的API把这个波形的传输请求间接“转发”给了具体的主机端驱动。当然，在这里，最好把关于波形的描述也以某种数据结构标准化。

3）外设端的驱动。外设接在I2 C、SPI、USB这样的总线上，但是它们本身可以是触摸屏、网卡、声卡或者任意一种类型的设备。我们在相关的i2c_driver、spi_driver、usb_driver这种xxx_driver的probe（）函数中去注册它具体的类型。当这些外设要求I2 C、SPI、USB等去访问它的时候，它调用“连接主机和外设的纽带”模块的标准API。

4）板级逻辑。板级逻辑用来描述主机和外设是如何互联的，它相当于一个“路由表”。假设板子上有多个SPI控制器和多个SPI外设，那究竟谁接在谁上面管理互联关系，既不是主机端的责任，也不是外设端的责任，这属于板级逻辑的责任。这部分通常出现在arch/arm/mach-xxx下面或者arch/arm/boot/dts下面。

什么叫良好的软件设计一言以蔽之，让正确的代码出现在正确的位置。不要在错误的时间、错误的地点，编写一段错误的代码。在LKML中，关于代码出现在错误的位置，常见的台词是代码“out of place”。

Linux通过上述的设计方法，把一堆杂乱不友好的代码变成了4个轻量级的小模块，每个模块都各得其所。每个模块都觉得很“爽”，站在主机端想一想，它其实也是很“爽”的，因为它的职责本来就是产生波形，而现在我们就让它只产生波形不干别的；站在外设端想一想，它也变得一身轻松，因为它根本就不需要知道自己接在主机的哪个控制器上，根本不关心对方是张三、李四、王五还是六麻子；站在板级逻辑的角度上，你做了一个板子，自己自然要知道谁接在谁上面了。

下面以SPI子系统为例来展开说明，后续章节的I2 C、USB等是类似的。

# 12.4.2　Linux SPI主机和设备驱动

在Linux中，用代码清单12.24的spi_master结构体来描述一个SPI主机控制器驱动，其主要成员是主机控制器的序号（系统中可能存在多个SPI主机控制器）、片选数量、SPI模式、时钟设置用到的和数据传输用到的函数等。

代码清单12.24　spi_master结构体

```
 1struct spi_master {
 2 struct devicedev;
 3
 4 s16           bus_num;
 5
 6 /* chipselects will be integral to many controllers; some others
 7  * might use board-specific GPIOs.
 8  */
 9 u16           num_chipselect;
10
11 ...
12
13 /* limits on transfer speed */
14 u32           min_speed_hz;
15 u32           max_speed_hz;
16
17 ...
18
19 /* Setup mode and clock, etc (spi driver may call many times).
20  *
21  * IMPORTANT:  this may be called when transfers to another
22  * device are active.  DO NOT UPDATE SHARED REGISTERS in ways
23  * which could break those transfers.
24  */
25 int            (*setup)(struct spi_device *spi);
26
27 /* bidirectional bulk transfers
28  *
29  * + The transfer() method may not sleep; its main role is
30  *   just to add the message to the queue.
31  * + For now there's no remove-from-queue operation, or
32  *   any other request management
33  * + To a given spi_device, message queueing is pure fifo
34  *
35  * + The master's main job is to process its message queue,
36  *   selecting a chip then transferring data
37  * + If there are multiple spi_device children, the i/o queue
38  *   arbitration algorithm is unspecified (round robin, fifo,
39  *   priority, reservations, preemption, etc)
40  *
41  * + Chipselect stays active during the entire message
42  *   (unless modified by spi_transfer.cs_change != 0).
43  * + The message transfers use clock and SPI mode parameters
44  *   previously established by setup() for this device
45  */
46 int            (*transfer)(struct spi_device *spi,
47                     struct spi_message *mesg);
48
49 /* called on release() to free memory provided by spi_master */
50 void         (*cleanup)(struct spi_device *spi);
51
52
53 ...
54 /*
55  * These hooks are for drivers that use a generic implementation
56  * of transfer_one_message() provied by the core.
57  */
58 void (*set_cs)(struct spi_device *spi, bool enable);
59 int (*transfer_one)(struct spi_master *master, struct spi_device *spi,
60             struct spi_transfer *transfer);
61
62 /* gpio chip select */
63 int            *cs_gpios;
64
65 ...
66};
```

分配、注册和注销SPI主机的API由SPI核心提供：

```
struct spi_master * spi_alloc_master(struct device *host, unsigned size);
int spi_register_master(struct spi_master *master);
void spi_unregister_master(struct spi_master *master);
```

在Linux中，用代码清单12.25的spi_driver结构体来描述一个SPI外设驱动，这个外设驱动可以认为是spi_master的客户端驱动。

代码清单12.25　spi_driver结构体

```
1struct spi_driver {
2 const struct spi_device_id *id_table;
3 int            (*probe)(struct spi_device *spi);
4 int            (*remove)(struct spi_device *spi);
5 void            (*shutdown)(struct spi_device *spi);
6 int            (*suspend)(struct spi_device *spi, pm_message_t mesg);
7 int            (*resume)(struct spi_device *spi);
8 struct device_driver    driver;
9};
```

可以看出，spi_driver结构体和platform_driver结构体有极大的相似性，都有probe（）、remove（）、suspend（）、resume（）这样的接口和device_driver的实例。是的，这几乎是一切客户端驱动的常用模板。

代码清单12.26　spi_transfer结构体

```
 1struct spi_transfer {
 2 /* it's ok if tx_buf == rx_buf (right )
 3  * for MicroWire, one buffer must be null
 4  * buffers must work with dma_*map_single() calls, unless
 5  *   spi_message.is_dma_mapped reports a pre-existing mapping
 6  */
 7 const void    *tx_buf;
 8 void        *rx_buf;
 9 unsigned    len;
10
11 dma_addr_t    tx_dma;
12 dma_addr_t    rx_dma;
13 struct sg_table tx_sg;
14 struct sg_table rx_sg;
15
16 unsigned    cs_change:1;
17 unsigned    tx_nbits:3;
18 unsigned    rx_nbits:3;
19#define    SPI_NBITS_SINGLE    0x01/* 1bit transfer */
20#define    SPI_NBITS_DUA       0x02/* 2bits transfer */
21#define    SPI_NBITS_QUAD      0x04/* 4bits transfer */
22 u8       bits_per_word;
23 u16       delay_usecs;
24 u32       speed_hz;
25
26 struct list_head transfer_list;
27};
```

而一次完整的SPI传输流程可能不是只包含一次spi_transfer，它可能包含一个或多个spi_transfer，这些spi_transfer最终通过spi_message组织在一起，其定义如代码清单12.27所示。

代码清单12.27　spi_message结构体

```
 1struct spi_message {
 2 struct list_head    transfers;
 3
 4 struct spi_device    *spi;
 5
 6 unsigned        is_dma_mapped:1;
 7
 8 /* REVISIT:  we might want a flag affecting the behavior of the
 9  * last transfer ... allowing things like "read 16bit length L"
10  * immediately followed by "read L bytes".  Basically imposing
11  * a specific message scheduling algorithm.
12  *
13  * Some controller drivers (message-at-a-time queue processing)
14  * could provide that as their default scheduling algorithm.  But
15  * others (with multi-message pipelines) could need a flag to
16  * tell them about such special cases.
17  */
18
19 /* completion is reported through a callback */
20    void            (*complete)(void *context);
21 void            *context;
22 unsigned        frame_length;
23 unsigned        actual_length;
24 int            status;
25
26 /* for optional use by whatever driver currently owns the
27  * spi_message ...  between calls to spi_async and then later
28  * complete(), that's the spi_master controller driver.
29  */
30 struct list_head    queue;
31 void            *state;
32};
```

通过spi_message_init（）可以初始化spi_message，而将spi_transfer添加到spi_message队列的方法则是：

```
void spi_message_add_tail(struct spi_transfer *t, struct spi_message *m);
```

发起一次spi_message的传输有同步和异步两种方式，使用同步API时，会阻塞等待这个消息被处理完。同步操作时使用的API是：

```
int spi_sync(struct spi_device *spi, struct spi_message *message);
```

使用异步API时，不会阻塞等待这个消息被处理完，但是可以在spi_message的complete字段挂接一个回调函数，当消息被处理完成后，该函数会被调用。在异步操作时使用的API是：

```
int spi_async(struct spi_device *spi, struct spi_message *message);
```

代码清单12.28是非常典型的初始化spi_transfer、spi_message并进行SPI数据传输的例子，同时spi_write（）、spi_read（）也是SPI核心层的两个通用快捷API，在SPI外设驱动中可以直接调用它们进行简单的纯写和纯读操作。

代码清单12.28　SPI传输实例spi_write（）、spi_read（）API

```
 1 static inline int
 2 spi_write(struct spi_device *spi, const u8*buf, size_t len)
 3 {
 4         struct spi_transfer     t = {
 5                         .tx_buf         = buf,
 6                         .len            = len,
 7                 };
 8         struct spi_message      m;
 9
10        spi_message_init(&m);
11        spi_message_add_tail(&t, &m);
12        return spi_sync(spi, &m);
13}
14
15static inline int
16spi_read(struct spi_device *spi, u8*buf, size_t len)
17{
18        struct spi_transfer     t = {
19                        .rx_buf         = buf,
20                        .len            = len,
21               };
22       struct spi_message      m;
23
24       spi_message_init(&m);
25       spi_message_add_tail(&t, &m);
26       return spi_sync(spi, &m);
27}
```

SPI主机控制器驱动位于drivers/spi/，这些驱动的主体是实现了spi_master的transfer（）、transfer_one（）、setup（）这样的成员函数，当然，也可能是实现spi_bitbang的txrx_bufs（）、setup_transfer（）、chipselect（）这样的成员函数。代码清单12.29摘取了drivers/spi/spi-pl022.c的部分代码。

代码清单12.29　SPI主机端驱动完成的波形传输

```
 1static int pl022_transfer_one_message(struct spi_master *master,
 2                      struct spi_message *msg)
 3{
 4 struct pl022*pl022= spi_master_get_devdata(master);
 5
 6 /* Initial message state */
 7 pl022->cur_msg = msg;
 8 msg->state = STATE_START;
 9
10 pl022->cur_transfer = list_entry(msg->transfers.next,
11                  struct spi_transfer, transfer_list);
12
13 /* Setup the SPI using the per chip configuration */
14 pl022->cur_chip = spi_get_ctldata(msg->spi);
15 pl022->cur_cs = pl022->chipselects[msg->spi->chip_select];
16
17 restore_state(pl022);
18 flush(pl022);
19
20 if (pl022->cur_chip->xfer_type == POLLING_TRANSFER)
21     do_polling_transfer(pl022);
22 else
23     do_interrupt_dma_transfer(pl022);
24
25 return 0;
26}
27
28static int pl022_setup(struct spi_device *spi)
29{
30 ...
31 /* Stuff that is common for all versions */
32 if (spi->mode & SPI_CPOL)
33     tmp = SSP_CLK_POL_IDLE_HIGH;
34 else
35     tmp = SSP_CLK_POL_IDLE_LOW;
36 SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPO, 6);
37
38 if (spi->mode & SPI_CPHA)
39     tmp = SSP_CLK_SECOND_EDGE;
40 else
41     tmp = SSP_CLK_FIRST_EDGE;
42 SSP_WRITE_BITS(chip->cr0, tmp, SSP_CR0_MASK_SPH, 7);
43
44 ...
45}
46
47static int pl022_probe(struct amba_device *adev, const struct amba_id *id)
48{
49 ...
50
51 /*
52  * Bus Number Which has been Assigned to this SSP controller
53  * on this board
54  */
55 master->bus_num = platform_info->bus_id;
56 master->num_chipselect = num_cs;
57 master->cleanup = pl022_cleanup;
58 master->setup = pl022_setup;
59 master->auto_runtime_pm = true;
60 master->transfer_one_message = pl022_transfer_one_message;
61 master->unprepare_transfer_hardware = pl022_unprepare_transfer_hardware;
62 master->rt = platform_info->rt;
63 master->dev.of_node = dev->of_node;
64
65    ...
66}
```

SPI外设驱动遍布于内核的drivers、sound的各个子目录之下，SPI只是一种总线，spi_driver的作用只是将SPI外设挂接在该总线上，因此在spi_driver的probe（）成员函数中，将注册SPI外设本身所属设备驱动的类型。

和platform_driver对应着一个platform_device一样，spi_driver也对应着一个spi_device；platform_device需要在BSP的板文件中添加板信息数据，而spi_device也同样需要。spi_device的板信息用spi_board_info结构体描述，该结构体记录着SPI外设使用的主机控制器序号、片选序号、数据比特率、SPI传输模式（即CPOL、CPHA）等。诺基亚770上的两个SPI设备的板信息数据如代码清单12.30所示，位于板文件arch/arm/mach-omap1/board-nokia770.c中。

代码清单12.30　诺基亚770板文件中的spi_board_info

```
 1static struct spi_board_info nokia770_spi_board_info[] __initdata = {
 2   [0] = {
 3           .modalias           = "lcd_mipid",
 4           .bus_num            = 2,          /* 用到的SPI主机控制器序号*/
 5           .chip_select        = 3,          /* 使用哪个片选*/
 6           .max_speed_hz       = 12000000,   /* SPI数据传输比特率*/
 7           .platform_data      = &nokia770_mipid_platform_data,
 8   },
 9   [1] = {
10           .modalias           = "ads7846",
11           .bus_num            = 2,
12           .chip_select        = 0,
13           .max_speed_hz       = 2500000,
14           .irq                = OMAP_GPIO_IRQ(15),
15           .platform_data      = &nokia770_ads7846_platform_data,
16   },
17};
```

在Linux启动过程中，在机器的init_machine（）函数中，会通过如下语句注册这些spi_board_info：

```
spi_register_board_info(nokia770_spi_board_info,
                       ARRAY_SIZE(nokia770_spi_board_info));
```

这一点和启动时通过platform_add_devices（）添加platform_device非常相似。

ARM Linux 3.x之后的内核在改为设备树后，不再需要在arch/arm/mach-xxx中编码SPI的板级信息了，而倾向于在SPI控制器节点下填写子节点，如代码清单12.31给出了arch/arm/boot/dts/omap3-overo-common-lcd43.dtsi中包含的ads7846节点。

代码清单12.31　通过设备树添加SPI外设

```
 1&mcspi1{
 2      pinctrl-names = "default";
 3      pinctrl-0= <&mcspi1_pins>;
 4
 5      /* touch controller */
 6      ads7846@0{
 7              pinctrl-names = "default";
 8              pinctrl-0= <&ads7846_pins>;
 9
10              compatible = "ti,ads7846";
11              vcc-supply = <&ads7846reg>;
12
13              reg = <0>;               /* CS0*/
14              spi-max-frequency = <1500000>;
15
16              interrupt-parent = <&gpio4>;
17              interrupts = <180>;    /* gpio_114*/
18              pendown-gpio = <&gpio4180>;
19
20              ti,x-min = /bits/ 16<0x0>;
21              ti,x-max = /bits/ 16<0x0fff>;
22              ti,y-min = /bits/ 16<0x0>;
23              ti,y-max = /bits/ 16<0x0fff>;
24              ti,x-plate-ohms = /bits/ 16<180>;
25              ti,pressure-max = /bits/ 16<255>;
26
27              linux,wakeup;
28      };
29};
```

