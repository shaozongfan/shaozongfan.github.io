# 14.9.1　DM9000网卡硬件描述

DM9000是开发板采用的网络芯片，是一个高度集成且功耗很低的高速网络控制器，可以和CPU直连，支持10/100MB以太网连接，芯片内部自带4KB双字节的SRAM（3KB用来发送，13KB用来接收）。针对不同的处理器，接口支持8位、16位和32位。DM9000一般直接挂在外面的内存总线上。

# 14.9.2　DM9000网卡驱动设计分析

DM9000网卡驱动位于内核源代码的drivers/net/dm9000.c中，它基于平台驱动架构，代码清单14.19抽取了它的主干。其核心工作是实现了前文所述net_device结构体中的hard_start_xmit（）、open（）、stop（）、set_multicast_list（）、do_ioctl（）、tx_timeout（）等成员函数，并借助中断辅助进行网络数据包的收发，另外它也实现了ethtool_ops中的成员函数。特别注意代码中的黑体部分，它标明了关键的数据收发流程。

代码清单14.19　DM9000网卡驱动

```
  1static const struct ethtool_ops dm9000_ethtool_ops = {
  2        .get_drvinfo            = dm9000_get_drvinfo,
  3        .get_settings           = dm9000_get_settings,
  4        .set_settings           = dm9000_set_settings,
  5        .get_msglevel           = dm9000_get_msglevel,
  6        .set_msglevel           = dm9000_set_msglevel,
  7        …
 8};
  9
 10/* Our watchdog timed out. Called by the networking layer */
 11static void dm9000_timeout(struct net_device *dev)
 12{
 13        ...
 14        netif_stop_queue(dev);
 15        dm9000_init_dm9000(dev);
 16        dm9000_unmask_interrupts(db);
 17        /* We can accept TX packets again */
 18        dev->trans_start = jiffies; /* prevent tx timeout */
 19        netif_wake_queue(dev);
 20
 21        …
 22}
 23
 24 static int
 25 dm9000_start_xmit(struct sk_buff *skb, struct net_device *dev)
 26 {
 27         ...
 28         /* TX control: First packet immediately send, second packet queue */
 29         if (db->tx_pkt_cnt == 1) {
 30                 dm9000_send_packet(dev, skb->ip_summed, skb->len);
 31         } else {
 32                 /* Second packet */
 33                 db->queue_pkt_len = skb->len;
 34                 db->queue_ip_summed = skb->ip_summed;
 35                 netif_stop_queue(dev);
 36         }
 37
 38         spin_unlock_irqrestore(&db->lock, flags);
 39
 40         /* free this SKB */
 41         dev_consume_skb_any(skb);
 42
 43         return NETDEV_TX_OK;
 44 }
 45
 46 static void dm9000_tx_done(struct net_device *dev, board_info_t *db)
 47 {
 48         int tx_status = ior(db, DM9000_NSR);    /* Got TX status */
 49
 50         if (tx_status & (NSR_TX2END | NSR_TX1END)) {
 51                 /* One packet sent complete */
 52                 db->tx_pkt_cnt--;
 53                 dev->stats.tx_packets++;
 54
 55                 if (netif_msg_tx_done(db))
 56                         dev_dbg(db->dev, "tx done, NSR %02x\n", tx_status);
 57
 58                 /* Queue packet check & send */
 59                 if (db->tx_pkt_cnt > 0)
 60                         dm9000_send_packet(dev, db->queue_ip_summed,
 61                                            db->queue_pkt_len);
 62                 netif_wake_queue(dev);
 63         }
 64 }
 65
 66 static void
 67 dm9000_rx(struct net_device *dev)
 68 {
 69         ...
 70
 71         /* Check packet ready or not */
 72         do {
 73                 ...
 74
 75                 /* Move data from DM9000*/
 76                 if (GoodPacket &&
 77                     ((skb = netdev_alloc_skb(dev, RxLen + 4)) != NULL)) {
 78                         skb_reserve(skb, 2);
 79                         rdptr = (u8*) skb_put(skb, RxLen - 4);
 80
 81                         /* Read received packet from RX SRAM */
 82
 83                         (db->inblk)(db->io_data, rdptr, RxLen);
 84                         dev->stats.rx_bytes += RxLen;
 85
 86                         /* Pass to upper layer */
 87                         skb->protocol = eth_type_trans(skb, dev);
 88                         if (dev->features & NETIF_F_RXCSUM) {
 89                                 if ((((rxbyte & 0x1c) << 3) & rxbyte) == 0)
 90                                         skb->ip_summed = CHECKSUM_UNNECESSARY;
 91                                 else
 92                                         skb_checksum_none_assert(skb);
 93                         }
 94                         netif_rx(skb);
 95                         dev->stats.rx_packets++;
 96
 97                 }...
 98         } while (rxbyte & DM9000_PKT_RDY);
 99 }
100
101 static irqreturn_t dm9000_interrupt(int irq, void *dev_id)
102 {
103         ...
104         /* Received the coming packet */
105         if (int_status & ISR_PRS)
106                 dm9000_rx(dev);
107
108         /* Trnasmit Interrupt check */
109         if (int_status & ISR_PTS)
110                 dm9000_tx_done(dev, db);
111
112         ...
113         return IRQ_HANDLED;
114 }
115
116 static int
117 dm9000_open(struct net_device *dev)
118 {
119         ...
120
121         /* Initialize DM9000board */
122         dm9000_init_dm9000(dev);
123
124         if (request_irq(dev->irq, dm9000_interrupt, irqflags, dev->name, dev))
125                 return -EAGAIN;
126         ...
127
128         mii_check_media(&db->mii, netif_msg_link(db), 1);
129         netif_start_queue(dev);
130
131         return 0;
132 }
133
134 static int
135 dm9000_stop(struct net_device *ndev)
136 {
137         ...
138
139         netif_stop_queue(ndev);
140         netif_carrier_off(ndev);
141
142         /* free interrupt */
143         free_irq(ndev->irq, ndev);
144
145         dm9000_shutdown(ndev);
146
147         return 0;
148 }
149
150 static const struct net_device_ops dm9000_netdev_ops = {
151         .ndo_open               = dm9000_open,
152         .ndo_stop               = dm9000_stop,
153         .ndo_start_xmit         = dm9000_start_xmit,
154         .ndo_tx_timeout         = dm9000_timeout,
155         .ndo_set_rx_mode        = dm9000_hash_table,
156         .ndo_do_ioctl           = dm9000_ioctl,
157         .ndo_change_mtu         = eth_change_mtu,
158         .ndo_set_features       = dm9000_set_features,
159         .ndo_validate_addr      = eth_validate_addr,
160         .ndo_set_mac_address    = eth_mac_addr,
161 #ifdef CONFIG_NET_POLL_CONTROLLER
162         .ndo_poll_controller    = dm9000_poll_controller,
163 #endif
164 };
165
166
167 /*
168  * Search DM9000board, allocate space and register it
169  */
170 static int
171 dm9000_probe(struct platform_device *pdev)
172 {
173         ...
174
175         /* Init network device */
176         ndev = alloc_etherdev(sizeof(struct board_info));
177         ...
178
179         /* setup board info structure */
180         db = netdev_priv(ndev);
181
182         ...
183
184         ...
185         /* driver system function */
186         ether_setup(ndev);
187
188         ndev->netdev_ops        = &dm9000_netdev_ops;
189         ndev->watchdog_timeo    = msecs_to_jiffies(watchdog);
190         ndev->ethtool_ops       = &dm9000_ethtool_ops;
191
192         ...
193         ret = register_netdev(ndev);
194
195 }
196
197 static int
198 dm9000_drv_remove(struct platform_device *pdev)
199 {
200         struct net_device *ndev = platform_get_drvdata(pdev);
201
202         unregister_netdev(ndev);
203         dm9000_release_board(pdev, netdev_priv(ndev));
204         free_netdev(ndev);              /* free device structure */
205         ...
206 }
207
208 #ifdef CONFIG_OF
209 static const struct of_device_id dm9000_of_matches[] = {
210         { .compatible = "davicom,dm9000", },
211         { /* sentinel */ }
212 };
213 MODULE_DEVICE_TABLE(of, dm9000_of_matches);
214 #endif
215
216 static struct platform_driver dm9000_driver = {
217         .driver = {
218                 .name    = "dm9000",
219                 .owner   = THIS_MODULE,
220                 .pm      = &dm9000_drv_pm_ops,
221                 .of_match_table = of_match_ptr(dm9000_of_matches),
222         },
223         .probe   = dm9000_probe,
224         .remove  = dm9000_drv_remove,
225 };
226
227 module_platform_driver(dm9000_driver);
```

DM9000驱动的实现与具体CPU无关，在将该驱动移植到特定电路板时，只需要在板文件中为与板上DM9000对应的平台设备的寄存器和数据基地址进行赋值，并指定正确的IRQ资源即可，代码清单14.20给出了在arch/arm/mach-at91/board-sam9261ek.c板文件中对DM9000添加的内容。

代码清单14.20　board-sam9261ek板文件中的DM9000的平台设备

```
 1static struct resource dm9000_resource[] = {
 2        [0] = {
 3                .start  = AT91_CHIPSELECT_2,
 4                .end    = AT91_CHIPSELECT_2+ 3,
 5                .flags  = IORESOURCE_MEM
 6        },
 7        [1] = {
 8                .start  = AT91_CHIPSELECT_2+ 0x44,
 9                .end    = AT91_CHIPSELECT_2+ 0xFF,
10                .flags  = IORESOURCE_MEM
11        },
12        [2] = {
13                .flags  = IORESOURCE_IRQ
14                        | IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE,
15        }
16};
17
18static struct dm9000_plat_data dm9000_platdata = {
19        .flags          = DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM,
20};
21
22static struct platform_device dm9000_device = {
23        .name           = "dm9000",
24        .id             = 0,
25        .num_resources  = ARRAY_SIZE(dm9000_resource),
26        .resource       = dm9000_resource,
27        .dev            = {
28                .platform_data  = &dm9000_platdata,
29        }
30};
```

