dmaengine是一套通用的DMA驱动框架，该框架为具体使用DMA通道的设备驱动提供了一套统一的API，而且也定义了用具体的DMA控制器实现这一套API的方法。

对于使用DMA引擎的设备驱动而言，发起DMA传输的过程变得整洁了，如在sound子系统的sound/soc/soc-dmaengine-pcm.c中，会使用dmaengine进行周期性的DMA传输，相关的代码如清单20.27所示。

代码清单20.27　dmaengine API的使用

```
 1static int dmaengine_pcm_prepare_and_submit(struct snd_pcm_substream *substream)
 2{
 3         struct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);
 4         struct dma_chan *chan = prtd->dma_chan;
 5         struct dma_async_tx_descriptor *desc;
 6         enum dma_transfer_direction direction;
 7         unsigned long flags = DMA_CTRL_ACK;
 8
 9         …
10         desc = dmaengine_prep_dma_cyclic(chan,
11                 substream->runtime->dma_addr,
12                 snd_pcm_lib_buffer_bytes(substream),
13                 snd_pcm_lib_period_bytes(substream), direction, flags);
14…
15         desc->callback = dmaengine_pcm_dma_complete;
16         desc->callback_param = substream;
17         prtd->cookie = dmaengine_submit(desc);
18}
19
20int snd_dmaengine_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
21{
22        struct dmaengine_pcm_runtime_data *prtd = substream_to_prtd(substream);
23        int ret;
24        switch (cmd) {
25        case SNDRV_PCM_TRIGGER_START:
26                ret = dmaengine_pcm_prepare_and_submit(substream);
27                …
28                dma_async_issue_pending(prtd->dma_chan);
29                break;
30        case SNDRV_PCM_TRIGGER_RESUME:
31        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
32                dmaengine_resume(prtd->dma_chan);
33                break;
34        …
35}
```

这个过程可分为4步：

1）通过dmaengine_prep_dma_xxx（）初始化一个具体的DMA传输描述符（本例中为结构体dma_async_tx_descriptor的实例desc，本例是一个周期性DMA，因此第10行调用的是dmaengine_prep_dma_cyclic（））。

2）通过dmaengine_submit（）将该描述符插入dmaengine驱动的传输队列（见第17行）。

3）在需要传输的时候通过类似dma_async_issue_pending（）的调用启动对应DMA通道上的传输（见第28行）。

4）DMA的完成，或者周期性DMA完成了一个周期，都会引发DMA传输描述符的完成回调函数被调用（本例中的赋值在第15行，对应的回调函数是dmaengine_pcm_dma_complete）。

也就是不管具体硬件的DMA控制器是如何实现的，在软件意义上都抽象为了设置DMA描述符、将DMA描述符插入传输队列以及启动DMA传输的过程。

除了前文提到的用dmaengine_prep_dma_cyclic（）定义周期性DMA传输外，还有一组类似的API可以用来定义各种类型的DMA描述符，特定硬件的DMA驱动的主要工作就是实现封装在内核dma_device结构体中的这些成员函数（定义在include/linux/dmaengine.h头文件中）：

```
/**
 * struct dma_device - info on the entity supplying DMA services
 * @device_prep_dma_memcpy: prepares a memcpy operation
 * @device_prep_dma_xor: prepares a xor operation
 * @device_prep_dma_xor_val: prepares a xor validation operation
 * @device_prep_dma_pq: prepares a pq operation
 * @device_prep_dma_pq_val: prepares a pqzero_sum operation
 * @device_prep_dma_memset: prepares a memset operation
 * @device_prep_dma_interrupt: prepares an end of chain interrupt operation
 * @device_prep_slave_sg: prepares a slave dma operation
 * @device_prep_dma_cyclic: prepare a cyclic dma operation suitable for audio.
 *      The function takes a buffer of size buf_len. The callback function will
 *      be called after period_len bytes have been transferred.
 * @device_prep_interleaved_dma: Transfer expression in a generic way.
 */
```

在底层的dmaengine驱动实例中，一般会组织好这个dma_device结构体，并通过dma_async_device_register（）完成注册。在其各个成员函数中，一般会通过链表来管理DMA描述符的运行、free等队列。

dma_device的成员函数device_issue_pending（）用于实现DMA传输开启的功能，每当DMA传输完成后，在驱动中注册的中断服务程序的顶半部或者底半部会调用DMA描述符dma_async_tx_descriptor中设置的回调函数，该回调函数来源于使用DMA通道的设备驱动。

典型的dmaengine驱动可见于drivers/dma/目录下的sirf-dma.c、omap-dma.c、pl330.c、ste_dma40.c等。