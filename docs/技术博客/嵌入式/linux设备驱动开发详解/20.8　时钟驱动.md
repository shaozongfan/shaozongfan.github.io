在一个SoC中，晶振、PLL、驱动和门等会形成一个时钟树形结构，在Linux 2.6中，也存有clk_get_rate（）、clk_set_rate（）、clk_get_parent（）、clk_set_parent（）等通用API，但是这些API由每个SoC单独实现，而且各个SoC供应商在实现方面的差异很大，于是内核增加了一个新的通用时钟框架以解决这个碎片化问题。之所以称为通用时钟，是因为这个通用主要体现在：

1）统一的clk结构体，统一的定义于clk.h中的clk API，这些API会调用统一的clk_ops中的回调函数；这个统一的clk结构体的定义如代码清单20.22所示。

代码清单20.22　clk结构体

```
 1struct clk {
 2        const char              *name;
 3        const struct clk_ops    *ops;
 4        struct clk_hw           *hw;
 5        char                    **parent_names;
 6        struct clk              **parents;
 7        struct clk              *parent;
 8        struct hlist_head       children;
 9        struct hlist_node       child_node;
10        ...
11};
```

其中第3行的clk_ops定义是关于时钟使能、禁止、计算频率等的操作集，定义如代码清单20.23所示。

代码清单20.23　clk_ops结构体

```
 1struct clk_ops {
 2               int             (*prepare)(struct clk_hw *hw);
 3               void            (*unprepare)(struct clk_hw *hw);
 4               int             (*enable)(struct clk_hw *hw);
 5               void            (*disable)(struct clk_hw *hw);
 6               int             (*is_enabled)(struct clk_hw *hw);
 7               unsigned long   (*recalc_rate)(struct clk_hw *hw,
 8                                               unsigned long parent_rate);
 9               long            (*round_rate)(struct clk_hw *hw, unsigned long,
10                                               unsigned long *);
11               int             (*set_parent)(struct clk_hw *hw, u8 index);
12               u8              (*get_parent)(struct clk_hw *hw);
13               int             (*set_rate)(struct clk_hw *hw, unsigned long);
14               void            (*init)(struct clk_hw *hw);
15};
```

2）对具体的SoC如何去实现针对自己SoC的clk驱动，如何提供硬件特定的回调函数的方法也进行了统一。

在代码清单20.22这个通用的clk结构体中，第4行的clk_hw是联系clk_ops中回调函数和具体硬件细节的纽带，clk_hw中只包含通用时钟结构体的指针以及具体硬件的init数据，如代码清单20.24所示。

代码清单20.24　clk_hw结构体

```
 1struct clk_hw {
 2         struct clk *clk;
 3         const struct clk_init_data *init;
 4};
```

其中的clk_init_data包含了具体时钟的名称、可能的父级时钟的名称列表parent_names、可能的父级时钟数量num_parents等，实际上这些名称的匹配对建立时钟间的父子关系功不可没，如代码清单20.25所示。

代码清单20.25　clk_init_data结构体

```
 1struct clk_init_data {
 2        const char              *name;
 3        const struct clk_ops    *ops;
 4        const char              **parent_names;
 5        u8                      num_parents;
 6        unsigned long           flags;
 7};
```

从clk核心层到具体芯片clk驱动的调用顺序为：

clk_enable（clk）；[插图] clk->ops->enable（clk->hw）；

通用的clk API（如clk_enable）在调用底层clk结构体的clk_ops成员函数（如clk->ops->enable）时，会将clk->hw传递过去。

一般在具体的驱动中会定义针对特定clk（如foo）的结构体，该结构体中包含clk_hw成员以及硬件私有数据：

```
struct clk_foo {
       struct clk_hw hw;
       ... hardware specific data goes here ...
};
```

并定义to_clk_foo（）宏，以便通过clk_hw获取clk_foo：

```
#define to_clk_foo(_hw) container_of(_hw, struct clk_foo, hw)
```

在针对clk_foo的clk_ops的回调函数中，我们便可以通过clk_hw和to_clk_foo最终获得硬件私有数据，并访问硬件读写寄存器以改变时钟的状态：

```
struct clk_ops clk_foo_ops {
       .enable         = &clk_foo_enable;
       .disable        = &clk_foo_disable;
};
int clk_foo_enable(struct clk_hw *hw)
{
       struct clk_foo *foo;
       foo = to_clk_foo(hw);
       /* 访问硬件读写寄存器以改变时钟的状态*/
       …
       return 0;
};
```

在具体的clk驱动中，需要通过clk_register（）以及它的变体注册硬件上所有的clk，通过clk_register_clkdev（）注册clk的一个lookup（这样可以通过con_id或者dev_id字符串寻找到这个clk），这两个函数的原型为：

```
struct clk *clk_register(struct device *dev, struct clk_hw *hw);
int clk_register_clkdev(struct clk *clk, const char *con_id,
         const char *dev_fmt, ...);
```

另外，针对不同的clk类型（如固定频率的clk、clk门、clk驱动等），clk子系统又提供了几个快捷函数以完成clk_register（）的过程：

```
struct clk *clk_register_fixed_rate(struct device *dev, const char *name,
                const char *parent_name, unsigned long flags,
                unsigned long fixed_rate);
struct clk *clk_register_gate(struct device *dev, const char *name,
                const char *parent_name, unsigned long flags,
                void __iomem *reg, u8 bit_idx,
                u8 clk_gate_flags, spinlock_t *lock);
struct clk *clk_register_divider(struct device *dev, const char *name,
                const char *parent_name, unsigned long flags,
                void __iomem *reg, u8 shift, u8 width,
                u8 clk_divider_flags, spinlock_t *lock);
```

以drivers/clk/clk-prima2.c为例，与该驱动对应的芯片SiRFprimaII的外围接了一个26MHz的晶振和一个32.768kHz的RTC晶振，在26MHz晶振的后面又有3个PLL，当然PLL后面又接了更多的clk节点，则它的相关驱动代码如清单20.26所示。

代码清单20.26　clk驱动案例

```
 1static unsigned long pll_clk_recalc_rate(struct clk_hw *hw,
 2unsigned long parent_rate)
 3{
 4unsigned long fin = parent_rate;
 5struct clk_pll *clk = to_pllclk(hw);
 6…
 7}
 8
 9static long pll_clk_round_rate(struct clk_hw *hw, unsigned long rate,
10unsigned long *parent_rate)
11{
12…
13}
14
15static int pll_clk_set_rate(struct clk_hw *hw, unsigned long rate,
16unsigned long parent_rate)
17{
18…
19}
20
21static struct clk_ops std_pll_ops = {
22.recalc_rate = pll_clk_recalc_rate,
23.round_rate = pll_clk_round_rate,
24.set_rate = pll_clk_set_rate,
25};
26
27static const char *pll_clk_parents[] = {
28"osc",
29};
30
31static struct clk_init_data clk_pll1_init = {
32.name = "pll1",
33.ops = &std_pll_ops,
34.parent_names = pll_clk_parents,
35.num_parents = ARRAY_SIZE(pll_clk_parents),
36};
37
38static struct clk_init_data clk_pll2_init = {
39.name = "pll2",
40.ops = &std_pll_ops,
41.parent_names = pll_clk_parents,
42.num_parents = ARRAY_SIZE(pll_clk_parents),
43};
44
45static struct clk_init_data clk_pll3_init = {
46.name = "pll3",
47.ops = &std_pll_ops,
48.parent_names = pll_clk_parents,
49.num_parents = ARRAY_SIZE(pll_clk_parents),
50};
51
52static struct clk_pll clk_pll1 = {
53.regofs = SIRFSOC_CLKC_PLL1_CFG0,
54.hw = {
55        .init = &clk_pll1_init,
56},
57};
58
59static struct clk_pll clk_pll2 = {
60.regofs = SIRFSOC_CLKC_PLL2_CFG0,
61.hw = {
62        .init = &clk_pll2_init,
63},
64};
65
66static struct clk_pll clk_pll3 = {
67.regofs = SIRFSOC_CLKC_PLL3_CFG0,
68.hw = {
69        .init = &clk_pll3_init,
70},
71};
72void __init sirfsoc_of_clk_init(void)
73{
74…
75
76/* These are always available (RTC and 26MHz OSC)*/
77clk = clk_register_fixed_rate(NULL, "rtc", NULL,
78       CLK_IS_ROOT, 32768);
79BUG_ON(!clk);
80clk = clk_register_fixed_rate(NULL, "osc", NULL,
81       CLK_IS_ROOT, 26000000);
82BUG_ON(!clk);
83
84clk = clk_register(NULL, &clk_pll1.hw);
85BUG_ON(!clk);
86clk = clk_register(NULL, &clk_pll2.hw);
87BUG_ON(!clk);
88clk = clk_register(NULL, &clk_pll3.hw);
89BUG_ON(!clk);
90…
91}
```

另外，目前内核更加倡导的方法是通过设备树来描述电路板上的时钟树，以及时钟和设备之间的绑定关系。通常我们需要在clk控制器的节点中定义#clock-cells属性，并且在clk驱动中通过of_clk_add_provider（）注册时钟控制器为一个时钟树的提供者（Provider），并建立系统中各个时钟和索引的映射表，如：

```
       Clock                   ID
       ---------------------------
       rtc                     0
       osc                     1
       pll1                    2
       pll2                    3
       pll3                    4
       mem                     5
       sys                     6
       security                7
       dsp                     8
       gps                     9
       mf                      10
       …
```

在每个具体的设备中，对应的.dts节点上的clocks=<&clks index>属性指向其引用的clk控制器节点以及使用的时钟的索引，如：

```
gps@a8010000 {
        compatible = "sirf,prima2-gps";
        reg = <0xa8010000 0x10000>;
        interrupts = <7>;
        clocks = <&clks 9>;
};
```

要特别强调的是，在具体的设备驱动中，一定要通过通用clk API来操作所有的时钟，而不要直接通过读写clk控制器的寄存器来进行，这些API包括：

```
struct clk *clk_get(struct device *dev, const char *id);
struct clk *devm_clk_get(struct device *dev, const char *id);
int clk_enable(struct clk *clk);
int clk_prepare(struct clk *clk);
void clk_unprepare(struct clk *clk);
void clk_disable(struct clk *clk);
static inline int clk_prepare_enable(struct clk *clk);
static inline void clk_disable_unprepare(struct clk *clk);
unsigned long clk_get_rate(struct clk *clk);
int clk_set_rate(struct clk *clk, unsigned long rate);
struct clk *clk_get_parent(struct clk *clk);
int clk_set_parent(struct clk *clk, struct clk *parent);
```

值得一提的是，名称中含有prepare、unprepare字符串的API是内核后来才加入的，过去只有clk_enable（）和clk_disable（）。只有clk_enable（）和clk_disable（）带来的问题是，有时候，某些硬件使能/禁止时钟可能会引起睡眠以使得使能/禁止不能在原子上下文进行。加上prepare后，把过去的clk_enable（）分解成不可在原子上下文调用的clk_prepare（）（该函数可能睡眠）和可以在原子上下文调用的clk_enable（）。而clk_prepare_enable（）则同时完成准备和使能的工作，当然也只能在可能睡眠的上下文调用该API。