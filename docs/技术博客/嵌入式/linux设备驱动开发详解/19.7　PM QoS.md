Linux内核的PM QoS系统针对内核和应用程序提供了一套接口，通过这个接口，用户可以设定自身对性能的期望。一类是系统级的需求，通过cpu_dma_latency、network_latency和network_throughput这些参数来设定；另一类是单个设备可以根据自身的性能需求发起per-device的PM QoS请求。

在内核空间，通过pm_qos_add_request（）函数可以注册PM QoS请求：

```
void pm_qos_add_request(struct pm_qos_request *req,
int pm_qos_class, s32 value);
```

通过pm_qos_update_request（）函数可以更新已注册的PM QoS请求：

```
void pm_qos_update_request(struct pm_qos_request *req,
                      s32 new_value);
void pm_qos_update_request_timeout(struct pm_qos_request *req, s32 new_value,
unsigned long timeout_us);
```

通过pm_qos_remove_request（）函数可以删除已注册的PM QoS请求：

```
void pm_qos_remove_request(struct pm_qos_request *req);
```

譬如在drivers/media/platform/via-camera.c这个摄像头驱动中，当摄像头开启后，通过如下语句可以阻止CPU进入C3级别的深度Idle：

```
static int viacam_streamon(struct file *filp, void *priv, enum v4l2_buf_type t)
{
    …
    pm_qos_add_request(&cam->qos_request, PM_QOS_CPU_DMA_LATENCY, 50);
    …
}
```

这是因为，在CPUIdle子系统中，会根据PM_QOS_CPU_DMA_LATENCY请求的情况选择合适的C状态，如drivers/cpuidle/governors/ladder.c中的ladder_select_state（）就会判断目标C状态的exit_latency与QoS要求的关系，如代码清单19.11所示。

代码清单19.11　CPUIdle LADDER governor对QoS的判断

```
 1static int ladder_select_state(struct cpuidle_driver *drv,
 2                          struct cpuidle_device *dev)
 3{
 4      …
 5      int latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);
 6
 7      …
 8
 9      /* consider promotion */
10      if (last_idx < drv->state_count - 1 &&
11         !drv->states[last_idx + 1].disabled &&
12         !dev->states_usage[last_idx + 1].disable &&
13         last_residency > last_state->threshold.promotion_time &&
14         drv->states[last_idx + 1].exit_latency <= latency_req) {
15            last_state->stats.promotion_count++;
16            last_state->stats.demotion_count = 0;
17            if(last_state->stats.promotion_count>=
18             last_state->threshold.promotion_count) {
19                  ladder_do_selection(ldev, last_idx, last_idx + 1);
20                  return last_idx + 1;
21            }
22      }
23      …
24}
```

LADDER在选择是否进入更深层次的C状态时，会比较C状态的exit_latency要小于通过pm_qos_request（PM_QOS_CPU_DMA_LATENCY）得到的PM QoS请求的延迟，见代码清单19.11的第14行。

同样的逻辑也出现于drivers/cpuidle/governors/menu.c中，如代码清单19.12的第18~19行。

代码清单19.12　CPUIdle MENU governor对QoS的判断

```
 1static int menu_select(struct cpuidle_driver *drv, struct cpuidle_device *dev)
 2{
 3       struct menu_device *data = &__get_cpu_var(menu_devices);
 4       int latency_req = pm_qos_request(PM_QOS_CPU_DMA_LATENCY);
 5       …
 6       /*
 7        * Find the idle state with the lowest power while satisfying
 8        * our constraints.
 9        */
10       for (i = CPUIDLE_DRIVER_STATE_START; i < drv->state_count; i++) {
11              struct cpuidle_state *s = &drv->states[i];
12              struct cpuidle_state_usage *su = &dev->states_usage[i];
13
14              if (s->disabled || su->disable)
15                     continue;
16              if (s->target_residency > data->predicted_us)
17                     continue;
18              if ( s->exit_latency > latency_req)
19                      continue;
20              if (s->exit_latency * multiplier > data->predicted_us)
21                     continue;
22
23              if (s->power_usage < power_usage) {
24                     power_usage = s->power_usage;
25                     data->last_state_idx = i;
26                     data->exit_us = s->exit_latency;
27              }
28       }
29
30       return data->last_state_idx;
31}
```

还是回到drivers/media/platform/via-camera.c中，当摄像头关闭后，它会通过如下语句告知上述代码对PM_QOS_CPU_DMA_LATENCY的性能要求取消：

```
static int viacam_streamon(struct file *filp, void *priv, enum v4l2_buf_type t)
{
    …
    pm_qos_remove_request(&cam->qos_request);
    …
}
```

类似的在设备驱动中申请QoS特性的例子还包括drivers/net/wireless/ipw2x00/ipw2100.c、drivers/tty/serial/omap-serial.c、drivers/net/ethernet/intel/e1000e/netdev.c等。

应用程序则可以通过向/dev/cpu_dma_latency和/dev/network_latency这样的设备节点写入值来发起QoS的性能请求。