在Linux中，内核打印语句printk（）会将内核信息输出到内核信息缓冲区中，内核缓冲区是在kernel/printk.c中通过如下语句静态定义的：

```
static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
```

内核信息缓冲区是一个环形缓冲区（Ring Buffer），因此，如果塞入的消息过多，则就会将之前的消息冲刷掉。

printk（）定义了8个消息级别，分为级别0~7，级别越低（数值越大），消息越不重要，第0级是紧急事件级，第7级是调试级，代码清单21.2所示为printk（）的级别定义。

代码清单21.2　printk（）的级别定义

```
 1 #define KERN_EMERG "<0>"      /* 紧急事件，一般是系统崩溃之前提示的消息 */
 2 #define KERN_ALERT "<1>"      /* 必须立即采取行动*/
 3 #define KERN_CRIT "<2>"       /* 临界状态，通常涉及严重的硬件或软件操作失败*/
 4 #define KERN_ERR  "<3>"       /* 用于报告错误状态，设备驱动程序会经常使用KERN_ERR来报告来自硬件的问题*/
 6 #define KERN_WARNING  "<4>"   /* 对可能出现问题的情况进行警告，
 7                                  这类情况通常不会对系统造成严重的问题*/
 8 #define KERN_NOTICE   "<5>"   /* 有必要进行提示的正常情形，
 9                                  许多与安全相关的状况用这个级别进行汇报*/
10#define KERN_INFO     "<6>"    /* 内核提示性信息，很多驱动程序
11                                  在启动的时候，用这个级别打印出它们找到的硬件信息*/
12#define KERN_DEBUG    "<7>"    /* 用于调试信息*/
```

通过/proc/sys/kernel/printk文件可以调节printk（）的输出等级，该文件有4个数字值，如下所示。

- ·控制台（一般是串口）日志级别：当前的打印级别，优先级高于该值的消息将被打印至控制台。
- ·默认的消息日志级别：将用该优先级来打印没有优先级前缀的消息，也就是在直接写printk（“xxx”）而不带打印级别的情况下，会使用该打印级别。
- ·最低的控制台日志级别：控制台日志级别可被设置的最小值（一般都是1）。
- ·默认的控制台日志级别：控制台日志级别的默认值。

如在Ubuntu PC上，/proc/sys/kernel/printk的值一般如下：

```
$ cat /proc/sys/kernel/printk
4   4    1   7
```

而我们通过如下命令可以使得Linux内核的任何printk（）都从控制台输出：

```
# echo 8 > /proc/sys/kernel/printk
```

在默认情况下，DEBUG级别的消息不会从控制台输出，我们可以通过在bootargs中设置ignore_loglevel来忽略打印级别，以保证所有消息都被打印到控制台。在系统启动后，用户还可以通过写/sys/module/printk/parameters/ignore_loglevel文件动态来设置是否忽略打印级别。

要注意的是，/proc/sys/kernel/printk并不控制内核消息进入__log_buf的门槛，因此无论消息级别是多少，都会进入__log_buf中，但是最终只有高于当前打印级别的内核消息才会从控制台打印。

用户可以通过dmesg命令查看内核打印缓冲区，而如果使用dmesg-c命令，则不仅会显示__log_buf，还会清除该缓冲区的内容。也可以使用cat/proc/kmsg命令来显示内核信息。/proc/kmsg是一个“永无休止的文件”，因此，cat/proc/kmsg的进程只能通过“Ctrl+C”或kill终止。

在设备驱动中，经常需要输出调试或系统信息，尽管可以直接采用printk（“<7>debug info…\n”）方式的printk（）语句输出，但是通常可以使用封装了printk（）的更高级的宏，如pr_debug（）、dev_debug（）等。代码清单21.3所示为pr_debug（）和pr_info（）的定义。

代码清单21.3　可替代printk（）的宏pr_debug（）和pr_info（）的定义

```
 1#ifdef DEBUG
 2#define pr_debug(fmt,arg...) \
 3  printk(KERN_DEBUG fmt,##arg)
 4#else
 5static inline int _ _attribute_ _ ((format (printf, 1, 2))) pr_debug(const char * fmt, ...)
 6{
 7   return 0;
 8}
 9#endif
10
11#define pr_info(fmt,arg...) \
12   printk(KERN_INFO fmt,##arg)
```

使用pr_xxx（）族API的好处是，可以在文件最开头通过pr_fmt（）定义一个打印格式，比如在kernel/watchdog.c的最开头通过如下定义可以保证之后watchdog.c调用的所有pr_xxx（）打印的消息都自动带有“NMI watchdog：”的前缀。

```
#define pr_fmt(fmt) "NMI watchdog: " fmt
#include <linux/mm.h>
#include <linux/cpu.h>
#include <linux/nmi.h>…
```

代码清单21.4所示为dev_dbg（）、dev_err（）、dev_info（）等的定义，使用dev_xxx（）族API打印的时候，设备名称会被自动加到打印消息的前头。

代码清单21.4　包含设备信息的可替代printk（）的宏

```
 1#define dev_printk(level, dev, format, arg...)  \
 2  printk(level "%s %s: " format , dev_driver_string(dev) , (dev)->bus_id , ## arg)
 3
 4#ifdef DEBUG
 5#define dev_dbg(dev, format, arg...)            \
 6       dev_printk(KERN_DEBUG , dev , format , ## arg)
 7#else
 8#define dev_dbg(dev, format, arg...) do { (void)(dev); } while (0)
 9#endif
10
11#define dev_err(dev, format, arg...)            \
12       dev_printk(KERN_ERR , dev , format , ## arg)
13#define dev_info(dev, format, arg...)           \
14       dev_printk(KERN_INFO , dev , format , ## arg)
15#define dev_warn(dev, format, arg...)           \
16       dev_printk(KERN_WARNING , dev , format , ## arg)
17#define dev_notice(dev, format, arg...)         \
18       dev_printk(KERN_NOTICE , dev , format , ## arg)
```

代码清单21.4所示为dev_dbg（）、dev_err（）、dev_info（）等的定义，使用dev_xxx（）族API打印的时候，设备名称会被自动加到打印消息的前头。

代码清单21.4　包含设备信息的可替代printk（）的宏

```
 1#define dev_printk(level, dev, format, arg...)  \
 2  printk(level "%s %s: " format , dev_driver_string(dev) , (dev)->bus_id , ## arg)
 3
 4#ifdef DEBUG
 5#define dev_dbg(dev, format, arg...)            \
 6       dev_printk(KERN_DEBUG , dev , format , ## arg)
 7#else
 8#define dev_dbg(dev, format, arg...) do { (void)(dev); } while (0)
 9#endif
10
11#define dev_err(dev, format, arg...)            \
12       dev_printk(KERN_ERR , dev , format , ## arg)
13#define dev_info(dev, format, arg...)           \
14       dev_printk(KERN_INFO , dev , format , ## arg)
15#define dev_warn(dev, format, arg...)           \
16       dev_printk(KERN_WARNING , dev , format , ## arg)
17#define dev_notice(dev, format, arg...)         \
18       dev_printk(KERN_NOTICE , dev , format , ## arg)
```

在打印信息时，如果想输出printk（）调用所在的函数名，可以使用__func__；如果想输出其所在代码的行号，可以使用__LINE__；想输出源代码文件名，可以使用__FILE__。例如drivers/block/sx8.c中的：

```
#ifdef CARM_NDEBUG
#define assert(expr)
#else
#define assert(expr) \
       if(unlikely(!(expr))) {                                 \
       printk(KERN_ERR "Assertion failed! %s,%s,%s,line=%d\n", \
       #expr, __FILE__, __func__, __LINE__);          \
       }
#endif
```

