# 9.3.1　在globalfifo驱动中增加异步通知

首先，参考代码清单9.3，应该将异步结构体指针添加到globalfifo_dev设备结构体内，如代码清单9.7所示。

代码清单9.7　增加异步通知后的globalfifo设备结构体

```
 1struct globalfifo_dev {
 2   struct cdev cdev;
 3   unsigned int current_len;
 4   unsigned char mem[GLOBALFIFO_SIZE];
 5   struct mutex mutex;
 6   wait_queue_head_t r_wait;
 7   wait_queue_head_t w_wait;
 8   struct fasync_struct *async_queue;
 9};
```

参考代码清单9.4的fasync（）函数模板，globalfifo的这个函数如代码清单9.8所示。

代码清单9.8　支持异步通知的globalfifo设备驱动fasync（）函数

```
 1static int globalfifo_fasync(int fd, struct file *filp, int mode)
 2{
 3   struct globalfifo_dev *dev = filp->private_data;
 4   return fasync_helper(fd, filp, mode, &dev->async_queue);
 5}
```

在globalfifo设备被正确写入之后，它变得可读，这个时候驱动应释放SIGIO信号，以便应用程序捕获，代码清单9.9给出了支持异步通知的globalfifo设备驱动的写函数。

代码清单9.9　支持异步通知的globalfifo设备驱动写函数

```
 1static ssize_t globalfifo_write(struct file *filp, const char __user *buf,
 2                  size_t count, loff_t *ppos)
 3{
 4  struct globalfifo_dev *dev = filp->private_data;
 5  int ret;
 6  DECLARE_WAITQUEUE(wait, current);
 7
 8  mutex_lock(&dev->mutex);
 9  add_wait_queue(&dev->w_wait, &wait);
10
11  while (dev->current_len == GLOBALFIFO_SIZE) {
12       if (filp->f_flags & O_NONBLOCK) {
13            ret = -EAGAIN;
14            goto out;
15       }
16       __set_current_state(TASK_INTERRUPTIBLE);
17
18       mutex_unlock(&dev->mutex);
19
20       schedule();
21       if (signal_pending(current)) {
22            ret = -ERESTARTSYS;
23            goto out2;
24       }
25
26       mutex_lock(&dev->mutex);
27  }
28
29  if (count > GLOBALFIFO_SIZE - dev->current_len)
30       count = GLOBALFIFO_SIZE - dev->current_len;
31
32  if (copy_from_user(dev->mem + dev->current_len, buf, count)) {
33       ret = -EFAULT;
34       goto out;
35  } else {
36       dev->current_len += count;
37       printk(KERN_INFO "written %d bytes(s),current_len:%d\n", count,
38              dev->current_len);
39
40       wake_up_interruptible(&dev->r_wait);
41
42       if (dev->async_queue) {
43            kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
44            printk(KERN_DEBUG "%s kill SIGIO\n", __func__);
45       }
46
47       ret = count;
48  }
49
50 out:
51  mutex_unlock(&dev->mutex);
52 out2:
53  remove_wait_queue(&dev->w_wait, &wait);
54  set_current_state(TASK_RUNNING);
55  return ret;
56}
```

参考代码清单9.6，增加异步通知后的globalfifo设备驱动的release（）函数中需调用globalfifo_fasync（）函数将文件从异步通知列表中删除，代码清单9.10给出了支持异步通知的globalfifo_release（）函数。

代码清单9.10　增加异步通知后的globalfifo设备驱动release（）函数

```
 1static int globalfifo_release(struct inode *inode, struct file *filp)
 2{
 3  globalfifo_fasync(-1, filp, 0);
 4  return 0;
 5}
```

# 9.3.2　在用户空间中验证globalfifo的异步通知

现在，我们可以采用与代码清单9.2类似的方法，编写一个在用户空间验证globalfifo异步通知的程序，这个程序在接收到由globalfifo发出的信号后将输出信号值，如代码清单9.11所示。

代码清单9.11　监控globalfifo异步通知信号的应用程序

```
 1static void signalio_handler(int signum)
 2{
 3   printf("receive a signal from globalfifo,signalnum:%d\n", signum);
 4}
 5
 6void main(void)
 7{
 8  int fd, oflags;
 9  fd = open("/dev/globalfifo", O_RDWR, S_IRUSR | S_IWUSR);
10  if (fd != -1) {
11       signal(SIGIO, signalio_handler);
12       fcntl(fd, F_SETOWN, getpid());
13       oflags = fcntl(fd, F_GETFL);
14       fcntl(fd, F_SETFL, oflags | FASYNC);
15       while (1) {
16            sleep(100);
17       }
18  } else {
19       printf("device open failure\n");
20  }
21}
```

本书代码/kernel/drivers/globalfifo/ch9包含了支持异步通知的globalfifo驱动以及代码清单9.11对应的globalfifo_test.c测试程序，在该目录运行make将得到globalfifo.ko和globalfifo_test。

按照与第8章相同的方法加载新的globalfifo设备驱动并创建设备文件节点，运行上述程序，每当通过echo向/dev/globalfifo写入新的数据时，signalio_handler（）将会被调用：

```
baohua@baohua-VirtualBox:~/develop/training/kernel/drivers/globalfifo/ch9$ sudo su
# ./globalfifo_test&
[1] 25251
# echo 1 > /dev/globalfifo
receive a signal from globalfifo,signalnum:29    -> globalfifo_test程序打印
# echo hello > /dev/globalfifo
receive a signal from globalfifo,signalnum:29   -> globalfifo_test程序打印
```

