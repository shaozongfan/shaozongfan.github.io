# 12.2.1　platform总线、设备与驱动

在Linux 2.6以后的设备驱动模型中，需关心总线、设备和驱动这3个实体，总线将设备和驱动绑定。在系统每注册一个设备的时候，会寻找与之匹配的驱动；相反的，在系统每注册一个驱动的时候，会寻找与之匹配的设备，而匹配由总线完成。

一个现实的Linux设备和驱动通常都需要挂接在一种总线上，对于本身依附于PCI、USB、I2 C、SPI等的设备而言，这自然不是问题，但是在嵌入式系统里面，在SoC系统中集成的独立外设控制器、挂接在SoC内存空间的外设等却不依附于此类总线。基于这一背景，Linux发明了一种虚拟的总线，称为platform总线，相应的设备称为platform_device，而驱动成为platform_driver

注意： 所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段，例如，我们通常把在SoC内部集成的I2 C、RTC、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。platform_device结构体的定义如代码清单12.1所示。

代码清单12.1　platform_device结构体

```
 1struct platform_device {
 2  const char    *name;
 3  int        id;
 4  boo    id_auto;
 5  struct devicedev;
 6  u32       num_resources;
 7  struct resource    *resource;
 8
 9  const struct platform_device_id    *id_entry;
10  char *driver_override; /* Driver name to force a match */
11
12  /* MFD cell pointer */
13  struct mfd_cell *mfd_cell;
14
15  /* arch specific additions */
16  struct pdev_archdata    archdata;
17};
```

platform_driver这个结构体中包含probe（）、remove（）、一个device_driver实例、电源管理函数suspend（）、resume（），如代码清单12.2所示。

代码清单12.2　platform_driver结构体

```
 1struct platform_driver {
 2 int (*probe)(struct platform_device *);
 3 int (*remove)(struct platform_device *);
 4 void (*shutdown)(struct platform_device *);
 5 int (*suspend)(struct platform_device *, pm_message_t state);
 6 int (*resume)(struct platform_device *);
 7 struct device_driver driver;
 8 const struct platform_device_id *id_table;
 9 bool prevent_deferred_probe;
10};
```

直接填充platform_driver的suspend（）、resume（）做电源管理回调的方法目前已经过时，较好的做法是实现platform_driver的device_driver中的dev_pm_ops结构体成员（后续的Linux电源管理章节会对此进行更细致的介绍），代码清单12.3给出了device_driver的定义。

代码清单12.3　device_driver结构体

```
 1struct device_driver {
 2       const char              *name;
 3       struct bus_type         *bus;
 4
 5       struct module           *owner;
 6       const char              *mod_name;  /* used for built-in modules */
 7
 8       bool suppress_bind_attrs;           /* disables bind/unbind via sysfs */
 9
10       const struct of_device_id           *of_match_table;
11       const struct acpi_device_id         *acpi_match_table;
12
13       int (*probe) (struct device *dev);
14       int (*remove) (struct device *dev);
15       void (*shutdown) (struct device *dev);
16       int (*suspend) (struct device *dev, pm_message_t state);
17       int (*resume) (struct device *dev);
18       const struct attribute_group **groups;
19
20       const struct dev_pm_ops *pm;
21
22       struct driver_private *p;
23};
```

与platform_driver地位对等的i2c_driver、spi_driver、usb_driver、pci_driver中都包含了device_driver结构体实例成员。它其实描述了各种xxx_driver（xxx是总线名）在驱动意义上的一些共性。

系统为platform总线定义了一个bus_type的实例platform_bus_type，其定义位于drivers/base/platform.c下，如代码清单12.4所示

代码清单12.4　platform总线的bus_type实例platform_bus_type

```
1struct bus_type platform_bus_type = {
2       .name           = "platform",
3       .dev_groups     = platform_dev_groups,
4       .match          = platform_match,
5       .uevent         = platform_uevent,
6       .pm             = &platform_dev_pm_ops,
7};
```

这里要重点关注其match（）成员函数，正是此成员函数确定了platform_device和platform_driver之间是如何进行匹配，如代码清单12.5所示。

代码清单12.5　platform_bus_type的match（）成员函数

```
 1static int platform_match(struct device *dev, struct device_driver *drv)
 2{
 3       struct platform_device *pdev = to_platform_device(dev);
 4       struct platform_driver *pdrv = to_platform_driver(drv);
 5
 6       /* Attempt an OF style match first */
 7       if (of_driver_match_device(dev, drv))
 8              return 1;
 9
10       /* Then try ACPI style match */
11       if (acpi_driver_match_device(dev, drv))
12                return 1;
13
14       /* Then try to match against the id table */
15       if (pdrv->id_table)
16                return platform_match_id(pdrv->id_table, pdev) != NULL;
17
18       /* fall-back to driver name match */
19       return (strcmp(pdev->name, drv->name) == 0);
20}
```

从代码清单12.5可以看出，匹配platform_device和platform_driver有4种可能性，

- 一是基于设备树风格的匹配；
- 二是基于ACPI风格的匹配；
- 三是匹配ID表（即platform_device设备名是否出现在platform_driver的ID表内）；
- 第四种是匹配platform_device设备名和驱动的名字。

对于Linux 2.6ARM平台而言，对platform_device的定义通常在BSP的板文件中实现，在板文件中，将platform_device归纳为一个数组，最终通过platform_add_devices（）函数统一注册。platform_add_devices（）函数可以将平台设备添加到系统中，这个函数的原型为：

```
int platform_add_devices(struct platform_device **devs, int num);
```

该函数的第一个参数为平台设备数组的指针，第二个参数为平台设备的数量，它内部调用了platform_device_register（）函数以注册单个的平台设备。

Linux 3.x之后，ARM Linux不太喜欢人们以编码的形式去填写platform_device和注册，而倾向于根据设备树中的内容自动展开platform_device。

# 12.2.2　将globalfifo作为platform设备

现在我们将前面章节的globalfifo驱动挂接到platform总线上，这要完成两个工作。

1）将globalfifo移植为platform驱动。

2）在板文件中添加globalfifo这个platform设备。

为完成将globalfifo移植到platform驱动的工作，需要在原始的globalfifo字符设备驱动中套一层platform_driver的外壳，如代码清单12.6所示。注意进行这一工作后，并没有改变globalfifo是字符设备的本质，只是将其挂接到了platform总线上。

代码清单12.6　为globalfifo添加platform_driver

```
 1static int globalfifo_probe(struct platform_device *pdev)
 2{
 3       int ret;
 4       dev_t devno = MKDEV(globalfifo_major, 0);
 5
 6       if (globalfifo_major)
 7              ret = register_chrdev_region(devno, 1, "globalfifo");
 8       else {
 9              ret = alloc_chrdev_region(&devno, 0, 1, "globalfifo");
10              globalfifo_major = MAJOR(devno);
11       }
12       if (ret < 0)
13              return ret;
14
15           globalfifo_devp = devm_kzalloc(&pdev->dev, sizeof(*globalfifo_devp),
             GFP_KERNEL);
16       if (!globalfifo_devp) {
17              ret = -ENOMEM;
18              goto fail_malloc;
19       }
20
21       globalfifo_setup_cdev(globalfifo_devp, 0);
22
23       mutex_init(&globalfifo_devp->mutex);
24       init_waitqueue_head(&globalfifo_devp->r_wait);
25       init_waitqueue_head(&globalfifo_devp->w_wait);
26
27       return 0;
28
29fail_malloc:
30       unregister_chrdev_region(devno, 1);
31       return ret;
32}
33
34static int globalfifo_remove(struct platform_device *pdev)
35{
36       cdev_del(&globalfifo_devp->cdev);
37       unregister_chrdev_region(MKDEV(globalfifo_major, 0), 1);
38
39       return 0;
40}
41
42static struct platform_driver globalfifo_driver = {
43       .driver = {
44               .name = "globalfifo",
45               .owner = THIS_MODULE,
46       },
47       .probe = globalfifo_probe,
48       .remove = globalfifo_remove,
49};
50
51module_platform_driver(globalfifo_driver);
```

在代码清单12.6中，module_platform_driver（）宏所定义的模块加载和卸载函数仅仅通过platform_driver_register（）、platform_driver_unregister（）函数进行platform_driver的注册与注销，而原先注册和注销字符设备的工作已经被移交到platform_driver的probe（）和remove（）成员函数中。

代码清单12.6未列出的部分与原始的globalfifo驱动相同，都是实现作为字符设备驱动核心的file_operations的成员函数。注册完globalfifo对应的platform_driver后，我们会发现/sys/bus/platform/drivers目录下多出了一个名字叫globalfifo的子目录。

为了完成在板文件中添加globalfifo这个platform设备的工作，需要在板文件arch/arm/mach-<soc名>/mach-<板名>.c）中添加相应的代码，如代码清单12.7所示。

代码清单12.7　与globalfifo对应的platform_device

```
1static struct platform_device globalfifo_device = {
2  .name         = "globalfifo",
3  .id         = -1,
4};
```

并最终通过类似于platform_add_devices（）的函数把这个platform_device注册进系统。如果一切顺利，我们会在/sys/devices/platform目录下看到一个名字叫globalfifo的子目录，/sys/devices/platform/globalfifo中会有一个driver文件，它是指向/sys/bus/platform/drivers/globalfifo的符号链接，这证明驱动和设备匹配上了。

# 12.2.3　platform设备资源和数据

留意一下代码清单12.1中platform_device结构体定义的第6~7行，它们描述了platform_device的资源，资源本身由resource结构体描述，其定义如代码清单12.8所示。

代码清单12.8　resource结构体定义

```
1struct resource {
2  resource__size_t start;
3  resource_size_t end;
4  const char *name;
5  unsigned long flags;
6  struct resource *parent, *sibling, *child;
7};
```

我们通常关心start、end和flags这3个字段，它们分别标明了资源的开始值、结束值和类型，flags可以为IORESOURCE_IO、IORESOURCE_MEM、IORESOURCE_IRQ、IORE-SOURCE_DMA等。start、end的含义会随着flags而变更，如当flags为IORESOURCE_MEM时，start、end分别表示该platform_device占据的内存的开始地址和结束地址；当flags为IORESOURCE_IRQ时，start、end分别表示该platform_device使用的中断号的开始值和结束值，如果只使用了1个中断号，开始和结束值相同。对于同种类型的资源而言，可以有多份，例如说某设备占据了两个内存区域，则可以定义两个IORESOURCE_MEM资源。

对resource的定义也通常在BSP的板文件中进行，而在具体的设备驱动中通过platform_get_resource（）这样的API来获取，此API的原型为：

```
struct resource *platform_get_resource(struct platform_device *, unsigned int,
    unsigned int);
```

例如在arch/arm/mach-at91/board-sam9261ek.c板文件中为DM9000网卡定义了如下resouce：

```
static struct resource dm9000_resource[] = {
       [0] = {
               .start  = AT91_CHIPSELECT_2,
               .end    = AT91_CHIPSELECT_2+ 3,
               .flags  = IORESOURCE_MEM
       },
       [1] = {
               .start  = AT91_CHIPSELECT_2+ 0x44,
               .end    = AT91_CHIPSELECT_2+ 0xFF,
               .flags  = IORESOURCE_MEM
       },
       [2] = {
               .flags  = IORESOURCE_IRQ
                       | IORESOURCE_IRQ_LOWEDGE | IORESOURCE_IRQ_HIGHEDGE,
       }
};
```

在DM9000网卡的驱动中则是通过如下办法拿到这3份资源：

```
db->addr_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
db->data_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
db->irq_res  = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
```

对于IRQ而言，platform_get_resource（）还有一个进行了封装的变体platform_get_irq（），其原型为：

```
int platform_get_irq(struct platform_device *dev, unsigned int num);
```

它实际上调用了“platform_get_resource（dev，IORESOURCE_IRQ，num）；”。

设备除了可以在BSP中定义资源以外，还可以附加一些数据信息，因为对设备的硬件描述除了中断、内存等标准资源以外，可能还会有一些配置信息，而这些配置信息也依赖于板，不适宜直接放置在设备驱动上。因此，platform也提供了platform_data的支持，platform_data的形式是由每个驱动自定义的，如对于DM9000网卡而言，platform_data为一个dm9000_plat_data结构体，完成定义后，就可以将MAC地址、总线宽度、板上有无EEPROM信息等放入platform_data中，如代码清单12.9所示。

代码清单12.9　platform_data的使用

```
 1static struct dm9000_plat_data dm9000_platdata = {
 2        .flags          = DM9000_PLATF_16BITONLY | DM9000_PLATF_NO_EEPROM,
 3};
 4
 5static struct platform_device dm9000_device = {
 6        .name           = "dm9000",
 7        .id             = 0,
 8        .num_resources  = ARRAY_SIZE(dm9000_resource),
 9        .resource       = dm9000_resource,
10        .dev            = {
11                .platform_data  = &dm9000_platdata,
12        }
13};
```

[插图]而在DM9000网卡的驱动drivers/net/ethernet/davicom/dm9000.c的probe（）中，通过如下方式就拿到了platform_data：

```
struct dm9000_plat_data *pdata = dev_get_platdata(&pdev->dev);
```

其中，pdev为platform_device的指针。

由以上分析可知，在设备驱动中引入platform的概念至少有如下好处。

1）使得设备被挂接在一个总线上，符合Linux 2.6以后内核的设备模型。其结果是使配套的sysfs节点、设备电源管理都成为可能。

2）隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体配置信息，而在驱动中，只需要通过通用API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。

3）让一个驱动支持多个设备实例。譬如DM9000的驱动只有一份，但是我们可以在板级添加多份DM9000的platform_device，它们都可以与唯一的驱动匹配。

在Linux 3.x之后的内核中，DM9000驱动实际上已经可以通过设备树的方法被枚举，可以参见补丁net：dm9000：Allow instantiation using device tree（内核commit的ID是0b8bf1ba）。

```
index a2408c8..dd243a1 100644
--- a/drivers/net/ethernet/davicom/dm9000.c
+++ b/drivers/net/ethernet/davicom/dm9000.c
@@ -29,6+29,8@@
#include <linux/spinlock.h>
#include <linux/crc32.h>
#include <linux/mii.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
#include <linux/ethtool.h>
#include <linux/dm9000.h>
#include <linux/delay.h>
@@ -1351,6+1353,31@@ static const struct net_device_ops dm9000_netdev_ops = {
#endif
};
+static struct dm9000_plat_data *dm9000_parse_dt(struct device *dev)
+{
+ …
+}
+
/*
* Search DM9000board, allocate space and register it
*/
@@ -1366,6+1393,12@@ dm9000_probe(struct platform_device *pdev)
int i;
u32id_val;
+ if (!pdata) {
+     pdata = dm9000_parse_dt(&pdev->dev);
+     if (IS_ERR(pdata))
+         return PTR_ERR(pdata);
+ }
+
/* Init network device */
ndev = alloc_etherdev(sizeof(struct board_info));
if (!ndev)
@@ -1676,11+1709,20@@ dm9000_drv_remove(struct platform_device *pdev)
return 0;
}
+#ifdef CONFIG_OF
+static const struct of_device_id dm9000_of_matches[] = {
+   { .compatible = "davicom,dm9000", },
+   { /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, dm9000_of_matches);
+#endif
+
static struct platform_driver dm9000_driver = {
    .driver = {
    .name = "dm9000",
    .owner = THIS_MODULE,
    .pm = &dm9000_drv_pm_ops,
+      .of_match_table = of_match_ptr(dm9000_of_matches),
},
.probe = dm9000_probe,
.remove = dm9000_drv_remove,
```

改为设备树后，在板上添加DM9000网卡的动作就变成了简单地修改dts文件，如arch/arm/boot/dts/s3c6410-mini6410.dts中就有这样的代码：

```
srom-cs1@18000000 {
        compatible = "simple-bus";
        #address-cells = <1>;
        #size-cells = <1>;
        reg = <0x180000000x8000000>;
        ranges;
        ethernet@18000000{
                compatible = "davicom,dm9000";
                reg = <0x180000000x20x180000040x2>;
                interrupt-parent = <&gpn>;
                interrupts = <7IRQ_TYPE_LEVEL_HIGH>;
                davicom,no-eeprom;
        };
};
```

