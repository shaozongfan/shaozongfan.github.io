<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">20.4　SMP多核启动以及CPU热插拔驱动 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="20.4　SMP多核启动以及CPU热插拔驱动 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="在Linux系统中，对于多核的ARM芯片而言，在Bootrom代码中，每个CPU都会识别自身ID，如果ID是0，则引导Bootloader和Linux内核执行，如果ID不是0，则Bootrom一般在上电时将自身置于WFI或者WFE状态，并等待CPU0给其发CPU核间中断或事件（一般通过SEV指令）以唤醒它。一个典型的多核Linux启动过程如图20.6所示。"><meta data-rh="true" property="og:description" content="在Linux系统中，对于多核的ARM芯片而言，在Bootrom代码中，每个CPU都会识别自身ID，如果ID是0，则引导Bootloader和Linux内核执行，如果ID不是0，则Bootrom一般在上电时将自身置于WFI或者WFE状态，并等待CPU0给其发CPU核间中断或事件（一般通过SEV指令）以唤醒它。一个典型的多核Linux启动过程如图20.6所示。"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ccca8cd0.css">
<link rel="preload" href="/assets/js/runtime~main.088d6f6b.js" as="script">
<link rel="preload" href="/assets/js/main.f2e9fa45.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人博客/docusaurus2.4">个人博客</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人生活/2025国家生育政策8大补贴汇总">个人生活</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/人生哲学/人生的底层逻辑">人生哲学</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/技术博客/AI相关/AI核心技能">技术博客</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/技术博客/AI相关/AI核心技能">AI相关</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">嵌入式</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">linux设备驱动开发详解</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">1.3　有操作系统时的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">10.1　中断与定时器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">10.2　Linux中断处理程序架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">10.4　中断共享</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">10.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">11.2　Linux内存管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">11.4　设备IO端口和IO内存的访问</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">11.5　IO内存静态映射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">11.6　DMA</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">11.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">12.1　Linux驱动的软件架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">13.1　块设备的IO操作特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">13.3　Linux块设备驱动的初始化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">13.4　块设备的打开与释放</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">13.5　块设备驱动的ioctl函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">13.8　Linux MMC子系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">13.9　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">14.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">14.1　Linux网络设备驱动的结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">14.2　网络设备驱动的注册与注销</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">14.3　网络设备的初始化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">14.4　网络设备的打开与释放</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">14.5　数据发送流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">14.6　数据接收流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">14.7　网络连接状态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">14.8　参数设置和统计数据</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">15.1　Linux I2 C体系结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">15.2　Linux I2 C核心</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">15.4　Linux I2 C设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">15.5　Tegra I2 C总线驱动实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">15.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">16.5　USB OTG驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">16.6　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">17.1　I2 C、SPI、USB驱动架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">18.1　ARM设备树起源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">18.2　设备树的组成和结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">18.3　由设备树引发的BSP和驱动变更</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">18.4　常用的OF API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">18.5　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">19.10　运行时的PM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">19.11　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">19.1　Linux电源管理的全局架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">19.2　CPUFreq驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">19.3　CPUIdle驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">19.4　PowerTop</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">19.5　Regulator驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">19.6　OPP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">19.7　PM QoS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">19.8　CPU热插拔</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">19.9　挂起到RAM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">2.2　存储器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">2.4　CPLD和FPGA</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">2.5　原理图分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">20.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">20.1　ARM Linux底层驱动的组成和现状</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">20.2　内核节拍驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">20.3　中断控制器驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">20.6　GPIO驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">20.7　pinctrl驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">20.8　时钟驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">20.9　dmaengine驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">21.10　使用仿真器调试内核</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">21.11　应用程序调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">21.12　Linux性能监控与调优工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">21.13　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">21.2　Linux内核调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">21.3　内核打印信息—printk（​）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">21.5　使用“proc”</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">21.6　Oops</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">21.8　strace</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">21.9　KGDB</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">3.1　Linux内核的发展与演变</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">3.2　Linux 2.6后的内核特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">3.6　工具链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">4.10　使用模块“绕开”GPL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">4.1　Linux内核模块简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">4.2　Linux内核模块程序结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">4.3　模块加载函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">4.4　模块卸载函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">4.5　模块参数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">4.6　导出符号</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">4.7　模块声明与描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">4.8　模块的使用计数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">4.9　模块的编译</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">5.3　devfs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">6.2　globalmem虚拟设备实例描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">7.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">7.1　并发与竞态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">7.2　编译乱序和执行乱序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">7.3　中断屏蔽</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">7.4　原子操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">7.6　信号量</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">7.7　互斥体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">7.8　完成量</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">8.1　阻塞与非阻塞IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">8.4　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">9.1　异步通知的概念与作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">9.5　总结</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/rzg部署kdump">rzg部署kdump</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/技术博客/网络/网络问题">网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">调试</a></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">技术博客</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">嵌入式</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">linux设备驱动开发详解</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">20.4　SMP多核启动以及CPU热插拔驱动</span><meta itemprop="position" content="4"></li></ul></nav><div class="theme-doc-markdown markdown"><header><h1>20.4　SMP多核启动以及CPU热插拔驱动</h1></header><p>在Linux系统中，对于多核的ARM芯片而言，在Bootrom代码中，每个CPU都会识别自身ID，如果ID是0，则引导Bootloader和Linux内核执行，如果ID不是0，则Bootrom一般在上电时将自身置于WFI或者WFE状态，并等待CPU0给其发CPU核间中断或事件（一般通过SEV指令）以唤醒它。一个典型的多核Linux启动过程如图20.6所示。</p><p>被CPU0唤醒的CPUn可以在运行过程中进行热插拔，譬如运行如下命令即可卸载CPU1，并且将CPU1上的任务全部迁移到其他CPU中：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo 0 &gt; /sys/devices/system/cpu/cpu1/online</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>同理，运行如下命令可以再次启动CPU1：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"># echo 1 &gt; /sys/devices/system/cpu/cpu1/online</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>之后CPU1会主动参与系统中各个CPU之间要运行任务的负载均衡工作。</p><p><img loading="lazy" alt="1747234215141" src="/assets/images/1747234215141-2523e04756487f4848dc15e1a615288a.png" width="976" height="847" class="img_ev3q"></p><p>图20.6　一个典型的多核Linux启动过程</p><p>CPU0唤醒其他CPU的动作在内核中被封装为一个smp_operations的结构体，对于ARM而言，它定义于arch/arm/include/asm/smp.h中。该结构体的成员函数如代码清单20.8所示。</p><p>代码清单20.8　smp_operations结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct smp_operations {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2#ifdef CONFIG_SMP</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         * Setup the set of possible CPUs (via set_cpu_possible)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        void (*smp_init_cpus)(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         * Initialize cpu_possible map, and enable coherency</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        void (*smp_prepare_cpus)(unsigned int max_cpus);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * Perform platform specific initialisation of the specified CPU.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        void (*smp_secondary_init)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         * Boot a secondary CPU, and assign it the specified idle task.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         * This also gives us the initial stack to use for this CPU.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        int  (*smp_boot_secondary)(unsigned int cpu, struct task_struct *idle);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21#ifdef CONFIG_HOTPLUG_CPU</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        int  (*cpu_kill)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        void (*cpu_die)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        int  (*cpu_disable)(unsigned int cpu);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>我们从arch/arm/mach-vexpress/v2m.c中看到VEXPRESS电路板用到的smp_ops（）为vexpress_smp_ops：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">DT_MACHINE_START(VEXPRESS_DT, &quot;ARM-Versatile Express&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .dt_compat      = v2m_dt_match,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .smp            = smp_ops(vexpress_smp_ops),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        .map_io         = v2m_dt_map_io,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">MACHINE_END</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过arch/arm/mach-vexpress/platsmp.c的实现代码可以看出，smp_operations的成员函数smp_init_cpus（），即vexpress_smp_init_cpus（）调用的ct_ca9x4_init_cpu_map（）会探测SoC内CPU核的个数，并通过set_cpu_possible（）设置这些CPU可见。</p><p>而smp_operations的成员函数smp_prepare_cpus（），即vexpress_smp_prepare_cpus（）则会通过v2m_flags_set（virt_to_phys（versatile_secondary_startup））设置其他CPU的启动地址为versatile_secondary_startup，如代码清单20.9所示。</p><p>代码清单20.9　在smp_prepare_cpus（）中设置CPU1...n的启动地址</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void __init vexpress_smp_prepare_cpus(unsigned int max_cpus)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         * Write the address of secondary startup into the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         * system-wide flags register. The boot monitor waits</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8         * until it receives a soft interrupt, and then the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9         * secondary CPU branches to this address.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        v2m_flags_set(virt_to_phys(versatile_secondary_startup));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>注意这部分的具体实现方法是与SoC相关的，由芯片的设计以及芯片内部的Bootrom决定。对于VEXPRESS来讲，设置方法如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void __init v2m_flags_set(u32 data)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writel(~0, v2m_sysreg_base + V2M_SYS_FLAGSCLR);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        writel(data, v2m_sysreg_base + V2M_SYS_FLAGSSET);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>即填充v2m_sysreg_base+V2M_SYS_FLAGSCLR标记清除寄存器为0xFFFFFFFF，将CPU1...n初始启动执行的指令地址填入v2m_sysreg_base+V2M_SYS_FLAGSSET寄存器。这两个地址由芯片实现时内部的Bootrom程序设定的。填入CPU1...n的起始地址都通过virt_to_phys（）转化为物理地址，因为此时CPU1...n的MMU尚未开启。</p><p>比较关键的是smp_operations的成员函数smp_boot_secondary（），对于本例而言为versatile_boot_secondary（），它完成CPU的最终唤醒工作，如代码清单20.10所示。</p><p>代码清单20.10　CPU0通过中断唤醒其他CPU</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void write_pen_release(int val)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3pen_release = val;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4smp_wmb();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5sync_cache_w(&amp;pen_release);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8int versatile_boot_secondary(unsigned int cpu, struct task_struct *idle)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10unsigned long timeout;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 * This is really belt and braces; we hold unintended secondary</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 * CPUs in the holding pen until we’re ready for them.  However,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 * since we haven’t sent them a soft interrupt, they shouldn’t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 * be there.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18write_pen_release(cpu_logical_map(cpu));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20/*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 * Send the secondary CPU a soft interrupt, thereby causing</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 * the boot monitor to read the system wide flags register,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 * and branch to the address found there.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25arch_send_wakeup_ipi_mask(cpumask_of(cpu));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27timeout = jiffies + (1 * HZ);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28while (time_before(jiffies, timeout)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29        smp_rmb();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        if (pen_release == -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31               break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33        udelay(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36return pen_release != -1   -ENOSYS : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第18行调用的write_pen_release（）会将pen_release变量设置为要唤醒的CPU核的CPU号cpu_logical_map（cpu），而后通过arch_send_wakeup_ipi_mask（）给要唤醒的CPU发IPI中断，这个时候，被唤醒的CPU会退出WFI状态并从前面smp_operations中的smp_prepare_cpus（）成员函数，即vexpress_smp_prepare_cpus（）里通过v2m_flags_set（）设置的起始地址versatile_secondary_startup开始执行，如果顺利的话，该CPU会将原先为正数的pen_release写为-1，以便CPU0从等待pen_release成为-1的循环（见第28~34行）中跳出。</p><p>versatile_secondary_startup实现于arch/arm/plat-versatile/headsmp.S中，是一段汇编，如代码清单20.11所示。</p><p>代码清单20.11　被唤醒CPU的执行入口</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1ENTRY(versatile_secondary_startup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        mrc     p15, 0, r0, c0, c0, 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        and     r0, r0, #15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        adr     r4, 1f</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        ldmia   r4, {r5, r6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        sub     r4, r4, r5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        add     r6, r6, r4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8pen:    ldr     r7, [r6]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        cmp     r7, r0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        bne     pen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * we’ve been released from the holding pen: secondary_stack</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         * should now contain the SVC stack for this core</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        b       secondary_startup</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        .align</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">191:      .long   .</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        .long   pen_release</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21ENDPROC(versatile_secondary_startup)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第8~10行的循环是等待pen_release变量成为CPU0设置的cpu_logical_map（cpu），一般直接就成立了。第16行则调用内核通用的secondary_startup（）函数，经过一系列的初始化（如MMU等），最终新的被唤醒的CPU将调用smp_operations的smp_secondary_init（）成员函数，对于本例为versatile_secondary_init（），如代码清单20.12所示。</p><p>代码清单20.12　被唤醒的CPU恢复pen_release（）</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void versatile_secondary_init(unsigned int cpu)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4         * let the primary processor know we’re out of the</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5         * pen, then head off into the C entry point</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        write_pen_release(-1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10         * Synchronise with the boot thread.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        spin_lock(&amp;boot_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        spin_unlock(&amp;boot_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码第7行会将pen_release写为-1，于是CPU0还在执行的代码清单20.10里versatile_boot_secondary（）函数中的如下循环就退出了：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">while (time_before(jiffies, timeout)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        smp_rmb();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (pen_release == -1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        udelay(10);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这样CPU0就知道目标CPU已经被正确地唤醒，此后CPU0和新唤醒的其他CPU各自运行。整个系统在运行过程中会进行实时进程和正常进程的动态负载均衡。</p><p>图20.7总结性地描述了前文提到的vexpress_smp_prepare_cpus（）、versatile_boot_secondary（）、write_pen_release（）、versatile_secondary_startup（）、versatile_secondary_init（）这些函数的执行顺序。</p><p><img loading="lazy" alt="1747234563927" src="/assets/images/1747234563927-5b5bc24d7f64913424af01a246cbc8a6.png" width="1120" height="1026" class="img_ev3q"></p><p>图20.7　CPU0唤醒其他CPU过程</p><p>CPU热插拔的实现也是与芯片相关的，对于VEXPRESS而言，实现了smp_operations的cpu_die（）成员函数，即vexpress_cpu_die（）。它会在进行CPUn的拔除操作时将CPUn投入低功耗的WFI状态，相关代码位于arch/arm/mach-vexpress/hotplug.c中，如代码清单20.13所示。</p><p>代码清单20.13　smp_operations的cpu_die（）成员函数案例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1void __ref vexpress_cpu_die(unsigned int cpu)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        int spurious = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6         * we’re ready for shutdown now, so do it</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        cpu_enter_lowpower();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        platform_do_lowpower(cpu, &amp;spurious);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12         * bring this CPU back into the world of cache</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13         * coherency, and then restore interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        cpu_leave_lowpower();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        if (spurious)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18                pr_warn(&quot;CPU%u: %u spurious wakeup calls\n&quot;, cpu, spurious);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20static inline void platform_do_lowpower(unsigned int cpu, int *spurious)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23         * there is no power-control hardware on this platform, so all</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24         * we can do is put the core into WFI; this is safe as the calling</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25         * code will have already disabled interrupts</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28                wfi();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30                if (pen_release == cpu_logical_map(cpu)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31                        /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32                         * OK, proper wakeup, we&#x27;re done</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33                         */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34                        break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35                }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37                /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38                 * Getting here, means that we have come out of WFI without</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39                 * having been woken up - this shouldn’t happen</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40                 *</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41                 * Just note it happening - when we’re woken, we can report</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                 * its occurrence.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44                (*spurious)++;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>CPUn睡眠于wfi（），之后再次在线的时候，又会因为CPU0给它发出的IPI而从wfi（）函数返回继续执行，醒来时CPUn也判断“pen_release==cpu_logical_map（cpu）”是否成立，以确定该次醒来确实是由CPU0唤醒的一次正常醒来。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/shaozongfan/shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">20.3　中断控制器驱动</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">20.5　DEBUG_LL和EARLY_PRINTK的设置</div></a></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.088d6f6b.js"></script>
<script src="/assets/js/main.f2e9fa45.js"></script>
</body>
</html>