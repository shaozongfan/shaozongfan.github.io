I2 C核心（drivers/i2c/i2c-core.c）中提供了一组不依赖于硬件平台的接口函数，这个文件一般不需要被工程师修改，但是理解其中的主要函数非常关键，因为I2 C总线驱动和设备驱动之间以I2 C核心作为纽带。I2 C核心中的主要函数如下。

（1）增加/删除i2c_adapter

```
int i2c_add_adapter(struct i2c_adapter *adap);
void i2c_del_adapter(struct i2c_adapter *adap);
```

（2）增加/删除i2c_driver

```
int i2c_register_driver(struct module *owner, struct i2c_driver *driver);
void i2c_del_driver(struct i2c_driver *driver);
#define i2c_add_driver(driver) \
        i2c_register_driver(THIS_MODULE, driver)
```

（3）I2 C传输、发送和接收

```
int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num);
int i2c_master_send(struct i2c_client *client,const char *buf ,int count);
int i2c_master_recv(struct i2c_client *client, char *buf ,int count);
```

i2c_transfer（）函数用于进行I2 C适配器和I2 C设备之间的一组消息交互，其中第2个参数是一个指向i2c_msg数组的指针，所以i2c_transfer（）一次可以传输多个i2c_msg（考虑到很多外设的读写波形比较复杂，比如读寄存器可能要先写，所以需要两个以上的消息）。而对于时序比较简单的外设，i2c_master_send（）函数和i2c_master_recv（）函数内部会调用i2c_transfer（）函数分别完成一条写消息和一条读消息，如代码清单15.6、15.7所示。

代码清单15.6　I2 C核心的i2c_master_send（）函数

```
 1int i2c_master_send(const struct i2c_client *client, const char *buf, int count)
 2{
 3         int ret;
 4         struct i2c_adapter *adap = client->adapter;
 5         struct i2c_msg msg;
 6
 7         msg.addr = client->addr;
 8         msg.flags = client->flags & I2C_M_TEN;
 9         msg.len = count;
10         msg.buf = (char *)buf;
11
12         ret = i2c_transfer(adap, &msg, 1);
13
14         /*
15          * If everything went ok (i.e. 1 msg transmitted), return #bytes
16          * transmitted, else error code.
17          */
18         return (ret == 1)   count : ret;
19}
```

代码清单15.7　I2 C核心的i2c_master_recv（）函数

```
 1int i2c_master_recv(const struct i2c_client *client, char *buf, int count)
 2{
 3         struct i2c_adapter *adap = client->adapter;
 4         struct i2c_msg msg;
 5         int ret;
 6
 7         msg.addr = client->addr;
 8         msg.flags = client->flags & I2C_M_TEN;
 9         msg.flags |= I2C_M_RD;
10         msg.len = count;
11         msg.buf = buf;
12
13         ret = i2c_transfer(adap, &msg, 1);
14
15         /*
16          * If everything went ok (i.e. 1 msg received), return #bytes received,
17          * else error code.
18          */
19         return (ret == 1)   count : ret;
20}
```

i2c_transfer（）函数本身不具备驱动适配器物理硬件以完成消息交互的能力，它只是寻找到与i2c_adapter对应的i2c_algorithm，并使用i2c_algorithm的master_xfer（）函数真正驱动硬件流程，如代码清单15.8所示。

代码清单15.8　I2 C核心的i2c_transfer（）函数

```
 1int i2c_transfer(struct i2c_adapter * adap, struct i2c_msg *msgs, int num)
 2{
 3   int ret;
 4
 5   if (adap->algo->master_xfer) {
 6       ...
 7       ret = adap->algo->master_xfer(adap,msgs,num);
 8       ...
 9       return ret;
10   } else {
11       dev_dbg(&adap->dev, "I2C level transfers not supported\n");
12       return -ENOSYS;
13   }
14}
```

