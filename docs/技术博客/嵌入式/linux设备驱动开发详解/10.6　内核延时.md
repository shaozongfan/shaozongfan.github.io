# 10.6.1　短延迟

Linux内核中提供了下列3个函数以分别进行纳秒、微秒和毫秒延迟：

```
void ndelay(unsigned long nsecs);
void udelay(unsigned long usecs);
void mdelay(unsigned long msecs);
```

上述延迟的实现原理本质上是忙等待，它根据CPU频率进行一定次数的循环。有时候，人们在软件中进行下面的延迟：

```
void delay(unsigned int time)
{
    while(time--);
}
```

ndelay（）、udelay（）和mdelay（）函数的实现方式原理与此类似。内核在启动时，会运行一个延迟循环校准（Delay Loop Calibration），计算出lpj（Loops Per Jiffy），内核启动时会打印如下类似信息：

```
Calibrating delay loop... 530.84 BogoMIPS (lpj=1327104)
```

如果我们直接在bootloader传递给内核的bootargs中设置lpj=1327104，则可以省掉这个校准的过程，节省约百毫秒级的开机时间。

毫秒时延（以及更大的秒时延）已经比较大了，在内核中，最好不要直接使用mdelay（）函数，这将耗费CPU资源，对于毫秒级以上的时延，内核提供了下述函数：

```
void msleep(unsigned int millisecs);
unsigned long msleep_interruptible(unsigned int millisecs);
void ssleep(unsigned int seconds);
```

上述函数将使得调用它的进程睡眠参数指定的时间为millisecs，msleep（）、ssleep（）不能被打断，而msleep_interruptible（）则可以被打断。

受系统Hz以及进程调度的影响，msleep（）类似函数的精度是有限的。

# 10.6.2　长延迟

在内核中进行延迟的一个很直观的方法是比较当前的jiffies和目标jiffies（设置为当前jiffies加上时间间隔的jiffies），直到未来的jiffies达到目标jiffies。代码清单10.15给出了使用忙等待先延迟100个jiffies再延迟2s的实例。

代码清单10.15　忙等待时延实例

```
1/* 延迟100个jiffies */
2unsigned long delay = jiffies + 100;
3while(time_before(jiffies, delay));
4
5/* 再延迟2s */
6unsigned long delay = jiffies + 2*Hz;
7while(time_before(jiffies, delay));
```

与time_before（）对应的还有一个time_after（），它们在内核中定义为（实际上只是将传入的未来时间jiffies和被调用时的jiffies进行一个简单的比较）：

```
#define time_after(a,b)        \
    (typecheck(unsigned long, a) && \
     typecheck(unsigned long, b) && \
     ((long)(b) - (long)(a) < 0))
#define time_before(a,b)    time_after(b,a)
```

为了防止在time_before（）和time_after（）的比较过程中编译器对jiffies的优化，内核将其定义为volatile变量，这将保证每次都会重新读取这个变量。因此volatile更多的作用还是避免这种读合并。

# 10.6.3　睡着延迟

睡着延迟无疑是比忙等待更好的方式，睡着延迟是在等待的时间到来之前进程处于睡眠状态，CPU资源被其他进程使用。schedule_timeout（）可以使当前任务休眠至指定的jiffies之后再重新被调度执行，msleep（）和msleep_interruptible（）在本质上都是依靠包含了schedule_timeout（）的schedule_timeout_uninterruptible（）和schedule_timeout_interruptible（）来实现的，如代码清单10.16所示。

代码清单10.16　schedule_timeout（）的使用

```
 1void msleep(unsigned int msecs)
 2{
 3   unsigned long timeout = msecs_to_jiffies(msecs) + 1;
 4
 5   while (timeout)
 6      timeout = schedule_timeout_uninterruptible(timeout);
 7}
 8
 9unsigned long msleep_interruptible(unsigned int msecs)
10{
11   unsigned long timeout = msecs_to_jiffies(msecs) + 1;
12
13   while (timeout && !signal_pending(current))
14      timeout = schedule_timeout_interruptible(timeout);
15  return jiffies_to_msecs(timeout);
16}
```

实际上，schedule_timeout（）的实现原理是向系统添加一个定时器，在定时器处理函数中唤醒与参数对应的进程。

代码清单10.16中第6行和第14行分别调用schedule_timeout_uninterruptible（）和schedule_timeout_interruptible（），这两个函数的区别在于前者在调用schedule_timeout（）之前置进程状态为TASK_INTERRUPTIBLE，后者置进程状态为TASK_UNINTERRUPTIBLE，如代码清单10.17所示。

代码清单10.17　schedule_timeout_interruptible（）和schedule_timeout_interruptible（）

```
 1signed long __sched schedule_timeout_interruptible(signed long timeout)
 2{
 3  __set_current_state(TASK_INTERRUPTIBLE);
 4  return schedule_timeout(timeout);
 5}
 6
 7signed long __sched schedule_timeout_uninterruptible(signed long timeout)
 8{
 9  __set_current_state(TASK_UNINTERRUPTIBLE);
10  return schedule_timeout(timeout);
11}
```

另外，下面两个函数可以将当前进程添加到等待队列中，从而在等待队列上睡眠。当超时发生时，进程将被唤醒（后者可以在超时前被打断）：

```
sleep_on_timeout(wait_queue_head_t *q, unsigned long timeout);
interruptible_sleep_on_timeout(wait_queue_head_t*q, unsigned long timeout);
```

