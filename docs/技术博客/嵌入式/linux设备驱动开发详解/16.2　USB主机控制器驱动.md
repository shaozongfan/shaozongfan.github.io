# 16.2.1　USB主机控制器驱动的整体结构

USB主机控制器有这些规格：OHCI（Open Host Controller Interface）、UHCI（Universal Host Controller Interface）、EHCI（Enhanced Host Controller Interface）和xHCI（eXtensible Host Controller Interface）。OHCI驱动程序用来为非PC系统上以及带有SiS和ALi芯片组的PC主板上的USB芯片提供支持。UHCI驱动程序多用来为大多数其他PC主板（包括Intel和Via）上的USB芯片提供支持。EHCI由USB 2.0规范所提出，它兼容于OHCI和UHCI。由于UHCI的硬件线路比OHCI简单，所以成本较低，但需要较复杂的驱动程序，CPU负荷稍重。xHCI，即可扩展的主机控制器接口是Intel公司开发的一个USB主机控制器接口，它目前主要是面向USB 3.0的，同时它也支持USB 2.0及以下的设备。

## 1.主机控制器驱动

在Linux内核中，用usb_hcd结构体描述USB主机控制器驱动，它包含USB主机控制器的“家务”信息、硬件资源、状态描述和用于操作主机控制器的hc_driver等，其定义如代码清单16.6所示

代码清单16.6　usb_hcd结构体

```
 1struct usb_hcd {
 2   struct usb_bus         self;           /* hcd is-a bus */
 3   struct kref        kref;               /* reference counter */
 4
 5   const char         *product_desc;      /* product/vendor string */
 6   int            speed;                  /* Speed for this roothub.
 7                           * May be different from
 8                           * hcd->driver->flags & HCD_MASK
 9                           */
10   char           irq_descr[24];          /* driver + bus # */
11
12   struct timer_list rh_timer;            /* drives root-hub polling */
13   struct urb     *status_urb;            /* the current status urb */
14#ifdef CONfiG_PM
15   struct work_struct    wakeup_work;     /* for remote wakeup */
16#endif
17
18   const struct hc_driver    *driver;     /* hw-specific hooks */
19
20   struct usb_phy        *usb_phy;
21   struct phy        *phy;
22
23   unsigned long     flags;
24
25   …
26
27   /* The HC driver's private data is stored at the end of
28   * this structure.
29   */
30   unsigned long hcd_priv[0]
31            __attribute__ ((aligned(sizeof(s64))));
32};
```

usb_hcd结构体中第18行的hc_driver成员非常重要，它包含具体的用于操作主机控制器的钩子函数，即“hw-specific hooks”，其定义如代码清单16.7所示。

代码清单16.7　hc_driver结构体

```
 1struct hc_driver {
 2   const char   *description;          /* "ehci-hcd" etc */
 3   const char   *product_desc;         /* product/vendor string */
 4   size_t       hcd_priv_size;         /* size of private data */
 5
 6   /* irq handler */
 7   irqreturn_t(*irq) (struct usb_hcd *hcd);
 8
 9   int flags;
10
11   /* called to init HCD and root hub */
12   int (*reset) (struct usb_hcd *hcd);
13   int (*start) (struct usb_hcd *hcd);
14   ...
15   /* cleanly make HCD stop writing memory and doing I/O */
16   void (*stop) (struct usb_hcd *hcd);
17
18   /* shutdown HCD */
19   void (*shutdown) (struct usb_hcd *hcd);
20
21   /* return current frame number */
22   int (*get_frame_number) (struct usb_hcd *hcd);
23
24   /* manage i/o requests, device state */
25   int (*urb_enqueue)(struct usb_hcd *hcd,
26                      struct urb *urb, gfp_t mem_flags);
27   int (*urb_dequeue)(struct usb_hcd *hcd,
28               struct urb *urb, int status);
29   ...
30        /* Allocate endpoint resources and add them to a new schedule */
31   int (*add_endpoint)(struct usb_hcd *, struct usb_device *,
32               struct usb_host_endpoint *);
33        /* Drop an endpoint from a new schedule */
34   int (*drop_endpoint)(struct usb_hcd *, struct usb_device *,
35                        struct usb_host_endpoint *);
36
37   int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
38   void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
39        /* Returns the hardware-chosen device address */
40   int (*address_device)(struct usb_hcd *, struct usb_device *udev);
41   ...
42   int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
43   /* USB 3.0 Link Power Management */
44        /* Returns the USB3 hub-encoded value for the U1/U2 timeout. */
45   int (*enable_usb3_lpm_timeout)(struct usb_hcd *,
46           struct usb_device *, enum usb3_link_state state);
47   int (*disable_usb3_lpm_timeout)(struct usb_hcd *,
48           struct usb_device *, enum usb3_link_state state);
49   int (*find_raw_port_number)(struct usb_hcd *, int);
50   /* Call for power on/off the port if necessary */
51   int (*port_power)(struct usb_hcd *hcd, int portnum, bool enable);
52};
```

在Linux内核中，使用如下函数来创建HCD：

```
struct usb_hcd *usb_create_hcd (const struct hc_driver *driver,
      struct device *dev, char *bus_name);
```

如下函数被用来增加和移除HCD：

```
int usb_add_hcd(struct usb_hcd *hcd,
       unsigned int irqnum, unsigned long irqflags);
void usb_remove_hcd(struct usb_hcd *hcd);
```

第25行的urb_enqueue（）函数非常关键，实际上，上层通过usb_submit_urb（）提交1个USB请求后，该函数调用usb_hcd_submit_urb（），并最终调用至usb_hcd的driver成员（hc_driver类型）的urb_enqueue（）函数。

## 2.EHCI主机控制器驱动

EHCI HCD驱动属于HCD驱动的实例，它定义了一个ehci_hcd结构体，通常作为代码清单16.6定义的usb_hcd结构体的私有数据（hcd_priv），这个结构体的定义位于drivers/usb/host/ehci.h中，如代码清单16.8所示。

代码清单16.8　ehci_hcd结构体

```
 1struct ehci_hcd {                      /* one per controller */
 2   /* timing support */
 3   enum ehci_hrtimer_event    next_hrtimer_event;
 4   unsigned     enabled_hrtimer_events;
 5   ktime_t          hr_timeouts[EHCI_HRTIMER_NUM_EVENTS];
 6   struct hrtimer       hrtimer;
 7
 8   int          PSS_poll_count;
 9   int          ASS_poll_count;
10   int          died_poll_count;
11   ...
12   /* general schedule support */
13   bool         scanning:1;
14   bool         need_rescan:1;
15   bool         intr_unlinking:1;
16   bool         iaa_in_progress:1;
17   bool         async_unlinking:1;
18   bool         shutdown:1;
19   struct ehci_qh        *qh_scan_next;
20
21   /* async schedule support */
22   struct ehci_qh        *async;
23   struct ehci_qh        *dummy;         /* For AMD quirk use */
24   struct list_head  async_unlink;
25   struct list_head  async_idle;
26   unsigned     async_unlink_cycle;
27   unsigned     async_count;             /* async activity count */
28
29   /* periodic schedule support */
30#define    DEFAULT_I_TDPS       1024   /* some HCs can do less */
31   unsigned      periodic_size;
32   __hc32            *periodic;          /* hw periodic table */
33   dma_addr_t        periodic_dma;
34   struct list_head  intr_qh_list;
35   unsigned     i_thresh;                /* uframes HC might cache */
36   ...
37   /* bandwidth usage */
38#define EHCI_BANDWIDTH_SIZE 64
39#define EHCI_BANDWIDTH_FRAMES   (EHCI_BANDWIDTH_SIZE >> 3)
40   u8           bandwidth[EHCI_BANDWIDTH_SIZE];
41                         /* us allocated per uframe */
42   u8           tt_budget[EHCI_BANDWIDTH_SIZE];
43                         /* us budgeted per uframe */
44   struct list_head tt_list;
45
46   /* platform-specific data -- must come last */
47   unsigned long    priv[0] __aligned(sizeof(s64));
48};
```

使用如下内联函数可实现usb_hcd和ehci_hcd的相互转换：

```
struct ehci_hcd *hcd_to_ehci (struct usb_hcd *hcd);
struct usb_hcd *ehci_to_hcd (const struct ohci_hcd *ohci);
```

从usb_hcd得到ehci_hcd只是取得“私有”数据，而从ehci_hcd得到usb_hcd则是通过container_of（）从结构体成员获得结构体指针。

使用如下函数可初始化EHCI主机控制器：

```
static int ehci_init(struct usb_hcd *hcd);
```

如下函数分别用于开启、停止及复位EHCI控制器：

```
static int ehci_run (struct usb_hcd *hcd);
static void ehci_stop (struct usb_hcd *hcd);
static int ehci_reset (struct ehci_hcd *ehci);
```

上述函数在drivers/usb/host/ehci-hcd.c文件中被填充给了一个hc_driver结构体的generic的实例ehci_hc_driver。

```
static const struct hc_driver ehci_hc_driver = {
       ...
       .reset =             ehci_setup,
       .start =             ehci_run,
       .stop =              ehci_stop,
       .shutdown =          ehci_shutdown,
}
```

drivers/usb/host/ehci-hcd.c实现了绝大多数ECHI主机驱动的工作，具体的EHCI实例简单地调用

```
void ehci_init_driver(struct hc_driver *drv,
             const struct ehci_driver_overrides *over);
```

初始化hc_driver即可，这个函数会被generic的ehci_hc_driver实例复制给每个具体底层驱动的实例，当然底层驱动可以通过第2个参数，即ehci_driver_overrides重写中间层的reset（）、port_power（）这2个函数，另外也可以填充一些额外的私有数据，这一点从代码清单16.9ehci_init_driver（）的实现中可以看出。

代码清单16.9　ehci_init_driver的实现

```
 1void ehci_init_driver(struct hc_driver *drv,
 2               const struct ehci_driver_overrides *over)
 3{
 4        /* Copy the generic table to drv and then apply the overrides */
 5        *drv = ehci_hc_driver;
 6
 7        if (over) {
 8               drv->hcd_priv_size += over->extra_priv_size;
 9               if (over->reset)
10                      drv->reset = over->reset;
11               if (over->port_power)
12                      drv->port_power = over->port_power;
13         }
14 }
```

# 16.2.2　实例：Chipidea USB主机驱动

Chipidea的USB IP在嵌入式系统中应用比较广泛，它的驱动位于drivers/usb/chipidea/目录下

当Chipidea USB驱动的内核代码drivers/usb/chipidea/core.c中的ci_hdrc_probe（）被执行后（即一个platform_device与ci_hdrc_driver这个platform_driver匹配上了），它会调用drivers/usb/chipidea/host.c中的ci_hdrc_host_init（）函数，该函数完成hc_driver的初始化并赋值一系列与Chipidea平台相关的私有数据，如代码清单16.10所示。

代码清单16.10　Chipidea USB host驱动初始化

```
 1int ci_hdrc_host_init(struct ci_hdrc *ci)
 2{
 3        struct ci_role_driver *rdrv;
 4
 5        if (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))
 6               return -ENXIO;
 7
 8        rdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);
 9        if (!rdrv)
10               return -ENOMEM;
11
12        rdrv->start    = host_start;
13        rdrv->stop     = host_stop;
14        rdrv->irq      = host_irq;
15        rdrv->name     = "host";
16        ci->roles[CI_ROLE_HOST] = rdrv;
17
18        ehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);
19
20        return 0;
21 }
```

