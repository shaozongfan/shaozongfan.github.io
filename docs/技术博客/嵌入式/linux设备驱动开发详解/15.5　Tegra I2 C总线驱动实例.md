NVIDIA Tegra I2 C总线驱动位于drivers/i2c/busses/i2c-tegra.c下，这里我们不具体研究它的硬件细节，只看一下驱动的框架和流程。

I2 C总线驱动是一个单独的驱动，在模块的加载和卸载函数中，只需注册和注销一个platform_driver结构体，如代码清单15.18所示。

代码清单15.18　Tegra I2 C总线驱动的模块加载与卸载

```
 1/* Match table for of_platform binding */
 2static const struct of_device_id tegra_i2c_of_match[] = {
 3    { .compatible = "nvidia,tegra114-i2c", .data = &tegra114_i2c_hw, },
 4    { .compatible = "nvidia,tegra30-i2c", .data = &tegra30_i2c_hw, },
 5    { .compatible = "nvidia,tegra20-i2c", .data = &tegra20_i2c_hw, },
 6    { .compatible = "nvidia,tegra20-i2c-dvc", .data = &tegra20_i2c_hw, },
 7    {},
 8};
 9MODULE_DEVICE_TABLE(of, tegra_i2c_of_match);
10
11static struct platform_driver tegra_i2c_driver = {
12    .probe   = tegra_i2c_probe,
13    .remove  = tegra_i2c_remove,
14    .driver  = {
15        .name  = "tegra-i2c",
16        .owner = THIS_MODULE,
17        .of_match_table = tegra_i2c_of_match,
18        .pm    = TEGRA_I2C_PM,
19    },
20};
21
22static int __init tegra_i2c_init_driver(void)
23{
24    return platform_driver_register(&tegra_i2c_driver);
25}
26
27static void __exit tegra_i2c_exit_driver(void)
28{
29    platform_driver_unregister(&tegra_i2c_driver);
30}
31
32subsys_initcall(tegra_i2c_init_driver);
33module_exit(tegra_i2c_exit_driver);
```

当在arch/arm/mach-tegra下创建一个名字为tegra-i2c的同名platform_device，或者在tegra的设备树中添加了tegra_i2c_of_match匹配表兼容的节点后，上述platform_driver中的probe（）函数会执行。

当在arch/arm/mach-tegra下创建一个名字为tegra-i2c的同名platform_device，或者在tegra的设备树中添加了tegra_i2c_of_match匹配表兼容的节点后，上述platform_driver中的probe（）函数会执行。

代码清单15.19　Tegra I2 C总线驱动中的tegra_i2c_probe（）函数

```
 1static int tegra_i2c_probe(struct platform_device *pdev)
 2{
 3    struct tegra_i2c_dev *i2c_dev;
 4    struct resource *res;
 5    struct clk *div_clk;
 6    struct clk *fast_clk;
 7    void __iomem *base;
 8    int irq;
 9    int ret = 0;
10
11    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
12    base = devm_ioremap_resource(&pdev->dev, res);
13    ...
14    res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
15    ...
16    irq = res->start;
17
18    div_clk = devm_clk_get(&pdev->dev, "div-clk");
19    ...
20
21    i2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);
22    ...
23
24    i2c_dev->base = base;
25    i2c_dev->div_clk = div_clk;
26    i2c_dev->adapter.algo = &tegra_i2c_algo;
27    i2c_dev->irq = irq;
28    i2c_dev->cont_id = pdev->id;
29    i2c_dev->dev = &pdev->dev;
30
31    i2c_dev->rst = devm_reset_control_get(&pdev->dev, "i2c");
32    ...
33
34    ret = of_property_read_u32(i2c_dev->dev->of_node, "clock-frequency",
35                         &i2c_dev->bus_clk_rate);
36    if (ret)
37    i2c_dev->bus_clk_rate = 100000; /* default clock rate */
38
39    i2c_dev->hw = &tegra20_i2c_hw;
40
41    ...
42    init_completion(&i2c_dev->msg_complete);
43
44    ...
45
46    platform_set_drvdata(pdev, i2c_dev);
47
48    ret = tegra_i2c_init(i2c_dev);
49    ...
50
51    ret = devm_request_irq(&pdev->dev, i2c_dev->irq,
52                      tegra_i2c_isr, 0, dev_name(&pdev->dev), i2c_dev);
53    ...
54
55    i2c_set_adapdata(&i2c_dev->adapter, i2c_dev);
56    i2c_dev->adapter.owner = THIS_MODULE;
57    i2c_dev->adapter.class = I2C_CLASS_DEPRECATED;
58    strlcpy(i2c_dev->adapter.name, "Tegra I2C adapter",
59         sizeof(i2c_dev->adapter.name));
60    i2c_dev->adapter.algo = &tegra_i2c_algo;
61    i2c_dev->adapter.dev.parent = &pdev->dev;
62    i2c_dev->adapter.nr = pdev->id;
63    i2c_dev->adapter.dev.of_node = pdev->dev.of_node;
64
65    ret = i2c_add_numbered_adapter(&i2c_dev->adapter);
66    ...
67
68    return 0;
69}
```

有与tegra_i2c_probe（）函数相反功能的函数是tegra_i2c_remove（）函数，它在适配器模块卸载函数调用platform_driver_unregister（）函数时通过platform_driver的remove指针方式被调用。tegra_i2c_remove（）的代码如清单15.20所示。

代码清单15.20　Tegra I2 C总线驱动中的tegra_i2c_remove（）函数

```
 1static int tegra_i2c_remove(struct platform_device *pdev)
 2{
 3     struct tegra_i2c_dev *i2c_dev = platform_get_drvdata(pdev);
 4     i2c_del_adapter(&i2c_dev->adapter);
 5     return 0;
 6}
```

代码清单15.19和代码清单15.20中的tegra_i2c_dev结构体可进行适配器所有信息的封装，类似于私有信息结构体，代码清单15.21所示为tegra_i2c_dev结构体的定义。我们在编程中要时刻牢记Linux这个编程习惯，这实际上也是面向对象的一种体现。

代码清单15.21　tegra_i2c_dev结构体

```
 1struct tegra_i2c_dev {
 2    struct device *dev;
 3    const struct tegra_i2c_hw_feature *hw;
 4    struct i2c_adapter adapter;
 5    struct clk *div_clk;
 6    struct clk *fast_clk;
 7    struct reset_control *rst;
 8    void __iomem *base;
 9    int cont_id;
10    int irq;
11    bool irq_disabled;
12    int is_dvc;
13    struct completion msg_complete;
14    int msg_err;
15    u8 *msg_buf;
16    size_t msg_buf_remaining;
17    int msg_read;
18    u32 bus_clk_rate;
19    bool is_suspended;
20};
```

tegra_i2c_probe（）函数中的platform_set_drvdata（pdev，i2c_dev）和i2c_set_adapdata（&i2c_dev->adapter，i2c_dev）已经把这个结构体的实例依附到了platform_device和i2c_adapter的私有数据上了，在其他地方只要用相应的方法就可以把这个结构体的实例取出来。

由代码清单15.19的第60行可以看出，与I2 C适配器对应的i2c_algorithm结构体实例为tegra_i2c_algo，代码清单15.22给出为tegra_i2c_algo的定义。

代码清单15.22　tegra_i2c_algo结构体

```
 1static const struct i2c_algorithm tegra_i2c_algo = {
 2    .master_xfer      = tegra_i2c_xfer,
 3    .functionality    = tegra_i2c_func,
 4};
```

上述代码第一行指定了Tegra I2 C总线通信传输函数tegra_i2c_xfer（），这个函数非常关键，所有在I2 C总线上对设备的访问最终应该由它来完成，代码清单15.23所示为这个重要函数以及其依赖的tegra_i2c_xfer_msg（）函数的源代码。

代码清单15.23　Tegra I2 C总线驱动的tegra_i2c_xfer（）函数

```
 1static int tegra_i2c_xfer_msg(struct tegra_i2c_dev *i2c_dev,
 2    struct i2c_msg *msg, enum msg_end_type end_state)
 3{
 4    ...
 5    i2c_dev->msg_buf = msg->buf;
 6    i2c_dev->msg_buf_remaining = msg->len;
 7    i2c_dev->msg_err = I2C_ERR_NONE;
 8    i2c_dev->msg_read = (msg->flags & I2C_M_RD);
 9    reinit_completion(&i2c_dev->msg_complete);
10
11    packet_header = (0 << PACKET_HEADER0_HEADER_SIZE_SHIFT) |
12              PACKET_HEADER0_PROTOCOL_I2C |
13              (i2c_dev->cont_id << PACKET_HEADER0_CONT_ID_SHIFT) |
14              (1 << PACKET_HEADER0_PACKET_ID_SHIFT);
15    i2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);
16
17    packet_header = msg->len - 1;
18    i2c_writel(i2c_dev, packet_header, I2C_TX_FIFO);
19
20    ...
21
22    ret = wait_for_completion_timeout(&i2c_dev->msg_complete, TEGRA_I2C_TIMEOUT);
23    ...
24}
25
26static int tegra_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[],
27    int num)
28{
29    struct tegra_i2c_dev *i2c_dev = i2c_get_adapdata(adap);
30    int i;
31    int ret = 0;
32
33    ...
34
35    for (i = 0; i < num; i++) {
36         enum msg_end_type end_type = MSG_END_STOP;
37         if (i < (num - 1)) {
38              if (msgs[i + 1].flags & I2C_M_NOSTART)
39                   end_type = MSG_END_CONTINUE;
40              else
41                   end_type = MSG_END_REPEAT_START;
42         }
43         ret = tegra_i2c_xfer_msg(i2c_dev, &msgs[i], end_type);
44         if (ret)
45              break;
46    }
47    tegra_i2c_clock_disable(i2c_dev);
48    return ret  : i;
49}
```

从代码层面上看，第35行的for循环遍历所有的i2c_msg，而每个i2c_msg则由tegra_i2c_xfer_msg（）函数处理，它每次发起硬件操作后，实际上需要通过wait_for_completion_timeout（）等待传输的完成，因此这里面就会有一个被调度出去的过程。中断到来且I2 C的包传输结束的时候，就是唤醒这个睡眠进程的时候，如代码清单15.24所示。

代码清单15.24　Tegra I2 C总线驱动的中断服务程序

```
 1static irqreturn_t tegra_i2c_isr(int irq, void *dev_id)
 2{
 3    ...
 4
 5    if (status & I2C_INT_PACKET_XFER_COMPLETE) {
 6         BUG_ON(i2c_dev->msg_buf_remaining);
 7         complete(&i2c_dev->msg_complete);
 8    }
 9    return IRQ_HANDLED;
10    ...
11}
```

