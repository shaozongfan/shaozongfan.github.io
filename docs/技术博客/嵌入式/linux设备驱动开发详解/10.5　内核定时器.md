# 10.5.1　内核定时器编程

软件意义上的定时器最终依赖硬件定时器来实现，内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部执行。实质上，时钟中断处理程序会唤起TIMER_SOFTIRQ软中断，运行当前处理器上到期的所有定时器。

在Linux设备驱动编程中，可以利用Linux内核中提供的一组函数和数据结构来完成定时触发工作或者完成某周期性的事务。这组函数和数据结构使得驱动工程师在多数情况下不用关心具体的软件定时器究竟对应着怎样的内核和硬件行为。

Linux内核所提供的用于操作定时器的数据结构和函数如下。

1.timer_list

在Linux内核中，timer_list结构体的一个实例对应一个定时器，如代码清单10.9所示。

```
 1struct timer_list {
 2        /*
 3         * All fields that change during normal runtime grouped to the
 4         * same cacheline
 5         */
 6        struct list_head entry;
 7        unsigned long expires;
 8        struct tvec_base *base;
 9
10        void (*function)(unsigned long);
11        unsigned long data;
12
13        int slack;
14
15#ifdef CONFIG_TIMER_STATS
16        int start_pid;
17        void *start_site;
18        char start_comm[16];
19#endif
20#ifdef CONFIG_LOCKDEP
21        struct lockdep_map lockdep_map;
22#endif
23};
```

当定时器期满后，其中第10行的function（）成员将被执行，而第11行的data成员则是传入其中的参数，第7行的expires则是定时器到期的时间（jiffies）。

如下代码定义一个名为my_timer的定时器：

```
struct timer_list my_timer;
```

2.初始化定时器

init_timer是一个宏，它的原型等价于：

```
void init_timer(struct timer_list * timer);
```

上述init_timer（）函数初始化timer_list的entry的next为NULL，并给base指针赋值。

TIMER_INITIALIZER（_function，_expires，_data）宏用于赋值定时器结构体的function、expires、data和base成员，这个宏等价于：

```
#define TIMER_INITIALIZER(_function, _expires, _data) {        \
                      .entry = { .prev = TIMER_ENTRY_STATIC }, \
                      .function = (_function),                 \
                      .expires = (_expires),                   \
                      .data = (_data),                         \
                      .base = &boot_tvec_bases,                \
        }
```

DEFINE_TIMER（_name，_function，_expires，_data）宏是定义并初始化定时器成员的“快捷方式”，这个宏定义为：

```
#define DEFINE_TIMER(_name, _function, _expires, _data)\
              struct timer_list _name =\
                            TIMER_INITIALIZER(_function, _expires, _data)
```

此外，setup_timer（）也可用于初始化定时器并赋值其成员，其源代码为：

```
#define __setup_timer(_timer, _fn, _data, _flags)               \
        do {                                                    \
                __init_timer((_timer), (_flags));               \
                (_timer)->function = (_fn);                     \
                (_timer)->data = (_data);                       \
        } while (0)
```

3.增加定时器

```
void add_timer(struct timer_list * timer);
```

上述函数用于注册内核定时器，将定时器加入到内核动态定时器链表中。

4.删除定时器

```
int del_timer(struct timer_list * timer);
```

上述函数用于删除定时器。

del_timer_sync（）是del_timer（）的同步版，在删除一个定时器时需等待其被处理完，因此该函数的调用不能发生在中断上下文中。

5.修改定时器的expire

```
int mod_timer(struct timer_list *timer, unsigned long expires);
```

上述函数用于修改定时器的到期时间，在新的被传入的expires到来后才会执行定时器函数。

代码清单10.10给出了一个完整的内核定时器使用模板，在大多数情况下，设备驱动都如这个模板那样使用定时器。

代码清单10.10　内核定时器使用模板

```
 1/* xxx设备结构体*/
 2struct xxx_dev {
 3  struct cdev cdev;
 4  ...
 5  timer_list xxx_timer;      /* 设备要使用的定时器 */
 6};
 7
 8/* xxx驱动中的某函数*/
 9xxx_func1(…)
10{
11  struct xxx_dev *dev = filp->private_data;
12  ...
13  /* 初始化定时器*/
14  init_timer(&dev->xxx_timer);
15  dev->xxx_timer.function = &xxx_do_timer;
16  dev->xxx_timer.data = (unsigned long)dev;
17                      /* 设备结构体指针作为定时器处理函数参数*/
18  dev->xxx_timer.expires = jiffies + delay;
19  /* 添加（注册）定时器*/
20  add_timer(&dev->xxx_timer);
21  ...
22}
23
24/* xxx驱动中的某函数*/
25xxx_func2(…)
26{
27 ...
28  /* 删除定时器 */
29  del_timer (&dev->xxx_timer);
30  ...
31}
32
33/* 定时器处理函数*/
34static void xxx_do_timer(unsigned long arg)
35{
36  struct xxx_device *dev = (struct xxx_device *)(arg);
37  ...
38  /* 调度定时器再执行*/
39  dev->xxx_timer.expires = jiffies + delay;
40  add_timer(&dev->xxx_timer);
41  ...
42}
```

从代码清单第18、39行可以看出，定时器的到期时间往往是在目前jiffies的基础上添加一个时延，若为Hz，则表示延迟1s。

在定时器处理函数中，在完成相应的工作后，往往会延后expires并将定时器再次添加到内核定时器链表中，以便定时器能再次被触发。

此外，Linux内核支持tickless和NO_HZ模式后，内核也包含对hrtimer（高精度定时器）的支持，它可以支持到微秒级别的精度。内核也定义了hrtimer结构体，hrtimer_set_expires（）、hrtimer_start_expires（）、hrtimer_forward_now（）、hrtimer_restart（）等类似的API来完成hrtimer的设置、时间推移以及到期回调。我们可以从sound/soc/fsl/imx-pcm-fiq.c中提取出一个使用范例，如代码清单10.11所示。

代码清单10.11　内核高精度定时器（hrtimer）使用模板

```
 1static enum hrtimer_restart snd_hrtimer_callback(struct hrtimer *hrt)
 2{
 3        ...
 4
 5        hrtimer_forward_now(hrt, ns_to_ktime(iprtd->poll_time_ns));
 6
 7        return HRTIMER_RESTART;
 8}
 9
10static int snd_imx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
11{
12        struct snd_pcm_runtime *runtime = substream->runtime;
13        struct imx_pcm_runtime_data *iprtd = runtime->private_data;
14
15        switch (cmd) {
16        case SNDRV_PCM_TRIGGER_START:
17        case SNDRV_PCM_TRIGGER_RESUME:
18        case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
19                ...
20                hrtimer_start(&iprtd->hrt, ns_to_ktime(iprtd->poll_time_ns),
21                      HRTIMER_MODE_REL);
22        ...
23}
24
25static int snd_imx_open(struct snd_pcm_substream *substream)
26{
27        ...
28        hrtimer_init(&iprtd->hrt, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
29        iprtd->hrt.function = snd_hrtimer_callback;
30
31        ...
32        return 0;
33}
34static int snd_imx_close(struct snd_pcm_substream *substream)
35{
36        ...
37        hrtimer_cancel(&iprtd->hrt);
38        ...
39}
```

第28~29行在声卡打开的时候通过hrtimer_init（）初始化了hrtimer，并指定回调函数为snd_hrtimer_callback（）；在启动播放（第15~21行SNDRV_PCM_TRIGGER_START）等时刻通过hrtimer_start（）启动了hrtimer；iprtd->poll_time_ns纳秒后，时间到snd_hrtimer_callback（）函数在中断上下文被执行，它紧接着又通过hrtimer_forward_now（）把hrtimer的时间前移了iprtd->poll_time_ns纳秒，这样周而复始；直到声卡被关闭，第37行又调用了hrtimer_cancel（）取消在open时初始化的hrtimer。

# 10.5.2　内核中延迟的工作delayed_work

对于周期性的任务，除了定时器以外，在Linux内核中还可以利用一套封装得很好的快捷机制，其本质是利用工作队列和定时器实现，这套快捷机制就是delayed_work，delayed_work结构体的定义如代码清单10.12所示。

代码清单10.12　delayed_work结构体

```
1struct delayed_work {
2        struct work_struct work;
3        struct timer_list timer;
4
5        /* target workqueue and CPU ->timer uses to queue ->work */
6        struct workqueue_struct *wq;
7        int cpu;
8};
```

我们可以通过如下函数调度一个delayed_work在指定的延时后执行：

```
int schedule_delayed_work(struct delayed_work *work, unsigned long delay);
```

当指定的delay到来时，delayed_work结构体中的work成员work_func_t类型成员func（）会被执行。work_func_t类型定义为：

```
typedef void (*work_func_t)(struct work_struct *work);
```

其中，delay参数的单位是jiffies，因此一种常见的用法如下：

```
schedule_delayed_work(&work, msecs_to_jiffies(poll_interval));
```

msecs_to_jiffies（）用于将毫秒转化为jiffies。

如果要周期性地执行任务，通常会在delayed_work的工作函数中再次调用schedule_delayed_work（），周而复始。

如下函数用来取消delayed_work：

```
int cancel_delayed_work(struct delayed_work *work);
int cancel_delayed_work_sync(struct delayed_work *work);
```

# 10.5.3　实例：秒字符设备

下面我们编写一个字符设备“second”（即“秒”）的驱动，它在被打开的时候初始化一个定时器并将其添加到内核定时器链表中，每秒输出一次当前的jiffies（为此，定时器处理函数中每次都要修改新的expires），整个程序如代码清单10.13所示。

代码清单10.13　使用内核定时器的second字符设备驱动

```
  1#include <linux/module.h>
  2#include <linux/fs.h>
  3#include <linux/mm.h>
  4#include <linux/init.h>
  5#include <linux/cdev.h>
  6#include <linux/slab.h>
  7#include <linux/uaccess.h>
  8
  9#define SECOND_MAJOR 248
 10
 11static int second_major = SECOND_MAJOR;
 12module_param(second_major, int, S_IRUGO);
 13
 14struct second_dev {
 15    struct cdev cdev;
 16    atomic_t counter;
 17    struct timer_list s_timer;
 18};
 19
 20static struct second_dev *second_devp;
 21
 22static void second_timer_handler(unsigned long arg)
 23{
 24 mod_timer(&second_devp->s_timer, jiffies + HZ);  /* 触发下一次定时*/
 25 atomic_inc(&second_devp->counter);               /* 增加秒计数*/
 26
 27 printk(KERN_INFO "current jiffies is %ld\n", jiffies);
 28}
 29
 30static int second_open(struct inode *inode, struct file *filp)
 31{
 32 init_timer(&second_devp->s_timer);
 33 second_devp->s_timer.function = &second_timer_handler;
 34 second_devp->s_timer.expires = jiffies + HZ;
 35
 36 add_timer(&second_devp->s_timer);
 37
 38 atomic_set(&second_devp->counter, 0);            /* 初始化秒计数为0 */
 39
 40 return 0;
 41}
 42
 43static int second_release(struct inode *inode, struct file *filp)
 44{
 45 del_timer(&second_devp->s_timer);
 46
 47 return 0;
 48}
 49
 50static ssize_t second_read(struct file *filp, char __user * buf, size_t count,
 51 loff_t * ppos)
 52{
 53 int counter;
 54
 55 counter = atomic_read(&second_devp->counter);
 56 if (put_user(counter, (int *)buf))/* 复制counter到userspace */
 57     return -EFAULT;
 58 else
 59   return sizeof(unsigned int);
 60}
 61
 62static const struct file_operations second_fops = {
 63 .owner = THIS_MODULE,
 64 .open = second_open,
 65 .release = second_release,
 66 .read = second_read,
 67};
 68
 69static void second_setup_cdev(struct second_dev *dev, int index)
 70{
 71 int err, devno = MKDEV(second_major, index);
 72
 73 cdev_init(&dev->cdev, &second_fops);
 74 dev->cdev.owner = THIS_MODULE;
 75 err = cdev_add(&dev->cdev, devno, 1);
 76 if (err)
 77     printk(KERN_ERR "Failed to add second device\n");
 78}
 79
 80static int __init second_init(void)
 81{
 82 int ret;
 83 dev_t devno = MKDEV(second_major, 0);
 84
 85 if (second_major)
 86     ret = register_chrdev_region(devno, 1, "second");
 87 else {
 88     ret = alloc_chrdev_region(&devno, 0, 1, "second");
 89     second_major = MAJOR(devno);
 90 }
 91 if (ret < 0)
 92     return ret;
 93
 94 second_devp = kzalloc(sizeof(*second_devp), GFP_KERNEL);
 95 if (!second_devp) {
 96     ret = -ENOMEM;
 97     goto fail_malloc;
 98 }
 99
100 second_setup_cdev(second_devp, 0);
101
102 return 0;
103
104fail_malloc:
105 unregister_chrdev_region(devno, 1);
106 return ret;
107}
108module_init(second_init);
109
110static void __exit second_exit(void)
111{
112 cdev_del(&second_devp->cdev);
113 kfree(second_devp);
114 unregister_chrdev_region(MKDEV(second_major, 0), 1);
115}
116module_exit(second_exit);
117
118MODULE_AUTHOR("Barry Song <21cnbao@gmail.com>");
119MODULE_LICENSE("GPL v2");
```

在second的open（）函数中，将启动定时器，此后每1s会再次运行定时器处理函数，在second的release（）函数中，定时器被删除。

second_dev结构体中的原子变量counter用于秒计数，每次在定时器处理函数中调用的atomic_inc（）会令其原子性地增1，second的read（）函数会将这个值返回给用户空间。

本书配套的Ubuntu中/home/baohua/develop/training/kernel/drivers/second/包含了second设备驱动以及second_test.c用户空间测试程序，运行make命令编译得到second.ko和second_test，加载second.ko内核模块并创建/dev/second设备文件节点：

```
# mknod /dev/second c 248 0
```

代码清单10.14给出了second_test.c这个应用程序，它打开/dev/second，其后不断地读取自/dev/second设备文件打开以后经历的秒数。

代码清单10.14　second设备用户空间测试程序

```
 1#include ...
 2
 3main()
 4{
 5  int fd;
 6  int counter = 0;
 7  int old_counter = 0;
 8
 9  /* 打开/dev/second设备文件*/
10  fd = open("/dev/second", O_RDONLY);
11  if (fd != - 1) {
13      while (1) {
15         read(fd,&counter, sizeof(unsigned int));/* 读目前经历的秒数*/
16         if(counter!=old_counter) {
18            printf("seconds after open /dev/second :%d\n",counter);
19               old_counter = counter;
20          }
21      }
22  } else {
25      printf("Device open failure\n");
26  }
27}
```

运行second_test后，内核将不断地输出目前的jiffies值

```
[13935.122093] current jiffies is 13635122
[13936.124441] current jiffies is 13636124
[13937.126078] current jiffies is 13637126
[13952.832648] current jiffies is 13652832
[13953.834078] current jiffies is 13653834
[13954.836090] current jiffies is 13654836
[13955.838389] current jiffies is 13655838
[13956.840453] current jiffies is 13656840
...
```

从上述内核的打印消息也可以看出，本书配套Ubuntu上的每秒jiffies大概走1000次。而应用程序将不断输出自/dec/second打开以后经历的秒数：

```
# ./second_test
seconds after open /dev/second :1
seconds after open /dev/second :2
seconds after open /dev/second :3
seconds after open /dev/second :4
seconds after open /dev/second :5
...
```

