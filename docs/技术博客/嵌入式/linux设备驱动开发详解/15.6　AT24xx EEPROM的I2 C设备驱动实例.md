drivers/misc/eeprom/at24.c文件支持大多数I2 C接口的EEPROM，正如我们之前所述，一个具体的I2 C设备驱动由i2c_driver的形式进行组织，用于将设备挂接于I2 C总线，组织好了后，再完成设备本身所属类型的驱动。对于EEPROM而言，设备本身的驱动以bin_attribute二进制sysfs节点形式呈现。代码清单15.25给出了该驱动的框架。

代码清单15.25　AT24xx EEPROM驱动

```
 1struct at24_data {
 2          struct at24_platform_data chip;
 3          ...
 4          struct bin_attribute bin;
 5          ...
 6};
 7
 8static const struct i2c_device_id at24_ids[] = {
 9          /* needs 8 addresses as A0-A2 are ignored */
10          { "24c00", AT24_DEVICE_MAGIC(128 / 8, AT24_FLAG_TAKE8ADDR) },
11          /* old variants can't be handled with this generic entry! */
12          { "24c01", AT24_DEVICE_MAGIC(1024 / 8, 0) },
13          { "24c02", AT24_DEVICE_MAGIC(2048 / 8, 0) },
14          ...
15          { /* END OF LIST */ }
16};
17MODULE_DEVICE_TABLE(i2c, at24_ids);
18
19static ssize_t at24_eeprom_read(struct at24_data *at24, char *buf,
20                  unsigned offset, size_t count)
21{
22          struct i2c_msg msg[2];
23          ...
24          i2c_transfer(client->adapter, msg, 2);
25          ...
26}
27
28static ssize_t at24_read(struct at24_data *at24,
29                  char *buf, loff_t off, size_t count)
30{
31          ...
32
33          status = at24_eeprom_read(at24, buf, off, count);
34          ...
35
36          return retval;
37 }
38
39static ssize_t at24_bin_read(struct file *filp, struct kobject *kobj,
40                  struct bin_attribute *attr,
41                  char *buf, loff_t off, size_t count)
42{
43          struct at24_data *at24;
44
45          at24 = dev_get_drvdata(container_of(kobj, struct device, kobj));
46          return at24_read(at24, buf, off, count);
47}
48
49…



50
51static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)
52{
53          ...
54          sysfs_bin_attr_init(&at24->bin);
55          at24->bin.attr.name = "eeprom";
56          at24->bin.attr.mode = chip.flags & AT24_FLAG_IRUGO   S_IRUGO : S_IRUSR;
57          at24->bin.read = at24_bin_read;
58          at24->bin.size = chip.byte_len;
59
60          ...
61          return err;
62}
63
64static int at24_remove(struct i2c_client *client)
65{
66          ...
67          sysfs_remove_bin_file(&client->dev.kobj, &at24->bin);
68          ...
69
70          return 0;
71}
72
73static struct i2c_driver at24_driver = {
74          .driver = {
75                  .name = "at24",
76                  .owner = THIS_MODULE,
77          },
78          .probe = at24_probe,
79          .remove = at24_remove,
80          .id_table = at24_ids,
81};
82
83static int __init at24_init(void)
84{
85          ...
86          return i2c_add_driver(&at24_driver);
87}
88module_init(at24_init);
89
90static void __exit at24_exit(void)
91{
92          i2c_del_driver(&at24_driver);
93}
94module_exit(at24_exit);
```

drivers/misc/eeprom/at24.c不依赖于具体的CPU和I2 C控制器的硬件特性，因此，如果某一电路板包含该外设，只需要在板级文件中添加对应的i2c_board_info，如：

```
static struct i2c_board_info i2c_devs0[] __initdata = {
     { I2C_BOARD_INFO("24c02", 0x57), },
};
```

在支持设备树的情况下，简单地在.dts文件中添加一个节点即可：

```
i2c@11000 {
       status = "okay";
       …
       eeprom@57 {
               compatible = "atmel,24c02";
               reg = <0x57>;
       };
};
```

