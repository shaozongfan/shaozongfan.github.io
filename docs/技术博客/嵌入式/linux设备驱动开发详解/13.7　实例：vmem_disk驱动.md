# 13.7.1　vmem_disk的硬件原理

vmem_disk是一种模拟磁盘，其数据实际上存储在RAM中。它使用通过vmalloc（）分配出来的内存空间来模拟出一个磁盘，以块设备的方式来访问这片内存。该驱动是对字符设备驱动章节中globalmem驱动的块方式改造。

加载vmem_disk.ko后，在使用默认模块参数的情况下，系统会增加4个块设备节点：

```
# ls -l /dev/vmem_disk*
brw-rw---- 1 root disk 252,  0  2月


 25 14:00 /dev/vmem_diska
brw-rw---- 1 root disk 252, 16  2月


 25 14:00 /dev/vmem_diskb
brw-rw---- 1 root disk 252, 32  2月


 25 14:00 /dev/vmem_diskc
brw-rw---- 1 root disk 252, 48  2月


 25 14:00 /dev/vmem_diskd
```

其中，mkfs.ext2/dev/vmem_diska命令的执行会回馈如下信息：

```
$ sudo mkfs.ext2  /dev/vmem_diska
mke2fs 1.42.9 (4-Feb-2014)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
Stride=0 blocks, Stripe width=0blocks
64 inodes, 512 blocks
25 blocks (4.88%) reserved for the super user
First data block=1
Maximum filesystem blocks=524288
1 block group
8192 blocks per group, 8192fragments per group
64 inodes per group
Allocating group tables: done
Writing inode tables: done
Writing superblocks and filesystem accounting information: done
```

它将/dev/vmem_diska格式化为EXT2文件系统。之后我们可以mount这个分区并在其中进行文件读写。

# 13.7.2　vmem_disk驱动模块的加载与卸载

vmem_disk驱动的模块加载函数完成的工作与13.3节给出的模板完全一致，它支持“制造请求”（对应于代码清单13.9）、请求队列（对应于代码清单13.10）两种模式（请注意在请求队列方面又支持简、繁两种模式），使用模块参数request_mode进行区分。代码清单13.13给出了vmem_disk设备驱动的模块加载与卸载函数。

代码清单13.13　vmem_disk设备驱动的模块加载与卸载函数

```
 1static void setup_device(struct vmem_disk_dev *dev, int which)
 2{
 3    memset (dev, 0, sizeof (struct vmem_disk_dev));
 4    dev->size = NSECTORS*HARDSECT_SIZE;
 5    dev->data = vmalloc(dev->size);
 6    if (dev->data == NULL) {
 7        printk (KERN_NOTICE "vmalloc failure.\n");
 8        return;
 9    }
10    spin_lock_init(&dev->lock);
11
12    /*
13     * The I/O queue, depending on whether we are using our own
14     * make_request function or not.
15     */
16    switch (request_mode) {
17    case VMEMD_NOQUEUE:
18        dev->queue = blk_alloc_queue(GFP_KERNEL);
19        if (dev->queue == NULL)
20            goto out_vfree;
21        blk_queue_make_request(dev->queue, vmem_disk_make_request);
22        break;
23    default:
24        printk(KERN_NOTICE "Bad request mode %d, using simple\n", request_mode);
25    case VMEMD_QUEUE:
26        dev->queue = blk_init_queue(vmem_disk_request, &dev->lock);
27        if (dev->queue == NULL)
28            goto out_vfree;
29        break;
30    }
31    blk_queue_logical_block_size(dev->queue, HARDSECT_SIZE);
32    dev->queue->queuedata = dev;
33
34    dev->gd = alloc_disk(VMEM_DISK_MINORS);
35    if (!dev->gd) {
36        printk (KERN_NOTICE "alloc_disk failure\n");
37        goto out_vfree;
38    }
39    dev->gd->major = vmem_disk_major;
40    dev->gd->first_minor = which*VMEM_DISK_MINORS;
41    dev->gd->fops = &vmem_disk_ops;
42    dev->gd->queue = dev->queue;
43    dev->gd->private_data = dev;
44    snprintf (dev->gd->disk_name, 32, "vmem_disk%c", which + 'a');
45    set_capacity(dev->gd, NSECTORS*(HARDSECT_SIZE/KERNEL_SECTOR_SIZE));
46    add_disk(dev->gd);
47    return;
48
49out_vfree:
50    if (dev->data)
51        vfree(dev->data);
52}
53
54
55static int __init vmem_disk_init(void)
56{
57    int i;
58
59    vmem_disk_major = register_blkdev(vmem_disk_major, "vmem_disk");
60    if (vmem_disk_major <= 0) {
61        printk(KERN_WARNING "vmem_disk: unable to get major number\n");
62        return -EBUSY;
63    }
64
65    devices = kmalloc(NDEVICES*sizeof (struct vmem_disk_dev), GFP_KERNEL);
66    if (!devices)
67        goto out_unregister;
68    for (i = 0; i < NDEVICES; i++)
69        setup_device(devices + i, i);
70
71    return 0;
72
73out_unregister:
74    unregister_blkdev(vmem_disk_major, "sbd");
75    return -ENOMEM;
76}
77module_init(vmem_disk_init);
```

注意上述代码的第16~30行，我们实际上支持两种I/O请求模式，一种是make_request，另一种是request_queue。make_request的版本直接使用vmem_disk_make_request（）来处理bio，而request_queue的版本则使用vmem_disk_request来处理请求队列。

# 13.7.3　vmem_disk设备驱动的block_device_operations

vmem_disk提供block_device_operations结构体中的getgeo（）成员函数，代码清单13.14给出了vmem_disk设备驱动的block_device_operations结构体定义及其成员函数的实现。

代码清单13.14　vmem_disk设备驱动的block_device_operations结构体及成员函数

```
 1static int vmem_disk_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 2{
 3    long size;
 4    struct vmem_disk_dev *dev = bdev->bd_disk->private_data;
 5
 6    size = dev->size*(HARDSECT_SIZE/KERNEL_SECTOR_SIZE);
 7    geo->cylinders = (size & ~0x3f) >> 6;
 8    geo->heads = 4;
 9    geo->sectors = 16;
10    geo->start = 4;
11
12    return 0;
13}
14
15static struct block_device_operations vmem_disk_ops = {
16    .getgeo          = vmem_disk_getgeo,
17};
```

# 13.7.4　vmem_disk的I/O请求处理

在vmem_disk驱动中，通过模块参数request_mode的方式来支持3种不同的请求处理模式以加深读者对它们的理解，代码清单13.15列出了vmem_disk设备驱动的请求处理代码。

代码清单13.15　vmem_disk设备驱动的请求处理函数

```
 1/*
 2 * Handle an I/O request.
 3 */
 4static void vmem_disk_transfer(struct vmem_disk_dev *dev, unsigned long sector,
 5        unsigned long nsect, char *buffer, int write)
 6{
 7    unsigned long offset = sector*KERNEL_SECTOR_SIZE;
 8    unsigned long nbytes = nsect*KERNEL_SECTOR_SIZE;
 9
10    if ((offset + nbytes) > dev->size) {
11        printk (KERN_NOTICE "Beyond-end write (%ld %ld)\n", offset, nbytes);
12        return;
13    }
14    if (write)
15        memcpy(dev->data + offset, buffer, nbytes);
16    else
17        memcpy(buffer, dev->data + offset, nbytes);
18}
19
20/*
21 * Transfer a single BIO.
22 */
23static int vmem_disk_xfer_bio(struct vmem_disk_dev *dev, struct bio *bio)
24{
25        struct bio_vec bvec;
26        struct bvec_iter iter;
27        sector_t sector = bio->bi_iter.bi_sector;
28
29    bio_for_each_segment(bvec, bio, iter) {
30        char *buffer = __bio_kmap_atomic(bio, iter);
31        vmem_disk_transfer(dev, sector, bio_cur_bytes(bio) >> 9,
32            buffer, bio_data_dir(bio) == WRITE);
33        sector += bio_cur_bytes(bio) >> 9;
34        __bio_kunmap_atomic(buffer);
35    }
36    return 0;
37}
38
39/*
40 * The request_queue version.
41 */
42static void vmem_disk_request(struct request_queue *q)
43{
44    struct request *req;
45    struct bio *bio;
46
47    while ((req = blk_peek_request(q)) != NULL) {
48        struct vmem_disk_dev *dev = req->rq_disk->private_data;
49        if (req->cmd_type != REQ_TYPE_FS) {
50            printk (KERN_NOTICE "Skip non-fs request\n");
51            blk_start_request(req);
52            __blk_end_request_all(req, -EIO);
53            continue;
54        }
55
56        blk_start_request(req);
57        __rq_for_each_bio(bio, req)
58            vmem_disk_xfer_bio(dev, bio);
59        __blk_end_request_all(req, 0);
60    }
61}
62
63
64/*
65 * The direct make request version.
66 */
67static void vmem_disk_make_request(struct request_queue *q, struct bio *bio)
68{
69    struct vmem_disk_dev *dev = q->queuedata;
70    int status;
71
72    status = vmem_disk_xfer_bio(dev, bio);
73    bio_endio(bio, status);
74}
```

第4行的vmem_disk_transfer（）完成真实的硬件I/O操作（对于本例而言，就是一个memcpy），第23行的vmem_disk_xfer_bio（）函数调用它来完成一个与bio对应的硬件操作，在完成的过程中通过第29行的bio_for_each_segment（）展开了该bio中的每个segment。

vmem_disk_make_request（）直接调用vmem_disk_xfer_bio（）来完成一个bio操作，而vmem_disk_request（）则通过第47行的blk_peek_request（）先从request_queue拿出一个请求，再通过第57行的__rq_for_each_bio（）从该请求中取出一个bio，之后调用vmem_disk_xfer_bio（）来完成该I/O请求，图13.4描述了这个过程。

![1744814119520](G:\typora文档\linux设备驱动开发详解\1744814119520.png)

图13.4　vmem_disk的I/O处理过程