<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">12.3.1　设备驱动核心层和例化 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="12.3.1　设备驱动核心层和例化 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="在12.1节，我们已经从感性上认识了Linux驱动软件分层的意义。其实，在分层设计的时候，Linux内核大量使用了面向对象的设计思想。"><meta data-rh="true" property="og:description" content="在12.1节，我们已经从感性上认识了Linux驱动软件分层的意义。其实，在分层设计的时候，Linux内核大量使用了面向对象的设计思想。"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.5fdb21e2.css">
<link rel="preload" href="/assets/js/runtime~main.33af3c92.js" as="script">
<link rel="preload" href="/assets/js/main.e3d1aa2c.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人博客/docusaurus2.4">个人博客</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人生活/2025国家生育政策8大补贴汇总">个人生活</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/人生哲学/人生的底层逻辑">人生哲学</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/技术博客/AI相关/AI核心技能">技术博客</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/技术博客/AI相关/AI核心技能">AI相关</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">嵌入式</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">linux设备驱动开发详解</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">1.3　有操作系统时的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.1　中断与定时器">10.1　中断与定时器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.2　Linux中断处理程序架构">10.2　Linux中断处理程序架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.4　中断共享">10.4　中断共享</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/10.7　总结">10.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.2　Linux内存管理">11.2　Linux内存管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">11.4　设备IO端口和IO内存的访问</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.5　IO内存静态映射">11.5　IO内存静态映射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.6　DMA">11.6　DMA</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/11.7　总结">11.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.1　Linux驱动的软件架构">12.1　Linux驱动的软件架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.1　块设备的IO操作特点">13.1　块设备的IO操作特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">13.3　Linux块设备驱动的初始化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.4　块设备的打开与释放">13.4　块设备的打开与释放</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">13.5　块设备驱动的ioctl函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.8　Linux MMC子系统">13.8　Linux MMC子系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/13.9　总结">13.9　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.10　总结">14.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">14.1　Linux网络设备驱动的结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">14.2　网络设备驱动的注册与注销</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.3　网络设备的初始化">14.3　网络设备的初始化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.4　网络设备的打开与释放">14.4　网络设备的打开与释放</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.5　数据发送流程">14.5　数据发送流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.6　数据接收流程">14.6　数据接收流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.7　网络连接状态">14.7　网络连接状态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.8　参数设置和统计数据">14.8　参数设置和统计数据</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.1　Linux I2 C体系结构">15.1　Linux I2 C体系结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.2　Linux I2 C核心">15.2　Linux I2 C核心</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">15.4　Linux I2 C设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">15.5　Tegra I2 C总线驱动实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/15.7　总结">15.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.5　USB OTG驱动">16.5　USB OTG驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/16.6　总结">16.6　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">17.1　I2 C、SPI、USB驱动架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.1　ARM设备树起源">18.1　ARM设备树起源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.2　设备树的组成和结构">18.2　设备树的组成和结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">18.3　由设备树引发的BSP和驱动变更</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.4　常用的OF API">18.4　常用的OF API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/18.5　总结">18.5　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.10　运行时的PM">19.10　运行时的PM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.11　总结">19.11　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">19.1　Linux电源管理的全局架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.2　CPUFreq驱动">19.2　CPUFreq驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.3　CPUIdle驱动">19.3　CPUIdle驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.4　PowerTop">19.4　PowerTop</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.5　Regulator驱动">19.5　Regulator驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.6　OPP">19.6　OPP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.7　PM QoS">19.7　PM QoS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.8　CPU热插拔">19.8　CPU热插拔</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/19.9　挂起到RAM">19.9　挂起到RAM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.2　存储器">2.2　存储器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.4　CPLD和FPGA">2.4　CPLD和FPGA</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.5　原理图分析">2.5　原理图分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.10　总结">20.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">20.1　ARM Linux底层驱动的组成和现状</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.2　内核节拍驱动">20.2　内核节拍驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.3　中断控制器驱动">20.3　中断控制器驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.6　GPIO驱动">20.6　GPIO驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.7　pinctrl驱动">20.7　pinctrl驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.8　时钟驱动">20.8　时钟驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/20.9　dmaengine驱动">20.9　dmaengine驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.10　使用仿真器调试内核">21.10　使用仿真器调试内核</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.11　应用程序调试">21.11　应用程序调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">21.12　Linux性能监控与调优工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.13　总结">21.13　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.2　Linux内核调试">21.2　Linux内核调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">21.3　内核打印信息—printk（​）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.5　使用“proc”">21.5　使用“proc”</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.6　Oops">21.6　Oops</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.8　strace">21.8　strace</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/21.9　KGDB">21.9　KGDB</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.1　Linux内核的发展与演变">3.1　Linux内核的发展与演变</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">3.2　Linux 2.6后的内核特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/3.6　工具链">3.6　工具链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">4.10　使用模块“绕开”GPL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.1　Linux内核模块简介">4.1　Linux内核模块简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.2　Linux内核模块程序结构">4.2　Linux内核模块程序结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.3　模块加载函数">4.3　模块加载函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.4　模块卸载函数">4.4　模块卸载函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.5　模块参数">4.5　模块参数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.6　导出符号">4.6　导出符号</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.7　模块声明与描述">4.7　模块声明与描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.8　模块的使用计数">4.8　模块的使用计数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/4.9　模块的编译">4.9　模块的编译</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.3　devfs">5.3　devfs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">6.2　globalmem虚拟设备实例描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.10　总结">7.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.1　并发与竞态">7.1　并发与竞态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.2　编译乱序和执行乱序">7.2　编译乱序和执行乱序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.3　中断屏蔽">7.3　中断屏蔽</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.4　原子操作">7.4　原子操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.6　信号量">7.6　信号量</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.7　互斥体">7.7　互斥体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.8　完成量">7.8　完成量</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">8.1　阻塞与非阻塞IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/8.4　总结">8.4　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.1　异步通知的概念与作用">9.1　异步通知的概念与作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-4 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/9.5　总结">9.5　总结</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/技术博客/嵌入式/rzg部署kdump">rzg部署kdump</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/技术博客/网络/网络问题">网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" tabindex="0" href="/docs/技术博客/调试/Linux内核追踪神器：perf实现原理剖析">调试</a></div></li></ul></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">技术博客</span><meta itemprop="position" content="1"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">嵌入式</span><meta itemprop="position" content="2"></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">linux设备驱动开发详解</span><meta itemprop="position" content="3"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">12.3.1　设备驱动核心层和例化</span><meta itemprop="position" content="4"></li></ul></nav><div class="theme-doc-markdown markdown"><h1>12.3.1　设备驱动核心层和例化</h1><p>在12.1节，我们已经从感性上认识了Linux驱动软件分层的意义。其实，在分层设计的时候，Linux内核大量使用了面向对象的设计思想。</p><p>在面向对象的程序设计中，可以为某一类相似的事物定义一个基类，而具体的事物可以继承这个基类中的函数。如果对于继承的这个事物而言，某成员函数的实现与基类一致，那它就可以直接继承基类的函数；相反，它也可以重写（Overriding），对父类的函数进行重新定义。若子类中的方法与父类中的某方法具有相同的方法名、返回类型和参数表，则新方法将覆盖原有的方法。这种面向对象的“多态”设计思想极大地提高了代码的可重用能力，是对现实世界中事物之间关系的一种良好呈现。</p><p>Linux内核完全是由C语言和汇编语言写成，但是却频繁地用到了面向对象的设计思想。在设备驱动方面，往往为同类的设备设计了一个框架，而框架中的核心层则实现了该设备通用的一些功能。同样的，如果具体的设备不想使用核心层的函数，也可以重写。举个例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">return_type core_funca(xxx_device * bottom_dev, param1_type param1, param1_type param2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (bottom_dev-&gt;funca)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return bottom_dev-&gt;funca(param1, param2);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    /* 核心层通用的funca代码*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述core_funca的实现中，会检查底层设备是否重写了funca（），如果重写了，就调用底层的代码，否则，直接使用通用层的。这样做的好处是，核心层的代码可以处理绝大多数与该类设备的funca（）对应的功能，只有少数特殊设备需要重新实现funca（）。</p><p>再看一个例子：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">return_type core_funca(xxx_device * bottom_dev, param1_type param1, param1_type param2)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /*通用的步骤代码A */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typea_dev_commonA();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* 底层操作ops1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bottom_dev-&gt;funca_ops1();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /*通用的步骤代码B */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typea_dev_commonB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /* 底层操作ops2 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bottom_dev-&gt;funca_ops2();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /*通用的步骤代码C */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     typea_dev_commonB();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     /** 底层操作ops3*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     bottom_dev-&gt;funca_ops3();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码假定为了实现funca（），对于同类设备而言，操作流程一致，都要经过“通用代码A、底层ops1、通用代码B、底层ops2、通用代码C、底层ops3”这几步，分层设计带来的明显好处是，对于通用代码A、B、C，具体的底层驱动不需要再实现，而仅仅只要关心其底层的操作ops1、ops2、ops3则可。</p><p>图12.5明确反映了设备驱动的核心层与具体设备驱动的关系，实际上，这种分层可能只有两层（见图12.5a），也可能是多层的（图12.5b）。</p><p><img loading="lazy" alt="1743910600543" src="/assets/images/1743910600543-d02d56ea80fecdd05e5ea57285cff529.png" width="1092" height="768" class="img_ev3q"></p><p>图12.5　Linux设备驱动的分层</p><p>这样的分层化设计在Linux的input、RTC、MTD、I2 C、SPI、tty、USB等诸多类型设备驱动中屡见不鲜。下面的几小节以input、RTC、Framebuffer等为例先进行一番讲解，当然，后续的章节会对与几个大的设备类型对应的驱动层次进行更详细的分析。</p><h1>12.3.2　输入设备驱动</h1><p>输入设备（如按键、键盘、触摸屏、鼠标等）是典型的字符设备，其一般的工作机理是底层在按键、触摸等动作发送时产生一个中断（或驱动通过Timer定时查询），然后CPU通过SPI、I2 C或外部存储器总线读取键值、坐标等数据，并将它们放入一个缓冲区，字符设备驱动管理该缓冲区，而驱动的read（）接口让用户可以读取键值、坐标等数据。</p><p>显然，在这些工作中，只是中断、读键值/坐标值是与设备相关的，而输入事件的缓冲区管理以及字符设备驱动的file_operations接口则对输入设备是通用的。基于此，内核设计了输入子系统，由核心层处理公共的工作。Linux内核输入子系统的框架如图12.6所示。</p><p><img loading="lazy" alt="1743911207521" src="/assets/images/1743911207521-64c305fa927dd1735ac1ade31f2f3d3d.png" width="850" height="984" class="img_ev3q"></p><p>图12.6　Linux内核输入子系统的框架</p><p>输入核心提供了底层输入设备驱动程序所需的API，如分配/释放一个输入设备：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct input_dev *input_allocate_device(void);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_free_device(struct input_dev *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>input_allocate_device（）返回的是1个input_dev的结构体，此结构体用于表征1个输入设备。</p><p>注册/注销输入设备用的接口如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int __must_check input_register_device(struct input_dev *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_unregister_device(struct input_dev *);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>报告输入事件用的接口如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告指定type、code的输入事件*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告键值*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_report_key(struct input_dev *dev, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告相对坐标*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_report_rel(struct input_dev *dev, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告绝对坐标 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_report_abs(struct input_dev *dev, unsigned int code, int value);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">/* 报告同步事件 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void input_sync(struct input_dev *dev);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>而对于所有的输入事件，内核都用统一的数据结构来描述，这个数据结构是input_event，如代码清单12.10所示。</p><p>代码清单12.10　input_event结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">1struct input_event {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">2   struct timeval time;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">3   __u16type;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">4   __u16code;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">5   __s32value;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/input/keyboard/gpio_keys.c基于input架构实现了一个通用的GPIO按键驱动。该驱动是基于platform_driver架构的，名为“gpio-keys”。它将与硬件相关的信息（如使用的GPIO号，按下和抬起时的电平等）屏蔽在板文件platform_device的platform_data中，因此该驱动可应用于各个处理器，具有良好的跨平台性。代码清单12.11列出了该驱动的probe（）函数。</p><p>代码清单12.11　GPIO按键驱动的probe（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int gpio_keys_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 struct device *dev = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 const struct gpio_keys_platform_data *pdata = dev_get_platdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct gpio_keys_drvdata *ddata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 struct input_dev *input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 size_t size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int i, error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 int wakeup = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!pdata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     pdata = gpio_keys_get_devtree_pdata(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     if (IS_ERR(pdata))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         return PTR_ERR(pdata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 size = sizeof(struct gpio_keys_drvdata) +</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         pdata-&gt;nbuttons * sizeof(struct gpio_button_data);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 ddata = devm_kzalloc(dev, size, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 if (!ddata) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     dev_err(dev, &quot;failed to allocate state\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22     return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 input = devm_input_allocate_device(dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 if (!input) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27     dev_err(dev, &quot;failed to allocate input device\n&quot;);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28     return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 ddata-&gt;pdata = pdata;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 ddata-&gt;input = input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 mutex_init(&amp;ddata-&gt;disable_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 platform_set_drvdata(pdev, ddata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 input_set_drvdata(input, ddata);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 input-&gt;name = pdata-&gt;name   : pdev-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39 input-&gt;phys = &quot;gpio-keys/input0&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 input-&gt;dev.parent = &amp;pdev-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 input-&gt;open = gpio_keys_open;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 input-&gt;close = gpio_keys_close;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44 input-&gt;id.bustype = BUS_HOST;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45 input-&gt;id.vendor = 0x0001;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46 input-&gt;id.product = 0x0001;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 input-&gt;id.version = 0x0100;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 /* Enable auto repeat feature of Linux input subsystem */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 if (pdata-&gt;rep)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51     __set_bit(EV_REP, input-&gt;evbit);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53 for (i = 0; i &lt; pdata-&gt;nbuttons; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54     const struct gpio_keys_button *button = &amp;pdata-&gt;buttons[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55     struct gpio_button_data *bdata = &amp;ddata-&gt;data[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57     error = gpio_keys_setup_key(pdev, input, bdata, button);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58     if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59         return error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61     if (button-&gt;wakeup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62         wakeup = 1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65 error = sysfs_create_group(&amp;pdev-&gt;dev.kobj, &amp;gpio_keys_attr_group);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67 error = input_register_device(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码的第25行分配了1个输入设备，第31~47行初始化了该input_dev的一些属性，第58行注册了这个输入设备。第53~63行则初始化了所用到的GPIO，第67行完成了这个输入设备的注册。</p><p>在注册输入设备后，底层输入设备驱动的核心工作只剩下在按键、触摸等人为动作发生时报告事件。代码清单12.12列出了GPIO按键中断发生时的事件报告代码。</p><p>代码清单12.12　GPIO按键中断发生时的事件报告</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static irqreturn_t gpio_keys_irq_isr(int irq, void *dev_id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 struct gpio_button_data *bdata = dev_id;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 const struct gpio_keys_button *button = bdata-&gt;button;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct input_dev *input = bdata-&gt;input;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 unsigned long flags;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 BUG_ON(irq != bdata-&gt;irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 spin_lock_irqsave(&amp;bdata-&gt;lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 if (!bdata-&gt;key_pressed) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13     if (bdata-&gt;button-&gt;wakeup)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14         pm_wakeup_event(bdata-&gt;input-&gt;dev.parent, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16     input_event(input, EV_KEY, button-&gt;code, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     input_sync(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19     if (!bdata-&gt;timer_debounce) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20         input_event(input, EV_KEY, button-&gt;code, 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21         input_sync(input);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22         goto out;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     bdata-&gt;key_pressed = true;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 if (bdata-&gt;timer_debounce)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29     mod_timer(&amp;bdata-&gt;timer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30         jiffies + msecs_to_jiffies(bdata-&gt;timer_debounce));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31out:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 spin_unlock_irqrestore(&amp;bdata-&gt;lock, flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 return IRQ_HANDLED;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>GPIO按键驱动通过input_event（）、input_sync（）这样的函数来汇报按键事件以及同步事件。从底层的GPIO按键驱动可以看出，该驱动中没有任何file_operations的动作，也没有各种I/O模型，注册进入系统也用的是input_register_device（）这样的与input相关的API。这是由于与Linux VFS接口的这一部分代码全部都在drivers/input/evdev.c中实现了，代码清单12.13摘取了部分关键代码。</p><p>代码清单12.13　input核心层的file_operations和read（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t evdev_read(struct file *file, char __user *buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2            size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 struct evdev_client *client = file-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct evdev *evdev = client-&gt;evdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 struct input_event event;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 size_t read = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 if (count != 0&amp;&amp; count &lt; input_event_size())</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11     return -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 for (;;) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14     if (!evdev-&gt;exist || client-&gt;revoked)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15         return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17     if (client-&gt;packet_head == client-&gt;tail &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18         (file-&gt;f_flags &amp; O_NONBLOCK))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19         return -EAGAIN;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21     /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22      * count == 0is special - no IO is done but we check</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23      * for error conditions (see above).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24      */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     if (count == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28     while (read + input_event_size() &lt;= count &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29            evdev_fetch_next_event(client, &amp;event)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31         if (input_event_to_user(buffer + read, &amp;event))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32             return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34         read += input_event_size();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     if (read)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40     if (!(file-&gt;f_flags &amp; O_NONBLOCK)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41         error = wait_event_interruptible(evdev-&gt;wait,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42                 client-&gt;packet_head != client-&gt;tail ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43                 !evdev-&gt;exist || client-&gt;revoked);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44         if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45             return error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 return read;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52static const struct file_operations evdev_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53 .owner        = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54 .read         = evdev_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55 .write        = evdev_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56 .pol          = evdev_poll,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57 .open         = evdev_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58 .release      = evdev_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59 .unlocked_ioct= evdev_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60#ifdef CONFIG_COMPAT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61 .compat_ioct= evdev_ioctl_compat,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63 .fasync        = evdev_fasync,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64 .flush         = evdev_flush,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65 .llseek        = no_llseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述代码中的17~19行在检查出是非阻塞访问后，立即返回EAGAIN错误，而第29行和第41~43行的代码则处理了阻塞的睡眠情况。回过头来想，其实gpio_keys驱动里面调用的input_event（）、input_sync（）有间接唤醒这个等待队列evdev-&gt;wait的功能，只不过这些代码都隐藏在其内部实现里了。</p><h1>12.3.3　RTC设备驱动</h1><p>RTC（实时钟）借助电池供电，在系统掉电的情况下依然可以正常计时。它通常还具有产生周期性中断以及闹钟（Alarm）中断的能力，是一种典型的字符设备。作为一种字符设备驱动，RTC需要有file_operations中接口函数的实现，如open（）、release（）、read（）、poll（）、ioctl（）等，而典型的IOCTL包括RTC_SET_TIME、RTC_ALM_READ、RTC_ALM_SET、RTC_IRQP_SET、RTC_IRQP_READ等，这些对于所有的RTC是通用的，只有底层的具体实现是与设备相关的。</p><p>因此，drivers/rtc/rtc-dev.c实现了RTC驱动通用的字符设备驱动层，它实现了file_opearations的成员函数以及一些通用的关于RTC的控制代码，并向底层导出rtc_device_register（）、rtc_device_unregister（）以注册和注销RTC；导出rtc_class_ops结构体以描述底层的RTC硬件操作。这个RTC通用层实现的结果是，底层的RTC驱动不再需要关心RTC作为字符设备驱动的具体实现，也无需关心一些通用的RTC控制逻辑，图12.7表明了这种关系。</p><p><img loading="lazy" alt="1743911539487" src="/assets/images/1743911539487-9fa10107f0ad0ca4d3fb8fc16e8f8cd9.png" width="907" height="487" class="img_ev3q"></p><p>图12.7　Linux RTC设备驱动的分层</p><p>drivers/rtc/rtc-s3c.c实现了S3C6410的RTC驱动，其注册RTC以及绑定rtc_class_ops的代码如代码清单12.14所示。</p><p>代码清单12.14　S3C6410RTC驱动的rtc_class_ops实例与RTC注册</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct rtc_class_ops s3c_rtcops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 .read_time     = s3c_rtc_gettime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 .set_time      = s3c_rtc_settime,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 .read_alarm    = s3c_rtc_getalarm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 .set_alarm     = s3c_rtc_setalarm,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 .proc          = s3c_rtc_proc,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 .alarm_irq_enable = s3c_rtc_setaie,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10static int s3c_rtc_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 rtc = devm_rtc_device_register(&amp;pdev-&gt;dev, &quot;s3c&quot;, &amp;s3c_rtcops,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               THIS_MODULE);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>drivers/rtc/rtc-dev.c以及其调用的drivers/rtc/interface.c等RTC核心层相当于把file_operations中的open（）、release（）、读取和设置时间等都间接“转发”给了底层的实例，代码清单12.15摘取了部分RTC核心层调用具体底层驱动callback的过程。</p><p>代码清单12.15　RTC核心层“转发”到底层RTC驱动callback</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int rtc_dev_open(struct inode *inode, struct file *file)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 err = ops-&gt;open   ops-&gt;open(rtc-&gt;dev.parent) : 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8static int __rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 int err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!rtc-&gt;ops)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     err = -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 else if (!rtc-&gt;ops-&gt;read_time)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      err = -EINVAL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19int rtc_read_time(struct rtc_device *rtc, struct rtc_time *tm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 int err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 err = mutex_lock_interruptible(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 if (err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25     return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 err = __rtc_read_time(rtc, tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32int rtc_set_time(struct rtc_device *rtc, struct rtc_time *tm)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 if (!rtc-&gt;ops)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     err = -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 else if (rtc-&gt;ops-&gt;set_time)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39     err = rtc-&gt;ops-&gt;set_time(rtc-&gt;dev.parent, tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44static long rtc_dev_ioctl(struct file *file,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45     unsigned int cmd, unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49 case RTC_RD_TIME:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50     mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52     err = rtc_read_time(rtc, &amp;tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53     if (err &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54         return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56     if (copy_to_user(uarg, &amp;tm, sizeof(tm)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57         err = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58     return err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60 case RTC_SET_TIME:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61     mutex_unlock(&amp;rtc-&gt;ops_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63     if (copy_from_user(&amp;tm, uarg, sizeof(tm)))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64         return -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66     return rtc_set_time(rtc, &amp;tm);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>12.3.4　Framebuffer设备驱动</h1><p>Framebuffer（帧缓冲）是Linux系统为显示设备提供的一个接口，它将显示缓冲区抽象，屏蔽图像硬件的底层差异，允许上层应用程序在图形模式下直接对显示缓冲区进行读写操作。对于帧缓冲设备而言，只要在显示缓冲区中与显示点对应的区域内写入颜色值，对应的颜色会自动在屏幕上显示。</p><p>图12.8所示为Linux帧缓冲设备驱动的主要结构，帧缓冲设备提供给用户空间的file_operations结构体由drivers/video/fbdev/core/fbmem.c中的file_operations提供，而特定帧缓冲设备fb_info结构体的注册、注销以及其中成员的维护，尤其是fb_ops中成员函数的实现则由对应的xxxfb.c文件实现，fb_ops中的成员函数最终会操作LCD控制其硬件寄存器。</p><p><img loading="lazy" alt="1743912007495" src="/assets/images/1743912007495-aaa31d8e9aaabef1db450c248aa3f832.png" width="1366" height="805" class="img_ev3q"></p><p>图12.8　Linux帧缓冲设备驱动的程序结构</p><p>多数显存的操作方法都是规范的，可以按照像素点格式的要求顺序写帧缓冲区。但是有少量LCD的显存写法可能比较特殊，这时候，在核心层drivers/video/fbdev/core/fbmem.c实现的fb_write（）中，实际上可以给底层提供一个重写自己的机会，如代码清单12.16所示。</p><p>代码清单12.16　LCD的framebuffer write（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2fb_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned long p = *ppos;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 struct fb_info *info = file_fb_info(file);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 u8*buffer, *src;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 u8__iomem *dst;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 int c, cnt = 0, err = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 unsigned long total_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 if (!info || !info-&gt;screen_base)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12     return -ENODEV;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 if (info-&gt;state != FBINFO_STATE_RUNNING)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15     return -EPERM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17 if (info-&gt;fbops-&gt;fb_write)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18     return info-&gt;fbops-&gt;fb_write(info, buf, count, ppos);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 total_size = info-&gt;screen_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 if (total_size == 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23     total_size = info-&gt;fix.smem_len;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 if (p &gt; total_size)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26     return -EFBIG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 if (count &gt; total_size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29     err = -EFBIG;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30     count = total_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 if (count + p &gt; total_size) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34     if (!err)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35         err = -ENOSPC;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37     count = total_size - p;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 buffer = kmalloc((count &gt; PAGE_SIZE)   PAGE_SIZE : count,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41          GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42 if (!buffer)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43     return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45 dst = (u8__iomem *) (info-&gt;screen_base + p);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47 if (info-&gt;fbops-&gt;fb_sync)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48     info-&gt;fbops-&gt;fb_sync(info);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50 while (count) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51     c = (count &gt; PAGE_SIZE)   PAGE_SIZE : count;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52     src = buffer;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54     if (copy_from_user(src, buf, c)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55         err = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56         break;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57     }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59     fb_memcpy_tofb(dst, src, c);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60     dst += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61     src += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62     *ppos += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63     buf += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64     cnt += c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65     count -= c;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66 }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68 kfree(buffer);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70 return (cnt)   cnt : err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第17~18行是一个检查底层LCD有没有实现自己特殊显存写法的代码，如果有，直接调底层的；如果没有，用中间层标准的显存写法就搞定了底层的那个不特殊的LCD。</p><h1>12.3.5　终端设备驱动</h1><p>在Linux系统中，终端是一种字符型设备，它有多种类型，通常使用tty（Teletype）来简称各种类型的终端设备。对于嵌入式系统而言，最普遍采用的是UART（Universal Asynchronous Receiver/Transmitter）串行端口，日常生活中简称串口。</p><p>Linux内核中tty的层次结构如图12.9所示，它包含tty核心tty_io.c、tty线路规程n_tty.c（实现N_TTY线路规程）和tty驱动实例xxx_tty.c，tty线路规程的工作是以特殊的方式格式化从一个用户或者硬件收到的数据，这种格式化常常采用一个协议转换的形式。</p><p>tty_io.c本身是一个标准的字符设备驱动，它对上有字符设备的职责，实现file_operations成员函数。但是tty核心层对下又定义了tty_driver的架构，这样tty设备驱动的主体工作就变成了填充tty_driver结构体中的成员，实现其中的tty_operations的成员函数，而不再是去实现file_operations这一级的工作。tty_driver结构体和tty_operations的定义分别如代码清单12.17和12.18所示。</p><p><img loading="lazy" alt="1743912094969" src="/assets/images/1743912094969-cca7f97f22f81f9ee17bec2ea8527f3d.png" width="897" height="511" class="img_ev3q"></p><p>图12.9　Linux内核中tty的层次结构</p><p>代码清单12.17　tty_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct tty_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      int     magic;                  /* magic number for this structure */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      struct kref kref;               /* Reference management */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      struct cdev *cdevs;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      struct module   *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      const char      *driver_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      const char      *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      int     name_base;              /* offset of printed name */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      int     major;                  /* major device number */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      int     minor_start;            /* start of minor device number */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11      unsigned int    num;            /* number of devices allocated */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12      short   type;                   /* type of tty driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13      short   subtype;                /* subtype of tty driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      struct ktermios init_termios;   /* Initial termios */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15      unsigned long   flags;          /* tty driver flags */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16      struct proc_dir_entry *proc_entry;   /* /proc fs entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17      struct tty_driver *other;       /* only used for the PTY driver */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19      /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20       * Pointer to the tty data structures</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22      struct tty_struct **ttys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23      struct tty_port **ports;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24      struct ktermios **termios;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25      void *driver_state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27      /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       * Driver methods</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31      const struct tty_operations *ops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32      struct list_head tty_drivers;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单12.18　tty_operations结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct tty_operations {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 struct tty_struct * (*lookup)(struct tty_driver *driver,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3          struct inode *inode, int idx);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 int  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 void (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 int  (*open)(struct tty_struct * tty, struct file * filp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 void (*close)(struct tty_struct * tty, struct file * filp);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 void (*shutdown)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 void (*cleanup)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 int  (*write)(struct tty_struct * tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11           const unsigned char *buf, int count);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 int  (*put_char)(struct tty_struct *tty, unsigned char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 void (*flush_chars)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 int  (*write_room)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 int  (*chars_in_buffer)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 int  (*ioctl)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17         unsigned int cmd, unsigned long arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 long (*compat_ioctl)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19                 unsigned int cmd, unsigned long arg);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 void (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21 void (*throttle)(struct tty_struct * tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 void (*unthrottle)(struct tty_struct * tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23 void (*stop)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 void (*start)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25 void (*hangup)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 int (*break_ctl)(struct tty_struct *tty, int state);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 void (*flush_buffer)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 void (*set_ldisc)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 void (*wait_until_sent)(struct tty_struct *tty, int timeout);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30 void (*send_xchar)(struct tty_struct *tty, char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 int (*tiocmget)(struct tty_struct *tty);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 int (*tiocmset)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33         unsigned int set, unsigned int clear);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34 int (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35 int (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36 int (*get_icount)(struct tty_struct *tty,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37             struct serial_icounter_struct *icount);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38#ifdef CONFIG_CONSOLE_POLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39 int (*poll_init)(struct tty_driver *driver, int line, char *options);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40 int (*poll_get_char)(struct tty_driver *driver, int line);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41 void (*poll_put_char)(struct tty_driver *driver, int line, char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43 const struct file_operations *proc_fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如图12.10所示，tty设备发送数据的流程为：tty核心从一个用户获取将要发送给一个tty设备的数据，tty核心将数据传递给tty线路规程驱动，接着数据被传递到tty驱动，tty驱动将数据转换为可以发送给硬件的格式。接收数据的流程为：从tty硬件接收到的数据向上交给tty驱动，接着进入tty线路规程驱动，再进入tty核心，在这里它被一个用户获取。</p><p><img loading="lazy" alt="1743949417804" src="/assets/images/1743949417804-5fc2c2172627c27de8f4fa2602247a23.png" width="741" height="1062" class="img_ev3q"></p><p>图12.10　tty设备发送、接收数据流的流程</p><p>代码清单12.18中第10行的tty_driver操作集tty_operations的成员函数write（）函数接收3个参数：tty_struct、发送数据指针及要发送的字节数。该函数是被file_operations的write（）成员函数间接触发调用的。从接收角度看，tty驱动一般收到字符后会通过tty_flip_buffer_push（）将接收缓冲区推到线路规程。</p><p>尽管一个特定的底层UART设备驱动完全可以遵循上述tty_driver的方法来设计，即定义tty_driver并实现tty_operations中的成员函数，但是鉴于串口之间的共性，Linux考虑在文件drivers/tty/serial/serial_core.c中实现了UART设备的通用tty驱动层（我们可以称其为串口核心层）。这样，UART驱动的主要任务就进一步演变成了实现serial-core.c中定义的一组uart_xxx接口而不是tty_xxx接口，如图12.11所示。因此，按照面向对象的思想，可以认为tty_driver是字符设备的泛化、serial-core是tty_driver的泛化，而具体的串口驱动又是serial-core的泛化。</p><p><img loading="lazy" alt="1743949470945" src="/assets/images/1743949470945-94ff25cef64847f9b26fde4100476734.png" width="927" height="654" class="img_ev3q"></p><p>图12.11　串口核心层</p><p>串口核心层又定义了新的uart_driver结构体和其操作集uart_ops。一个底层的UART驱动需要创建和通过uart_register_driver（）注册一个uart_driver而不是tty_driver，代码清单12.19给出了uart_driver的定义。</p><p>代码清单12.19　uart_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct uart_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      struct module           *owner;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      const char              *driver_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      const char              *dev_name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      int                      major;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      int                      minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      int                      nr;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      struct console          *cons;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10      /*</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       * these are private; the low level driver should not</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12       * touch these; they should be initialised to NULL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13       */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14      struct uart_state       *state;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15      struct tty_driver       *tty_driver;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>uart_driver结构体在本质上是派生自uart_driver结构体，因此，它的第15行也包含了一个tty_driver结构体成员。tty_operations在UART这个层面上也被进一步泛化为了uart_ops，其定义如代码清单12.20所示。</p><p>代码清单12.20　uart_ops结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct uart_ops {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2 unsigned int    (*tx_empty)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3 void        (*set_mctrl)(struct uart_port *, unsigned int mctrl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4 unsigned int    (*get_mctrl)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5 void        (*stop_tx)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6 void        (*start_tx)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7 void        (*throttle)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8 void        (*unthrottle)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9 void        (*send_xchar)(struct uart_port *, char ch);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10 void        (*stop_rx)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11 void        (*enable_ms)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12 void        (*break_ctl)(struct uart_port *, int ctl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13 int         (*startup)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14 void        (*shutdown)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15 void        (*flush_buffer)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16 void        (*set_termios)(struct uart_port *, struct ktermios *new,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17                    struct ktermios *old);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18 void        (*set_ldisc)(struct uart_port *, struct ktermios *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19 void        (*pm)(struct uart_port *, unsigned int state,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20               unsigned int oldstate);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22 const char    *(*type)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24 void        (*release_port)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26 int         (*request_port)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27 void        (*config_port)(struct uart_port *, int);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28 int         (*verify_port)(struct uart_port *, struct serial_struct *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29 int         (*ioctl)(struct uart_port *, unsigned int, unsigned long);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30#ifdef CONFIG_CONSOLE_POLL</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31 int         (*poll_init)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32 void        (*poll_put_char)(struct uart_port *, unsigned char);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33 int         (*poll_get_char)(struct uart_port *);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于drivers/tty/serial/serial_core.c是一个tty_driver，因此在serial_core.c中，存在一个tty_operations的实例，这个实例的成员函数会进一步调用struct uart_ops的成员函数，这样就把file_operations里的成员函数、tty_operations的成员函数和uart_ops的成员函数串起来了。</p><h1>12.3.6　misc设备驱动</h1><p>由于Linux驱动倾向于分层设计，所以各个具体的设备都可以找到它归属的类型，从而套到它相应的架构里面去，并且只需要实现最底层的那一部分。但是，也有部分类似globalmem、globalfifo的字符设备，确实不知道它属于什么类型，我们一般推荐大家采用miscdevice框架结构。miscdevice本质上也是字符设备，只是在miscdevice核心层的misc_init（）函数中，通过register_chrdev（MISC_MAJOR，&quot;misc&quot;，&amp;misc_fops）注册了字符设备，而具体miscdevice实例调用misc_register（）的时候又自动完成了device_create（）、获取动态次设备号的动作。</p><p>miscdevice的主设备号是固定的，MISC_MAJOR定义为10，在Linux内核中，大概可以找到200多处使用miscdevice框架结构的驱动。</p><p>miscdevice结构体的定义如代码清单12.21所示，在它的第4行，指向了一个file_operations的结构体。miscdevice结构体内file_operations中的成员函数实际上是由drivers/char/misc.c中misc驱动核心层的misc_fops成员函数间接调用的，比如misc_open（）就会间接调用底层注册的miscdevice的fops-&gt;open。</p><p>代码清单12.21　miscdevice结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct miscdevice  {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2      int minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3      const char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4      const struct file_operations *fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5      struct list_head list;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6      struct device *parent;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7      struct device *this_device;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8      const char *nodename;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9      umode_t mode;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果上述代码第2行的minor为MISC_DYNAMIC_MINOR，miscdevice核心层会自动找一个空闲的次设备号，否则用minor指定的次设备号。第3行的name是设备的名称。</p><p>miscdevice驱动的注册和注销分别用下面两个API</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int misc_register(struct miscdevice * misc);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int misc_deregister(struct miscdevice *misc);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>因此miscdevice驱动的一般结构形如：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static const struct file_operations xxx_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .unlocked_ioctl = xxx_ioctl,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .mmap           = xxx_mmap,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            …</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static struct miscdevice xxx_dev = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .minor  = MISC_DYNAMIC_MINOR,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .name   = &quot;xxx&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       .fops   = &amp;xxx_fops</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">static int __init xxx_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       pr_info(&quot;ARC Hostlink driver mmap at 0x%p\n&quot;, __HOSTLINK__);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">       return misc_register(&amp;xxx_dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在调用misc_register（&amp;xxx_dev）时，该函数内部会自动调用device_create（），而device_create（）会以xxx_dev作为drvdata参数。其次，在miscdevice核心层misc_open（）函数的帮助下，在file_operations的成员函数中，xxx_dev会自动成为file的private_data（misc_open会完成file-&gt;private_data的赋值操作）。</p><p>如果我们用面向对象的封装思想把一个设备的属性、自旋锁、互斥体、等待队列、miscdevice等封装在一个结构体里面：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct xxx_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     unsigned int version;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     unsigned int size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">     spinlock_t lock;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct miscdevice miscdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在file_operations的成员函数中，就可以通过container_of（）和file-&gt;private_data反推出xxx_dev的实例。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">static long xxx_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    struct xxx_dev *xxx = container_of(file-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                struct xxx_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面我们把globalfifo驱动改造成基于platform_driver且采用miscdevice框架的结构体。首先这个新的驱动变成了要通过platform_driver的probe（）函数来初始化，其次不再直接采用register_chrdev（）、cdev_add（）之类的原始API，而采用miscdevice的注册方法。代码清单12.22列出了新的globalfifo驱动相对于第9章globalfifo驱动变化的部分。</p><p>代码清单12.22　新的globalfifo驱动相对于第9章globalfifo驱动变化的部分</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct globalfifo_dev {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    struct miscdevice miscdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6static int globalfifo_fasync(int fd, struct file *filp, int mode)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13static long globalfifo_ioctl(struct file *filp, unsigned int cmd,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                 unsigned long arg)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21static unsigned int globalfifo_poll(struct file *filp, poll_table * wait)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28static ssize_t globalfifo_read(struct file *filp, char __user *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29                   size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36static ssize_t globalfifo_write(struct file *filp, const char __user *buf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37                size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    struct globalfifo_dev *dev = container_of(filp-&gt;private_data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40        struct globalfifo_dev, miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44static int globalfifo_probe(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    struct globalfifo_dev *gl;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47    int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    gl = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*gl), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50    if (!gl)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51        return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52    gl-&gt;miscdev.minor = MISC_DYNAMIC_MINOR;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53    gl-&gt;miscdev.name = &quot;globalfifo&quot;;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54    gl-&gt;miscdev.fops = &amp;globalfifo_fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56    mutex_init(&amp;gl-&gt;mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57    init_waitqueue_head(&amp;gl-&gt;r_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58    init_waitqueue_head(&amp;gl-&gt;w_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59    platform_set_drvdata(pdev, gl);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61    ret = misc_register(&amp;gl-&gt;miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62    if (ret &lt; 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63        goto err;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">64    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">65    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">66err:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">67    return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">68}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">69</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">70static int globalfifo_remove(struct platform_device *pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">71{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">72    struct globalfifo_dev *gl = platform_get_drvdata(pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">73    misc_deregister(&amp;gl-&gt;miscdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">74    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">75}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">76</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">77static struct platform_driver globalfifo_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">78    .driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">79        .name = &quot;globalfifo&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">80        .owner = THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">81    },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">82    .probe = globalfifo_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">83    .remove = globalfifo_remove,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">84};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">85module_platform_driver(globalfifo_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在上述代码中，file_operations的各个成员函数都使用container_of（）反向求出private_data，第61行在platform_driver的probe（）函数中完成了miscdev的注册，而在remove（）函数中使用misc_deregister（）完成了miscdev的注销。</p><p>上述代码也改用了platform_device和platform_driver的体系结构。我们增加了一个模块来完成platform_device的注册，在模块初始化的时候通过platform_device_alloc（）和platform_device_add（）分配并添加platform_device，而在模块卸载的时候则通过platform_device_unregister（）注销platform_device，如代码清单12.23所示。</p><p>代码清单12.23　与globalfifo对应的platform_device的注册和注销</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct platform_device *globalfifo_pdev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3static int __init globalfifodev_init(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        globalfifo_pdev = platform_device_alloc(&quot;globalfifo&quot;, -1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        if (!globalfifo_pdev)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9                return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        ret = platform_device_add(globalfifo_pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        if (ret) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                platform_device_put(globalfifo_pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                return ret;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20module_init(globalfifodev_init);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22static void __exit globalfifodev_exit(void)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        platform_device_unregister(globalfifo_pdev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26module_exit(globalfifodev_exit);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>本书配套代码/home/baohua/develop/training/kernel/drivers/globalfifo/ch12中包含了globalfifo driver和device端的两个模块。在该目录运行make，会生成两个模块：globalfifo.ko和globalfifo-dev.ko，把globalfifo.ko和globalfifo-dev.ko先后insmod，会导致platform_driver和platform_device的匹配，globalfifo_probe（）会执行，/dev/globalfifo节点会自动生成，默认情况下需要root权限来访问/dev/globalfifo。</p><p>如果此后我们rmmod globalfifo-dev.ko，则会导致platform_driver的remove（）成员函数，即globalfifo_remove（）函数被执行，/dev/globalfifo节点会自动消失。</p><h1>12.3.7　驱动核心层</h1><p>分析了上述多个实例，我们可以归纳出核心层肩负的3大职责：</p><p>1）对上提供接口。file_operations的读、写、ioctl都被中间层搞定，各种I/O模型也被处理掉了。</p><p>2）中间层实现通用逻辑。可以被底层各种实例共享的代码都被中间层搞定，避免底层重复实现。</p><p>3）对下定义框架。底层的驱动不再需要关心Linux内核VFS的接口和各种可能的I/O模型，而只需处理与具体硬件相关的访问。</p><p>这种分层有时候还不是两层，可以有更多层，在软件上呈现为面向对象里类继承和多态的状态。上一节介绍的终端设备驱动，在软件层次上类似图12.12的效果。</p><p><img loading="lazy" alt="1743949827184" src="/assets/images/1743949827184-2ca392615809b015f21a14e91917ad72.png" width="331" height="550" class="img_ev3q"></p><p>图12.12　tty驱动各层泛化</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/shaozongfan/shaozongfan.github.io/docs/技术博客/嵌入式/linux设备驱动开发详解/12.3　设备驱动的分层思想.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.2　platform设备驱动"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">12.2.1　platform总线、设备与驱动</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/技术博客/嵌入式/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">12.4.1　主机驱动与外设驱动分离</div></a></nav></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.33af3c92.js"></script>
<script src="/assets/js/main.e3d1aa2c.js"></script>
</body>
</html>