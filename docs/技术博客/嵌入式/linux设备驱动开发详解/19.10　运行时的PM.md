在前文给出的dev_pm_ops结构体中，有3个以runtime开头的成员函数：runtime_suspend（）、runtime_resume（）和runtime_idle（），它们辅助设备完成运行时的电源管理：

```
struct dev_pm_ops {
       ...
       int (*runtime_suspend)(struct device *dev);
       int (*runtime_resume)(struct device *dev);
       int (*runtime_idle)(struct device *dev);
       ...
};
```

运行时的PM与前文描述的系统级挂起到RAM时候的PM不太一样，它是针对单个设备，指系统在非睡眠状态的情况下，某个设备在空闲时可以进入运行时挂起状态，而在不是空闲时执行运行时恢复使得设备进入正常工作状态，如此，这个设备在运行时会省电。Linux运行时PM最早是在Linux2.6.32内核中被合并的。

Linux提供了一系列API，以便于设备可以声明自己的运行时PM状态：

```
int pm_runtime_suspend(struct device *dev);
```

引发设备的挂起，执行相关的runtime_suspend（）函数。

```
int pm_schedule_suspend(struct device *dev, unsigned int delay);
```

“调度”设备的挂起，延迟delay毫秒后将挂起工作挂入pm_wq等待队列，结果等价于delay毫秒后执行相关的runtime_suspend（）函数。

```
int pm_request_autosuspend(struct device *dev);
```

“调度”设备的挂起，自动挂起的延迟到后，挂起的工作项目被自动放入队列。

```
int pm_runtime_resume(struct device *dev);
```

引发设备的恢复，执行相关的runtime_resume（）函数。

```
int pm_request_resume(struct device *dev);
```

发起一个设备恢复的请求，该请求也是挂入pm_wq等待队列。

```
int pm_runtime_idle(struct device *dev);
```

引发设备的空闲，执行相关的runtime_idle（）函数。

```
int pm_request_idle(struct device *dev);
```

发起一个设备空闲的请求，该请求也是挂入pm_wq等待队列。

```
void pm_runtime_enable(struct device *dev);
```

使能设备的运行时PM支持。

```
int pm_runtime_disable(struct device *dev);
```

禁止设备的运行时PM支持。

```
int pm_runtime_get(struct device *dev);
int pm_runtime_get_sync(struct device *dev);
```

增加设备的引用计数（usage_count），这类似于clk_get（），会间接引发设备的runtime_resume（）。

```
int pm_runtime_put(struct device *dev);
int pm_runtime_put_sync(struct device *dev)
```

减小设备的引用计数，这类似于clk_put（），会间接引发设备的runtime_idle（）。

我们可以这样简单地理解Linux运行时PM的机制，每个设备（总线的控制器自身也属于一个设备）都有引用计数usage_count和活跃子设备（Active Children，子设备的意思就是该级总线上挂的设备）计数child_count，当两个计数都为0的时候，就进入空闲状态，调用pm_request_idle（dev）。当设备进入空闲状态，与pm_request_idle（dev）对应的PM核并不一定直接调用设备驱动的runtime_suspend（），它实际上在多数情况下是调用与该设备对应的bus_type的runtime_idle（）。下面是内核的代码逻辑：

```
static pm_callback_t __rpm_get_callback(struct device *dev, size_t cb_offset)
{
pm_callback_t cb;
const struct dev_pm_ops *ops;
if (dev->pm_domain)
ops = &dev->pm_domain->ops;
else if (dev->type && dev->type->pm)
ops = dev->type->pm;
else if (dev->class && dev->class->pm)
ops = dev->class->pm;
else if (dev->bus && dev->bus->pm)
ops = dev->bus->pm;
else
ops = NULL;
if (ops)
cb = *(pm_callback_t *)((void *)ops + cb_offset);
else
cb = NULL;
if (!cb && dev->driver && dev->driver->pm)
cb = *(pm_callback_t *)((void *)dev->driver->pm + cb_offset);
return cb;
}
```

据此可知，bus_type级的回调函数实际上可以被pm_domain、type、class覆盖掉，这些都统称为子系统。bus_type等子系统级别的runtime_idle（）行为完全由相应的总线类型、设备分类和pm_domain因素决定，但是一般的行为是子系统级别的runtime_idle（）会调度设备驱动的runtime_suspend（）。

在具体的设备驱动中，一般的用法则是在设备驱动probe（）时运行pm_runtime_enable（）使能运行时PM支持，在运行过程中动态地执行“pm_runtime_get_xxx（）->做工作->pm_runtime_put_xxx（）”的序列。如代码清单19.19中的drivers/watchdog/omap_wdt.c OMAP的看门狗驱动。在omap_wdt_start（）中启动了pm_runtime_get_sync（），而在omap_wdt_stop（）中调用了pm_runtime_put_sync（）。

代码清单19.19　运行时PM的pm_runtime_get（）和pm_runtime_put（）

```
 1static int omap_wdt_start(struct watchdog_device *wdog)
 2{
 3      struct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);
 4      void __iomem *base = wdev->base;
 5
 6      mutex_lock(&wdev->lock);
 7
 8      wdev->omap_wdt_users = true;
 9
10      pm_runtime_get_sync(wdev->dev);
11
12      /* initialize prescaler */
13      while (readl_relaxed(base + OMAP_WATCHDOG_WPS) & 0x01)
14            cpu_relax();
15      ...
16      mutex_unlock(&wdev->lock);
17
18      return 0;
19}
20static int omap_wdt_stop(struct watchdog_device *wdog)
21{
22      struct omap_wdt_dev *wdev = watchdog_get_drvdata(wdog);
23
24      mutex_lock(&wdev->lock);
25      omap_wdt_disable(wdev);
26      pm_runtime_put_sync(wdev->dev);
27      wdev->omap_wdt_users = false;
28      mutex_unlock(&wdev->lock);
29      return 0;
30}
31
32static const struct watchdog_ops omap_wdt_ops = {
33      .owner          = THIS_MODULE,
34      .start          = omap_wdt_start,
35      .stop           = omap_wdt_stop,
36      .ping           = omap_wdt_ping,
37      .set_timeout    = omap_wdt_set_timeout,
38};
```

上述代码第10行的pm_runtime_get_sync（wdev->dev）告诉内核要开始用看门狗这个设备了，如果看门狗设备已经进入省电模式（之前引用计数为0且执行了运行时挂起），会导致该设备的运行时恢复；第26行告诉内核不用这个设备了，如果引用计数变为0且活跃子设备为0，则导致该看门狗设备的运行时挂起。

上述代码第10行的pm_runtime_get_sync（wdev->dev）告诉内核要开始用看门狗这个设备了，如果看门狗设备已经进入省电模式（之前引用计数为0且执行了运行时挂起），会导致该设备的运行时恢复；第26行告诉内核不用这个设备了，如果引用计数变为0且活跃子设备为0，则导致该看门狗设备的运行时挂起。

在执行操作的时候声明pm_runtime_get（），操作完成后执行pm_runtime_mark_last_busy（）和pm_runtime_put_autosuspend（），一旦自动挂动的延时到期且设备的使用计数为0，则引发相关runtime_suspend（）入口函数的调用。一个典型用法如代码清单19.20所示。

代码清单19.20　运行时PM的自动挂动

```
 1foo_read_or_write(struct foo_priv *foo, void *data)
 2{
 3      lock(&foo->private_lock);
 4      add_request_to_io_queue(foo, data);
 5      if (foo->num_pending_requests++ == 0)
 6             pm_runtime_get(&foo->dev);
 7      if (!foo->is_suspended)
 8             foo_process_next_request(foo);
 9      unlock(&foo->private_lock);
10}
11
12foo_io_completion(struct foo_priv *foo, void *req)
13{
14       lock(&foo->private_lock);
15       if (--foo->num_pending_requests == 0) {
16              pm_runtime_mark_last_busy(&foo->dev);
17              pm_runtime_put_autosuspend(&foo->dev);
18       } else {
19              foo_process_next_request(foo);
20       }
21       unlock(&foo->private_lock);
22       /* 将请求结果返回给用户
 ... */
23}
```

在上述代码的第6行开始进行I/O传输了，因此运行了pm_runtime_get（）之后，当I/O传输结束的时候，第16~17行向内核告知该设备最后的忙时刻，并执行了pm_runtime_put_autosuspend（）。

设备驱动PM成员的runtime_suspend（）一般完成保存上下文、切到省电模式的工作，而runtime_resume（）一般完成对硬件上电、恢复上下文的工作。代码清单19.21给出了一个drivers/spi/spi-pl022.c的案例。

代码清单19.21　运行时PM的runtime_suspend/resume（）案例

```
 1#ifdef CONFIG_PM
 2static int pl022_runtime_suspend(struct device *dev)
 3{
 4      struct pl022 *pl022 = dev_get_drvdata(dev);
 5
 6      clk_disable_unprepare(pl022->clk);
 7      pinctrl_pm_select_idle_state(dev);
 8
 9      return 0;
10}
11
12static int pl022_runtime_resume(struct device *dev)
13{
14      struct pl022 *pl022 = dev_get_drvdata(dev);
15
16      pinctrl_pm_select_default_state(dev);
17      clk_prepare_enable(pl022->clk);
18
19      return 0;
20}
21#endif
22
23static const struct dev_pm_ops pl022_dev_pm_ops = {
24      SET_SYSTEM_SLEEP_PM_OPS(pl022_suspend, pl022_resume)
25      SET_RUNTIME_PM_OPS(pl022_runtime_suspend, pl022_runtime_resume, NULL)
26};
```

第25行的SET_RUNTIME_PM_OPS（）是一个快捷宏，它完成了runtime_suspend、runtime_resume的赋值动作，其定义如下：

```
#define SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
       .runtime_suspend = suspend_fn, \
       .runtime_resume = resume_fn, \
       .runtime_idle = idle_fn,
```

其实，除了SET_RUNTIME_PM_OPS（）和前文介绍的SET_SYSTEM_SLEEP_PM_OPS（），在include/linux/pm.h中还定义了SIMPLE_DEV_PM_OPS（）、UNIVERSAL_DEV_PM_OPS（）等更快捷的宏：

```
#define SIMPLE_DEV_PM_OPS(name, suspend_fn, resume_fn) \
const struct dev_pm_ops name = { \
       SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
}
#define UNIVERSAL_DEV_PM_OPS(name, suspend_fn, resume_fn, idle_fn) \
const struct dev_pm_ops name = { \
       SET_SYSTEM_SLEEP_PM_OPS(suspend_fn, resume_fn) \
       SET_RUNTIME_PM_OPS(suspend_fn, resume_fn, idle_fn) \
}
```

在内核里充斥着这些宏的使用例子。我们从UNIVERSAL_DEV_PM_OPS（）这个宏的定义可以看出，它针对的是挂起到RAM和运行时PM行为一致的场景。