# 10.3.1　申请和释放中断

在Linux设备驱动中，使用中断的设备需要申请和释放对应的中断，并分别使用内核提供的request_irq（）和free_irq（）函数。

1.申请irq

```
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
            const char *name, void *dev);
```

irq是要申请的硬件中断号。

handler是向系统登记的中断处理函数（顶半部），是一个回调函数，中断发生时，系统调用这个函数，dev参数将被传递给它。

irqflags是中断处理的属性，可以指定中断的触发方式以及处理方式。在触发方式方面，可以是IRQF_TRIGGER_RISING、IRQF_TRIGGER_FALLING、IRQF_TRIGGER_HIGH、IRQF_TRIGGER_LOW等。在处理方式方面，若设置了IRQF_SHARED，则表示多个设备共享中断，dev是要传递给中断服务程序的私有数据，一般设置为这个设备的设备结构体或者NULL。

request_irq（）返回0表示成功，返回-EINVAL表示中断号无效或处理函数指针为NULL，返回-EBUSY表示中断已经被占用且不能共享。

```
int devm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,
                 unsigned long irqflags, const char *devname, void *dev_id);
```

此函数与request_irq（）的区别是devm_开头的API申请的是内核“managed”的资源，一般不需要在出错处理和remove（）接口里再显式的释放。有点类似Java的垃圾回收机制。比如，对于at86rf230驱动，如下的补丁中改用devm_request_irq（）后就删除了free_irq（），该补丁对应的内核commit ID是652355c5。

```
--- a/drivers/net/ieee802154/at86rf230.c
+++ b/drivers/net/ieee802154/at86rf230.c
@@ -1190,24+1190,22@@ static int at86rf230_probe(struct spi_device *spi)
     if (rc)
          goto err_hw_init;
-    rc = request_irq(spi->irq, irq_handler, IRQF_SHARED,
-               dev_name(&spi->dev), lp);
+    rc = devm_request_irq(&spi->dev, spi->irq, irq_handler, IRQF_SHARED,
+                    dev_name(&spi->dev), lp);
     if (rc)
         goto err_hw_init;
     /* Read irq status register to reset irq line */
     rc = at86rf230_read_subreg(lp, RG_IRQ_STATUS, 0xff, 0, &status);
     if (rc)
-        goto err_irq;
+        goto err_hw_init;
     rc = ieee802154_register_device(lp->dev);
     if (rc)
-        goto err_irq;
+        goto err_hw_init;
     return rc;
-err_irq:
-    free_irq(spi->irq, lp);
 err_hw_init:
     flush_work(&lp->irqwork);
     spi_set_drvdata(spi, NULL);
@@ -1232,7+1230,6@@ static int at86rf230_remove(struct spi_device *spi)
     at86rf230_write_subreg(lp, SR_IRQ_MASK, 0);
     ieee802154_unregister_device(lp->dev);
-    free_irq(spi->irq, lp);
     flush_work(&lp->irqwork);
     if (gpio_is_valid(pdata->slp_tr))
```

顶半部handler的类型irq_handler_t定义为：

```
typedef irqreturn_t (*irq_handler_t)(int, void *);
typedef int irqreturn_t;
```

2.释放irq

与request_irq（）相对应的函数为free_irq（），free_irq（）的原型为：

```
void free_irq(unsigned int irq,void *dev_id);
```

free_irq（）中参数的定义与request_irq（）相同。

# 10.3.2　使能和屏蔽中断

下列3个函数用于屏蔽一个中断源：

```
void disable_irq(int irq);
void disable_irq_nosync(int irq);
void enable_irq(int irq);
```

disable_irq_nosync（）与disable_irq（）的区别在于前者立即返回，而后者等待目前的中断处理完成。由于disable_irq（）会等待指定的中断被处理完，因此如果在n号中断的顶半部调用disable_irq（n），会引起系统的死锁，这种情况下，只能调用disable_irq_nosync（n）。

下列两个函数（或宏，具体实现依赖于CPU的体系结构）将屏蔽本CPU内的所有中断：

```
#define local_irq_save(flags) ...
void local_irq_disable(void);
```

前者会将目前的中断状态保留在flags中（注意flags为unsigned long类型，被直接传递，而不是通过指针），后者直接禁止中断而不保存状态。

与上述两个禁止中断对应的恢复中断的函数（或宏）是：

```
#define local_irq_restore(flags) ...
void local_irq_enable(void);
```

以上各以local_开头的方法的作用范围是本CPU内。

# 10.3.3　底半部机制

Linux实现底半部的机制主要有tasklet、工作队列、软中断和线程化irq。

1.tasklet

tasklet的使用较简单，它的执行上下文是软中断，执行时机通常是顶半部返回的时候。我们只需要定义tasklet及其处理函数，并将两者关联则可，例如：

```
void my_tasklet_func(unsigned long); /*定义一个处理函数*/
DECLARE_TASKLET(my_tasklet, my_tasklet_func, data);
  /*定义一个tasklet结构my_tasklet，与my_tasklet_func(data)函数相关联*/
```

代码DECLARE_TASKLET（my_tasklet，my_tasklet_func，data）实现了定义名称为my_tasklet的tasklet，并将其与my_tasklet_func（）这个函数绑定，而传入这个函数的参数为data。

在需要调度tasklet的时候引用一个tasklet_schedule（）函数就能使系统在适当的时候进行调度运行：

```
tasklet_schedule(&my_tasklet);
```

使用tasklet作为底半部处理中断的设备驱动程序模板如代码清单10.2所示（仅包含与中断相关的部分）。

代码清单10.2　tasklet使用模板

```
 1/* 定义tasklet和底半部函数并将它们关联 */
 2void xxx_do_tasklet(unsigned long);
 3DECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0);
 4
 5/* 中断处理底半部*/
 6void xxx_do_tasklet(unsigned long)
 7{
 8    ...
 9}
10
11/* 中断处理顶半部*/
12irqreturn_t xxx_interrupt(int irq, void *dev_id)
13{
14 ...
15 tasklet_schedule(&xxx_tasklet);
16 ...
17}
18
19/* 设备驱动模块加载函数*/
20int __init xxx_init(void)
21{
22 ...
23 /* 申请中断 */
24 result = request_irq(xxx_irq, xxx_interrupt,
25     0, "xxx", NULL);
26 ...
27 return IRQ_HANDLED;
28}
29
30/* 设备驱动模块卸载函数*/
31void __exit xxx_exit(void)
32{
33 ...
34 /* 释放中断*/
35 free_irq(xxx_irq, xxx_interrupt);
36 ...
37}
```

上述程序在模块加载函数中申请中断（第24~25行），并在模块卸载函数中释放它（第35行）。对应于xxx_irq的中断处理程序被设置为xxx_interrupt（）函数，在这个函数中，第15行的tasklet_schedule（&xxx_tasklet）调度被定义的tasklet函数xxx_do_tasklet（）在适当的时候执行。

2.工作队列

工作队列的使用方法和tasklet非常相似，但是工作队列的执行上下文是内核线程，因此可以调度和睡眠。下面的代码用于定义一个工作队列和一个底半部执行函数：

```
struct work_struct my_wq;                    /* 定义一个工作队列 */
void my_wq_func(struct work_struct *work);   /* 定义一个处理函数*/
```

通过INIT_WORK（）可以初始化这个工作队列并将工作队列与处理函数绑定：

```
INIT_WORK(&my_wq, my_wq_func);
  /* 初始化工作队列并将其与处理函数绑定*/
```

与tasklet_schedule（）对应的用于调度工作队列执行的函数为schedule_work（），如：

```
schedule_work(&my_wq);     /* 调度工作队列执行*/
```

与代码清单10.2对应的使用工作队列处理中断底半部的设备驱动程序模板如代码清单10.3所示（仅包含与中断相关的部分）。

代码清单10.3　工作队列使用模板

```
 1/* 定义工作队列和关联函数*/
 2struct work_struct xxx_wq;
 3void xxx_do_work(struct work_struct *work);
 4
 5/* 中断处理底半部*/
 6void xxx_do_work(struct work_struct *work)
 7{
 8 ...
 9}
10
11/*中断处理顶半部*/
12irqreturn_t xxx_interrupt(int irq, void *dev_id)
13{
14 ...
15 schedule_work(&xxx_wq);
16 ...
17 return IRQ_HANDLED;
18}
19
20/* 设备驱动模块加载函数*/
21int xxx_init(void)
22{
23 ...
24 /* 申请中断*/
25 result = request_irq(xxx_irq, xxx_interrupt,
26      0, "xxx", NULL);
27 ...
28 /* 初始化工作队列*/
29 INIT_WORK(&xxx_wq, xxx_do_work);
30 ...
31}
32
33/* 设备驱动模块卸载函数 */
34void xxx_exit(void)
35{
36 ...
37 /* 释放中断 */
38 free_irq(xxx_irq, xxx_interrupt);
39 ...
40}
```

与代码清单10.2不同的是，上述程序在设计驱动模块加载函数中增加了初始化工作队列的代码（第29行）。

工作队列早期的实现是在每个CPU核上创建一个worker内核线程，所有在这个核上调度的工作都在该worker线程中执行，其并发性显然差强人意。在Linux 2.6.36以后，转而实现了“Concurrency-managed workqueues”，简称cmwq，cmwq会自动维护工作队列的线程池以提高并发性，同时保持了API的向后兼容。

3.软中断

软中断（Softirq）也是一种传统的底半部处理机制，它的执行时机通常是顶半部返回的时候，tasklet是基于软中断实现的，因此也运行于软中断上下文。

在Linux内核中，用softirq_action结构体表征一个软中断，这个结构体包含软中断处理函数指针和传递给该函数的参数。使用open_softirq（）函数可以注册软中断对应的处理函数，而raise_softirq（）函数可以触发一个软中断。

软中断和tasklet运行于软中断上下文，仍然属于原子上下文的一种，而工作队列则运行于进程上下文。因此，在软中断和tasklet处理函数中不允许睡眠，而在工作队列处理函数中允许睡眠。

local_bh_disable（）和local_bh_enable（）是内核中用于禁止和使能软中断及tasklet底半部机制的函数。

内核中采用softirq的地方包括HI_SOFTIRQ、TIMER_SOFTIRQ、NET_TX_SOFTIRQ、NET_RX_SOFTIRQ、SCSI_SOFTIRQ、TASKLET_SOFTIRQ等，一般来说，驱动的编写者不会也不宜直接使用softirq。

第9章异步通知所基于的信号也类似于中断，现在，总结一下硬中断、软中断和信号的区别：硬中断是外部设备对CPU的中断，软中断是中断底半部的一种处理机制，而信号则是由内核（或其他进程）对某个进程的中断。在涉及系统调用的场合，人们也常说通过软中断（例如ARM为swi）陷入内核，此时软中断的概念是指由软件指令引发的中断，和我们这个地方说的softirq是两个完全不同的概念，一个是software，一个是soft。

需要特别说明的是，软中断以及基于软中断的tasklet如果在某段时间内大量出现的话，内核会把后续软中断放入ksoftirqd内核线程中执行。总的来说，中断优先级高于软中断，软中断又高于任何一个线程。软中断适度线程化，可以缓解高负载情况下系统的响应。

4.threaded_irq

在内核中，除了可以通过request_irq（）、devm_request_irq（）申请中断以外，还可以通过request_threaded_irq（）和devm_request_threaded_irq（）申请。这两个函数的原型为：

```
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
                     irq_handler_t thread_fn,
                     unsigned long flags, const char *name, void *dev);
int devm_request_threaded_irq(struct device *dev, unsigned int irq,
                          irq_handler_t handler, irq_handler_t thread_fn,
                          unsigned long irqflags, const char *devname,
                          void *dev_id);
```

由此可见，它们比request_irq（）、devm_request_irq（）多了一个参数thread_fn。用这两个API申请中断的时候，内核会为相应的中断号分配一个对应的内核线程。注意这个线程只针对这个中断号，如果其他中断也通过request_threaded_irq（）申请，自然会得到新的内核线程。

参数handler对应的函数执行于中断上下文，thread_fn参数对应的函数则执行于内核线程。如果handler结束的时候，返回值是IRQ_WAKE_THREAD，内核会调度对应线程执行thread_fn对应的函数。

request_threaded_irq（）和devm_request_threaded_irq（）支持在irqflags中设置IRQF_ONESHOT标记，这样内核会自动帮助我们在中断上下文中屏蔽对应的中断号，而在内核调度thread_fn执行后，重新使能该中断号。对于我们无法在上半部清除中断的情况，IRQF_ONESHOT特别有用，避免了中断服务程序一退出，中断就洪泛的情况。

handler参数可以设置为NULL，这种情况下，内核会用默认的irq_default_primary_handler（）代替handler，并会使用IRQF_ONESHOT标记。irq_default_primary_handler（）定义为：

```
/*
 * Default primary interrupt handler for threaded interrupts. Is
 * assigned as primary handler when request_threaded_irq is called
 * with handler == NULL. Useful for oneshot interrupts.
 */
static irqreturn_t irq_default_primary_handler(int irq, void *dev_id)
{
        return IRQ_WAKE_THREAD;
}
```

# 10.3.4　实例：GPIO按键的中断

drivers/input/keyboard/gpio_keys.c是一个放之四海皆准的GPIO按键驱动，为了让该驱动在特定的电路板上工作，通常只需要修改arch/arm/mach-xxx下的板文件或者修改device tree对应的dts。该驱动会为每个GPIO申请中断，在gpio_keys_setup_key（）函数中进行。注意最后一个参数bdata，会被传入中断服务程序。

代码清单10.4　GPIO按键驱动中断申请

```
 1static int gpio_keys_setup_key(struct platform_device *pdev,
 2                  struct input_dev *input,
 3                  struct gpio_button_data *bdata,
 4                  const struct gpio_keys_button *button)
 5{
 6  ...
 7
 8  error = request_any_context_irq(bdata->irq, isr, irqflags, desc, bdata);
 9  if (error < 0) {
10      dev_err(dev, "Unable to claim irq %d; error %d\n",
11          bdata->irq, error);
12      goto fail;
13  }
14  ...
15}
```

第8行的request_any_context_irq（）会根据GPIO控制器本身的“上级”中断是否为threaded_irq来决定采用request_irq（）还是request_threaded_irq（）。一组GPIO（如32个GPIO）虽然每个都提供一个中断，并且都有中断号，但是在硬件上一组GPIO通常是嵌套在上一级的中断控制器上的一个中断。

request_any_context_irq（）也有一个变体是devm_request_any_context_irq（）。

在GPIO按键驱动的remove_key（）函数中，会释放GPIO对应的中断，如代码清单10.5所示。

代码清单10.5　GPIO按键驱动中断释放

```
1static void gpio_remove_key(struct gpio_button_data *bdata)
2{
3    free_irq(bdata->irq, bdata);
4    if (bdata->timer_debounce)
5         del_timer_sync(&bdata->timer);
6    cancel_work_sync(&bdata->work);
7    if (gpio_is_valid(bdata->button->gpio))
8         gpio_free(bdata->button->gpio);
```

第3行直接从dev_id取出了bdata，这就是对应的那个GPIO键的数据结构，之后根据情况启动timer以进行debounce或者直接调度工作队列去汇报按键事件。在GPIO按键驱动初始化的时候，通过INIT_WORK（&bdata->work，gpio_keys_gpio_work_func）初始化了bdata->work，对应的处理函数是gpio_keys_gpio_work_func（），如代码清单10.7所示

代码清单10.7　GPIO按键驱动的工作队列底半部

```
 1static void gpio_keys_gpio_work_func(struct work_struct *work)
 2{
 3        struct gpio_button_data *bdata =
 4                container_of(work, struct gpio_button_data, work);
 5
 6        gpio_keys_gpio_report_event(bdata);
 7
 8        if (bdata->button->wakeup)
 9                pm_relax(bdata->input->dev.parent);
10}
```

观察其中的第3~4行，它通过container_of（）再次从work_struct反向解析出了bdata。原因是work_struct本身在定义时，就嵌入在gpio_button_data结构体内。读者朋友们应该掌握Linux的这种可以到处获取一个结构体指针的技巧，它实际上类似于面向对象里面的“this”指针。

```
struct gpio_button_data {
        const struct gpio_keys_button *button;
        struct input_dev *input;
        struct timer_list timer;
        struct work_struct work;
        unsigned int timer_debounce;    /* in msecs */
        unsigned int irq;
        spinlock_t lock;
        bool disabled;
        bool key_pressed;
};
```

