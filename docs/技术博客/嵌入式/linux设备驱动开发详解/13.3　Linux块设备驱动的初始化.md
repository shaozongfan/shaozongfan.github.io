在块设备的注册和初始化阶段，与字符设备驱动类似，块设备驱动要注册它们自己到内核，申请设备号，完成这个任务的函数是register_blkdev（），其原型为：

```
int register_blkdev(unsigned int major, const char *name);
```

major参数是块设备要使用的主设备号，name为设备名，它会显示在/proc/devices中。如果major为0，内核会自动分配一个新的主设备号，register_blkdev（）函数的返回值就是这个主设备号。如果register_blkdev（）返回一个负值，表明发生了一个错误。

与register_blkdev（）对应的注销函数是unregister_blkdev（），其原型为：

```
int unregister_blkdev(unsigned int major, const char *name);
```

这里，传递给register_blkdev（）的参数必须与传递给register_blkdev（）的参数匹配，否则这个函数返回-EINVAL。

除此之外，在块设备驱动初始化过程中，通常需要完成分配、初始化请求队列，绑定请求队列和请求处理函数的工作，并且可能会分配、初始化gendisk，给gendisk的major、fops、queue等成员赋值，最后添加gendisk。

代码清单13.6演示了一个典型的块设备驱动的初始化过程，其中包含了register_blkdev（）、blk_init_queue（）和add_disk（）的工作。

代码清单13.6　块设备驱动的初始化

```
 1static int xxx_init(void)
 2{
 3  /* 块设备驱动注册*/
 4  if (register_blkdev(XXX_MAJOR, "xxx")) {
 5    err =  -EIO;
 6    goto out;
 7  }
 8
 9  /* 请求队列初始化 */
10  xxx_queue = blk_init_queue(xxx_request, xxx_lock);
11  if (!xxx_queue)
12    goto out_queue;
13  blk_queue_max_hw_sectors(xxx_queue, 255);
14  blk_queue_logical_block_size(xxx_queue, 512);
15
16  /* gendisk初始化*/
17  xxx_disks->major = XXX_MAJOR;
18  xxx_disks->first_minor = 0;
19  xxx_disks->fops = &xxx_op;
20  xxx_disks->queue = xxx_queue;
21  sprintf(xxx_disks->disk_name, "xxx%d", i);
22  set_capacity(xxx_disks, xxx_size *2);
23  add_disk(xxx_disks); /* 添加gendisk */
24
25  return 0;
26  out_queue: unregister_blkdev(XXX_MAJOR, "xxx");
27  out: put_disk(xxx_disks);
28  blk_cleanup_queue(xxx_queue);
29
30  return  -ENOMEM;
31}
```

上述代码第13行的blk_queue_max_hw_sectors（）用于通知通用块层和I/O调度器该请求队列支持的每个请求中能够包含的最大扇区数，第14行blk_queue_logical_block_size（）则用于告知该请求队列的逻辑块大小。

在块设备驱动的卸载过程中完成与模块加载函数相反的工作。

1）清除请求队列，使用blk_cleanup_queue（）。

2）删除对gendisk的引用，使用put_disk（）。

3）删除对块设备的引用，注销块设备驱动，使用unregister_blkdev（）。