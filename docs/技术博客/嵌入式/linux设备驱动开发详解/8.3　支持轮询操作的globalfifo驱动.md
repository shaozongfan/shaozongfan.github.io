# 8.3.1　在globalfifo驱动中增加轮询操作

在globalfifo的poll（）函数中，首先将设备结构体中的r_wait和w_wait等待队列头部添加到等待列表中（意味着因调用select而阻塞的进程可以被r_wait和w_wait唤醒），然后通过判断dev->current_len是否等于0来获得设备的可读状态，通过判断dev->current_len是否等于GLOBALFIFO_SIZE来获得设备的可写状态，如代码清单8.9所示。

代码清单8.9　globalfifo设备驱动的poll（）函数

```
 1static unsigned int globalfifo_poll(struct file *filp, poll_table * wait)
 2{
 3  unsigned int mask = 0;
 4  struct globalfifo_dev *dev = filp->private_data;
 5
 6  mutex_lock(&dev->mutex);;
 7
 8  poll_wait(filp, &dev->r_wait, wait);
 9  poll_wait(filp, &dev->w_wait, wait);
10
11  if (dev->current_len != 0) {
12       mask |= POLLIN | POLLRDNORM;
13  }
14
15  if (dev->current_len != GLOBALFIFO_SIZE) {
16       mask |= POLLOUT | POLLWRNORM;
17  }
18
19  mutex_unlock(&dev->mutex);;
20  return mask;
21}
```

注意，要把globalfifo_poll赋给globalfifo_fops的poll成员：

```
static const struct file_operations globalfifo_fops = {
   ...
   .poll = globalfifo_poll,
   ...
};
```

# 8.3.2　在用户空间中验证globalfifo设备的轮询

编写一个应用程序globalfifo_poll.c，以用select（）监控globalfifo的可读写状态，这个程序如代码清单8.10所示。

代码清单8.10　使用select监控globalfifo是否可非阻塞读、写的应用程序

```
 1#define FIFO_CLEAR 0x1
 2#define BUFFER_LEN 20
 3void main(void)
 4{
 5  int fd, num;
 6  char rd_ch[BUFFER_LEN];
 7  fd_set rfds, wfds; /* 读/写文件描述符集 */
 8
 9  /* 以非阻塞方式打开/dev/globalfifo设备文件 */
10  fd = open("/dev/globalfifo", O_RDONLY | O_NONBLOCK);
11  if (fd != -1) {
12       /* FIFO清0 */
13       if (ioctl(fd, FIFO_CLEAR, 0) < 0)
14            printf("ioctl command failed\n");
15
16       while (1) {
17            FD_ZERO(&rfds);
18            FD_ZERO(&wfds);
19            FD_SET(fd, &rfds);
20            FD_SET(fd, &wfds);
21
22            select(fd + 1, &rfds, &wfds, NULL, NULL);
23            /* 数据可获得*/
24            if (FD_ISSET(fd, &rfds))
25                 printf("Poll monitor:can be read\n");
26            /* 数据可写入*/
27            if (FD_ISSET(fd, &wfds))
28                 printf("Poll monitor:can be written\n");
29       }
30  } else {
31       printf("Device open failure\n");
32  }
33}
```

在运行时可看到，当没有任何输入，即FIFO为空时，程序不断地输出Poll monitor：can be written，当通过echo向/dev/globalfifo写入一些数据后，将输出Poll monitor：can be read和Poll monitor：can be written，如果不断地通过echo向/dev/globalfifo写入数据直至写满FIFO，则发现pollmonitor程序将只输出Poll monitor：can be read。对于globalfifo而言，不会出现既不能读，又不能写的情况。

编写一个应用程序globalfifo_epoll.c，以用epoll监控globalfifo的可读状态，这个程序如代码清单8.11所示。

代码清单8.11　使用epoll监控globalfifo是否可非阻塞读的应用程序

```
 1#define FIFO_CLEAR 0x1
 2#define BUFFER_LEN 20
 3void main(void)
 4{
 5  int fd;
 6
 7  fd = open("/dev/globalfifo", O_RDONLY | O_NONBLOCK);
 8  if (fd != -1) {
 9       struct epoll_event ev_globalfifo;
10       int err;
11       int epfd;
12
13       if (ioctl(fd, FIFO_CLEAR, 0) < 0)
14            printf("ioctl command failed\n");
15
16       epfd = epoll_create(1);
17       if (epfd < 0) {
18            perror("epoll_create()");
19            return;
20       }
21
22       bzero(&ev_globalfifo, sizeof(struct epoll_event));
23       ev_globalfifo.events = EPOLLIN | EPOLLPRI;
24
25       err = epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev_globalfifo);
26       if (err < 0) {
27            perror("epoll_ctl()");
28            return;
29       }
30       err = epoll_wait(epfd, &ev_globalfifo, 1, 15000);
31       if (err < 0) {
32            perror("epoll_wait()");
33       } else if (err == 0) {
34            printf("No data input in FIFO within 15 seconds.\n");
35       } else {
36            printf("FIFO is not empty\n");
37       }
38       err = epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &ev_globalfifo);
39       if (err < 0)
40            perror("epoll_ctl()");
41  } else {
42       printf("Device open failure\n");
43  }
44}
```

上述程序第25行epoll_ctl（epfd，EPOLL_CTL_ADD，fd，&ev_globalfifo）将globalfifo对应的fd加入到了侦听的行列，第23行设置侦听读事件，第30行进行等待，若15秒内没有人写/dev/globalfifo，该程序会打印No data input in FIFO within 15seconds，否则程序会打印FIFO is not empty。