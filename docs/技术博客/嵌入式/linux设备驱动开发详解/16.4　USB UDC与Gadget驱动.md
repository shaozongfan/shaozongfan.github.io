# 16.4.1　UDC和Gadget驱动的关键数据结构与API

这里的USB设备控制器（UDC）驱动指的是作为其他USB主机控制器外设的USB硬件设备上底层硬件控制器的驱动，该硬件和驱动负责将一个USB设备依附于一个USB主机控制器上。例如，当某运行Linux系统的手机作为PC的U盘时，手机中的底层USB控制器行使USB设备控制器的功能，这时候运行在底层的是UDC驱动，而手机要成为U盘，在UDC驱动之上仍然需要另外一个驱动，对于USB大容量存储器而言，这个驱动为File Storage驱动，称为Function驱动。从图16.1左边可以看出，USB设备驱动调用USB核心的API，因此具体驱动与SoC无关；同样，从图16.1右边可以看出，Function驱动调用通用的Gadget Function API，因此具体Function驱动也变得与SoC无关。软件分层设计的好处再一次得到了深刻的体现

UDC驱动和Function驱动都位于内核的drivers/usb/gadget目录中，如drivers/usb/gadget/udc下面的fsl_mxc_udc.c、omap_udc.c、s3c2410_udc.c等是对应SoC平台上的UDC驱动，而drivers/usb/gadget/function子目录的f_serial.c、f_mass_storage.c、f_rndis.c等文件实现了一些Gadget功能，重要的Function驱动如下所示。

Ethernet over USB：该驱动模拟以太网网口，它支持多种运行方式—CDC Ethernet（实现标准的Communications Device Class"Ethernet Model"协议）、CDC Subset以及RNDIS（微软公司对CDC Ethernet的变种实现）。

File-Backed Storage Gadget：最常见的U盘功能实现。

Serial Gadget：包括Generic Serial实现（只需要Bulk-in/Bulk-out端点+ep0）和CDC ACM规范实现。内核源代码中的Documentation/usb/gadget_serial.txt文档讲解了如何将Serial Gadget与Windows和Linux主机连接。

Gadget MIDI：暴露ALSA MIDI接口。

USB Video Class Gadget驱动：让Linux系统成为另外一个系统的USB视频采集源

另外，drivers/usb/gadget源代码还实现了一个Gadget文件系统（GadgetFS），可以将Gadget API接口暴露给应用层，以便在应用层实现用户空间的驱动。

在USB设备控制器驱动中，我们主要关心几个核心的数据结构，这些数据结构包括描述一个USB设备控制器的usb_gadget、UDC操作usb_gadget_ops、描述一个端点的usb_ep以及描述端点操作的usb_ep_ops结构体。UDC驱动围绕这些数据结构及其成员函数而展开，代码清单16.30列出了这些关键的数据结构，它们都定义于include/linux/usb/gadget.h文件。

代码清单16.30　UDC驱动的关键数据结构

```
 1struct usb_gadget {
 2        struct work_struct              work;
 3        /* readonly to gadget driver    */
 4        const struct usb_gadget_ops       *ops;
 5        struct usb_ep                   *ep0;
 6        struct list_head                ep_list;        /* of usb_ep */
 7        enum usb_device_speed            speed;
 8        enum usb_device_speed            max_speed;
 9        enum usb_device_state            state;
10        const char                      *name;
11        struct device                   dev;
12        unsigned                       out_epnum;
13        unsigned                       in_epnum;
14
15        unsigned                       sg_supported:1;
16        unsigned                       is_otg:1;
17        unsigned                       is_a_peripheral:1;
18        unsigned                       b_hnp_enable:1;
19        unsigned                       a_hnp_support:1;
20        unsigned                       a_alt_hnp_support:1;
21        unsigned                       quirk_ep_out_aligned_size:1;
22        unsigned                       is_selfpowered:1;
23};
24
25struct usb_ep {
26        void                   *driver_data;
27
28        const char              *name;
29        const struct usb_ep_ops   *ops;
30        struct list_head        ep_list;
31        unsigned               maxpacket:16;
32        unsigned               maxpacket_limit:16;
33        unsigned               max_streams:16;
34        unsigned               mult:2;
35        unsigned               maxburst:5;
36        u8                    address;
37        const struct usb_endpoint_descriptor    *desc;
38        const struct usb_ss_ep_comp_descriptor  *comp_desc;
39};
40
41struct usb_gadget_ops {
42        int    (*get_frame)(struct usb_gadget *);
43        int    (*wakeup)(struct usb_gadget *);
44        int    (*set_selfpowered) (struct usb_gadget *, int is_selfpowered);
45        int    (*vbus_session) (struct usb_gadget *, int is_active);
46        int    (*vbus_draw) (struct usb_gadget *, unsigned mA);
47        int    (*pullup) (struct usb_gadget *, int is_on);
48        int    (*ioctl)(struct usb_gadget *,
49                            unsigned code, unsigned long param);
50        void   (*get_config_params)(struct usb_dcd_config_params *);
51        int    (*udc_start)(struct usb_gadget *,
52                     struct usb_gadget_driver *);
53        int    (*udc_stop)(struct usb_gadget *);
54};
55struct usb_ep_ops {
56        int (*enable) (struct usb_ep *ep,
57               const struct usb_endpoint_descriptor *desc);
58        int (*disable) (struct usb_ep *ep);
59
60        struct usb_request *(*alloc_request) (struct usb_ep *ep,
61               gfp_t gfp_flags);
62        void (*free_request) (struct usb_ep *ep, struct usb_request *req);
63
64        int (*queue) (struct usb_ep *ep, struct usb_request *req,
65               gfp_t gfp_flags);
66        int (*dequeue) (struct usb_ep *ep, struct usb_request *req);
67
68        int (*set_halt) (struct usb_ep *ep, int value);
69        int (*set_wedge) (struct usb_ep *ep);
70
71        int (*fifo_status) (struct usb_ep *ep);
72        void (*fifo_flush) (struct usb_ep *ep);
73};
```

在具体的UDC驱动中，需要封装usb_gadget和每个端点usb_ep，实现usb_gadget的usb_gadget_ops并实现端点的usb_ep_ops，完成usb_request。这些事情都搞定后，就可以注册一个UDC，它是通过usb_add_gadget_udc（）API来进行的，其原型为：

```
int usb_add_gadget_udc(struct device *parent, struct usb_gadget *gadget);
```

在注册UDC之前，我们需要先把usb_gadget这个结构体类的ep_list，即端点链表填充好，并填充好usb_gadget的usb_gadget_ops以及每个端点的usb_gadget_ops。

而Gadget的Function这边，则需要自己填充usb_interface_descriptor、usb_endpoint_descriptor，合成一些usb_descriptor_header，并实现usb_function结构体的成员函数，usb_function结构体定义于include/linux/usb/composite.h中，其形式如代码清单16.31所示。

代码清单16.31　usb_function结构体

```
 1struct usb_function {
 2   const char            *name;
 3   struct usb_gadget_strings  **strings;
 4   struct usb_descriptor_header   **fs_descriptors;
 5   struct usb_descriptor_header   **hs_descriptors;
 6   struct usb_descriptor_header   **ss_descriptors;
 7
 8   struct usb_configuration  *config;
 9
10   struct usb_os_desc_table  *os_desc_table;
11   unsigned                  os_desc_n;
12
13   /* configuration management:  bind/unbind */
14   int          (*bind)(struct usb_configuration *,
15                    struct usb_function *);
16   void         (*unbind)(struct usb_configuration *,
17                    struct usb_function *);
18   void         (*free_func)(struct usb_function *f);
19   struct module    *mod;
20
21   /* runtime state management */
22   int          (*set_alt)(struct usb_function *,
23                    unsigned interface, unsigned alt);
24   int          (*get_alt)(struct usb_function *,
25                    unsigned interface);
26   void         (*disable)(struct usb_function *);
27   int          (*setup)(struct usb_function *,
28                    const struct usb_ctrlrequest *);
29   void         (*suspend)(struct usb_function *);
30   void         (*resume)(struct usb_function *);
31
32   /* USB 3.0 additions */
33   int          (*get_status)(struct usb_function *);
34   int          (*func_suspend)(struct usb_function *,
35                        u8 suspend_opt);
36   /* private: */
37   /* internals */
38   struct list_head     list;
39   DECLARE_BITMAP(endpoints, 32);
40   const struct usb_function_instance *fi;
41};
```

第4行的fs_descriptors是全速和低速的描述符表；第5行的hs_descriptors是高速描述符表；ss_descriptors是超高速描述符。bind（）完成在Gadget注册时获取I/O缓冲、端点等资源。

在usb_function的成员函数以及各种描述符准备好后，在内核通过usb_function_register（）API来完成Gadget Function的注册，该API的原型为：

```
int usb_function_register(struct usb_function_driver *newf);
```

在Gadget驱动中，用usb_request结构体来描述一次传输请求，这个结构体的地位类似于USB主机侧的URB。usb_request结构体的定义如代码清单16.32所示。

代码清单16.32　usb_request结构体

```
 1struct usb_request {
 2        void                   *buf; /* Buffer used for data */
 3        unsigned               length;
 4        dma_addr_t             dma;  /* DMA address corresponding to 'buf' */
 5
 6        struct scatterlist       *sg; /* a scatterlist for SG-capable controllers */
 7        unsigned              num_sgs;
 8        unsigned              num_mapped_sgs;
 9
10        unsigned              stream_id:16;
11        unsigned              no_interrupt:1;
12        unsigned              zero:1;
13        unsigned              short_not_ok:1;
14
15        void                  (*complete)(struct usb_ep *ep,
16            struct usb_request *req);  /* Function called when request completes */
17        void                  *context;
18        struct list_head        list;
19
20        int                   status;
21        unsigned               actual;
22};
```

在include/linux/usb/gadget.h文件中，还封装了一些常用的API，以供Gadget Function驱动调用，从而便于它们操作端点，如下所示。

## （1）使能和禁止端点

```
static inline int usb_ep_enable(struct usb_ep *ep);
static inline int usb_ep_disable(struct usb_ep *ep);
```

它们分别调用了“ep->ops->enable（ep，desc）；”和“ep->ops->disable（ep）；”。

## （2）分配和释放usb_request

```
struct usb_request *alloc_ep_req(struct usb_ep *ep, int len, int default_len);
static inline struct usb_request *usb_ep_alloc_request(struct usb_ep *ep,
                                                       gfp_t gfp_flags);
static inline void usb_ep_free_request(struct usb_ep *ep,
                                       struct usb_request *req);
```

usb_ep_alloc_request（）和usb_ep_free_request（）分别调用了“ep->ops->alloc_request（ep，gfp_flags）；”和“ep->ops->free_request（ep，req）；”，以用于分配和释放一个依附于某端点的usb_request，而alloc_ep_req（）则是内嵌了对usb_ep_alloc_request（ep，GFP_ATOMIC）的调用，同时自动申请了usb_request的缓冲器的内存。

## （3）提交和取消usb_request

```
static inline int usb_ep_queue(struct usb_ep *ep,
                               struct usb_request *req, gfp_t gfp_flags);
static inline int usb_ep_dequeue(struct usb_ep *ep, struct usb_request *req);
```

## （4）端点FIFO管理

```
static inline int usb_ep_fifo_status(struct usb_ep *ep);
static inline void usb_ep_fifo_flush(struct usb_ep *ep);
```

前者调用“ep->ops->fifo_status（ep）”返回目前FIFO中的字节数，后者调用“ep->ops->fifo_flush（ep）”以冲刷掉FIFO中的数据。

## （5）端点自动配置

```
struct usb_ep *usb_ep_autoconfig(
      struct usb_gadget               *gadget,
      struct usb_endpoint_descriptor  *desc);
```

根据端点描述符及控制器端点情况，分配一个合适的端点。

# 16.4.2　实例：Chipidea USB UDC驱动

drivers/usb/chipidea/udc.c是Chipidea USB UDC驱动的主体代码，代码清单16.33列出了它的初始化流程部分。它定义了usb_ep_ops、usb_gadget_ops，在最终进行usb_add_gadget_udc（）之前填充好了UDC的端点列表。

代码清单16.33　Chipidea USB UDC驱动实例

```
 1static const struct usb_ep_ops usb_ep_ops = {
 2    .enable          = ep_enable,
 3    .disable       = ep_disable,
 4    .alloc_request  = ep_alloc_request,
 5    .free_request  = ep_free_request,
 6    .queue         = ep_queue,
 7    .dequeue      = ep_dequeue,
 8    .set_halt     = ep_set_halt,
 9    .set_wedge    = ep_set_wedge,
10    .fifo_flush   = ep_fifo_flush,
11};
12
13static const struct usb_gadget_ops usb_gadget_ops = {
14    .vbus_session= ci_udc_vbus_session,
15    .wakeup      = ci_udc_wakeup,
16    .set_selfpowered = ci_udc_selfpowered,
17    .pullup      = ci_udc_pullup,
18    .vbus_draw   = ci_udc_vbus_draw,
19    .udc_start   = ci_udc_start,
20    .udc_stop    = ci_udc_stop,
21};
22
23static int init_eps(struct ci_hdrc *ci)
24{
25    int retval = 0, i, j;
26
27    for (i = 0; i < ci->hw_ep_max/2; i++)
28        for (j = RX; j <= TX; j++) {
29            int k = i + j * ci->hw_ep_max/2;
30            struct ci_hw_ep *hwep = &ci->ci_hw_ep[k];
31
32            ...
33
34            hwep->ep.name      = hwep->name;
35            hwep->ep.ops       = &usb_ep_ops;
36
37            usb_ep_set_maxpacket_limit(&hwep->ep, (unsigned short)~0);
38
39            ...
40
41            /*
42             * set up shorthands for ep0 out and in endpoints,
43             * don't add to gadget's ep_list
44             */
45            if (i == 0) {
46                if (j == RX)
47                ci->ep0out = hwep;
48            else
49                ci->ep0in = hwep;
50
51            usb_ep_set_maxpacket_limit(&hwep->ep, CTRL_PAYLOAD_MAX);
52            continue;
53        }
54
55        list_add_tail(&hwep->ep.ep_list, &ci->gadget.ep_list);
56    }
57
58return retval;
59}
60
61static int udc_start(struct ci_hdrc *ci)
62{
63    ...
64    ci->gadget.ops    = &usb_gadget_ops;
65    ci->gadget.speed     = USB_SPEED_UNKNOWN;
66    ci->gadget.max_speed  = USB_SPEED_HIGH;
67    ci->gadget.is_otg    = ci->is_otg   1 : 0;
68    ci->gadget.name     = ci->platdata->name;
69
70    INIT_LIST_HEAD(&ci->gadget.ep_list);
71
72    ...
73
74    retval = init_eps(ci);
75    if (retval)
76        goto free_pools;
77
78    ci->gadget.ep0 = &ci->ep0in->ep;
79
80    retval = usb_add_gadget_udc(dev, &ci->gadget);
81    ...
82}
```

# 16.4.3　实例：Loopback Function驱动

drivers/usb/gadget/function/f_loopback.c实现了一个最简单的Loopback驱动，它完成的主要工作如下。

1）实现usb_function实例及其中的成员函数bind（）、set_alt（）、disable（）、free_func（）等成员函数。

2）准备USB外设的配置描述符接口描述符usb_interface_descriptor、端点描述符usb_endpoint_descriptor等。

3）发起usb_request处理usb_request的完成并回环。

代码清单16.34是抽取了drivers/usb/gadget/function/f_loopback.c文件中能反映一个Function驱动主体结构的少量代码。

代码清单16.34　Loopback USB Gadget Function驱动实例

```
  1static struct usb_interface_descriptor loopback_intf = {
  2        .bLength =            sizeof loopback_intf,
  3        .bDescriptorType =     USB_DT_INTERFACE,
  4
  5        .bNumEndpoints =       2,
  6        .bInterfaceClass =     USB_CLASS_VENDOR_SPEC,
  7        /* .iInterface = DYNAMIC */
  8};
  9
 10static struct usb_endpoint_descriptor fs_loop_source_desc = {
 11        .bLength =            USB_DT_ENDPOINT_SIZE,
 12        .bDescriptorType =     USB_DT_ENDPOINT,
 13
 14        .bEndpointAddress =    USB_DIR_IN,
 15        .bmAttributes =       USB_ENDPOINT_XFER_BULK,
 16};
 17static struct usb_descriptor_header *fs_loopback_descs[] = {
 18        (struct usb_descriptor_header *) &loopback_intf,
 19        (struct usb_descriptor_header *) &fs_loop_sink_desc,
 20        (struct usb_descriptor_header *) &fs_loop_source_desc,
 21        NULL,
 22};
 23static struct usb_string strings_loopback[] = {
 24        [0].s = "loop input to output",
 25        {  }                              /* end of list */
 26};
 27
 28static struct usb_gadget_strings stringtab_loop = {
 29        .language      = 0x0409,          /* en-us */
 30        .strings       = strings_loopback,
 31};
 32
 33static struct usb_gadget_strings *loopback_strings[] = {
 34        &stringtab_loop,
 35        NULL,
 36};
 37
 38static int loopback_bind(struct usb_configuration *c, struct usb_function *f)
 39{
 40...
 41loop->in_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_source_desc);
 42...
 43loop->out_ep = usb_ep_autoconfig(cdev->gadget, &fs_loop_sink_desc);
 44if (!loop->out_ep)
 45      goto autoconf_fail;
 46loop->out_ep->driver_data = cdev;/* claim */
 47
 48/* support high speed hardware */
 49hs_loop_source_desc.bEndpointAddress =
 50      fs_loop_source_desc.bEndpointAddress;
 51hs_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;
 52
 53/* support super speed hardware */
 54ss_loop_source_desc.bEndpointAddress =
 55      fs_loop_source_desc.bEndpointAddress;
 56ss_loop_sink_desc.bEndpointAddress = fs_loop_sink_desc.bEndpointAddress;
 57
 58ret = usb_assign_descriptors(f, fs_loopback_descs, hs_loopback_descs,
 59            ss_loopback_descs);
 60...
 61return 0;
 62}
 63
 64static void lb_free_func(struct usb_function *f)
 65{
 66...
 67usb_free_all_descriptors(f);
 68kfree(func_to_loop(f));
 69}
 70
 71static struct usb_function *loopback_alloc(struct usb_function_instance *fi)
 72{
 73       ...
 74       loop->function.name = "loopback";
 75       loop->function.bind = loopback_bind;
 76       loop->function.set_alt = loopback_set_alt;
 77       loop->function.disable = loopback_disable;
 78       loop->function.strings = loopback_strings;
 79
 80       loop->function.free_func = lb_free_func;
 81
 82       return &loop->function;
 83}
 84
 85static void loopback_complete(struct usb_ep *ep, struct usb_request *req)
 86{
 87...
 88}
 89
 90static int enable_endpoint(struct usb_composite_dev *cdev, struct f_loopback *loop,
 91                          struct usb_ep *ep)
 92{
 93struct usb_request           *req;
 94...
 95result = config_ep_by_speed(cdev->gadget, &(loop->function), ep);
 96
 97result = usb_ep_enable(ep);
 98
 99ep->driver_data = loop;
100
101for (i = 0; i < qlen && result == 0; i++) {
102      req = lb_alloc_ep_req(ep, 0);
103      if (!req)
104          goto fail1;
105
106      req->complete = loopback_complete;
107      result = usb_ep_queue(ep, req, GFP_ATOMIC);
108      if (result) {
109          ERROR(cdev, "%s queue req --> %d\n",
110                  ep->name, result);
111          goto fail1;
112      }
113}
114
115...
116}
```

