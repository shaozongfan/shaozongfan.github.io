在嵌入式系统中，为调试Linux应用程序，可在目标板上先运行GDBServer，再让主机上的GDB与目标板上的GDBServer通过网口或串口通信。

# 1.目标板

需要运行如下命令启动GDBServer：

```
gdbserver <host_ip>:<port> <app>
```

<host_ip>：port为主机的IP地址和端口，app是可执行的应用程序名。

当然，也可以用系统中空闲的串口作为GDB调试器和GDBServer的底层通信手段，如：

```
gdbserver/dev/ttyS0./tdemo
```

# 2.主机

需要先运行如下命令启动GDB：

```
arm-eabi-gdb <app>
```

app与GDBServer的app参数对应。

之后，运行如下命令就可以连接目标板：

```
target remote <target_ip>:<port>
```

<target_ip>：< port>为目标机的IP地址和端口。

如果目标板上的GDBServer使用串口，则在宿主机上GDB也应该使用串口，如：

```
(gdb)target remote/dev/ttyS1
```

之后，便可以使用GDB像调试本机上的程序一样调试目标机上的程序。

# 3.通过GDB server和ARM GDB调试应用程序

在ARM开发板上放置GDB server，便可以通过目标板与调试PC之间的以太网等调试。要调试的应用程序的源代码如下：

```
/*
* gdb_example.c: program to show how to use arm-linux-gdb
*/
void increase_one(int *data)
{    *data = *data + 1;
}
int main(int argc, char *argv[])
{    int dat = 0;
     int *p = 0;
     increase_one(&dat);
     /* program will crash here */
     increase_one(p);
     return 0;
}
```

通过debug方式编译它：

```
arm-linux-gnueabi-gcc -g -o gdb_example gdb_example.c
```

将程序下载到目标板后，在目标板上运行：

```
# gdbserver 192.168.1.20:1234 gdb_example
Process gdb_example created; pid = 1096
Listening on port 1234
```

其中192.168.1.20为目标板的3IP，1234为GDBserver的侦听端口。

如果目标机是Android系统，且没有以太网，可以尝试使用adb forward功能，比如adb forward tcp：1234tcp：1234是把目标机1234端口与主机1234端口进行转发。

在主机上运行：

```
$ arm-eabi-gdb gdb_example…
```

主机的GDB中运行如下命令以连接目标板：

```
(gdb) target remote 192.168.1.20:1234
Remote debugging using 192.168.1.20:1234
...
0x400007b0 in ??  ()
```

如果是Android的adb forward，则上述target remote 192.168.1.20：1234中的IP地址可以去掉，因为它变成直接连接本机了，可直接写成target remote：1234。

运行如下命令将断点设置在increase_one（&dat）；这一行：

```
(gdb) b gdb_example.c:16
Breakpoint 1 at 0x8390: file gdb_example.c, line 16.
```

通过c命令继续运行目标板上的程序，发生断点：

```
(gdb) c
Continuing.
...
Breakpoint 1, main (argc=1, argv=0xbead4eb4) at gdb_example.c:16
16increase_one(&dat);
```

运行n命令执行完increase_one（&dat）；再查看dat的值：

```
(gdb) n
19increase_one(p); (gdb) p dat
$1 = 1
```

发现dat变成1。继续运行c命令，由于即将访问空指针，gdb_example将崩溃：

```
 (gdb) c
Continuing.
Program received signal SIGSEGV, Segmentation fault.
0x0000834c in increase_one (data=0x0) at gdb_example.c:8
8*data = *data + 1;
```

我们通过bt命令可以拿到backtrace：

```
(gdb) bt
#0  0x0000834c in increase_one (data=0x0) at gdb_example.c:8
#1  0x000083a4 in main (argc=1, argv=0xbead4eb4) at gdb_example.c:19
```

通过info reg命令可以查看当时的寄存器值：

```
(gdb) info reg
r00x0 0
r10xbead4eb43199028916
r20x1 1
r30x0 0
r40x4001e5e01073866208
r50x0 0
r60x826c33388
r70x0 0
r80x0 0
r90x0 0
r10 0x400250001073893376
r11 0xbead4d443199028548
r12 0xbead4d483199028552
sp 0xbead4d300xbead4d30
lr 0x83a433700
pc 0x834c0x834c <increase_one+24>
fps 0x0 0
cpsr 0x600000101610612752
```

