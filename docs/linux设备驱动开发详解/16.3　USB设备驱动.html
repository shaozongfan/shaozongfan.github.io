<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-linux设备驱动开发详解/16.3　USB设备驱动">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.21">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="蒲城小农的文字世界 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="蒲城小农的文字世界 Atom Feed"><title data-rh="true">16.3.1　USB设备驱动的整体结构 | 蒲城小农的文字世界</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://shaozongfan.github.io/docs/linux设备驱动开发详解/16.3　USB设备驱动"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="16.3.1　USB设备驱动的整体结构 | 蒲城小农的文字世界"><meta data-rh="true" name="description" content="这里所说的USB设备驱动指的是从主机角度来看，怎样访问被插入的USB设备，而不是指USB设备内部本身运行的固件程序。Linux系统实现了几类通用的USB设备驱动（也称客户驱动），划分为如下几个设备类。"><meta data-rh="true" property="og:description" content="这里所说的USB设备驱动指的是从主机角度来看，怎样访问被插入的USB设备，而不是指USB设备内部本身运行的固件程序。Linux系统实现了几类通用的USB设备驱动（也称客户驱动），划分为如下几个设备类。"><link data-rh="true" rel="canonical" href="https://shaozongfan.github.io/docs/linux设备驱动开发详解/16.3　USB设备驱动"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/linux设备驱动开发详解/16.3　USB设备驱动" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://shaozongfan.github.io/docs/linux设备驱动开发详解/16.3　USB设备驱动" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.ccca8cd0.css">
<link rel="preload" href="/assets/js/runtime~main.1c06d183.js" as="script">
<link rel="preload" href="/assets/js/main.63ebc7ad.js" as="script">
</head>
<body class="navigation-with-keyboard" data-theme="light">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_fXgn">跳到主要内容</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">蒲城小农的文字世界</b></a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="dsla-search-wrapper"><div class="dsla-search-field" data-tags="default,docs-default-current"></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_BCFX"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/AI相关/AI核心技能">AI相关</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">docs/intro.md</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" aria-expanded="true" href="/docs/linux设备驱动开发详解/1.1　设备驱动的作用">linux设备驱动开发详解</a></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/1.1　设备驱动的作用">1.1　设备驱动的作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/1.2　无操作系统时的设备驱动">1.2　无操作系统时的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/1.3　有操作系统时的设备驱动">1.3　有操作系统时的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/1.4　Linux设备驱动">1.4.1　设备的分类及特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/1.6　设备驱动Hello World：LED驱动">1.6.1　无操作系统时的LED驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.1　中断与定时器">10.1　中断与定时器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.2　Linux中断处理程序架构">10.2　Linux中断处理程序架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.3　Linux中断编程">10.3.1　申请和释放中断</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.4　中断共享">10.4　中断共享</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.5　内核定时器">10.5.1　内核定时器编程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.6　内核延时">10.6.1　短延迟</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/10.7　总结">10.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.1　CPU与内存、IO">11.1.1　内存空间与I/O空间</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.2　Linux内存管理">11.2　Linux内存管理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.3　内存存取">11.3.1　用户空间内存动态申请</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.4　设备IO端口和IO内存的访问">11.4　设备IO端口和IO内存的访问</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.5　IO内存静态映射">11.5　IO内存静态映射</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.6　DMA">11.6　DMA</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/11.7　总结">11.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/12.1　Linux驱动的软件架构">12.1　Linux驱动的软件架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/12.2　platform设备驱动">12.2.1　platform总线、设备与驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/12.3　设备驱动的分层思想">12.3.1　设备驱动核心层和例化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/12.4　主机驱动与外设驱动分离的设计思想">12.4.1　主机驱动与外设驱动分离</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.1　块设备的IO操作特点">13.1　块设备的IO操作特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.2　Linux块设备驱动结构">13.2.1　block_device_operations结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.3　Linux块设备驱动的初始化">13.3　Linux块设备驱动的初始化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.4　块设备的打开与释放">13.4　块设备的打开与释放</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.5　块设备驱动的ioctl函数">13.5　块设备驱动的ioctl函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.6　块设备驱动的IO请求处理">13.6.1　使用请求队列</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.7　实例：vmem_disk驱动">13.7.1　vmem_disk的硬件原理</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.8　Linux MMC子系统">13.8　Linux MMC子系统</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/13.9　总结">13.9　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.10　总结">14.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.1　Linux网络设备驱动的结构">14.1　Linux网络设备驱动的结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.2　网络设备驱动的注册与注销">14.2　网络设备驱动的注册与注销</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.3　网络设备的初始化">14.3　网络设备的初始化</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.4　网络设备的打开与释放">14.4　网络设备的打开与释放</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.5　数据发送流程">14.5　数据发送流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.6　数据接收流程">14.6　数据接收流程</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.7　网络连接状态">14.7　网络连接状态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.8　参数设置和统计数据">14.8　参数设置和统计数据</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/14.9　DM9000网卡设备驱动实例">14.9.1　DM9000网卡硬件描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.1　Linux I2 C体系结构">15.1　Linux I2 C体系结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.2　Linux I2 C核心">15.2　Linux I2 C核心</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.3　Linux I2 C适配器驱动">15.3.1　I2 C适配器驱动的注册与注销</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.4　Linux I2 C设备驱动">15.4　Linux I2 C设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.5　Tegra I2 C总线驱动实例">15.5　Tegra I2 C总线驱动实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.6　AT24xx EEPROM的I2 C设备驱动实例">15.6　AT24xx EEPROM的I2 C设备驱动实例</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/15.7　总结">15.7　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/16.1　Linux USB驱动层次">16.1.1　主机侧与设备侧USB驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/16.2　USB主机控制器驱动">16.2.1　USB主机控制器驱动的整体结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/linux设备驱动开发详解/16.3　USB设备驱动">16.3.1　USB设备驱动的整体结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动">16.4.1　UDC和Gadget驱动的关键数据结构与API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/16.5　USB OTG驱动">16.5　USB OTG驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/16.6　总结">16.6　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/17.1　I2 C、SPI、USB驱动架构">17.1　I2 C、SPI、USB驱动架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/17.2　I2 C主机和外设眼里的Linux世界">17.2　I2 C主机和外设眼里的Linux世界</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/18.1　ARM设备树起源">18.1　ARM设备树起源</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/18.2　设备树的组成和结构">18.2　设备树的组成和结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/18.3　由设备树引发的BSP和驱动变更">18.3　由设备树引发的BSP和驱动变更</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/18.4　常用的OF API">18.4　常用的OF API</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/18.5　总结">18.5　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.10　运行时的PM">19.10　运行时的PM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.11　总结">19.11　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.1　Linux电源管理的全局架构">19.1　Linux电源管理的全局架构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.2　CPUFreq驱动">19.2　CPUFreq驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.3　CPUIdle驱动">19.3　CPUIdle驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.4　PowerTop">19.4　PowerTop</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.5　Regulator驱动">19.5　Regulator驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.6　OPP">19.6　OPP</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.7　PM QoS">19.7　PM QoS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.8　CPU热插拔">19.8　CPU热插拔</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/19.9　挂起到RAM">19.9　挂起到RAM</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.1　处理器">2.1.1　通用处理器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.2　存储器">2.2　存储器</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.3　接口与总线">2.3.1　串口</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.4　CPLD和FPGA">2.4　CPLD和FPGA</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.5　原理图分析">2.5　原理图分析</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.6　硬件时序分析">2.6.1　时序分析的概念</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.7　芯片数据手册阅读方法">2.7　芯片数据手册阅读方法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/2.8　仪器仪表使用">2.8.1　万用表</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.10　总结">20.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.1　ARM Linux底层驱动的组成和现状">20.1　ARM Linux底层驱动的组成和现状</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.2　内核节拍驱动">20.2　内核节拍驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.3　中断控制器驱动">20.3　中断控制器驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.4　SMP多核启动以及CPU热插拔驱动">20.4　SMP多核启动以及CPU热插拔驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.5　DEBUG_LL和EARLY_PRINTK的设置">20.5　DEBUG_LL和EARLY_PRINTK的设置</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.6　GPIO驱动">20.6　GPIO驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.7　pinctrl驱动">20.7　pinctrl驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.8　时钟驱动">20.8　时钟驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/20.9　dmaengine驱动">20.9　dmaengine驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.10　使用仿真器调试内核">21.10　使用仿真器调试内核</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.11　应用程序调试">21.11　应用程序调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.12　Linux性能监控与调优工具">21.12　Linux性能监控与调优工具</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.13　总结">21.13　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.1　GDB调试器的用法">21.1.1　GDB的基本用法</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.2　Linux内核调试">21.2　Linux内核调试</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.3　内核打印信息—printk（​）">21.3　内核打印信息—printk（​）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.4　DEBUG_LL和EARLY_PRINTK">21.4　DEBUG_LL和EARLY_PRINTK</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.5　使用“proc”">21.5　使用“proc”</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.6　Oops">21.6　Oops</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.7　BUG_ON（​）和WARN_ON（​）">21.7　BUG_ON（​）和WARN_ON（​）</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.8　strace">21.8　strace</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/21.9　KGDB">21.9　KGDB</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/3.1　Linux内核的发展与演变">3.1　Linux内核的发展与演变</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/3.2　Linux 2.6后的内核特点">3.2　Linux 2.6后的内核特点</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/3.3　Linux内核的组成">3.3.1　Linux内核源代码的目录结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/3.4　Linux内核的的编译及加载">3.4.3　Linux内核的引导</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/3.5　Linux下的C编程特点">3.5.1　Linux编码风格</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/3.6　工具链">3.6　工具链</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.10　使用模块“绕开”GPL">4.10　使用模块“绕开”GPL</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.1　Linux内核模块简介">4.1　Linux内核模块简介</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.2　Linux内核模块程序结构">4.2　Linux内核模块程序结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.3　模块加载函数">4.3　模块加载函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.4　模块卸载函数">4.4　模块卸载函数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.5　模块参数">4.5　模块参数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.6　导出符号">4.6　导出符号</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.7　模块声明与描述">4.7　模块声明与描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.8　模块的使用计数">4.8　模块的使用计数</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/4.9　模块的编译">4.9　模块的编译</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/5.1　Linux文件操作">5.1.1　文件操作系统调用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/5.2　Linux文件系统">5.2.1　Linux文件系统目录结构</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/5.3　devfs">5.3　devfs</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/5.4　udev用户空间设备管理">5.4.1　udev与devfs的区别</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/6.1　Linux字符设备驱动结构">6.1.1　cdev结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/6.2　globalmem虚拟设备实例描述">6.2　globalmem虚拟设备实例描述</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/6.3　globalmem设备驱动">6.3.1　头文件、宏及设备结构体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.10　总结">7.10　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.1　并发与竞态">7.1　并发与竞态</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.2　编译乱序和执行乱序">7.2　编译乱序和执行乱序</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.3　中断屏蔽">7.3　中断屏蔽</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.4　原子操作">7.4　原子操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.5　自旋锁">7.5.1　自旋锁的使用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.6　信号量">7.6　信号量</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.7　互斥体">7.7　互斥体</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.8　完成量">7.8　完成量</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/7.9　增加并发控制后的globalmem的设备驱动">7.9　增加并发控制后的globalmem的设备驱动</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/8.1　阻塞与非阻塞IO">8.1　阻塞与非阻塞IO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/8.2　轮询操作">8.2.1　轮询的概念与作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/8.3　支持轮询操作的globalfifo驱动">8.3.1　在globalfifo驱动中增加轮询操作</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/8.4　总结">8.4　总结</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/9.1　异步通知的概念与作用">9.1　异步通知的概念与作用</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/9.2　Linux异步通知编程">9.2.1　Linux信号</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/9.3　支持异步通知的globalfifo驱动">9.3.1　在globalfifo驱动中增加异步通知</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/9.4　Linux异步IO">9.4.1　AIO概念与GNU C库AIO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/linux设备驱动开发详解/9.5　总结">9.5　总结</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人博客/docusaurus2.4">个人博客</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/个人生活/2025国家生育政策8大补贴汇总">个人生活</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/人生哲学/人生的底层逻辑">人生哲学</a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs">笔记本开篇序言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/奔跑吧linux/arm64体系结构编程与实践/A64指令集其他重要指令面试题">奔跑吧linux</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/奔跑吧linux内核（第2版）卷1：基础架构/第1章　处理器架构">奔跑吧linux内核（第2版）卷1：基础架构</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/网络/网络问题">网络</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/调试/Linux内核追踪神器：perf实现原理剖析">调试</a></div></li></ul></nav></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_GujU"><div class="docItemContainer_Adtb"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">linux设备驱动开发详解</span><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">16.3.1　USB设备驱动的整体结构</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_aoJ5"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>16.3.1　USB设备驱动的整体结构</h1><p>这里所说的USB设备驱动指的是从主机角度来看，怎样访问被插入的USB设备，而不是指USB设备内部本身运行的固件程序。Linux系统实现了几类通用的USB设备驱动（也称客户驱动），划分为如下几个设备类。</p><ul><li>·音频设备类。</li><li>·通信设备类。</li><li>·HID（人机接口）设备类。</li><li>·显示设备类。</li><li>·海量存储设备类。</li><li>·电源设备类。</li><li>·打印设备类。</li><li>·集线器设备类。</li></ul><p>一般的通用Linux设备（如U盘、USB鼠标、USB键盘等）都不需要工程师再编写驱动，而工程师需要编写的是特定厂商、特定芯片的驱动，而且往往也可以参考已经在内核中提供的驱动模板。</p><p>Linux内核为各类USB设备分配了相应的设备号，如ACM USB调制解调器的主设备号为166（默认设备名/dev/ttyACMn）、USB打印机的主设备号为180，次设备号为0~15（默认设备名/dev/lpn）、USB串口的主设备号为188（默认设备名/dev/ttyUSBn）等，详见<a href="http://www.lanana.org/" target="_blank" rel="noopener noreferrer">http://www.lanana.org/</a> 网站的设备列表。</p><p>在debugfs下，/sys/kernel/debug/usb/devices包含了USB的设备信息，在Ubuntu上插入一个U盘后，我们在/sys/kernel/debug/usb/devices中可看到类似信息。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">$ sudo cat /sys/kernel/debug/usb/devices</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T:  Bus=02 Lev=00 Prnt=00 Port=00 Cnt=00 Dev#=  1 Spd=12   MxCh= 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">B:  Alloc=  2/900 us ( 0%), #Int=  1, #Iso=  0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">D:  Ver= 1.10 Cls=09(hub  ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">P:  Vendor=1d6b ProdID=0001 Rev= 4.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Manufacturer=Linux 4.0.0-rc1 ohci_hcd</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Product=OHCI PCI host controller</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  SerialNumber=0000:00:06.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">C:* #Ifs= 1 Cfg#= 1 Atr=e0 MxPwr=  0mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I:* If#= 0 Alt= 0 #EPs= 1 Cls=09(hub  ) Sub=00 Prot=00 Driver=hub</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=81(I) Atr=03(Int.) MxPS=   2 Ivl=255ms…</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">T:  Bus=01 Lev=01 Prnt=01 Port=00 Cnt=01 Dev#=  2 Spd=480  MxCh= 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">D:  Ver= 2.10 Cls=00(&gt;ifc ) Sub=00 Prot=00 MxPS=64 #Cfgs=  1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">P:  Vendor=0930 ProdID=6545 Rev= 1.00</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Manufacturer=Kingston</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  Product=DataTraveler 3.0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">S:  SerialNumber=60A44C3FAE22EEA0797900F7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">C:* #Ifs= 1 Cfg#= 1 Atr=80 MxPwr=498mA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">I:* If#= 0 Alt= 0 #EPs= 2 Cls=08(stor.) Sub=06 Prot=50 Driver=usb-storage</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=81(I) Atr=02(Bulk) MxPS= 512 Ivl=0ms</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">E:  Ad=02(O) Atr=02(Bulk) MxPS= 512 Ivl=0ms</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过分析上述记录信息，可以得到系统中USB的完整信息。USBView（<a href="http://www.kroah.com/linux-usb/" target="_blank" rel="noopener noreferrer">http://www.kroah.com/linux-usb/</a> ）是一个图形化的GTK工具，可以显示USB信息。</p><p>此外，在sysfs文件系统中，同样包含了USB相关信息的描述，但只限于接口级别。USB设备和USB接口在sysfs中均表示为单独的USB设备，其目录命名规则如下：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">根集线器</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-集线器端口号（</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-集线器端口号</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-...）</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">:配置</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">.接口</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>下面给出一个/sys/bus/usb目录下的树形结构实例，其中的多数文件都是锚定到/sys/devices及/sys/drivers中相应文件的链接。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> devices│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-0:1.0 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-1 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-1:1.0 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1/1-1:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-0:1.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2/2-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-1 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2/2-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-1:1.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2/2-1/2-1:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb1 -&gt; ../../../devices/pci0000:00/0000:00:0b.0/usb1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb2 -&gt; ../../../devices/pci0000:00/0000:00:06.0/usb2├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> drivers│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> hub│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-0:1.0 -&gt; ../../../../devices/pci0000:00/0000:00:0b.0/usb1/1-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-0:1.0 -&gt; ../../../../devices/pci0000:00/0000:00:06.0/usb2/2-0:1.0│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> module -&gt; ../../../../module/usbcore│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> new_id│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> remove_id│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uevent│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unbind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 1-1 -&gt; ../../../../devices/pci0000:00/0000:00:0b.0/usb1/1-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2-1 -&gt; ../../../../devices/pci0000:00/0000:00:06.0/usb2/2-1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> bind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> uevent│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unbind│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   ├──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb1 -&gt; ../../../../devices/pci0000:00/0000:00:0b.0/usb1│</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   │</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">   └──</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb2 -&gt; ../../../../devices/pci0000:00/0000:00:06.0/usb2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>正如tty_driver、i2c_driver等，在Linux内核中，使用usb_driver结构体描述一个USB设备驱动，usb_driver结构体的定义如代码清单16.11所示。</p><p>代码清单16.11　usb_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        const char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        int (*probe) (struct usb_interface *intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                    const struct usb_device_id *id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        void (*disconnect) (struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        int (*unlocked_ioctl) (struct usb_interface *intf, unsigned int code,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                     void *buf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        int (*suspend) (struct usb_interface *intf, pm_message_t message);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int (*resume) (struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        int (*reset_resume)(struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int (*pre_reset)(struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        int (*post_reset)(struct usb_interface *intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        const struct usb_device_id *id_table;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        struct usb_dynids dynids;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        struct usbdrv_wrap drvwrap;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        unsigned int no_dynamic_id:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        unsigned int supports_autosuspend:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        unsigned int disable_hub_initiated_lpm:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        unsigned int soft_unbind:1;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在编写新的USB设备驱动时，主要应该完成的工作是probe（）和disconnect（）函数，即探测和断开函数，它们分别在设备被插入和拔出的时候调用，用于初始化和释放软硬件资源。对usb_driver的注册和注销可通过下面两个函数完成：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register(struct usb_driver *new_driver)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">void usb_deregister(struct usb_driver *driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_driver结构体中的id_table成员描述了这个USB驱动所支持的USB设备列表，它指向一个usb_device_id数组，usb_device_id结构体包含有USB设备的制造商ID、产品ID、产品版本、设备类、接口类等信息及其要匹配标志成员match_flags（标明要与哪些成员匹配，包含DEV_LO、DEV_HI、DEV_CLASS、DEV_SUBCLASS、DEV_PROTOCOL、INT_CLASS、INT_SUBCLASS、INT_PROTOCOL）。可以借助下面一组宏来生成usb_device_id结构体的实例：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_DEVICE(vendor, product)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏根据制造商ID和产品ID生成一个usb_device_id结构体的实例，在数组中增加该元素将意味着该驱动可支持与制造商ID、产品ID匹配的设备。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_DEVICE_VER(vendor, product, lo, hi)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏根据制造商ID、产品ID、产品版本的最小值和最大值生成一个usb_device_id结构体的实例，在数组中增加该元素将意味着该驱动可支持与制造商ID、产品ID匹配和lo~hi范围内版本的设备。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_DEVICE_INFO(class, subclass, protocol)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏用于创建一个匹配设备指定类型的usb_device_id结构体实例。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">USB_INTERFACE_INFO(class, subclass, protocol)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该宏用于创建一个匹配接口指定类型的usb_device_id结构体实例。</p><p>代码清单16.12所示为两个用于描述某USB驱动支持的USB设备的usb_device_id结构体数组实例。</p><p>代码清单16.12　usb_device_id结构体数组实例</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1/* 本驱动支持的USB设备列表*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3/* 实例1 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4static struct usb_device_id id_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   { USB_DEVICE(VENDOR_ID, PRODUCT_ID) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8MODULE_DEVICE_TABLE (usb, id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10/* 实例2 */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11static struct usb_device_id id_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   { .idVendor = 0x10D2, .match_flags = USB_DEVICE_ID_MATCH_VENDOR, },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   { },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15MODULE_DEVICE_TABLE (usb, id_table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当USB核心检测到某个设备的属性和某个驱动程序的usb_device_id结构体所携带的信息一致时，这个驱动程序的probe（）函数就被执行（如果这个USB驱动是个模块的话，相关的.ko还应被Linux自动加载）。拔掉设备或者卸掉驱动模块后，USB核心就执行disconnect（）函数来响应这个动作。</p><p>上述usb_driver结构体中的函数是USB设备驱动中与USB相关的部分，而USB只是一个总线，USB设备驱动真正的主体工作仍然是USB设备本身所属类型的驱动，如字符设备、tty设备、块设备、输入设备等。因此USB设备驱动包含其作为总线上挂接设备的驱动和本身所属设备类型的驱动两部分。</p><p>与platform_driver、i2c_driver类似，usb_driver起到了“牵线”的作用，即在probe（）里注册相应的字符、tty等设备，在disconnect（）注销相应的字符、tty等设备，而原先对设备的注册和注销一般直接发生在模块加载和卸载函数中。</p><p>尽管USB本身所属设备驱动的结构与其挂不挂在USB总线上没什么关系，但是据此在访问方式上却有很大的变化，例如，对于USB接口的字符设备而言，尽管仍然是write（）、read（）、ioctl（）这些函数，但是在这些函数中，贯穿始终的是称为URB的USB请求块。</p><p>如图16.3所示，在这棵树里，我们把树根比作主机控制器，树叶比作具体的USB设备，树干和树枝就是USB总线。树叶本身与树枝通过usb_driver连接，而树叶本身的驱动（读写、控制）则需要通过其树叶设备本身所属类设备驱动来完成。树根和树叶之间的“通信”依靠在树干和树枝里“流淌”的URB来完成。</p><p><img loading="lazy" alt="1745247374129" src="/assets/images/1745247374129-31e34ded71baa9955f6b54aa9479649f.png" width="1402" height="1039" class="img_ev3q"></p><p>图16.3　USB设备驱动结构</p><p>由此可见，usb_driver本身只是有找到USB设备、管理USB设备连接和断开的作用，也就是说，它是公司入口处的“打卡机”，可以获得员工（USB设备）的上/下班情况。树叶和员工一样，可以是研发工程师也可以是销售工程师，而作为USB设备的树叶可以是字符树叶、网络树叶或块树叶，因此必须实现相应设备类的驱动。</p><h1>16.3.2　USB请求块</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="1urb结构体">1.urb结构体<a class="hash-link" href="#1urb结构体" title="标题的直接链接">​</a></h2><p>USB请求块（USB Request Block，URB）是USB设备驱动中用来描述与USB设备通信所用的基本载体和核心数据结构，非常类似于网络设备驱动中的sk_buff结构体。</p><p>代码清单16.13　URB结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct urb {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        /* public: documented fields in the urb that can be used by drivers */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct list_head urb_list;      /* list head for use by the urb&#x27;s</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                                      * current owner */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        struct usb_host_endpoint *ep;   /* (internal) pointer to endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        unsigned int pipe;              /* (in) pipe information */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        unsigned int stream_id;         /* (in) stream ID */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        int status;                     /* (return) non-ISO status */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        unsigned int transfer_flags;    /* (in) URB_SHORT_NOT_OK | ...*/</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        void *transfer_buffer;          /* (in) associated data buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        dma_addr_t transfer_dma;        /* (in) dma addr for transfer_buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        struct scatterlist *sg;         /* (in) scatter gather buffer list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        int num_mapped_sgs;             /* (internal) mapped sg entries */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        int num_sgs;                    /* (in) number of entries in the sg list */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        u32 transfer_buffer_length;     /* (in) data buffer length */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        u32 actual_length;              /* (return) actual transfer length */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        unsigned char *setup_packet;    /* (in) setup packet (control only) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        dma_addr_t setup_dma;           /* (in) dma addr for setup_packet */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        int start_frame;                /* (modify) start frame (ISO) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        int number_of_packets;          /* (in) number of ISO packets */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        int interval;                   /* (modify) transfer interval</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                                       * (INT/ISO) */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25        int error_count;                /* (return) number of ISO errors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        void *context;                  /* (in) context for completion */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27        usb_complete_t complete;        /* (in) completion routine */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28        struct usb_iso_packet_descriptor iso_frame_desc[0];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29                                        /* (in) ISO ONLY */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2urb处理流程">2.URB处理流程<a class="hash-link" href="#2urb处理流程" title="标题的直接链接">​</a></h2><p>USB设备中的每个端点都处理一个URB队列，在队列被清空之前，一个URB的典型生命周期如下。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1被一个usb设备驱动创建">1）被一个USB设备驱动创建。<a class="hash-link" href="#1被一个usb设备驱动创建" title="标题的直接链接">​</a></h3><p>创建URB结构体的函数为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">struct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>iso_packets是这个URB应当包含的等时数据包的数目，若为0表示不创建等时数据包。mem_flags参数是分配内存的标志，和kmalloc（）函数的分配标志参数含义相同。如果分配成功，该函数返回一个URB结构体指针，否则返回0。</p><p>URB结构体在驱动中不宜静态创建，因为这可能破坏USB核心给URB使用的引用计数方法。</p><p>usb_alloc_urb（）的“反函数”为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_free_urb(struct urb *urb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于释放由usb_alloc_urb（）分配的URB结构体。</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_free_urb(struct urb *urb);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>该函数用于释放由usb_alloc_urb（）分配的URB结构体。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2初始化被安排给一个特定usb设备的特定端点">2）初始化，被安排给一个特定USB设备的特定端点。<a class="hash-link" href="#2初始化被安排给一个特定usb设备的特定端点" title="标题的直接链接">​</a></h3><p>对于中断URB，使用usb_fill_int_urb（）函数来初始化URB，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_fill_int_urb(struct urb *urb, struct usb_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unsigned int pipe, void *transfer_buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> int buffer_length, usb_complete_t complete,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void *context, int interval);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>URB参数指向要被初始化的URB的指针；dev指向这个URB要被发送到的USB设备；pipe是这个URB要被发送到的USB设备的特定端点；transfer_buffer是指向发送数据或接收数据的缓冲区的指针，和URB一样，它也不能是静态缓冲区，必须使用kmalloc（）来分配；buffer_length是transfer_buffer指针所指向缓冲区的大小；complete指针指向当这个URB完成时被调用的完成处理函数；context是完成处理函数的“上下文”；interval是这个URB应当被调度的间隔。</p><p>上述函数参数中的pipe使用usb_sndintpipe（）或usb_rcvintpipe（）创建。</p><p>对于批量URB，使用usb_fill_bulk_urb（）函数来初始化，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_fill_bulk_urb(struct urb *urb, struct usb_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unsigned int pipe, void *transfer_buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> int buffer_length, usb_complete_t complete,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void *context);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了没有对应于调度间隔的interval参数以外，该函数的参数和usb_fill_int_urb（）函数的参数含义相同。</p><p>上述函数参数中的pipe使用usb_sndbulkpipe（）或者usb_rcvbulkpipe（）函数来创建。</p><p>对于控制URB，使用usb_fill_control_urb（）函数来初始化，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_fill_control_urb(struct urb *urb, struct usb_device *dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> unsigned int pipe, unsigned char *setup_packet,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> void *transfer_buffer, int buffer_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> usb_complete_t complete, void *context);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>除了增加了新的setup_packet参数以外，该函数的参数和usb_fill_bulk_urb（）函数的参数含义相同。setup_packet参数指向即将被发送到端点的设置数据包。</p><p>上述函数参数中的pipe使用usb_sndctrlpipe（）或usb_rcvictrlpipe（）函数来创建。</p><p>等时URB没有像中断、控制和批量URB的初始化函数usb_fill_iso_urb（），我们只能手动对它初始化，而后才能提交给USB核心。代码清单16.14给出了初始化等时URB的例子，它来自drivers/media/usb/uvc/uvc_video.c文件。</p><p>代码清单16.14　初始化等时URB</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1        for (i = 0; i &lt; UVC_URBS; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2               urb = usb_alloc_urb(npackets, gfp_flags);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3               if (urb == NULL) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4                      uvc_uninit_video(stream, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5                      return -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6               }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8               urb-&gt;dev = stream-&gt;dev-&gt;udev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               urb-&gt;context = stream;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10               urb-&gt;pipe = usb_rcvisocpipe(stream-&gt;dev-&gt;udev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                                 ep-&gt;desc.bEndpointAddress);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12#ifndef CONfiG_DMA_NONCOHERENT</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13               urb-&gt;transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14               urb-&gt;transfer_dma = stream-&gt;urb_dma[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15#else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16               urb-&gt;transfer_flags = URB_ISO_ASAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17#endif</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18               urb-&gt;interval = ep-&gt;desc.bInterval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19               urb-&gt;transfer_buffer = stream-&gt;urb_buffer[i];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20               urb-&gt;complete = uvc_video_complete;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21               urb-&gt;number_of_packets = npackets;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22               urb-&gt;transfer_buffer_length = size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24               for (j = 0; j &lt; npackets; ++j) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25                      urb-&gt;iso_frame_desc[j].offset = j * psize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26                      urb-&gt;iso_frame_desc[j].length = psize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27               }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29               stream-&gt;urb[i] = urb;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30        }</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="3被usb设备驱动提交给usb核心">3）被USB设备驱动提交给USB核心。<a class="hash-link" href="#3被usb设备驱动提交给usb核心" title="标题的直接链接">​</a></h3><p>在完成第1）、2）步的创建和初始化URB后，URB便可以提交给USB核心了，可通过usb_submit_urb（）函数来完成，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_submit_urb(struct urb *urb, gfp_t mem_flags);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>URB参数是指向URB的指针，mem_flags参数与传递给kmalloc（）函数参数的意义相同，它用于告知USB核心如何在此时分配内存缓冲区。</p><p>在提交URB到USB核心后，直到完成函数被调用之前，不要访问URB中的任何成员。</p><p>usb_submit_urb（）在原子上下文和进程上下文中都可以被调用，mem_flags变量需根据调用环境进行相应的设置，如下所示。</p><ul><li>·GFP_ATOMIC：在中断处理函数、底半部、tasklet、定时器处理函数以及URB完成函数中，在调用者持有自旋锁或者读写锁时以及当驱动将current-&gt;state修改为非TASK_RUNNING时，应使用此标志。</li><li>·GFP_NOIO：在存储设备的块I/O和错误处理路径中，应使用此标志；</li><li>·GFP_KERNEL：如果没有任何理由使用GFP_ATOMIC和GFP_NOIO，就使用GFP_KERNEL。</li></ul><p>如果usb_submit_urb（）调用成功，即URB的控制权被移交给USB核心，该函数返回0；否则，返回错误号。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="4提交由usb核心指定的usb主机控制器驱动">4）提交由USB核心指定的USB主机控制器驱动。<a class="hash-link" href="#4提交由usb核心指定的usb主机控制器驱动" title="标题的直接链接">​</a></h3><h3 class="anchor anchorWithStickyNavbar_LWe7" id="5被usb主机控制器处理进行一次到usb设备的传送">5）被USB主机控制器处理，进行一次到USB设备的传送。<a class="hash-link" href="#5被usb主机控制器处理进行一次到usb设备的传送" title="标题的直接链接">​</a></h3><p>第4）~5）步由USB核心和主机控制器完成，不受USB设备驱动的控制。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="6当urb完成usb主机控制器驱动通知usb设备驱动">6）当URB完成，USB主机控制器驱动通知USB设备驱动。<a class="hash-link" href="#6当urb完成usb主机控制器驱动通知usb设备驱动" title="标题的直接链接">​</a></h3><p>在如下3种情况下，URB将结束，URB完成回调函数将被调用（完成回调是通过usb_fill_xxx_urb的参数传入的）。在完成回调中，我们通常要进行urb-&gt;status的判断。</p><ul><li>·URB被成功发送给设备，并且设备返回正确的确认。如果urb-&gt;status为0，意味着对于一个输出URB，数据被成功发送；对于一个输入URB，请求的数据被成功收到。</li><li>·如果发送数据到设备或从设备接收数据时发生了错误，urb-&gt;status将记录错误值。</li><li>·URB被从USB核心“去除连接”，这发生在驱动通过usb_unlink_urb（）或usb_kill_urb（）函数取消或URB虽已提交而USB设备被拔出的情况下</li></ul><p>usb_unlink_urb（）和usb_kill_urb（）这两个函数用于取消已提交的URB，其参数为要被取消的URB指针。usb_unlink_urb（）是异步的，搞定后对应的完成回调会被调用；而usb_kill_urb（）会彻底终止URB的生命周期并等待这一行为，它通常在设备的disconnect（）函数中被调用。</p><p>当URB生命结束时（处理完成或被解除链接），在URB的完成回调中通过URB结构体的status成员可以获知其原因，如0表示传输成功，-ENOENT表示被usb_kill_urb（）杀死，-ECONNRESET表示被usb_unlink_urb（）杀死，-EPROTO表示传输中发生了bitstuff错误或者硬件未能及时收到响应数据包，-ENODEV表示USB设备已被移除，-EXDEV表示等时传输仅完成了一部分等。</p><p>对以上URB的处理步骤进行一个总结，图16.4给出了一个URB的完整处理流程，虚线框的usb_unlink_urb（）和usb_kill_urb（）并不一定会发生，它们只是在URB正在被USB核心和主机控制器处理时又被驱动程序取消的情况下才发生。</p><p><img loading="lazy" alt="1745247828456" src="/assets/images/1745247828456-9341f4f96bfe430b601dc646a057ffe5.png" width="994" height="664" class="img_ev3q"></p><p>图16.4　URB处理流程</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="3简单的批量与控制urb">3.简单的批量与控制URB<a class="hash-link" href="#3简单的批量与控制urb" title="标题的直接链接">​</a></h2><p>有时USB驱动程序只是从USB设备上接收或向USB设备发送一些简单的数据，这时候，没有必要将URB创建、初始化、提交、完成处理的整个流程走一遍，而可以使用两个更简单的函数，如下所示。</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1usb_bulk_msg">（1）usb_bulk_msg（）<a class="hash-link" href="#1usb_bulk_msg" title="标题的直接链接">​</a></h3><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 void *data, int len, int *actual_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                 int timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_dev参数为批量消息要发送的USB设备的指针，pipe为批量消息要发送到的USB设备的端点，data参数为指向要发送或接收的数据缓冲区的指针，len参数为data参数所指向的缓冲区的长度，actual_length用于返回实际发送或接收的字节数，timeout是发送超时，以jiffies为单位，0意味着永远等待。</p><p>如果函数调用成功，返回0；否则，返回1个负的错误值</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="2usb_control_msg函数">（2）usb_control_msg（）函数<a class="hash-link" href="#2usb_control_msg函数" title="标题的直接链接">​</a></h2><p>usb_control_msg（）函数与usb_bulk_msg（）函数类似，不过它提供给驱动发送和结束USB控制信息而不是批量信息的能力，该函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    __u8 requesttype, __u16 value, __u16 index, void *data,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                    __u16 size, int timeout);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>dev指向控制消息发往的USB设备，pipe是控制消息要发往的USB设备的端点，request是这个控制消息的USB请求值，requesttype是这个控制消息的USB请求类型，value是这个控制消息的USB消息值，index是这个控制消息的USB消息索引值，data指向要发送或接收的数据缓冲区，size是data参数所指向的缓冲区的大小，timeout是发送超时，以毫秒为单位，0意味着永远等待。</p><p>参数request、requesttype、value和index与USB规范中定义的USB控制消息直接对应。</p><p>如果函数调用成功，该函数返回发送到设备或从设备接收到的字节数；否则，返回一个负的错误值。</p><p>对usb_bulk_msg（）和usb_control_msg（）函数的使用要特别慎重，由于它们是同步的，因此不能在中断上下文和持有自旋锁的情况下使用。而且，该函数也不能被任何其他函数取消，因此，务必要使得驱动程序的disconnect（）函数掌握足够的信息，以判断和等待该调用的结束。</p><h1>16.3.3　探测和断开函数</h1><p>在USB设备驱动usb_driver结构体的probe（）函数中，应该完成如下工作。</p><ul><li>·探测设备的端点地址、缓冲区大小，初始化任何可能用于控制USB设备的数据结构。</li><li>·把已初始化的数据结构的指针保存到接口设备中。</li></ul><p>usb_set_intfdata（）函数可以设置usb_interface的私有数据，这个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_set_intfdata (struct usb_interface *intf, void *data);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>这个函数的“反函数”用于得到usb_interface的私有数据，其原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void *usb_get_intfdata (struct usb_interface *intf);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><ul><li>·注册USB设备。</li></ul><p>如果是简单的字符设备，则可调用usb_register_dev（），这个函数的原型为：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">int usb_register_dev(struct usb_interface *intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                     struct usb_class_driver *class_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>上述函数中的第二个参数为usb_class_driver结构体，这个结构体的定义如代码清单16.15所示</p><p>代码清单16.15　usb_class_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_class_driver {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        char *name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        char *(*devnode)(struct device *dev, umode_t *mode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        const struct file_operations *fops;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int minor_base;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于字符设备而言，usb_class_driver结构体的fops成员中的write（）、read（）、ioctl（）等函数的地位完全等同于本书第6章中的file_operations成员函数。</p><p>如果是其他类型的设备，如tty设备，则调用对应设备的注册函数。</p><p>在USB设备驱动usb_driver结构体的probe（）函数中，应该完成如下工作。</p><ul><li>·释放所有为设备分配的资源。</li><li>·设置接口设备的数据指针为NULL。</li><li>·注销USB设备。</li></ul><p>对于字符设备，可以直接调用usb_register_dev（）函数的“反函数”，如下所示：</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">void usb_deregister_dev(struct usb_interface *intf,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        struct usb_class_driver *class_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对于其他类型的设备，如tty设备，则调用对应设备的注销函数。</p><h1>16.3.4　USB骨架程序</h1><p>Linux内核源代码中的driver/usb/usb-skeleton.c文件为我们提供了一个最基础的USB驱动程序，即USB骨架程序，它可被看作一个最简单的USB设备驱动实例。尽管具体的USB设备驱动千差万别，但其骨架则万变不离其宗</p><p>首先看看USB骨架程序的usb_driver结构体定义，如代码清单16.16所示。</p><p>代码清单16.16　USB骨架程序的usb_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_driver skel_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .name =         &quot;skeleton&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        .probe =        skel_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        .disconnect =   skel_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        .suspend =      skel_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .resume =       skel_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .pre_reset =    skel_pre_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .post_reset =   skel_post_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        .id_table =     skel_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .supports_autosuspend = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从上述代码第9行可以看出，它所支持的USB设备的列表数组为skel_table[]，其定义如代码清单16.17所示。</p><p>代码清单16.17　USB骨架程序的id_table</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_device_id skel_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2    { USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3    { }                  /* Terminating entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5MODULE_DEVICE_TABLE(usb, skel_table);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>对上述usb_driver的注册和注销发生在USB骨架程序的模块加载与卸载函数内，其分别调用了usb_register（）和usb_deregister（），不过这个注册和注销的代码却不用写出来，直接用一个快捷宏module_usb_driver即可，如代码清单16.18所示。</p><p>代码清单16.18　USB骨架程序的模块加载</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_driver skel_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .name =        &quot;skeleton&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        .probe =       skel_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        .disconnect =   skel_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        .suspend =     skel_suspend,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .resume =      skel_resume,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .pre_reset =    skel_pre_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .post_reset =   skel_post_reset,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        .id_table =     skel_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .supports_autosuspend = 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13module_usb_driver(skel_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在usb_driver的probe（）成员函数中，会根据usb_interface的成员寻找第一个批量输入和输出端点，将端点地址、缓冲区等信息存入为USB骨架程序定义的usb_skel结构体中，并将usb_skel实例的指针传入usb_set_intfdata（）中以作为USB接口的私有数据，最后，它会注册USB设备，如代码清单16.19所示。</p><p>代码清单16.19　USB骨架程序的probe（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int skel_probe(struct usb_interface *interface,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2            const struct usb_device_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   struct usb_host_interface *iface_desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   struct usb_endpoint_descriptor *endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   size_t buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8   int i;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9   int retval = -ENOMEM;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11   /* allocate memory for our device state and initialize it */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14   kref_init(&amp;dev-&gt;kref);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15   sema_init(&amp;dev-&gt;limit_sem, WRITES_IN_FLIGHT);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16   mutex_init(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17   spin_lock_init(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18   init_usb_anchor(&amp;dev-&gt;submitted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19   init_waitqueue_head(&amp;dev-&gt;bulk_in_wait);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21   dev-&gt;udev = usb_get_dev(interface_to_usbdev(interface));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22   dev-&gt;interface = interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24   /* set up the endpoint information */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25   /* use only the first bulk-in and bulk-out endpoints */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   iface_desc = interface-&gt;cur_altsetting;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27   for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; ++i) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28       endpoint = &amp;iface_desc-&gt;endpoint[i].desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30       if (!dev-&gt;bulk_in_endpointAddr &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31          usb_endpoint_is_bulk_in(endpoint)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32           /* we found a bulk in endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33           buffer_size = usb_endpoint_maxp(endpoint);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34           dev-&gt;bulk_in_size = buffer_size;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35           dev-&gt;bulk_in_endpointAddr = endpoint-&gt;bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36           dev-&gt;bulk_in_buffer = kmalloc(buffer_size, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37           ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38           dev-&gt;bulk_in_urb = usb_alloc_urb(0, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39           ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42       if (!dev-&gt;bulk_out_endpointAddr &amp;&amp;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43          usb_endpoint_is_bulk_out(endpoint)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44           /* we found a bulk out endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45           dev-&gt;bulk_out_endpointAddr = endpoint-&gt;bEndpointAddress;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50   /* save our data pointer in this interface device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51   usb_set_intfdata(interface, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53   /* we can register the device now, as it is ready */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54   retval = usb_register_dev(interface, &amp;skel_class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56   return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>usb_skel结构体可以被看作是一个私有数据结构体，其定义如代码清单16.20所示，应该根据具体的设备量身定制。</p><p>代码清单16.20　USB骨架程序的自定义数据结构usb_skel</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1struct usb_skel {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        struct usb_device      *udev;         /* the usb device for this device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_interface   *interface;    /* the interface for this device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct semaphore limit_sem;    /* limiting the number of writes in progress */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        struct usb_anchor submitted;   /* in case we need to retract our submissions */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        struct urb  *bulk_in_urb;             /* the urb to read data with */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        unsigned char  *bulk_in_buffer;       /* the buffer to receive data */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        size_t bulk_in_size;                  /* the size of the receive buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        size_t  bulk_in_filled;               /* number of bytes in the buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        size_t   bulk_in_copied;              /* already copied to user space */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        __u8 bulk_in_endpointAddr;         /* the address of the bulk in endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        __u8  bulk_out_endpointAddr;        /* the address of the bulk out endpoint */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        int                  errors;          /* the last request tanked */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        bool                 ongoing_read;    /* a read is going on */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        spinlock_t            err_lock;       /* lock for errors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        struct kref           kref;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        struct mutex          io_mutex;       /* synchronize I/O with disconnect */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18        wait_queue_head_t      bulk_in_wait;     /* to wait for an ongoing read */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>USB骨架程序的断开函数会完成与probe（）函数相反的工作，即设置接口数据为NULL，注销USB设备，如代码清单16.21所示。</p><p>代码清单16.21　USB骨架程序的断开函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void skel_disconnect(struct usb_interface *interface)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        int minor = interface-&gt;minor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        dev = usb_get_intfdata(interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        usb_set_intfdata(interface, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9        /* give back our minor */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        usb_deregister_dev(interface, &amp;skel_class);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        /* prevent more I/O from starting */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        mutex_lock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14        dev-&gt;interface = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        mutex_unlock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17        usb_kill_anchored_urbs(&amp;dev-&gt;submitted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        /* decrement our usage count */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        kref_put(&amp;dev-&gt;kref, skel_delete);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        dev_info(&amp;interface-&gt;dev, &quot;USB Skeleton #%d now disconnected&quot;, minor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>代码清单16.19第54行usb_register_dev（interface，&amp;skel_class）中的第二个参数包含了字符设备的file_operations结构体指针，而这个结构体中的成员实现也是USB字符设备的另一个组成成分。代码清单16.22给出了USB骨架程序的字符设备文件操作file_operations结构体的定义。</p><p>代码清单16.22　USB骨架程序的字符设备文件操作结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static const struct file_operations skel_fops = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        .owner =       THIS_MODULE,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        .read =        skel_read,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        .write =       skel_write,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        .open =        skel_open,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        .release =     skel_release,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        .flush =        skel_flush,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        .llseek =      noop_llseek,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9};</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于只是一个象征性的骨架程序，open（）成员函数的实现非常简单，它根据usb_driver和次设备号通过usb_find_interface（）获得USB接口，之后通过usb_get_intfdata（）获得接口的私有数据并赋予file-&gt;private_data，如代码清单16.23所示。</p><p>代码清单16.23　USB骨架程序的字符设备open（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int skel_open(struct inode *inode, struct file *file)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        struct usb_interface *interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        int subminor;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6        int retval = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        subminor = iminor(inode);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        interface = usb_find_interface(&amp;skel_driver, subminor);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        dev = usb_get_intfdata(interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15        retval = usb_autopm_get_interface(interface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16        if (retval)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17               goto exit;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        /* increment our usage count for the device */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20        kref_get(&amp;dev-&gt;kref);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        /* save our object in the file&#x27;s private structure */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23        file-&gt;private_data = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25exit:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26        return retval;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>由于在open（）函数中并没有申请任何软件和硬件资源，所以与open（）函数对应的release（）函数不用进行资源的释放，而只需进行减少在open（）中增加的引用计数等工作。</p><p>接下来要分析的是读写函数，前面已经提到，在访问USB设备的时候，贯穿其中的“中枢神经”是URB结构体。</p><p>在skel_write（）函数中进行的关于URB的操作与16.3.2小节的描述完全对应，即进行了URB的分配（调用usb_alloc_urb（））、初始化（调用usb_fill_bulk_urb（））和提交（调用usb_submit_urb（））的操作，如代码清单16.24所示。</p><p>代码清单16.24　USB骨架程序的字符设备写函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static ssize_t skel_write(struct file *file, const char *user_buffer,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2               size_t count, loff_t *ppos)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    int retval = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    struct urb *urb = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    char *buf = NULL;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    size_t writesize = min(count, (size_t)MAX_TRANSFER);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    dev = file-&gt;private_data;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    spin_lock_irq(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13    retval = dev-&gt;errors;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    spin_unlock_irq(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    /* create a urb, and a buffer for it, and copy the data to the urb */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19    urb = usb_alloc_urb(0, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20 ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22    buf = usb_alloc_coherent(dev-&gt;udev, writesize, GFP_KERNEL,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                    &amp;urb-&gt;transfer_dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26    if (copy_from_user(buf, user_buffer, writesize)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27         retval = -EFAULT;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28         goto error;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    /* this lock makes sure we don&#x27;t submit URBs to gone devices */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32    mutex_lock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35    /* initialize the urb properly */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36    usb_fill_bulk_urb(urb, dev-&gt;udev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37               usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38               buf, writesize, skel_write_bulk_callback, dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40    usb_anchor_urb(urb, &amp;dev-&gt;submitted);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42    /* send the data out the bulk port */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43    retval = usb_submit_urb(urb, GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44    mutex_unlock(&amp;dev-&gt;io_mutex);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    usb_free_urb(urb);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48    return writesize;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在写函数中发起的URB结束后，第38行填入的完成函数skel_write_bulk_callback（）将被调用，它会进行urb-&gt;status的判断，如代码清单16.25所示。</p><p>代码清单16.25　USB骨架程序的字符设备写操作完成函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void skel_write_bulk_callback(struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3        struct usb_skel *dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5        dev = urb-&gt;context;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7        /* sync/async unlink faults aren&#x27;t errors */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8        if (urb-&gt;status) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9               if (!(urb-&gt;status == -ENOENT ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10                   urb-&gt;status == -ECONNRESET ||</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11                   urb-&gt;status == -ESHUTDOWN))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12                      dev_err(&amp;dev-&gt;interface-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13                            &quot;%s - nonzero write bulk status received: %d\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                            __func__, urb-&gt;status);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16               spin_lock(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17               dev-&gt;errors = urb-&gt;status;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18               spin_unlock(&amp;dev-&gt;err_lock);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        /* free up our allocated buffer */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22        usb_free_coherent(urb-&gt;dev, urb-&gt;transfer_buffer_length,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                      urb-&gt;transfer_buffer, urb-&gt;transfer_dma);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24        up(&amp;dev-&gt;limit_sem);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h1>16.3.5　实例：USB键盘驱动</h1><p>在Linux系统中，键盘被认定为标准输入设备，对于一个USB键盘而言，其驱动主要由两部分组成：usb_driver的成员函数以及输入设备驱动的input_event获取和报告。</p><p>在USB键盘设备驱动的模块加载和卸载函数中，将分别注册和注销对应于USB键盘的usb_driver结构体usb_kbd_driver，代码清单16.26所示为模块加载与卸载函数以及usb_driver结构体的定义。</p><p>代码清单16.26　USB键盘设备驱动的模块加载与卸载函数以及usb_driver结构体</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static struct usb_device_id usb_kbd_id_table [] = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2        { USB_INTERFACE_INFO(USB_INTERFACE_CLASS_HID, USB_INTERFACE_SUBCLASS_BOOT,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3               USB_INTERFACE_PROTOCOL_KEYBOARD) },</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4        { }                                      /* Terminating entry */</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7MODULE_DEVICE_TABLE (usb, usb_kbd_id_table);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9static struct usb_driver usb_kbd_driver = {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        .name =        &quot;usbkbd&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11        .probe =       usb_kbd_probe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12        .disconnect =   usb_kbd_disconnect,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13        .id_table =    usb_kbd_id_table,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14};</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16module_usb_driver(usb_kbd_driver);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在usb_driver的probe（）函数中，将进行输入设备的初始化和注册，USB键盘要使用的中断URB和控制URB的初始化，并设置接口的私有数据，如代码清单16.27所示。</p><p>代码清单16.27　USB键盘设备驱动的probe（）函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static int usb_kbd_probe(struct usb_interface *iface,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2             const struct usb_device_id *id)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4    struct usb_device *dev = interface_to_usbdev(iface);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5    struct usb_host_interface *interface;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6    struct usb_endpoint_descriptor *endpoint;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7    struct usb_kbd *kbd;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8    struct input_dev *input_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10    interface = iface-&gt;cur_altsetting;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12    endpoint = &amp;interface-&gt;endpoint[0].desc;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14    pipe = usb_rcvintpipe(dev, endpoint-&gt;bEndpointAddress);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15    maxp = usb_maxpacket(dev, pipe, usb_pipeout(pipe));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17    kbd = kzalloc(sizeof(struct usb_kbd), GFP_KERNEL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18    input_dev = input_allocate_device();</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20    if (usb_kbd_alloc_mem(dev, kbd))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21        goto fail2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23    kbd-&gt;usbdev = dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24    kbd-&gt;dev = input_dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26    usb_make_path(dev, kbd-&gt;phys, sizeof(kbd-&gt;phys));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27    strlcat(kbd-&gt;phys, &quot;/input0&quot;, sizeof(kbd-&gt;phys));</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29    input_dev-&gt;name = kbd-&gt;name;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30    input_dev-&gt;phys = kbd-&gt;phys;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31    usb_to_input_id(dev, &amp;input_dev-&gt;id);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">32    input_dev-&gt;dev.parent = &amp;iface-&gt;dev;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">33</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">34    input_set_drvdata(input_dev, kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">35</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">36    input_dev-&gt;evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_LED) |</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">37        BIT_MASK(EV_REP);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">38    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">39    input_dev-&gt;event = usb_kbd_event;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">40    input_dev-&gt;open = usb_kbd_open;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">41    input_dev-&gt;close = usb_kbd_close;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">42</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">43    usb_fill_int_urb(kbd-&gt;irq, dev, pipe,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">44              kbd-&gt;new, (maxp &gt; 8   8 : maxp),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">45              usb_kbd_irq, kbd, endpoint-&gt;bInterval);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">46    kbd-&gt;irq-&gt;transfer_dma = kbd-&gt;new_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">47    kbd-&gt;irq-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">48    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">49    usb_fill_control_urb(kbd-&gt;led, dev, usb_sndctrlpipe(dev, 0),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">50                 (void *) kbd-&gt;cr, kbd-&gt;leds, 1,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">51                 usb_kbd_led, kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">52    kbd-&gt;led-&gt;transfer_dma = kbd-&gt;leds_dma;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">53    kbd-&gt;led-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">54</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">55    error = input_register_device(kbd-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">56    if (error)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">57        goto fail2;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">58</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">59    usb_set_intfdata(iface, kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">60    device_set_wakeup_enable(&amp;dev-&gt;dev, 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">61    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">62    ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">63}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>在usb_driver的断开函数中，将设置接口私有数据为NULL、终止已提交的URB并注销输入设备，如代码清单16.28所示。</p><p>代码清单16.28　USB键盘设备驱动的断开函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void usb_kbd_disconnect(struct usb_interface *intf)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   struct usb_kbd *kbd = usb_get_intfdata (intf);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5   usb_set_intfdata(intf, NULL);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6   if (kbd) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7       usb_kill_urb(kbd-&gt;irq);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8       input_unregister_device(kbd-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       usb_kill_urb(kbd-&gt;led);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10        usb_kbd_free_mem(interface_to_usbdev(intf), kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11       kfree(kbd);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>键盘主要依赖于中断传输模式，在键盘中断URB的完成函数usb_kbd_irq（）中（通过代码清单16.27的第45行可以看出），将会通过input_report_key（）报告按键事件，通过input_sync（）报告同步事件，如代码清单16.29所示。</p><p>代码清单16.29　USB键盘设备驱动的中断URB完成函数</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain"> 1static void usb_kbd_irq(struct urb *urb)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 2{</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 3   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 4   for (i = 0; i &lt; 8; i++)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 5       input_report_key(kbd-&gt;dev, usb_kbd_keycode[i + 224], (kbd-&gt;new[0] &gt;&gt; i) &amp; 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 6</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 7   for (i = 2; i &lt; 8; i++) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"> 9       if (kbd-&gt;old[i]&gt;3 &amp;&amp; memscan(kbd-&gt;new + 2, kbd-&gt;old[i], 6)==kbd-&gt;new + 8) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">10           if (usb_kbd_keycode[kbd-&gt;old[i]])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">11               input_report_key(kbd-&gt;dev, usb_kbd_keycode[kbd-&gt;old[i]], 0);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">12           else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">13               hid_info(urb-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">14                    &quot;Unknown key (scancode %#x) released.\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">15                    kbd-&gt;old[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">16       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">17</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">18       if (kbd-&gt;new[i] &gt; 3&amp;&amp;memscan(kbd-&gt;old + 2, kbd-&gt;new[i], 6)==kbd-&gt;old + 8) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">19           if (usb_kbd_keycode[kbd-&gt;new[i]])</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">20               input_report_key(kbd-&gt;dev, usb_kbd_keycode[kbd-&gt;new[i]], 1);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">21           else</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">22               hid_info(urb-&gt;dev,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">23                    &quot;Unknown key (scancode %#x) pressed.\n&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">24                    kbd-&gt;new[i]);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">25       }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">26   }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">27</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">28   input_sync(kbd-&gt;dev);</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">29</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">30   ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">31}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>从USB键盘驱动的例子中，我们进一步看到了usb_driver本身只是起一个挂接总线的作用，而具体设备类型的驱动仍然是工作的主体，例如键盘就是input、USB串口就是tty，只是在这些设备底层进行硬件访问的时候，调用的都是与URB相关的接口，这套USB核心层API—URB的存在使我们无须关心底层USB主机控制器的具体细节，因此，USB设备驱动也变得与平台无关，同样的驱动可应用于不同的SoC。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/shaozongfan/shaozongfan.github.io/docs/linux设备驱动开发详解/16.3　USB设备驱动.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_eYIM" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_vbeJ"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文档分页导航"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/linux设备驱动开发详解/16.2　USB主机控制器驱动"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">16.2.1　USB主机控制器驱动的整体结构</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/linux设备驱动开发详解/16.4　USB UDC与Gadget驱动"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">16.4.1　UDC和Gadget驱动的关键数据结构与API</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#1urb结构体" class="table-of-contents__link toc-highlight">1.urb结构体</a></li><li><a href="#2urb处理流程" class="table-of-contents__link toc-highlight">2.URB处理流程</a><ul><li><a href="#1被一个usb设备驱动创建" class="table-of-contents__link toc-highlight">1）被一个USB设备驱动创建。</a></li><li><a href="#2初始化被安排给一个特定usb设备的特定端点" class="table-of-contents__link toc-highlight">2）初始化，被安排给一个特定USB设备的特定端点。</a></li><li><a href="#3被usb设备驱动提交给usb核心" class="table-of-contents__link toc-highlight">3）被USB设备驱动提交给USB核心。</a></li><li><a href="#4提交由usb核心指定的usb主机控制器驱动" class="table-of-contents__link toc-highlight">4）提交由USB核心指定的USB主机控制器驱动。</a></li><li><a href="#5被usb主机控制器处理进行一次到usb设备的传送" class="table-of-contents__link toc-highlight">5）被USB主机控制器处理，进行一次到USB设备的传送。</a></li><li><a href="#6当urb完成usb主机控制器驱动通知usb设备驱动" class="table-of-contents__link toc-highlight">6）当URB完成，USB主机控制器驱动通知USB设备驱动。</a></li></ul></li><li><a href="#3简单的批量与控制urb" class="table-of-contents__link toc-highlight">3.简单的批量与控制URB</a><ul><li><a href="#1usb_bulk_msg" class="table-of-contents__link toc-highlight">（1）usb_bulk_msg（）</a></li></ul></li><li><a href="#2usb_control_msg函数" class="table-of-contents__link toc-highlight">（2）usb_control_msg（）函数</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title"></div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">shaozongfan<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/shaozongfan" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_lCJq"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright ? 2025 蒲城小农的文字世界, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.1c06d183.js"></script>
<script src="/assets/js/main.63ebc7ad.js"></script>
</body>
</html>